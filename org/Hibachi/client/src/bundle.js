webpackJsonp([0],[
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path='../typings/hibachiTypescript.d.ts' />
	/// <reference path='../typings/tsd.d.ts' />
	/*jshint browser:true */
	var basebootstrap_1 = __webpack_require__(2);
	var hibachi_module_1 = __webpack_require__(108);
	var logger_module_1 = __webpack_require__(210);
	//custom bootstrapper
	var bootstrapper = (function (_super) {
	    __extends(bootstrapper, _super);
	    function bootstrapper() {
	        var _this = this;
	        var angular = _this = _super.call(this, [hibachi_module_1.hibachimodule.name, logger_module_1.loggermodule.name]) || this;
	        angular.bootstrap();
	        return _this;
	    }
	    return bootstrapper;
	}(basebootstrap_1.BaseBootStrapper));
	module.exports = new bootstrapper();


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path='../typings/hibachiTypescript.d.ts' />
	/// <reference path='../typings/tsd.d.ts' />
	"use strict";
	var core_module_1 = __webpack_require__(3);
	var config = __webpack_require__(105);
	var enBundle = __webpack_require__(106);
	var enUsBundle = __webpack_require__(107);
	var md5 = __webpack_require__(75);
	//generic bootstrapper
	var BaseBootStrapper = (function () {
	    function BaseBootStrapper(myApplication) {
	        var _this = this;
	        this._resourceBundle = {};
	        this.getData = function (invalidCache) {
	            var promises = {};
	            for (var i in invalidCache) {
	                var invalidCacheName = invalidCache[i];
	                var functionName = invalidCacheName.charAt(0).toUpperCase() + invalidCacheName.slice(1);
	                promises[invalidCacheName] = _this['get' + functionName + 'Data']();
	            }
	            return _this.$q.all(promises).then(function (data) {
	            });
	        };
	        this.getAttributeCacheKeyData = function () {
	            var urlString = "";
	            if (!hibachiConfig) {
	                hibachiConfig = {};
	            }
	            if (!hibachiConfig.baseURL) {
	                hibachiConfig.baseURL = '';
	            }
	            urlString += hibachiConfig.baseURL;
	            if (urlString.length && urlString.slice(-1) !== '/') {
	                urlString += '/';
	            }
	            return _this.$http.get(urlString + '?' + hibachiConfig.action + '=api:main.getAttributeModel')
	                .then(function (resp) {
	                core_module_1.coremodule.constant('attributeMetaData', resp.data.data);
	                //for safari private mode which has no localStorage
	                try {
	                    localStorage.setItem('attributeMetaData', JSON.stringify(resp.data.data));
	                }
	                catch (e) { }
	                _this.attributeMetaData = resp.data.data;
	            }, function (response) {
	            });
	        };
	        this.getInstantiationKeyData = function () {
	            if (!_this.instantiationKey) {
	                var d = new Date();
	                var n = d.getTime();
	                _this.instantiationKey = n.toString();
	            }
	            var urlString = "";
	            if (!hibachiConfig) {
	                hibachiConfig = {};
	            }
	            if (!hibachiConfig.baseURL) {
	                hibachiConfig.baseURL = '';
	            }
	            urlString += hibachiConfig.baseURL;
	            if (hibachiConfig.baseURL.length && hibachiConfig.baseURL.charAt(hibachiConfig.baseURL.length - 1) != '/') {
	                urlString += '/';
	            }
	            return _this.$http.get(urlString + 'custom/config/config.json?instantiationKey=' + _this.instantiationKey)
	                .then(function (resp) {
	                var appConfig = resp.data.data;
	                if (hibachiConfig.baseURL.length) {
	                    appConfig.baseURL = urlString;
	                }
	                core_module_1.coremodule.constant('appConfig', resp.data.data);
	                _this.appConfig = appConfig;
	                return _this.getResourceBundles();
	            }, function (response) {
	            });
	        };
	        this.getResourceBundle = function (locale) {
	            var deferred = _this.$q.defer();
	            var locale = locale || _this.appConfig.rbLocale;
	            if (_this._resourceBundle[locale]) {
	                return _this._resourceBundle[locale];
	            }
	            var urlString = _this.appConfig.baseURL + '/custom/config/resourceBundles/' + locale + '.json?instantiationKey=' + _this.appConfig.instantiationKey;
	            _this.$http({
	                url: urlString,
	                method: "GET"
	            }).success(function (response, status, headersGetter) {
	                _this._resourceBundle[locale] = response;
	                deferred.resolve(response);
	            }).error(function (response, status) {
	                if (status === 404) {
	                    _this._resourceBundle[locale] = {};
	                    deferred.resolve(response);
	                }
	                else {
	                    deferred.reject(response);
	                }
	            });
	            return deferred.promise;
	        };
	        this.getResourceBundles = function () {
	            var rbLocale = _this.appConfig.rbLocale.split('_');
	            var localeListArray = rbLocale;
	            var rbPromise;
	            var rbPromises = [];
	            rbPromise = _this.getResourceBundle(_this.appConfig.rbLocale);
	            rbPromises.push(rbPromise);
	            if (localeListArray.length === 2) {
	                //$log.debug('has two');
	                rbPromise = _this.getResourceBundle(localeListArray[0]);
	                rbPromises.push(rbPromise);
	            }
	            if (localeListArray[0] !== 'en') {
	                //$log.debug('get english');
	                _this.getResourceBundle('en_us');
	                _this.getResourceBundle('en');
	            }
	            var resourceBundlePromises = _this.$q.all(rbPromises).then(function (data) {
	                core_module_1.coremodule.constant('resourceBundles', _this._resourceBundle);
	            }, function (error) {
	                //can enterhere due to 404
	                core_module_1.coremodule.constant('resourceBundles', _this._resourceBundle);
	            });
	            return resourceBundlePromises;
	        };
	        this.myApplication = myApplication;
	        core_module_1.coremodule.constant('appConfig', config['data']);
	        core_module_1.coremodule.constant('resourceBundles', { en: enBundle, en_us: enUsBundle });
	        core_module_1.coremodule.constant('attributeMetaData', {});
	    }
	    return BaseBootStrapper;
	}());
	exports.BaseBootStrapper = BaseBootStrapper;


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path='../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../typings/tsd.d.ts' />
	"use strict";
	var hibachiinterceptor_1 = __webpack_require__(4);
	//constant
	var hibachipathbuilder_1 = __webpack_require__(5);
	//services
	var cacheservice_1 = __webpack_require__(6);
	var publicservice_1 = __webpack_require__(7);
	var accountservice_1 = __webpack_require__(8);
	var cartservice_1 = __webpack_require__(23);
	var draggableservice_1 = __webpack_require__(24);
	var utilityservice_1 = __webpack_require__(25);
	var selectionservice_1 = __webpack_require__(27);
	var observerservice_1 = __webpack_require__(28);
	var orderservice_1 = __webpack_require__(29);
	var orderpaymentservice_1 = __webpack_require__(30);
	var formservice_1 = __webpack_require__(31);
	var filterservice_1 = __webpack_require__(32);
	var expandableservice_1 = __webpack_require__(33);
	var metadataservice_1 = __webpack_require__(34);
	var rbkeyservice_1 = __webpack_require__(35);
	var typeaheadservice_1 = __webpack_require__(36);
	var hibachiservice_1 = __webpack_require__(37);
	var historyservice_1 = __webpack_require__(38);
	var localstorageservice_1 = __webpack_require__(39);
	var hibachiservicedecorator_1 = __webpack_require__(40);
	var hibachiscope_1 = __webpack_require__(41);
	var requestservice_1 = __webpack_require__(42);
	var scopeservice_1 = __webpack_require__(46);
	var skuservice_1 = __webpack_require__(47);
	var hibachivalidationservice_1 = __webpack_require__(48);
	var entityservice_1 = __webpack_require__(49);
	//controllers
	var globalsearch_1 = __webpack_require__(50);
	//filters
	var percentage_1 = __webpack_require__(51);
	var entityrbkey_1 = __webpack_require__(52);
	var swtrim_1 = __webpack_require__(53);
	var swunique_1 = __webpack_require__(54);
	var datefilter_1 = __webpack_require__(55);
	//directives
	//  components
	var swactioncaller_1 = __webpack_require__(56);
	var swtypeaheadsearch_1 = __webpack_require__(57);
	var swtypeaheadinputfield_1 = __webpack_require__(58);
	var swtypeaheadmultiselect_1 = __webpack_require__(59);
	var swtypeaheadsearchlineitem_1 = __webpack_require__(60);
	var swtypeaheadremoveselection_1 = __webpack_require__(61);
	var swcollectionconfig_1 = __webpack_require__(62);
	var swcollectionfilter_1 = __webpack_require__(63);
	var swcollectionorderby_1 = __webpack_require__(64);
	var swcollectioncolumn_1 = __webpack_require__(65);
	var swactioncallerdropdown_1 = __webpack_require__(66);
	var swcolumnsorter_1 = __webpack_require__(67);
	var swconfirm_1 = __webpack_require__(68);
	var swdraggable_1 = __webpack_require__(69);
	var swdraggablecontainer_1 = __webpack_require__(70);
	var swentityactionbar_1 = __webpack_require__(71);
	var swentityactionbarbuttongroup_1 = __webpack_require__(72);
	var swexpandablerecord_1 = __webpack_require__(73);
	var swgravatar_1 = __webpack_require__(74);
	var swlogin_1 = __webpack_require__(79);
	var swmodallauncher_1 = __webpack_require__(80);
	var swmodalwindow_1 = __webpack_require__(81);
	var swnumbersonly_1 = __webpack_require__(82);
	var swloading_1 = __webpack_require__(83);
	var swscrolltrigger_1 = __webpack_require__(84);
	var swtabgroup_1 = __webpack_require__(85);
	var swtabcontent_1 = __webpack_require__(86);
	var swtooltip_1 = __webpack_require__(87);
	var swrbkey_1 = __webpack_require__(88);
	var swoptions_1 = __webpack_require__(89);
	var swselection_1 = __webpack_require__(90);
	var swclickoutside_1 = __webpack_require__(91);
	var swdirective_1 = __webpack_require__(92);
	var swexportaction_1 = __webpack_require__(93);
	var swhref_1 = __webpack_require__(94);
	var swprocesscaller_1 = __webpack_require__(95);
	var swsortable_1 = __webpack_require__(96);
	var sworderbycontrols_1 = __webpack_require__(97);
	var alert_module_1 = __webpack_require__(98);
	var dialog_module_1 = __webpack_require__(102);
	var coremodule = angular.module('hibachi.core', [
	    //Angular Modules
	    'ngAnimate',
	    'ngRoute',
	    'ngSanitize',
	    //3rdParty modules
	    'ui.bootstrap',
	    alert_module_1.alertmodule.name,
	    dialog_module_1.dialogmodule.name
	])
	    .config(['$httpProvider', '$logProvider', '$filterProvider', '$provide', 'hibachiPathBuilder', 'appConfig', function ($httpProvider, $logProvider, $filterProvider, $provide, hibachiPathBuilder, appConfig) {
	        hibachiPathBuilder.setBaseURL(appConfig.baseURL);
	        hibachiPathBuilder.setBasePartialsPath('/org/Hibachi/client/src/');
	        $logProvider.debugEnabled(appConfig.debugFlag);
	        $filterProvider.register('likeFilter', function () {
	            return function (text) {
	                if (angular.isDefined(text) && angular.isString(text)) {
	                    return text.replace(new RegExp('%', 'g'), '');
	                }
	            };
	        });
	        //This filter is used to shorten a string by removing the charecter count that is passed to it and ending it with "..."
	        $filterProvider.register('truncate', function () {
	            return function (input, chars, breakOnWord) {
	                if (isNaN(chars))
	                    return input;
	                if (chars <= 0)
	                    return '';
	                if (input && input.length > chars) {
	                    input = input.substring(0, chars);
	                    if (!breakOnWord) {
	                        var lastspace = input.lastIndexOf(' ');
	                        //get last space
	                        if (lastspace !== -1) {
	                            input = input.substr(0, lastspace);
	                        }
	                    }
	                    else {
	                        while (input.charAt(input.length - 1) === ' ') {
	                            input = input.substr(0, input.length - 1);
	                        }
	                    }
	                    return input + '...';
	                }
	                return input;
	            };
	        });
	        //This filter is used to shorten long string but unlike "truncate", it removes from the start of the string and prepends "..."
	        $filterProvider.register('pretruncate', function () {
	            return function (input, chars, breakOnWord) {
	                if (isNaN(chars))
	                    return input;
	                if (chars <= 0)
	                    return '';
	                if (input && input.length > chars) {
	                    input = input.slice('-' + chars);
	                    //  input = input.substring(0, chars);
	                    if (!breakOnWord) {
	                        var lastspace = input.lastIndexOf(' ');
	                        //get last space
	                        if (lastspace !== -1) {
	                            input = input.substr(0, lastspace);
	                        }
	                    }
	                    else {
	                        while (input.charAt(input.length - 1) === ' ') {
	                            input = input.substr(0, input.length - 1);
	                        }
	                    }
	                    return '...' + input;
	                }
	                return input;
	            };
	        });
	        hibachiPathBuilder.setBaseURL(appConfig.baseURL);
	        hibachiPathBuilder.setBasePartialsPath('/org/Hibachi/client/src/');
	        // $provide.decorator('$hibachi',
	        $httpProvider.interceptors.push('hibachiInterceptor');
	    }])
	    .run(['$rootScope', '$hibachi', '$route', '$location', function ($rootScope, $hibachi, $route, $location) {
	        $rootScope.buildUrl = $hibachi.buildUrl;
	        var original = $location.path;
	        $location.path = function (path, reload) {
	            if (reload === false) {
	                var lastRoute = $route.current;
	                var un = $rootScope.$on('$locationChangeSuccess', function () {
	                    $route.current = lastRoute;
	                    un();
	                });
	            }
	            return original.apply($location, [path]);
	        };
	    }])
	    .constant('hibachiPathBuilder', new hibachipathbuilder_1.HibachiPathBuilder())
	    .constant('corePartialsPath', 'core/components/')
	    .service('cacheService', cacheservice_1.CacheService)
	    .service('publicService', publicservice_1.PublicService)
	    .service('utilityService', utilityservice_1.UtilityService)
	    .service('selectionService', selectionservice_1.SelectionService)
	    .service('observerService', observerservice_1.ObserverService)
	    .service('draggableService', draggableservice_1.DraggableService)
	    .service('expandableService', expandableservice_1.ExpandableService)
	    .service('filterService', filterservice_1.FilterService)
	    .service('formService', formservice_1.FormService)
	    .service('historyService', historyservice_1.HistoryService)
	    .service('metadataService', metadataservice_1.MetaDataService)
	    .service('rbkeyService', rbkeyservice_1.RbKeyService)
	    .service('typeaheadService', typeaheadservice_1.TypeaheadService)
	    .provider('$hibachi', hibachiservice_1.$Hibachi)
	    .decorator('$hibachi', hibachiservicedecorator_1.HibachiServiceDecorator)
	    .service('hibachiInterceptor', hibachiinterceptor_1.HibachiInterceptor.Factory())
	    .service('hibachiScope', hibachiscope_1.HibachiScope)
	    .service('scopeService', scopeservice_1.ScopeService)
	    .service('skuService', skuservice_1.SkuService)
	    .service('localStorageService', localstorageservice_1.LocalStorageService)
	    .service('requestService', requestservice_1.RequestService)
	    .service('accountService', accountservice_1.AccountService)
	    .service('orderService', orderservice_1.OrderService)
	    .service('orderPaymentService', orderpaymentservice_1.OrderPaymentService)
	    .service('cartService', cartservice_1.CartService)
	    .service('hibachiValidationService', hibachivalidationservice_1.HibachiValidationService)
	    .service('entityService', entityservice_1.EntityService)
	    .controller('globalSearch', globalsearch_1.GlobalSearchController)
	    .filter('dateFilter', ['$filter', datefilter_1.DateFilter.Factory])
	    .filter('percentage', [percentage_1.PercentageFilter.Factory])
	    .filter('trim', [swtrim_1.SWTrim.Factory])
	    .filter('entityRBKey', ['rbkeyService', entityrbkey_1.EntityRBKey.Factory])
	    .filter('swdate', ['$filter', datefilter_1.DateFilter.Factory])
	    .filter('unique', [swunique_1.SWUnique.Factory])
	    .directive('swCollectionConfig', swcollectionconfig_1.SWCollectionConfig.Factory())
	    .directive('swCollectionColumn', swcollectioncolumn_1.SWCollectionColumn.Factory())
	    .directive('swCollectionFilter', swcollectionfilter_1.SWCollectionFilter.Factory())
	    .directive('swCollectionOrderBy', swcollectionorderby_1.SWCollectionOrderBy.Factory())
	    .directive('swTypeaheadSearch', swtypeaheadsearch_1.SWTypeaheadSearch.Factory())
	    .directive('swTypeaheadInputField', swtypeaheadinputfield_1.SWTypeaheadInputField.Factory())
	    .directive('swTypeaheadMultiselect', swtypeaheadmultiselect_1.SWTypeaheadMultiselect.Factory())
	    .directive('swTypeaheadSearchLineItem', swtypeaheadsearchlineitem_1.SWTypeaheadSearchLineItem.Factory())
	    .directive('swTypeaheadRemoveSelection', swtypeaheadremoveselection_1.SWTypeaheadRemoveSelection.Factory())
	    .directive('swActionCaller', swactioncaller_1.SWActionCaller.Factory())
	    .directive('swActionCallerDropdown', swactioncallerdropdown_1.SWActionCallerDropdown.Factory())
	    .directive('swColumnSorter', swcolumnsorter_1.SWColumnSorter.Factory())
	    .directive('swConfirm', swconfirm_1.SWConfirm.Factory())
	    .directive('swEntityActionBar', swentityactionbar_1.SWEntityActionBar.Factory())
	    .directive('swEntityActionBarButtonGroup', swentityactionbarbuttongroup_1.SWEntityActionBarButtonGroup.Factory())
	    .directive('swExpandableRecord', swexpandablerecord_1.SWExpandableRecord.Factory())
	    .directive('swGravatar', swgravatar_1.SWGravatar.Factory())
	    .directive('swDraggable', swdraggable_1.SWDraggable.Factory())
	    .directive('swDraggableContainer', swdraggablecontainer_1.SWDraggableContainer.Factory())
	    .directive('swLogin', swlogin_1.SWLogin.Factory())
	    .directive('swModalLauncher', swmodallauncher_1.SWModalLauncher.Factory())
	    .directive('swModalWindow', swmodalwindow_1.SWModalWindow.Factory())
	    .directive('swNumbersOnly', swnumbersonly_1.SWNumbersOnly.Factory())
	    .directive('swLoading', swloading_1.SWLoading.Factory())
	    .directive('swScrollTrigger', swscrolltrigger_1.SWScrollTrigger.Factory())
	    .directive('swRbkey', swrbkey_1.SWRbKey.Factory())
	    .directive('swOptions', swoptions_1.SWOptions.Factory())
	    .directive('swSelection', swselection_1.SWSelection.Factory())
	    .directive('swTabGroup', swtabgroup_1.SWTabGroup.Factory())
	    .directive('swTabContent', swtabcontent_1.SWTabContent.Factory())
	    .directive('swTooltip', swtooltip_1.SWTooltip.Factory())
	    .directive('swClickOutside', swclickoutside_1.SWClickOutside.Factory())
	    .directive('swDirective', swdirective_1.SWDirective.Factory())
	    .directive('swExportAction', swexportaction_1.SWExportAction.Factory())
	    .directive('swHref', swhref_1.SWHref.Factory())
	    .directive('swProcessCaller', swprocesscaller_1.SWProcessCaller.Factory())
	    .directive('sw:sortable', swsortable_1.SWSortable.Factory())
	    .directive('swOrderByControls', sworderbycontrols_1.SWOrderByControls.Factory());
	exports.coremodule = coremodule;


/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var HibachiInterceptor = (function () {
	    //@ngInject
	    function HibachiInterceptor($location, $q, $log, $injector, localStorageService, alertService, appConfig, dialogService, utilityService, hibachiPathBuilder) {
	        var _this = this;
	        this.$location = $location;
	        this.$q = $q;
	        this.$log = $log;
	        this.$injector = $injector;
	        this.localStorageService = localStorageService;
	        this.alertService = alertService;
	        this.appConfig = appConfig;
	        this.dialogService = dialogService;
	        this.utilityService = utilityService;
	        this.hibachiPathBuilder = hibachiPathBuilder;
	        this.urlParam = null;
	        this.authHeader = 'Authorization';
	        this.authPrefix = 'Bearer ';
	        this.request = function (config) {
	            _this.$log.debug('request');
	            //bypass interceptor rules when checking template cache
	            if (config.url.charAt(0) !== '/') {
	                return config;
	            }
	            if (config.method == 'GET' && config.url.indexOf('.html') >= 0 && config.url.indexOf('/') >= 0) {
	                //all partials are bound to instantiation key
	                config.url = config.url + '?instantiationKey=' + _this.appConfig.instantiationKey;
	                return config;
	            }
	            config.cache = true;
	            config.headers = config.headers || {};
	            if (_this.localStorageService.hasItem('token')) {
	                config.headers['Auth-Token'] = 'Bearer ' + _this.localStorageService.getItem('token');
	            }
	            var queryParams = _this.utilityService.getQueryParamsFromUrl(config.url);
	            if (config.method == 'GET' && (queryParams[_this.appConfig.action] && queryParams[_this.appConfig.action] === 'api:main.get')) {
	                _this.$log.debug(config);
	                config.method = 'POST';
	                config.data = {};
	                var data = {};
	                if (angular.isDefined(config.params)) {
	                    data = config.params;
	                }
	                var params = {};
	                params.serializedJsonData = angular.toJson(data);
	                params.context = "GET";
	                config.data = $.param(params);
	                delete config.params;
	                config.headers['Content-Type'] = 'application/x-www-form-urlencoded';
	            }
	            return config;
	        };
	        this.requestError = function (rejection) {
	            return _this.$q.reject(rejection);
	        };
	        this.response = function (response) {
	            if (response.data.messages) {
	                var alerts = _this.alertService.formatMessagesToAlerts(response.data.messages);
	                _this.alertService.addAlerts(alerts);
	            }
	            return response;
	        };
	        this.responseError = function (rejection) {
	            if (angular.isDefined(rejection.status) && rejection.status !== 404 && rejection.status !== 403 && rejection.status !== 499) {
	                if (rejection.data && rejection.data.messages) {
	                    var alerts = _this.alertService.formatMessagesToAlerts(rejection.data.messages);
	                    _this.alertService.addAlerts(alerts);
	                }
	                else {
	                    var message = {
	                        msg: 'there was error retrieving data',
	                        type: 'error'
	                    };
	                    _this.alertService.addAlert(message);
	                }
	            }
	            if (rejection.status === 499) {
	                // handle the case where the user is not authenticated
	                if (rejection.data && rejection.data.messages) {
	                    //var deferred = $q.defer();
	                    var $http = _this.$injector.get('$http');
	                    if (rejection.data.messages[0].message === 'timeout') {
	                        //open dialog
	                        _this.dialogService.addPageDialog(_this.hibachiPathBuilder.buildPartialsPath('preprocesslogin'), {});
	                    }
	                    else if (rejection.data.messages[0].message === 'invalid_token') {
	                        return $http.get(_this.baseUrl + '?slataction=api:main.login').then(function (loginResponse) {
	                            if (loginResponse.status === 200) {
	                                _this.localStorageService.setItem('token', loginResponse.data.token);
	                                rejection.config.headers = rejection.config.headers || {};
	                                rejection.config.headers['Auth-Token'] = 'Bearer ' + loginResponse.data.token;
	                                return $http(rejection.config).then(function (response) {
	                                    return response;
	                                });
	                            }
	                        }, function (rejection) {
	                            return rejection;
	                        });
	                    }
	                }
	            }
	            return rejection;
	        };
	        this.$location = $location;
	        this.$q = $q;
	        this.$log = $log;
	        this.$injector = $injector;
	        this.alertService = alertService;
	        this.appConfig = appConfig;
	        this.baseUrl = appConfig.baseURL;
	        this.dialogService = dialogService;
	        this.utilityService = utilityService;
	        this.hibachiPathBuilder = hibachiPathBuilder;
	        this.localStorageService = localStorageService;
	    }
	    HibachiInterceptor.Factory = function () {
	        var eventHandler = function ($location, $q, $log, $injector, localStorageService, alertService, appConfig, dialogService, utilityService, hibachiPathBuilder) { return new HibachiInterceptor($location, $q, $log, $injector, localStorageService, alertService, appConfig, dialogService, utilityService, hibachiPathBuilder); };
	        eventHandler.$inject = [
	            '$location',
	            '$q',
	            '$log',
	            '$injector',
	            'localStorageService',
	            'alertService',
	            'appConfig',
	            'dialogService',
	            'utilityService',
	            'hibachiPathBuilder'
	        ];
	        return eventHandler;
	    };
	    return HibachiInterceptor;
	}());
	exports.HibachiInterceptor = HibachiInterceptor;


/***/ },
/* 5 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	/*services return promises which can be handled uniquely based on success or failure by the controller*/
	var HibachiPathBuilder = (function () {
	    //@ngInject
	    function HibachiPathBuilder() {
	        var _this = this;
	        this.setBaseURL = function (baseURL) {
	            _this.baseURL = baseURL;
	        };
	        this.setBasePartialsPath = function (basePartialsPath) {
	            _this.basePartialsPath = basePartialsPath;
	        };
	        this.setApiSubsystemName = function (apiSubsystemName) {
	            _this.apiSubsystemName = apiSubsystemName;
	        };
	        this.buildPartialsPath = function (componentsPath) {
	            if (angular.isDefined(_this.baseURL) && angular.isDefined(_this.basePartialsPath)) {
	                return _this.baseURL + _this.basePartialsPath + componentsPath;
	            }
	            else {
	                throw ('need to define baseURL and basePartialsPath in hibachiPathBuilder. Inject hibachiPathBuilder into module and configure it there');
	            }
	        };
	    }
	    return HibachiPathBuilder;
	}());
	exports.HibachiPathBuilder = HibachiPathBuilder;


/***/ },
/* 6 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var CacheService = (function () {
	    //@ngInject
	    function CacheService(localStorageService) {
	        var _this = this;
	        this.localStorageService = localStorageService;
	        this.cacheData = {};
	        this.saveCacheData = function () {
	            _this.localStorageService.setItem("cacheData", _this.cacheData);
	        };
	        this.hasKey = function (key) {
	            if (angular.isDefined(_this.cacheData[key])) {
	                return true;
	            }
	            return false;
	        };
	        this.dateExpired = function (key) {
	            if (_this.cacheData[key].expiresTime == "forever") {
	                return false;
	            }
	            return _this.cacheData[key].expiresTime < Date.now();
	        };
	        this.put = function (key, dataPromise, dataTarget, expiresTime) {
	            if (expiresTime === void 0) { expiresTime = "forever"; }
	            _this.cacheData[key] = {};
	            _this.cacheData[key].expiresTime = expiresTime;
	            _this.cacheData[key].dataPromise = dataPromise;
	            _this.cacheData[key].dataTarget = dataTarget;
	            dataPromise.then(function (response) {
	                _this.localStorageService.setItem(key, response[dataTarget]);
	            }, function (reason) {
	                delete _this.cacheData[key];
	            });
	            _this.saveCacheData();
	            return dataPromise;
	        };
	        this.reload = function (key, expiresTime) {
	            if (expiresTime === void 0) { expiresTime = "forever"; }
	            _this.cacheData[key].expiresTime = expiresTime;
	            _this.cacheData[key].dataPromise.then(function (response) {
	                _this.localStorageService.setItem(key, response[_this.cacheData[key].dataTarget]);
	            }, function (reason) {
	                delete _this.cacheData[key];
	            });
	            _this.saveCacheData();
	            return _this.cacheData[key].dataPromise;
	        };
	        this.fetch = function (key) {
	            if (_this.hasKey(key) && !_this.dateExpired(key)) {
	                if (_this.localStorageService.hasItem(key)) {
	                    return _this.localStorageService.getItem(key);
	                }
	                _this.put(key, _this.cacheData[key].dataPromise, _this.cacheData[key].dataTarget, _this.cacheData[key].expiresTime).finally(function () {
	                    return _this.localStorageService.getItem(key);
	                });
	            }
	        };
	        this.fetchOrReload = function (key, expiresTime) {
	            if (angular.isDefined(_this.fetch(key))) {
	                return _this.fetch(key);
	            }
	            else {
	                _this.reload(key, expiresTime).then(function (response) {
	                    return _this.fetch(key);
	                }, function (reason) {
	                    //throw
	                });
	            }
	        };
	        if (localStorageService.hasItem("cacheData")) {
	            this.cacheData = localStorageService.getItem("cacheData");
	        }
	    }
	    return CacheService;
	}());
	exports.CacheService = CacheService;


/***/ },
/* 7 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var PublicService = (function () {
	    ///index.cfm/api/scope/
	    //@ngInject
	    function PublicService($http, $q, $window, $location, $hibachi, $injector, requestService, accountService, cartService, orderService, observerService, appConfig) {
	        var _this = this;
	        this.$http = $http;
	        this.$q = $q;
	        this.$window = $window;
	        this.$location = $location;
	        this.$hibachi = $hibachi;
	        this.$injector = $injector;
	        this.requestService = requestService;
	        this.accountService = accountService;
	        this.cartService = cartService;
	        this.orderService = orderService;
	        this.observerService = observerService;
	        this.appConfig = appConfig;
	        this.requests = {};
	        this.errors = {};
	        this.baseActionPath = "";
	        this.months = [{ name: '01 - JAN', value: 1 }, { name: '02 - FEB', value: 2 }, { name: '03 - MAR', value: 3 }, { name: '04 - APR', value: 4 }, { name: '05 - MAY', value: 5 }, { name: '06 - JUN', value: 6 }, { name: '07 - JUL', value: 7 }, { name: '08 - AUG', value: 8 }, { name: '09 - SEP', value: 9 }, { name: '10 - OCT', value: 10 }, { name: '11 - NOV', value: 11 }, { name: '12 - DEC', value: 12 }];
	        this.years = [];
	        this.shippingAddress = "";
	        this.billingAddress = "";
	        this.imagePath = {};
	        // public hasErrors = ()=>{
	        //     return this.errors.length;
	        // }
	        /**
	         * Helper methods for getting errors from the cart
	         */
	        this.getErrors = function () {
	            _this.errors = {};
	            for (var key in _this.requests) {
	                var request = _this.requests[key];
	                if (Object.keys(request.errors).length) {
	                    _this.errors[key] = request.errors;
	                }
	            }
	            return _this.errors;
	        };
	        /** grab the valid expiration years for credit cards  */
	        this.getExpirationYears = function () {
	            var baseDate = new Date();
	            var today = baseDate.getFullYear();
	            var start = today;
	            for (var i = 0; i <= 15; i++) {
	                _this.years.push(start + i);
	            }
	        };
	        /** accessors for account */
	        this.getAccount = function (refresh) {
	            if (refresh === void 0) { refresh = false; }
	            var urlBase = _this.baseActionPath + 'getAccount/';
	            if (!_this.accountDataPromise || refresh) {
	                _this.accountDataPromise = _this.getData(urlBase, "account", "");
	            }
	            return _this.accountDataPromise;
	        };
	        /** accessors for cart */
	        this.getCart = function (refresh) {
	            if (refresh === void 0) { refresh = false; }
	            var urlBase = _this.baseActionPath + 'getCart/';
	            if (!_this.cartDataPromise || refresh) {
	                _this.cartDataPromise = _this.getData(urlBase, "cart", "");
	            }
	            return _this.cartDataPromise;
	        };
	        /** accessors for countries */
	        this.getCountries = function (refresh) {
	            if (refresh === void 0) { refresh = false; }
	            var urlBase = _this.baseActionPath + 'getCountries/';
	            if (!_this.countryDataPromise || refresh) {
	                _this.countryDataPromise = _this.getData(urlBase, "countries", "");
	            }
	            return _this.countryDataPromise;
	        };
	        /** accessors for states */
	        this.getStates = function (countryCode, refresh) {
	            if (refresh === void 0) { refresh = false; }
	            if (!angular.isDefined(countryCode))
	                countryCode = "US";
	            var urlBase = _this.baseActionPath + 'getStateCodeOptionsByCountryCode/';
	            if (!_this.stateDataPromise || refresh) {
	                _this.stateDataPromise = _this.getData(urlBase, "states", "?countryCode=" + countryCode);
	            }
	            return _this.stateDataPromise;
	        };
	        /** accessors for states */
	        this.getAddressOptions = function (countryCode, refresh) {
	            if (refresh === void 0) { refresh = false; }
	            if (!angular.isDefined(countryCode))
	                countryCode = "US";
	            var urlBase = _this.baseActionPath + 'getAddressOptionsByCountryCode/';
	            if (!_this.addressOptionData || refresh) {
	                _this.addressOptionData = _this.getData(urlBase, "addressOptions", "&countryCode=" + countryCode);
	            }
	            return _this.addressOptionData;
	        };
	        /** accessors for states */
	        this.getData = function (url, setter, param) {
	            var urlBase = url + param;
	            var request = _this.requestService.newPublicRequest(urlBase);
	            request.promise.then(function (result) {
	                //don't need account and cart for anything other than account and cart calls.
	                if (setter.indexOf('account') == -1 || setter.indexOf('cart') == -1) {
	                    if (result['account']) {
	                        delete result['account'];
	                    }
	                    if (result['cart']) {
	                        delete result['cart'];
	                    }
	                }
	                if (setter == 'cart' || setter == 'account') {
	                    //cart and account return cart and account info flat
	                    _this[setter].populate(result);
	                }
	                else {
	                    //other functions reutrn cart,account and then data
	                    _this[setter] = (result);
	                }
	            }).catch(function (reason) {
	            });
	            _this.requests[request.getAction()] = request;
	            return request.promise;
	        };
	        /** sets the current shipping address */
	        this.setShippingAddress = function (shippingAddress) {
	            _this.shippingAddress = shippingAddress;
	        };
	        /** sets the current shipping address */
	        this.setBillingAddress = function (billingAddress) {
	            _this.billingAddress = billingAddress;
	        };
	        /** this is the generic method used to call all server side actions.
	        *  @param action {string} the name of the action (method) to call in the public service.
	        *  @param data   {object} the params as key value pairs to pass in the post request.
	        *  @return a deferred promise that resolves server response or error. also includes updated account and cart.
	        */
	        this.doAction = function (action, data, method) {
	            if (!action) {
	                throw "Action is required exception";
	            }
	            var urlBase = "";
	            //check if the caller is defining a path to hit, otherwise use the public scope.
	            if (action.indexOf(":") !== -1) {
	                urlBase = action; //any path
	            }
	            else {
	                urlBase = "/index.cfm/api/scope/" + action; //public path
	            }
	            if (data) {
	                method = "post";
	                data.returnJsonObjects = "cart,account";
	            }
	            else {
	                urlBase += "&returnJsonObject=cart,account";
	            }
	            if (method == "post") {
	                data.returnJsonObjects = "cart,account";
	                //post
	                var request_1 = _this.requestService.newPublicRequest(urlBase, data, method);
	                request_1.promise.then(function (result) {
	                    _this.processAction(result, request_1);
	                }).catch(function (response) {
	                });
	                _this.requests[request_1.getAction()] = request_1;
	                return request_1.promise;
	            }
	            else {
	                //get
	                var url = urlBase + "&returnJsonObject=cart,account";
	                var request_2 = _this.requestService.newPublicRequest(url);
	                request_2.promise.then(function (result) {
	                    _this.processAction(result, request_2);
	                }).catch(function (reason) {
	                });
	                _this.requests[request_2.getAction()] = request_2;
	                return request_2.promise;
	            }
	        };
	        this.processAction = function (response, request) {
	            /** update the account and the cart */
	            _this.account.populate(response.account);
	            _this.account.request = request;
	            _this.cart.populate(response.cart);
	            _this.cart.request = request;
	            //if the action that was called was successful, then success is true.
	            if (request.hasSuccessfulAction()) {
	                for (var action in request.successfulActions) {
	                    if (request.successfulActions[action].indexOf('public:cart.placeOrder') !== -1) {
	                        _this.$window.location.href = _this.confirmationUrl;
	                    }
	                }
	            }
	            if (!request.hasSuccessfulAction()) {
	            }
	        };
	        this.getRequestByAction = function (action) {
	            return _this.requests[action];
	        };
	        /**
	         * Helper methods so that everything in account and cart can be accessed using getters.
	         */
	        this.userIsLoggedIn = function () {
	            return _this.account.userIsLoggedIn();
	        };
	        this.getActivePaymentMethods = function () {
	            var urlString = "/?slataction=admin:ajax.getActivePaymentMethods";
	            var request = _this.requestService.newPublicRequest(urlString)
	                .then(function (result) {
	                if (angular.isDefined(result.data.paymentMethods)) {
	                    _this.paymentMethods = result.data.paymentMethods;
	                }
	            });
	            _this.requests[request.getAction()] = request;
	        };
	        /**
	         * Given a payment method name, returns the id.
	         */
	        this.getPaymentMethodID = function (name) {
	            for (var method in _this.paymentMethods) {
	                if (_this.paymentMethods[method].paymentMethodName == name && _this.paymentMethods[method].activeFlag == "Yes ") {
	                    return _this.paymentMethods[method].paymentMethodID;
	                }
	            }
	        };
	        this.hasPaymentMethod = function (paymentMethodName) {
	            for (var method in _this.paymentMethods) {
	                if (_this.paymentMethods[method].paymentMethodName == paymentMethodName && _this.paymentMethods[method].activeFlag == "Yes ") {
	                    return true;
	                }
	            }
	            return false;
	        };
	        this.hasCreditCardPaymentMethod = function () {
	            return _this.hasPaymentMethod("Credit Card");
	        };
	        this.hasPaypalPaymentMethod = function () {
	            return _this.hasPaymentMethod("PayPal Express");
	        };
	        this.hasGiftCardPaymentMethod = function () {
	            return _this.hasPaymentMethod("Gift Card");
	        };
	        this.hasMoneyOrderPaymentMethod = function () {
	            return _this.hasPaymentMethod("Money Order");
	        };
	        this.hasCashPaymentMethod = function () {
	            return _this.hasPaymentMethod("Cash");
	        };
	        /** Returns true if the order requires a fulfillment */
	        this.orderRequiresFulfillment = function () {
	            return _this.cart.orderRequiresFulfillment();
	        };
	        /**
	         *  Returns true if the order requires a account
	         *  Either because the user is not logged in, or because they don't have one.
	         *
	         */
	        this.orderRequiresAccount = function () {
	            return _this.cart.orderRequiresAccount();
	        };
	        /** Returns true if the payment tab should be active */
	        this.hasShippingAddressAndMethod = function () {
	            return _this.cart.hasShippingAddressAndMethod();
	        };
	        /**
	         * Returns true if the user has an account and is logged in.
	         */
	        this.hasAccount = function () {
	            if (_this.account.accountID) {
	                return true;
	            }
	            return false;
	        };
	        /** Redirects to the order confirmation page if the order placed successfully
	        */
	        this.redirectExact = function (url) {
	            _this.$location.url(url);
	        };
	        // /** Returns true if a property on an object is undefined or empty. */
	        this.isUndefinedOrEmpty = function (object, property) {
	            if (!angular.isDefined(object[property]) || object[property] == "") {
	                return true;
	            }
	            return false;
	        };
	        /** A simple method to return the quantity sum of all orderitems in the cart. */
	        this.getOrderItemQuantitySum = function () {
	            var totalQuantity = 0;
	            if (angular.isDefined(_this.cart)) {
	                return _this.cart.getOrderItemQuantitySum();
	            }
	            return totalQuantity;
	        };
	        /** Returns the index of the state from the list of states */
	        this.getSelectedStateIndexFromStateCode = function (stateCode, states) {
	            for (var state in states) {
	                if (states[state].value == stateCode) {
	                    return state;
	                }
	            }
	        };
	        /**
	         * Returns true if on a mobile device. This is important for placeholders.
	         */
	        this.isMobile = function () {
	            if (this.$window.innerWidth <= 800 && this.$window.innerHeight <= 600) {
	                return true;
	            }
	            return false;
	        };
	        /** returns true if the shipping method is the selected shipping method
	        */
	        this.isSelectedShippingMethod = function (index, value) {
	            if (this.cart.fulfillmentTotal &&
	                value == this.cart.orderFulfillments[this.cart.orderFulfillmentWithShippingMethodOptionsIndex].shippingMethod.shippingMethodID ||
	                this.cart.orderFulfillments[this.cart.orderFulfillmentWithShippingMethodOptionsIndex].shippingMethodOptions.length == 1) {
	                return true;
	            }
	            return false;
	        };
	        /** returns the index of the selected shipping method.
	        */
	        this.getSelectedShippingIndex = function (index, value) {
	            for (var i = 0; i <= this.cart.orderFulfillments[this.cart.orderFulfillmentWithShippingMethodOptionsIndex].shippingMethodOptions.length; i++) {
	                if (this.cart.fulfillmentTotal == this.cart.orderFulfillments[this.cart.orderFulfillmentWithShippingMethodOptionsIndex].shippingMethodOptions[i].totalCharge) {
	                    return i;
	                }
	            }
	        };
	        /** simple validation just to ensure data is present and accounted for.
	        */
	        this.validateNewOrderPayment = function (newOrderPayment) {
	            var newOrderPaymentErrors = {};
	            if (_this.isUndefinedOrEmpty(newOrderPayment, 'newOrderPayment.billingAddress.streetAddress')) {
	                newOrderPaymentErrors['streetAddress'] = 'Required *';
	            }
	            if (_this.isUndefinedOrEmpty(newOrderPayment, 'newOrderPayment.billingAddress.countrycode')) {
	                newOrderPaymentErrors['countrycode'] = 'Required *';
	            }
	            if (_this.isUndefinedOrEmpty(newOrderPayment, 'newOrderPayment.billingAddress.statecode')) {
	                if (_this.isUndefinedOrEmpty(newOrderPayment, 'newOrderPayment.billingAddress.locality')) {
	                    newOrderPaymentErrors['statecode'] = 'Required *';
	                }
	            }
	            if (_this.isUndefinedOrEmpty(newOrderPayment, 'newOrderPayment.billingAddress.city')) {
	                if (_this.isUndefinedOrEmpty(newOrderPayment, 'newOrderPayment.billingAddress.city')) {
	                    newOrderPaymentErrors['city'] = 'Required *';
	                }
	            }
	            if (_this.isUndefinedOrEmpty(newOrderPayment, 'newOrderPayment.billingAddress.locality')) {
	                if (_this.isUndefinedOrEmpty(newOrderPayment, 'newOrderPayment.billingAddress.statecode')) {
	                    newOrderPaymentErrors['locality'] = 'Required *';
	                }
	            }
	            if (_this.isUndefinedOrEmpty(newOrderPayment, 'newOrderPayment.billingAddress.postalcode')) {
	                newOrderPaymentErrors['postalCode'] = 'Required *';
	            }
	            if (_this.isUndefinedOrEmpty(newOrderPayment, 'newOrderPayment.nameOnCreditCard')) {
	                newOrderPaymentErrors['nameOnCreditCard'] = 'Required *';
	            }
	            if (_this.isUndefinedOrEmpty(newOrderPayment, 'newOrderPayment.expirationMonth')) {
	                newOrderPaymentErrors['streetAddress'] = 'Required *';
	            }
	            if (_this.isUndefinedOrEmpty(newOrderPayment, 'newOrderPayment.expirationYear')) {
	                newOrderPaymentErrors['expirationYear'] = 'Required *';
	            }
	            if (_this.isUndefinedOrEmpty(newOrderPayment, 'newOrderPayment.creditCardNumber')) {
	                newOrderPaymentErrors['creditCardNumber'] = 'Required *';
	            }
	            if (_this.isUndefinedOrEmpty(newOrderPayment, 'newOrderPayment.securityCode')) {
	                newOrderPaymentErrors['securityCode'] = 'Required *';
	            }
	            if (Object.keys(newOrderPaymentErrors).length) {
	            }
	        };
	        /** Allows an easy way to calling the service addOrderPayment.
	        */
	        this.addOrderPayment = function (formdata) {
	            //reset the form errors.
	            // this.cart.hasErrors=false;
	            // this.cart.orderPayments.errors = {};
	            // this.cart.orderPayments.hasErrors = false;
	            //Grab all the data
	            var billingAddress = _this.newBillingAddress;
	            var expirationMonth = formdata.month;
	            var expirationYear = formdata.year;
	            var country = formdata.country;
	            var state = formdata.state;
	            var accountFirst = _this.account.firstName;
	            var accountLast = _this.account.lastName;
	            var data = {};
	            var processObject = _this.orderService.newOrder_AddOrderPayment();
	            // processObject.newBillingAddress = this.newBillingAddress;
	            // processObject.newBillingAddress.expirationMonth = formdata.month;
	            // processObject.newBillingAddress.expirationYear = formdata.year;
	            // processObject.newBillingAddress.billingAddress.country = formdata.country || processObject.data.newOrderPayment.billingAddress.country;
	            // processObject.newBillingAddress.billingAddress.statecode = formdata.state || processObject.data.newOrderPayment.billingAddress.statecode;
	            // processObject.newBillingAddress.saveShippingAsBilling=(this.saveShippingAsBilling == true);
	            data = {
	                'newOrderPayment.billingAddress.addressID': '',
	                'newOrderPayment.billingAddress.streetAddress': billingAddress.streetAddress,
	                'newOrderPayment.billingAddress.street2Address': billingAddress.street2Address,
	                'newOrderPayment.nameOnCreditCard': billingAddress.nameOnCreditCard,
	                'newOrderPayment.billingAddress.name': billingAddress.nameOnCreditCard,
	                'newOrderPayment.expirationMonth': expirationMonth,
	                'newOrderPayment.expirationYear': expirationYear,
	                'newOrderPayment.billingAddress.countrycode': country || billingAddress.countrycode,
	                'newOrderPayment.billingAddress.city': '' + billingAddress.city,
	                'newOrderPayment.billingAddress.statecode': state || billingAddress.statecode,
	                'newOrderPayment.billingAddress.locality': billingAddress.locality || '',
	                'newOrderPayment.billingAddress.postalcode': billingAddress.postalcode,
	                'newOrderPayment.securityCode': billingAddress.cvv,
	                'newOrderPayment.creditCardNumber': billingAddress.cardNumber,
	                'newOrderPayment.saveShippingAsBilling': (_this.saveShippingAsBilling == true),
	            };
	            //processObject.populate(data);
	            //Make sure we have required fields for a newOrderPayment.
	            _this.validateNewOrderPayment(data);
	            if (_this.cart.orderPayments.hasErrors && Object.keys(_this.cart.orderPayments.errors).length) {
	                return -1;
	            }
	            //Post the new order payment and set errors as needed.
	            _this.doAction('addOrderPayment', data, 'post').then(function (result) {
	                var serverData = result;
	                if (serverData.cart.hasErrors || angular.isDefined(_this.cart.orderPayments[_this.cart.orderPayments.length - 1]['errors']) && !_this.cart.orderPayments[_this.cart.orderPayments.length - 1]['errors'].hasErrors) {
	                    _this.cart.hasErrors = true;
	                    _this.readyToPlaceOrder = true;
	                    _this.edit = '';
	                }
	                else {
	                    _this.editPayment = false;
	                    _this.readyToPlaceOrder = true;
	                    _this.edit = '';
	                }
	            });
	        };
	        /** Allows an easy way to calling the service addOrderPayment.
	        */
	        this.addGiftCardOrderPayments = function (redeemGiftCardToAccount) {
	            //reset the form errors.
	            _this.cart.hasErrors = false;
	            _this.cart.orderPayments.errors = {};
	            _this.cart.orderPayments.hasErrors = false;
	            //Grab all the data
	            var giftCards = _this.account.giftCards;
	            var data = {};
	            data = {
	                'newOrderPayment.paymentMethod.paymentMethodID': '50d8cd61009931554764385482347f3a',
	                'newOrderPayment.redeemGiftCardToAccount': redeemGiftCardToAccount,
	            };
	            //add the amounts from the gift cards
	            for (var card in giftCards) {
	                if (giftCards[card].applied == true) {
	                    data['newOrderPayment.giftCardNumber'] = giftCards[card].giftCardCode;
	                    if (giftCards[card].calculatedTotal < _this.cart.calculatedTotal) {
	                        data['newOrderPayment.amount'] = giftCards[card].calculatedBalanceAmount; //will use once we have amount implemented.
	                    }
	                    else {
	                        data['newOrderPayment.amount'] = _this.cart.calculatedTotal; //this is so it doesn't throw the 100% error
	                    }
	                    data['copyFromType'] = "";
	                    //Post the new order payment and set errors as needed.
	                    _this.$q.all([_this.doAction('addOrderPayment', data, 'post')]).then(function (result) {
	                        var serverData;
	                        if (angular.isDefined(result['0'])) {
	                            serverData = result['0'].data;
	                        }
	                        if (serverData.cart.hasErrors || angular.isDefined(this.cart.orderPayments[this.cart.orderPayments.length - 1]['errors']) && !this.cart.orderPayments['' + (this.cart.orderPayments.length - 1)]['errors'].hasErrors) {
	                            this.cart.hasErrors = true;
	                            this.readyToPlaceOrder = true;
	                            this.edit = '';
	                        }
	                        else {
	                        }
	                    });
	                }
	            }
	        };
	        /** returns the index of the last selected shipping method. This is used to get rid of the delay.
	        */
	        this.selectShippingMethod = function (index) {
	            for (var method in this.lastSelectedShippingMethod) {
	                if (method != index) {
	                    this.lastSelectedShippingMethod[method] = 'false';
	                }
	            }
	            this.lastSelectedShippingMethod[index] = 'true';
	        };
	        /** returns true if this was the last selected method
	        */
	        this.isLastSelectedShippingMethod = function (index) {
	            if (this.lastSelectedShippingMethod[index] === 'true') {
	                return true;
	            }
	            return false;
	        };
	        /** Allows an easy way to calling the service addOrderPayment.
	        */
	        this.addOrderPaymentAndPlaceOrder = function (formdata) {
	            //reset the form errors.
	            _this.orderPlaced = false;
	            //Grab all the data
	            var billingAddress = _this.newBillingAddress;
	            var expirationMonth = formdata.month;
	            var expirationYear = formdata.year;
	            var country = formdata.country;
	            var state = formdata.state;
	            var accountFirst = _this.account.firstName;
	            var accountLast = _this.account.lastName;
	            var data = {};
	            data = {
	                'orderid': _this.cart.orderID,
	                'newOrderPayment.billingAddress.streetAddress': billingAddress.streetAddress,
	                'newOrderPayment.billingAddress.street2Address': billingAddress.street2Address,
	                'newOrderPayment.nameOnCreditCard': billingAddress.nameOnCard || accountFirst + ' ' + accountLast,
	                'newOrderPayment.expirationMonth': expirationMonth,
	                'newOrderPayment.expirationYear': expirationYear,
	                'newOrderPayment.billingAddress.countrycode': country || billingAddress.countrycode,
	                'newOrderPayment.billingAddress.city': '' + billingAddress.city,
	                'newOrderPayment.billingAddress.statecode': state || billingAddress.statecode,
	                'newOrderPayment.billingAddress.locality': billingAddress.locality || '',
	                'newOrderPayment.billingAddress.postalcode': billingAddress.postalcode,
	                'newOrderPayment.securityCode': billingAddress.cvv,
	                'newOrderPayment.creditCardNumber': billingAddress.cardNumber,
	                'newOrderPayment.saveShippingAsBilling': (_this.saveShippingAsBilling == true),
	            };
	            //Make sure we have required fields for a newOrderPayment.
	            //this.validateNewOrderPayment( data );
	            if (_this.cart.orderPayments.hasErrors && Object.keys(_this.cart.orderPayments.errors).length) {
	                return -1;
	            }
	            //Post the new order payment and set errors as needed.
	            _this.$q.all([_this.doAction('addOrderPayment,placeOrder', data, 'post')]).then(function (result) {
	                var serverData;
	                if (angular.isDefined(result['0'])) {
	                    serverData = result['0'].data;
	                }
	                else {
	                } //|| angular.isDefined(serverData.cart.orderPayments[serverData.cart.orderPayments.length-1]['errors']) && slatwall.cart.orderPayments[''+slatwall.cart.orderPayments.length-1]['errors'].hasErrors
	                if (serverData.cart.hasErrors || (angular.isDefined(serverData.failureActions) && serverData.failureActions.length && serverData.failureActions[0] == "public:cart.addOrderPayment")) {
	                    if (serverData.failureActions.length) {
	                        for (var action in serverData.failureActions) {
	                        }
	                    }
	                    this.edit = '';
	                    return true;
	                }
	                else if (serverData.successfulActions.length) {
	                    //
	                    this.cart.hasErrors = false;
	                    this.editPayment = false;
	                    this.edit = '';
	                    for (var action in serverData.successfulActions) {
	                        //
	                        if (serverData.successfulActions[action].indexOf("placeOrder") != -1) {
	                            //if there are no errors then redirect.
	                            this.orderPlaced = true;
	                            this.redirectExact('/order-confirmation/');
	                        }
	                    }
	                }
	                else {
	                    this.edit = '';
	                }
	            });
	        };
	        //Applies a giftcard from the user account onto the payment.
	        this.applyGiftCard = function (giftCardCode) {
	            _this.finding = true;
	            //find the code already on the account.
	            var found = false;
	            for (var giftCard in _this.account.giftCards) {
	                if (_this.account.giftCards[giftCard].balanceAmount == 0) {
	                    _this.account.giftCards[giftCard]['error'] = "The balance is $0.00 for this card.";
	                    found = false;
	                }
	                if (_this.account.giftCards[giftCard].giftCardCode == giftCardCode) {
	                    _this.account.giftCards[giftCard].applied = true;
	                    found = true;
	                }
	            }
	            if (found) {
	                _this.finding = false;
	                _this.addGiftCardOrderPayments(false);
	            }
	            else {
	                _this.finding = false;
	                _this.addGiftCardOrderPayments(true);
	            }
	        };
	        //returns the amount total of giftcards added to this account.
	        this.getAppliedGiftCardTotals = function () {
	            //
	            var total = 0;
	            for (var payment in _this.cart.orderPayments) {
	                if (_this.cart.orderPayments[payment].giftCardNumber != "") {
	                    total = total + parseInt(_this.cart.orderPayments[payment]['amount']);
	                }
	            }
	            return total;
	        };
	        //gets the calcuated total minus the applied gift cards.
	        this.getTotalMinusGiftCards = function () {
	            var total = _this.getAppliedGiftCardTotals();
	            return _this.cart.calculatedTotal - total;
	        };
	        //get estimated shipping rates given a weight, from to zips
	        this.getEstimatedRates = function (zipcode) {
	            var weight = 0;
	            for (var item in _this.cart.orderFulfillments) {
	                weight += _this.cart.orderFulfillments[item].totalShippingWeight;
	            }
	            var shipFromAddress = {
	                "postalcode": ""
	            };
	            var shipToAddress = {
	                "postalcode": zipcode
	            };
	            var totalWeight = weight;
	            //get the rates.
	            var urlString = "?slataction=admin:ajax.getEstimatedShippingRates&shipFromAddress=" + JSON.stringify(shipFromAddress)
	                + "&shipToAddress=" + JSON.stringify(shipToAddress) + "&totalWeight=" + JSON.stringify(weight);
	            var request = _this.requestService.newPublicRequest(urlString)
	                .then(function (result) {
	                _this.rates = result.data;
	            });
	        };
	        /** Returns the state from the list of states by stateCode */
	        this.getStateByStateCode = function (stateCode) {
	            for (var state in _this.states.stateCodeOptions) {
	                if (_this.states.stateCodeOptions[state].value == stateCode) {
	                    return _this.states.stateCodeOptions[state];
	                }
	            }
	        };
	        /** Returns the state from the list of states by stateCode */
	        this.resetRequests = function (request) {
	            delete _this.requests[request];
	        };
	        /** Returns true if the addresses match. */
	        this.addressesMatch = function (address1, address2) {
	            if (angular.isDefined(address1) && angular.isDefined(address2)) {
	                if ((address1.streetAddress == address2.streetAddress &&
	                    address1.street2Address == address2.street2Address &&
	                    address1.city == address2.city &&
	                    address1.postalcode == address2.postalcode &&
	                    address1.countrycode == address2.countrycode)) {
	                    return true;
	                }
	            }
	            return false;
	        };
	        /** Should be pushed down into core. Returns the profile image by name. */
	        this.getResizedImageByProfileName = function (profileName, skuIDList) {
	            _this.imagePath = {};
	            if (profileName == undefined) {
	                profileName = "medium";
	            }
	            _this.$http.get("/index.cfm/api/scope/?context=getResizedImageByProfileName&profileName=" + profileName + "&skuIds=" + skuIDList).success(function (result) {
	                _this.imagePath[skuIDList] = "";
	                result = angular.fromJson(result);
	                if (angular.isDefined(result.resizedImagePaths) && angular.isDefined(result.resizedImagePaths.resizedImagePaths) && result.resizedImagePaths.resizedImagePaths[0] != undefined) {
	                    _this.imagePath[skuIDList] = result.resizedImagePaths.resizedImagePaths[0];
	                    _this.loading = false;
	                    return _this.imagePath[skuIDList];
	                }
	                else {
	                    return "";
	                }
	            });
	        };
	        /**
	       *  Returns true when the fulfillment body should be showing
	       *  Show if we don't need an account but do need a fulfillment
	       *
	       */
	        this.showFulfillmentTabBody = function () {
	            if ((_this.cart.orderRequirementsList.indexOf('account') == -1) && _this.account.accountID &&
	                (_this.cart.orderRequirementsList.indexOf('fulfillment') != -1) ||
	                (_this.cart.orderRequirementsList.indexOf('fulfillment') == -1) &&
	                    (_this.edit == 'fulfillment')) {
	                return true;
	            }
	            return false;
	        };
	        /**
	         *  Returns true when the fulfillment body should be showing
	         *  Show if we don't need an account,fulfillment, and don't have a payment - or
	         *  we have a payment but are editting the payment AND nothing else is being edited
	         *
	         */
	        this.showPaymentTabBody = function () {
	            if ((_this.cart.orderRequirementsList.indexOf('account') == -1) && _this.account.accountID &&
	                (_this.cart.orderRequirementsList.indexOf('fulfillment') == -1) &&
	                (_this.cart.orderRequirementsList.indexOf('payment') != -1) && _this.edit == '' ||
	                (_this.cart.orderRequirementsList.indexOf('payment') == -1) &&
	                    (_this.edit == 'payment')) {
	                return true;
	            }
	            return false;
	        };
	        /**
	         *  Returns true if the review tab body should be showing.
	         *  Show if we don't need an account,fulfillment,payment, but not if something else is being edited
	         *
	         */
	        this.showReviewTabBody = function () {
	            if ((_this.cart.orderRequirementsList.indexOf('account') == -1) && _this.account.accountID &&
	                (_this.cart.orderRequirementsList.indexOf('fulfillment') == -1) &&
	                (_this.cart.orderRequirementsList.indexOf('payment') == -1) &&
	                (_this.edit == '') || (_this.edit == 'review')) {
	                return true;
	            }
	            return false;
	        };
	        /** Returns true if the fulfillment tab should be active */
	        this.fulfillmentTabIsActive = function () {
	            if ((_this.edit == 'fulfillment') ||
	                (_this.edit == '' && ((_this.cart.orderRequirementsList.indexOf('account') == -1) && _this.account.accountID) &&
	                    (_this.cart.orderRequirementsList.indexOf('fulfillment') != -1))) {
	                return true;
	            }
	            return false;
	        };
	        /** Returns true if the payment tab should be active */
	        this.paymentTabIsActive = function () {
	            if ((_this.edit == 'payment') ||
	                (_this.edit == '' &&
	                    (_this.cart.orderRequirementsList.indexOf('account') == -1) && _this.account.accountID &&
	                    (_this.cart.orderRequirementsList.indexOf('fulfillment') == -1) &&
	                    (_this.cart.orderRequirementsList.indexOf('payment') != -1))) {
	                return true;
	            }
	            return false;
	        };
	        this.orderService = orderService;
	        this.cartService = cartService;
	        this.accountService = accountService;
	        this.requestService = requestService;
	        this.appConfig = appConfig;
	        this.baseActionPath = this.appConfig.baseURL + "/index.cfm/api/scope/"; //default path
	        this.confirmationUrl = "/order-confirmation";
	        this.$http = $http;
	        this.$location = $location;
	        this.$q = $q;
	        this.$injector = $injector;
	        this.getExpirationYears();
	        this.$window = $window;
	        this.$hibachi = $hibachi;
	        this.cart = this.cartService.newCart();
	        this.account = this.accountService.newAccount();
	        this.observerService = observerService;
	    }
	    return PublicService;
	}());
	exports.PublicService = PublicService;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var baseentityservice_1 = __webpack_require__(9);
	var AccountService = (function (_super) {
	    __extends(AccountService, _super);
	    //@ngInject
	    function AccountService($injector, $hibachi, utilityService) {
	        var _this = _super.call(this, $injector, $hibachi, utilityService, 'Account') || this;
	        _this.$injector = $injector;
	        _this.$hibachi = $hibachi;
	        _this.utilityService = utilityService;
	        return _this;
	    }
	    return AccountService;
	}(baseentityservice_1.BaseEntityService));
	exports.AccountService = AccountService;


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var baseobject_1 = __webpack_require__(10);
	var Entities = __webpack_require__(11);
	var Processes = __webpack_require__(20);
	var BaseEntityService = (function (_super) {
	    __extends(BaseEntityService, _super);
	    //@ngInject
	    function BaseEntityService($injector, $hibachi, utilityService, baseObjectName, objectName) {
	        var _this = _super.call(this, $injector) || this;
	        _this.$injector = $injector;
	        _this.$hibachi = $hibachi;
	        _this.utilityService = utilityService;
	        _this.baseObjectName = baseObjectName;
	        _this.objectName = objectName;
	        _this.newEntity = function (baseObjectName, objectName) {
	            if (!objectName) {
	                objectName = baseObjectName;
	            }
	            return _this.newObject('Entity', baseObjectName, objectName);
	        };
	        _this.newProcessObject = function (baseObjectName, objectName) {
	            if (!objectName) {
	                objectName = baseObjectName;
	            }
	            return _this.newObject('Process', baseObjectName, objectName);
	        };
	        _this.newObject = function (type, baseObjectName, objectName) {
	            if (!objectName) {
	                objectName = baseObjectName;
	            }
	            var baseObject = _this.$hibachi.getEntityDefinition(baseObjectName);
	            var Barrell = {};
	            if (type === 'Entity') {
	                Barrell = Entities;
	            }
	            else if (type === 'Process') {
	                Barrell = Processes;
	            }
	            if (Barrell[objectName]) {
	                _this.utilityService.extend(Barrell[objectName], baseObject);
	                var entity = new Barrell[objectName](_this.$injector);
	            }
	            else {
	                var entity = new baseObject();
	            }
	            return entity;
	        };
	        _this.utilityService = utilityService;
	        _this.$hibachi = $hibachi;
	        _this.$injector = $injector;
	        if (!_this.objectName) {
	            _this.objectName = _this.baseObjectName;
	        }
	        _this['new' + _this.objectName] = function () {
	            return _this.newEntity(_this.baseObjectName, _this.objectName);
	        };
	        return _this;
	    }
	    return BaseEntityService;
	}(baseobject_1.BaseObject));
	exports.BaseEntityService = BaseEntityService;


/***/ },
/* 10 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var BaseObject = (function () {
	    //@ngInject
	    function BaseObject($injector) {
	        var _this = this;
	        this.getService = function (serviceName) {
	            //return;
	            if (_this.$injector.has(serviceName)) {
	                //returns a generic service
	                return _this.$injector.get(serviceName);
	            }
	        };
	        this.getHibachiScope = function () {
	            return _this.getService('publicService');
	        };
	        this.getAppConfig = function () {
	            return _this.getService('appConfig');
	        };
	        this.$injector = $injector;
	        var constructorString = this.constructor.toString();
	        this.className = constructorString.match(/\w+/g)[1];
	    }
	    return BaseObject;
	}());
	exports.BaseObject = BaseObject;


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path='../../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../../typings/tsd.d.ts' />
	"use strict";
	var account_1 = __webpack_require__(12);
	exports.Account = account_1.Account;
	var address_1 = __webpack_require__(15);
	exports.Address = address_1.Address;
	var cart_1 = __webpack_require__(16);
	exports.Cart = cart_1.Cart;
	var orderitem_1 = __webpack_require__(17);
	exports.OrderItem = orderitem_1.OrderItem;
	var orderpayment_1 = __webpack_require__(18);
	exports.OrderPayment = orderpayment_1.OrderPayment;
	var sku_1 = __webpack_require__(19);
	exports.Sku = sku_1.Sku;


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path='../../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../../typings/tsd.d.ts' />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var baseentity_1 = __webpack_require__(13);
	var Account = (function (_super) {
	    __extends(Account, _super);
	    function Account($injector) {
	        var _this = _super.call(this, $injector) || this;
	        _this.giftCards = [];
	        _this.userIsLoggedIn = function () {
	            if (_this.accountID !== '') {
	                return true;
	            }
	            return false;
	        };
	        return _this;
	    }
	    return Account;
	}(baseentity_1.BaseEntity));
	exports.Account = Account;


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path='../../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../../typings/tsd.d.ts' />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var basetransient_1 = __webpack_require__(14);
	var BaseEntity = (function (_super) {
	    __extends(BaseEntity, _super);
	    function BaseEntity($injector) {
	        return _super.call(this, $injector) || this;
	    }
	    return BaseEntity;
	}(basetransient_1.BaseTransient));
	exports.BaseEntity = BaseEntity;


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path='../../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../../typings/tsd.d.ts' />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var baseobject_1 = __webpack_require__(10);
	var BaseTransient = (function (_super) {
	    __extends(BaseTransient, _super);
	    function BaseTransient($injector) {
	        var _this = _super.call(this, $injector) || this;
	        _this.errors = {};
	        _this.messages = {};
	        _this.populate = function (response) {
	            var data = response;
	            if (response.data) {
	                data = response.data;
	            }
	            data = _this.utilityService.nvpToObject(data);
	            var _loop_1 = function () {
	                var propertyIdentifier = key.replace(_this.className.toLowerCase() + '.', '');
	                var propertyIdentifierArray = propertyIdentifier.split('.');
	                var propertyIdentifierKey = propertyIdentifier.replace(/\./g, '_');
	                var currentEntity = _this;
	                angular.forEach(propertyIdentifierArray, function (property, propertyKey) {
	                    if (currentEntity.metaData[property]) {
	                        //if we are on the last item in the array
	                        if (propertyKey === propertyIdentifierArray.length - 1) {
	                            //if is json
	                            //if(currentEntity.metaData[key]){
	                            //if propertyidentifier
	                            // }else{
	                            if (angular.isObject(data[key]) && currentEntity.metaData[property].fieldtype && currentEntity.metaData[property].fieldtype === 'many-to-one') {
	                                var relatedEntity = _this.entityService.newEntity(currentEntity.metaData[property].cfc);
	                                if (relatedEntity.populate) {
	                                    relatedEntity.populate(data[key]);
	                                    currentEntity['$$set' + currentEntity.metaData[property].name.charAt(0).toUpperCase() + currentEntity.metaData[property].name.slice(1)](relatedEntity);
	                                }
	                                else {
	                                    relatedEntity.$$init(data[key]);
	                                    currentEntity['$$set' + currentEntity.metaData[property].name.charAt(0).toUpperCase() + currentEntity.metaData[property].name.slice(1)](relatedEntity);
	                                }
	                            }
	                            else if (angular.isArray(data[propertyIdentifierKey]) && currentEntity.metaData[property].fieldtype && (currentEntity.metaData[property].fieldtype === 'one-to-many')) {
	                                currentEntity[property] = [];
	                                angular.forEach(data[key], function (arrayItem, propertyKey) {
	                                    var relatedEntity = _this.entityService.newEntity(currentEntity.metaData[property].cfc);
	                                    if (relatedEntity.populate) {
	                                        relatedEntity.populate(arrayItem);
	                                        var hasItem = false;
	                                        for (var item in currentEntity[property]) {
	                                            if (currentEntity[property][item].$$getID().length > 0 && currentEntity[property][item].$$getID() === relatedEntity.$$getID()) {
	                                                hasItem = true;
	                                                break;
	                                            }
	                                        }
	                                        if (!hasItem) {
	                                            currentEntity['$$add' + currentEntity.metaData[property].singularname.charAt(0).toUpperCase() + currentEntity.metaData[property].singularname.slice(1)](relatedEntity);
	                                        }
	                                    }
	                                    else {
	                                        relatedEntity.$$init(arrayItem);
	                                        currentEntity['$$add' + currentEntity.metaData[property].singularname.charAt(0).toUpperCase() + currentEntity.metaData[property].singularname.slice(1)](relatedEntity);
	                                    }
	                                });
	                            }
	                            else {
	                                currentEntity[property] = data[key];
	                            }
	                        }
	                        else {
	                            var propertyMetaData = currentEntity.metaData[property];
	                            if (angular.isUndefined(currentEntity.data[property]) || (currentEntity.data[property] && currentEntity.data[property] === null)) {
	                                if (propertyMetaData.fieldtype === 'one-to-many') {
	                                    relatedEntity = [];
	                                }
	                                else {
	                                    relatedEntity = _this.$hibachi['new' + propertyMetaData.cfc]();
	                                }
	                            }
	                            else {
	                                relatedEntity = currentEntity.data[property];
	                            }
	                            currentEntity['$$set' + propertyMetaData.name.charAt(0).toUpperCase() + propertyMetaData.name.slice(1)](relatedEntity);
	                            currentEntity = relatedEntity;
	                        }
	                    }
	                    else {
	                        _this[key] = data[key];
	                    }
	                });
	            };
	            for (var key in data) {
	                _loop_1();
	            }
	            if (response.errors) {
	                _this.errors = response.errors;
	                _this.messages = response.messages;
	            }
	        };
	        _this.addError = function (errorName, errorMessage) {
	            if (!_this.errors[errorName]) {
	                _this.errors[errorName] = [];
	            }
	            if (angular.isArray(errorMessage)) {
	                _this.addErrorsByArray(errorName, errorMessage);
	            }
	            else if (angular.isObject(errorMessage)) {
	                _this.addErrorsByObject(errorName, errorMessage);
	            }
	            else {
	                _this.errors[errorName].push(errorMessage);
	            }
	        };
	        _this.addErrorsByArray = function (errorName, errorMessages) {
	            for (var i = 0; i < errorMessages.length; i++) {
	                var message = errorMessages[i];
	                _this.errors[errorName].push(message);
	            }
	        };
	        _this.addErrorsByObject = function (errorName, errorMessage) {
	            if (!_this.errors[errorName]) {
	                _this.errors[errorName] = [];
	            }
	            for (var key in errorMessage) {
	                for (var i = 0; i < errorMessage[key].length; i++) {
	                    var message = errorMessage[i];
	                    _this.errors[errorName].push(message);
	                }
	            }
	        };
	        _this.addErrors = function (errors) {
	            for (var key in errors) {
	                if (!_this.errors[key]) {
	                    _this.errors[key] = [];
	                }
	                for (var message in errors[key]) {
	                    _this.errors[key].push(message);
	                }
	            }
	        };
	        _this.getError = function (errorName) {
	            return _this.getErrorByErrorName(errorName);
	        };
	        _this.getErrorByErrorName = function (errorName) {
	            return _this.errors[errorName];
	        };
	        _this.hasError = function (errorName) {
	            return _this.hasErrorByErrorName(errorName);
	        };
	        _this.hasErrorByErrorName = function (errorName) {
	            return angular.isDefined(_this.errors[errorName]);
	        };
	        _this.hasErrors = function () {
	            return Object.keys(_this.errors).length;
	        };
	        _this.hasSuccessfulAction = function (action) {
	            return;
	        };
	        _this.$hibachi = _this.getService('$hibachi');
	        _this.hibachiValidationService = _this.getService('hibachiValidationService');
	        _this.utilityService = _this.getService('utilityService');
	        _this.entityService = _this.getService('entityService');
	        return _this;
	    }
	    return BaseTransient;
	}(baseobject_1.BaseObject));
	exports.BaseTransient = BaseTransient;


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path='../../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../../typings/tsd.d.ts' />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var baseentity_1 = __webpack_require__(13);
	var Address = (function (_super) {
	    __extends(Address, _super);
	    function Address($injector) {
	        return _super.call(this, $injector) || this;
	    }
	    return Address;
	}(baseentity_1.BaseEntity));
	exports.Address = Address;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path='../../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../../typings/tsd.d.ts' />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var baseentity_1 = __webpack_require__(13);
	var Cart = (function (_super) {
	    __extends(Cart, _super);
	    //deprecated
	    function Cart($injector) {
	        var _this = _super.call(this, $injector) || this;
	        _this.requiresFulfillment = false;
	        _this.orderRequirementsList = "";
	        _this.orderPayments = [];
	        _this.orderItems = [];
	        _this.orderFulfillments = [];
	        _this.hasShippingAddressAndMethod = function () {
	            if (_this.orderRequirementsList.indexOf('fulfillment') == -1) {
	                return true;
	            }
	            return false;
	        };
	        _this.orderRequiresAccount = function () {
	            if (_this.orderRequirementsList.indexOf('account') != -1 || !_this.account.accountID) {
	                return true;
	            }
	            return false;
	        };
	        _this.orderRequiresFulfillment = function () {
	            return _this.requiresFulfillment;
	        };
	        _this.getOrderItemQuantitySum = function () {
	            var totalQuantity = 0;
	            if (angular.isDefined(_this.orderItems)) {
	                for (var orderItem in _this.orderItems) {
	                    totalQuantity = totalQuantity + _this.orderItems[orderItem].quantity;
	                }
	                return totalQuantity;
	            }
	            return totalQuantity;
	        };
	        return _this;
	    }
	    return Cart;
	}(baseentity_1.BaseEntity));
	exports.Cart = Cart;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path='../../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../../typings/tsd.d.ts' />
	var baseentity_1 = __webpack_require__(13);
	var OrderItem = (function (_super) {
	    __extends(OrderItem, _super);
	    function OrderItem($injector) {
	        return _super.call(this, $injector) || this;
	    }
	    return OrderItem;
	}(baseentity_1.BaseEntity));
	exports.OrderItem = OrderItem;


/***/ },
/* 18 */
/***/ function(module, exports) {

	/// <reference path='../../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../../typings/tsd.d.ts' />
	"use strict";
	var OrderPayment = (function () {
	    function OrderPayment() {
	    }
	    return OrderPayment;
	}());
	exports.OrderPayment = OrderPayment;


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path='../../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../../typings/tsd.d.ts' />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var baseentity_1 = __webpack_require__(13);
	var Sku = (function (_super) {
	    __extends(Sku, _super);
	    function Sku($injector) {
	        var _this = _super.call(this, $injector) || this;
	        _this.setNewQOH = function (value) {
	            _this.newQOH = value;
	        };
	        _this.getNewQOH = function () {
	            return _this.newQOH;
	        };
	        return _this;
	    }
	    return Sku;
	}(baseentity_1.BaseEntity));
	exports.Sku = Sku;


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path='../../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../../typings/tsd.d.ts' />
	"use strict";
	var order_addorderpayment_1 = __webpack_require__(21);
	exports.Order_AddOrderPayment = order_addorderpayment_1.Order_AddOrderPayment;


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path='../../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../../typings/tsd.d.ts' />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var baseprocess_1 = __webpack_require__(22);
	var Order_AddOrderPayment = (function (_super) {
	    __extends(Order_AddOrderPayment, _super);
	    function Order_AddOrderPayment($injector) {
	        var _this = _super.call(this, $injector) || this;
	        _this.$injector = $injector;
	        return _this;
	    }
	    return Order_AddOrderPayment;
	}(baseprocess_1.BaseProcess));
	exports.Order_AddOrderPayment = Order_AddOrderPayment;


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path='../../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../../typings/tsd.d.ts' />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var basetransient_1 = __webpack_require__(14);
	var BaseProcess = (function (_super) {
	    __extends(BaseProcess, _super);
	    function BaseProcess($injector) {
	        return _super.call(this, $injector) || this;
	    }
	    return BaseProcess;
	}(basetransient_1.BaseTransient));
	exports.BaseProcess = BaseProcess;


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var baseentityservice_1 = __webpack_require__(9);
	var CartService = (function (_super) {
	    __extends(CartService, _super);
	    //@ngInject
	    //@ngInject
	    function CartService($injector, $hibachi, utilityService) {
	        var _this = _super.call(this, $injector, $hibachi, utilityService, 'Order', 'Cart') || this;
	        _this.$injector = $injector;
	        _this.$hibachi = $hibachi;
	        _this.utilityService = utilityService;
	        return _this;
	    }
	    return CartService;
	}(baseentityservice_1.BaseEntityService));
	exports.CartService = CartService;


/***/ },
/* 24 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var DraggableService = (function () {
	    //ngInject
	    function DraggableService() {
	        this.isDropAllowed = function (event) {
	            //todo implement
	            return true;
	        };
	        this.isMouseInFirstHalf = function (event, targetNode, relativeToParent, horizontal) {
	            var mousePointer = horizontal ? (event.offsetX || event.layerX)
	                : (event.offsetY || event.layerY);
	            var targetSize = horizontal ? targetNode.offsetWidth : targetNode.offsetHeight;
	            var targetPosition = horizontal ? targetNode.offsetLeft : targetNode.offsetTop;
	            targetPosition = relativeToParent ? targetPosition : 0;
	            return mousePointer < targetPosition + targetSize / 2;
	        };
	    }
	    return DraggableService;
	}());
	exports.DraggableService = DraggableService;


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	/*services return promises which can be handled uniquely based on success or failure by the controller*/
	var baseservice_1 = __webpack_require__(26);
	var UtilityService = (function (_super) {
	    __extends(UtilityService, _super);
	    //@ngInject
	    function UtilityService($parse) {
	        var _this = _super.call(this) || this;
	        _this.$parse = $parse;
	        _this.structKeyExists = function (struct, key) {
	            return key in struct;
	        };
	        _this.keyToAttributeString = function (key) {
	            var attributeString = "data-";
	            for (var i = 0; i < key.length; i++) {
	                if (key.charAt(i) == "_") {
	                    attributeString += "-";
	                }
	                else if (_this.isUpperCase(key.charAt(i))) {
	                    //special case for ID and Acronyms because it doesn't follow naming conventions
	                    if (i + 1 <= key.length && _this.isUpperCase(key.charAt(i + 1))) {
	                        if (key.charAt(i) + key.charAt(i + 1) == "ID") {
	                            attributeString += "-id";
	                            i++; //skip ahead
	                        }
	                        else if (_this.isUpperCase(key.charAt(i + 1))) {
	                            attributeString += "-";
	                            //this handles acronyms IE QATS 
	                            while (i + 1 <= key.length && _this.isUpperCase(key.charAt(i + 1))) {
	                                attributeString += key.charAt(i).toLowerCase();
	                                i++;
	                            }
	                        }
	                    }
	                    else {
	                        attributeString += "-" + key.charAt(i).toLowerCase();
	                    }
	                }
	                else {
	                    attributeString += key.charAt(i);
	                }
	            }
	            return attributeString;
	        };
	        _this.isUpperCase = function (character) {
	            return character == character.toUpperCase();
	        };
	        _this.isLowerCase = function (character) {
	            return character == character.toLowerCase();
	        };
	        _this.snakeToCapitalCase = function (s) {
	            return s.charAt(0).toUpperCase() + s.replace(/(\-\w)/g, function (m) { return m[1].toUpperCase(); }).slice(1);
	        };
	        _this.camelCaseToSnakeCase = function (s) {
	            return s.replace(/([A-Z])/g, function ($1) { return "-" + $1.toLowerCase(); });
	        };
	        _this.replaceStringWithProperties = function (stringItem, context) {
	            var properties = _this.getPropertiesFromString(stringItem);
	            if (!properties)
	                return;
	            var data = [];
	            angular.forEach(properties, function (property) {
	                if (property.indexOf('.') != -1) {
	                    property = property.replace('.', '_');
	                }
	                var parseFunction = _this.$parse(property);
	                data.push(parseFunction(context));
	            });
	            return _this.replacePropertiesWithData(stringItem, data);
	        };
	        //used to do inheritance at runtime
	        _this.extend = function (ChildClass, ParentClass) {
	            ChildClass.prototype = new ParentClass();
	            ChildClass.prototype.constructor = ChildClass;
	        };
	        _this.getQueryParamsFromUrl = function (url) {
	            // This function is anonymous, is executed immediately and
	            // the return value is assigned to QueryString!
	            var query_string = {};
	            if (url && url.split) {
	                var spliturl = url.split('?');
	                if (spliturl.length) {
	                    url = spliturl[1];
	                    if (url && url.split) {
	                        var vars = url.split("&");
	                        if (vars && vars.length) {
	                            for (var i = 0; i < vars.length; i++) {
	                                var pair = vars[i].split("=");
	                                // If first entry with this name
	                                if (typeof query_string[pair[0]] === "undefined") {
	                                    query_string[pair[0]] = pair[1];
	                                }
	                                else if (typeof query_string[pair[0]] === "string") {
	                                    var arr = [query_string[pair[0]], pair[1]];
	                                    query_string[pair[0]] = arr;
	                                }
	                                else {
	                                    query_string[pair[0]].push(pair[1]);
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	            return query_string;
	        };
	        _this.isAngularRoute = function () {
	            return /[\?&]ng#!/.test(window.location.href);
	        };
	        _this.ArrayFindByPropertyValue = function (arr, property, value) {
	            var currentIndex = -1;
	            arr.forEach(function (arrItem, index) {
	                if (arrItem[property] && arrItem[property] === value) {
	                    currentIndex = index;
	                }
	            });
	            return currentIndex;
	        };
	        _this.listLast = function (list, delimiter) {
	            if (list === void 0) { list = ''; }
	            if (delimiter === void 0) { delimiter = ','; }
	            var listArray = list.split(delimiter);
	            return listArray[listArray.length - 1];
	        };
	        _this.listRest = function (list, delimiter) {
	            if (list === void 0) { list = ''; }
	            if (delimiter === void 0) { delimiter = ","; }
	            var listArray = list.split(delimiter);
	            if (listArray.length) {
	                listArray.splice(0, 1);
	            }
	            return listArray.join(delimiter);
	        };
	        _this.listFirst = function (list, delimiter) {
	            if (list === void 0) { list = ''; }
	            if (delimiter === void 0) { delimiter = ','; }
	            var listArray = list.split(delimiter);
	            return listArray[0];
	        };
	        _this.listPrepend = function (list, substring, delimiter) {
	            if (list === void 0) { list = ''; }
	            if (substring === void 0) { substring = ''; }
	            if (delimiter === void 0) { delimiter = ','; }
	            var listArray = list.split(delimiter);
	            if (listArray.length) {
	                return substring + delimiter + list;
	            }
	            else {
	                return substring;
	            }
	        };
	        _this.listAppend = function (list, substring, delimiter) {
	            if (list === void 0) { list = ''; }
	            if (substring === void 0) { substring = ''; }
	            if (delimiter === void 0) { delimiter = ','; }
	            var listArray = list.split(delimiter);
	            if (list.trim() != '' && listArray.length) {
	                return list + delimiter + substring;
	            }
	            else {
	                return substring;
	            }
	        };
	        _this.listAppendUnique = function (list, substring, delimiter) {
	            if (list === void 0) { list = ''; }
	            if (substring === void 0) { substring = ''; }
	            if (delimiter === void 0) { delimiter = ','; }
	            var listArray = list.split(delimiter);
	            if (list.trim() != '' && listArray.length && listArray.indexOf(substring) == -1) {
	                return list + delimiter + substring;
	            }
	            else {
	                return substring;
	            }
	        };
	        _this.formatValue = function (value, formatType, formatDetails, entityInstance) {
	            if (angular.isUndefined(formatDetails)) {
	                formatDetails = {};
	            }
	            var typeList = ["currency", "date", "datetime", "pixels", "percentage", "second", "time", "truefalse", "url", "weight", "yesno"];
	            if (typeList.indexOf(formatType)) {
	                _this['format_' + formatType](value, formatDetails, entityInstance);
	            }
	            return value;
	        };
	        _this.format_currency = function (value, formatDetails, entityInstance) {
	            if (angular.isUndefined) {
	                formatDetails = {};
	            }
	        };
	        _this.format_date = function (value, formatDetails, entityInstance) {
	            if (angular.isUndefined) {
	                formatDetails = {};
	            }
	        };
	        _this.format_datetime = function (value, formatDetails, entityInstance) {
	            if (angular.isUndefined) {
	                formatDetails = {};
	            }
	        };
	        _this.format_pixels = function (value, formatDetails, entityInstance) {
	            if (angular.isUndefined) {
	                formatDetails = {};
	            }
	        };
	        _this.format_yesno = function (value, formatDetails, entityInstance) {
	            if (angular.isUndefined) {
	                formatDetails = {};
	            }
	            if (Boolean(value) === true) {
	                return entityInstance.metaData.$$getRBKey("define.yes");
	            }
	            else if (value === false || value.trim() === 'No' || value.trim === 'NO' || value.trim() === '0') {
	                return entityInstance.metaData.$$getRBKey("define.no");
	            }
	        };
	        _this.left = function (stringItem, count) {
	            return stringItem.substring(0, count);
	        };
	        _this.right = function (stringItem, count) {
	            return stringItem.substring(stringItem.length - count, stringItem.length);
	        };
	        //this.utilityService.mid(propertyIdentifier,1,propertyIdentifier.lastIndexOf('.'));
	        _this.mid = function (stringItem, start, count) {
	            var end = start + count;
	            return stringItem.substring(start, end);
	        };
	        _this.getPropertiesFromString = function (stringItem) {
	            if (!stringItem)
	                return;
	            var capture = false;
	            var property = '';
	            var results = [];
	            for (var i = 0; i < stringItem.length; i++) {
	                if (!capture && stringItem.substr(i, 2) == "${") {
	                    property = '';
	                    capture = true;
	                    i = i + 1; //skip the ${
	                }
	                else if (capture && stringItem[i] != '}') {
	                    property = property.concat(stringItem[i]);
	                }
	                else if (capture) {
	                    results.push(property);
	                    capture = false;
	                }
	            }
	            return results;
	        };
	        _this.replacePropertiesWithData = function (stringItem, data) {
	            var results = _this.getPropertiesFromString(stringItem);
	            for (var i = 0; i < results.length; i++) {
	                stringItem = stringItem.replace('${' + results[i] + '}', data[i]);
	            }
	            return stringItem;
	        };
	        _this.replaceAll = function (stringItem, find, replace) {
	            return stringItem.replace(new RegExp(_this.escapeRegExp(find), 'g'), replace);
	        };
	        _this.escapeRegExp = function (stringItem) {
	            return stringItem.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
	        };
	        _this.createID = function (count) {
	            var count = count || 26;
	            var text = "";
	            var firstPossibleCharacters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
	            var nextPossibleCharacters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
	            var currentPossibleCharacters = "";
	            for (var i = 0; i < count; i++) {
	                if (i === 0) {
	                    currentPossibleCharacters = firstPossibleCharacters;
	                }
	                else {
	                    currentPossibleCharacters = nextPossibleCharacters;
	                }
	                text += currentPossibleCharacters.charAt(Math.floor(Math.random() * currentPossibleCharacters.length));
	            }
	            return text;
	        };
	        //list functions
	        _this.arrayToList = function (array, delimiter) {
	            if (delimiter != null) {
	                return array.join(delimiter);
	            }
	            else {
	                return array.join();
	            }
	        };
	        _this.getPropertyValue = function (object, propertyIdentifier) {
	            var keys = propertyIdentifier.split('.'), obj = object, keyPart;
	            while ((keyPart = keys.shift()) && keys.length) {
	                obj = obj[keyPart];
	            }
	            return obj[keyPart];
	        };
	        _this.setPropertyValue = function (object, propertyIdentifier, value) {
	            var keys = propertyIdentifier.split('.'), obj = object, keyPart;
	            while ((keyPart = keys.shift()) && keys.length) {
	                if (!obj[keyPart]) {
	                    obj[keyPart] = {};
	                }
	                obj = obj[keyPart];
	            }
	            obj[keyPart] = value;
	        };
	        _this.nvpToObject = function (NVPData) {
	            var object = {};
	            for (var key in NVPData) {
	                var value = NVPData[key];
	                var propertyIdentitifer = key.replace(/\_/g, '.');
	                _this.setPropertyValue(object, propertyIdentitifer, value);
	            }
	            return object;
	        };
	        _this.isDescendantElement = function (parent, child) {
	            var node = child.parentNode;
	            while (node != null) {
	                if (node == parent) {
	                    return true;
	                }
	                node = node.parentNode;
	            }
	            return false;
	        };
	        //utility service toJson avoids circular references
	        _this.toJson = function (obj) {
	            var seen = [];
	            return JSON.stringify(obj, function (key, val) {
	                if (val != null && typeof val == "object") {
	                    if (seen.indexOf(val) >= 0) {
	                        return;
	                    }
	                    seen.push(val);
	                }
	                return val;
	            });
	        };
	        _this.listFind = function (list, value, delimiter) {
	            if (list === void 0) { list = ''; }
	            if (value === void 0) { value = ''; }
	            if (delimiter === void 0) { delimiter = ','; }
	            var splitString = list.split(delimiter);
	            var stringFound = -1;
	            for (var i = 0; i < splitString.length; i++) {
	                var stringPart = splitString[i];
	                if (stringPart === value) {
	                    stringFound = i;
	                }
	            }
	            return stringFound;
	        };
	        _this.listLen = function (list, delimiter) {
	            if (list === void 0) { list = ''; }
	            if (delimiter === void 0) { delimiter = ','; }
	            var splitString = list.split(delimiter);
	            return splitString.length;
	        };
	        //This will enable you to sort by two separate keys in the order they are passed in
	        _this.arraySorter = function (array, keysToSortBy) {
	            var arrayOfTypes = [], returnArray = [], firstKey = keysToSortBy[0];
	            if (angular.isDefined(keysToSortBy[1])) {
	                var secondKey = keysToSortBy[1];
	            }
	            for (var itemIndex in array) {
	                if (!(arrayOfTypes.indexOf(array[itemIndex][firstKey]) > -1)) {
	                    arrayOfTypes.push(array[itemIndex][firstKey]);
	                }
	            }
	            arrayOfTypes.sort(function (a, b) {
	                if (a < b) {
	                    return -1;
	                }
	                else if (a > b) {
	                    return 1;
	                }
	                else {
	                    return 0;
	                }
	            });
	            for (var typeIndex in arrayOfTypes) {
	                var tempArray = [];
	                for (var itemIndex in array) {
	                    if (array[itemIndex][firstKey] == arrayOfTypes[typeIndex]) {
	                        tempArray.push(array[itemIndex]);
	                    }
	                }
	                if (keysToSortBy[1] != null) {
	                    tempArray.sort(function (a, b) {
	                        if (a[secondKey] < b[secondKey]) {
	                            return -1;
	                        }
	                        else if (a[secondKey] > b[secondKey]) {
	                            return 1;
	                        }
	                        else {
	                            return 0;
	                        }
	                    });
	                }
	                for (var finalIndex in tempArray) {
	                    returnArray.push(tempArray[finalIndex]);
	                }
	            }
	            return returnArray;
	        };
	        _this.minutesOfDay = function (m) {
	            return m.getMinutes() + m.getHours() * 60;
	        };
	        return _this;
	    }
	    return UtilityService;
	}(baseservice_1.BaseService));
	exports.UtilityService = UtilityService;


/***/ },
/* 26 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var BaseService = (function () {
	    function BaseService() {
	    }
	    return BaseService;
	}());
	exports.BaseService = BaseService;


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	/*services return promises which can be handled uniquely based on success or failure by the controller*/
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var baseservice_1 = __webpack_require__(26);
	var SelectionService = (function (_super) {
	    __extends(SelectionService, _super);
	    //@ngInject
	    function SelectionService(observerService) {
	        var _this = _super.call(this) || this;
	        _this.observerService = observerService;
	        _this._selection = {};
	        /* add current selectionid to main selection object*/
	        _this.createSelections = function (selectionid) {
	            _this._selection[selectionid] = {
	                allSelected: false,
	                ids: []
	            };
	        };
	        _this.radioSelection = function (selectionid, selection) {
	            _this.createSelections(selectionid);
	            _this._selection[selectionid].ids.push(selection);
	            _this.observerService.notify('swSelectionToggleSelection' + selectionid, { action: 'check', selectionid: selectionid, selection: selection });
	        };
	        _this.addSelection = function (selectionid, selection) {
	            /*if allSelected flag is true addSelection will remove selection*/
	            if (_this.isAllSelected(selectionid)) {
	                var index = _this._selection[selectionid].ids.indexOf(selection);
	                if (index > -1) {
	                    _this._selection[selectionid].ids.splice(index, 1);
	                    _this.observerService.notify('swSelectionToggleSelection' + selectionid, { action: 'check', selectionid: selectionid, selection: selection });
	                }
	            }
	            else if (!_this.hasSelection(selectionid, selection)) {
	                _this._selection[selectionid].ids.push(selection);
	                _this.observerService.notify('swSelectionToggleSelection' + selectionid, { action: 'check', selectionid: selectionid, selection: selection });
	            }
	            console.info(_this._selection[selectionid]);
	        };
	        _this.setSelection = function (selectionid, selections) {
	            if (angular.isUndefined(_this._selection[selectionid])) {
	                _this.createSelections(selectionid);
	            }
	            _this._selection[selectionid].ids = selections;
	        };
	        _this.removeSelection = function (selectionid, selection) {
	            if (angular.isUndefined(_this._selection[selectionid])) {
	                return;
	            }
	            if (!_this.isAllSelected(selectionid)) {
	                var index = _this._selection[selectionid].ids.indexOf(selection);
	                if (index > -1) {
	                    _this._selection[selectionid].ids.splice(index, 1);
	                    _this.observerService.notify('swSelectionToggleSelection' + selectionid, { action: 'uncheck', selectionid: selectionid, selection: selection });
	                }
	            }
	            else if (!_this.hasSelection(selectionid, selection)) {
	                _this._selection[selectionid].ids.push(selection);
	                _this.observerService.notify('swSelectionToggleSelection' + selectionid, { action: 'uncheck', selectionid: selectionid, selection: selection });
	            }
	            console.info(_this._selection[selectionid]);
	        };
	        _this.hasSelection = function (selectionid, selection) {
	            if (angular.isUndefined(_this._selection[selectionid])) {
	                return false;
	            }
	            return _this._selection[selectionid].ids.indexOf(selection) > -1;
	        };
	        _this.getSelections = function (selectionid) {
	            if (angular.isUndefined(_this._selection[selectionid])) {
	                _this.createSelections(selectionid);
	            }
	            return _this._selection[selectionid].ids;
	        };
	        _this.getSelectionCount = function (selectionid) {
	            if (angular.isUndefined(_this._selection[selectionid])) {
	                _this.createSelections(selectionid);
	            }
	            return _this._selection[selectionid].ids.length;
	        };
	        _this.clearSelection = function (selectionid) {
	            _this.createSelections(selectionid);
	            _this.observerService.notify('swSelectionToggleSelection' + selectionid, { action: 'clear' });
	            console.info(_this._selection[selectionid]);
	        };
	        _this.selectAll = function (selectionid) {
	            _this._selection[selectionid] = {
	                allSelected: true,
	                ids: []
	            };
	            _this.observerService.notify('swSelectionToggleSelection' + selectionid, { action: 'selectAll' });
	            console.info(_this._selection[selectionid]);
	        };
	        _this.isAllSelected = function (selectionid) {
	            if (angular.isUndefined(_this._selection[selectionid])) {
	                _this.createSelections(selectionid);
	            }
	            return _this._selection[selectionid].allSelected;
	        };
	        return _this;
	    }
	    return SelectionService;
	}(baseservice_1.BaseService));
	exports.SelectionService = SelectionService;


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	/**
	 * @ngdoc service
	 * @name sdt.models:ObserverService
	 * @description
	 * # ObserverService
	 * Manages all events inside the application
	 *
	 */
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var baseservice_1 = __webpack_require__(26);
	var ObserverService = (function (_super) {
	    __extends(ObserverService, _super);
	    //@ngInject
	    function ObserverService($timeout, historyService, utilityService) {
	        var _this = 
	        /**
	         * @ngdoc property
	         * @name ObserverService#observers
	         * @propertyOf sdt.models:ObserverService
	         * @description object to store all observers in
	         * @returns {object} object
	         */
	        _super.call(this) || this;
	        _this.$timeout = $timeout;
	        _this.historyService = historyService;
	        _this.utilityService = utilityService;
	        /* Declare methods */
	        /**
	         * @ngdoc method
	         * @name ObserverService#attach
	         * @methodOf sdt.models:ObserverService
	         * @param {function} callback the callback function to fire
	         * @param {string} event name of the event
	         * @param {string} id unique id for the object that is listening i.e. namespace
	         * @description adds events listeners
	         */
	        _this.attach = function (callback, event, id) {
	            if (!id) {
	                id = _this.utilityService.createID();
	            }
	            event = event.toLowerCase();
	            id = id.toLowerCase();
	            if (!_this.observers[event]) {
	                _this.observers[event] = {};
	            }
	            if (!_this.observers[event][id])
	                _this.observers[event][id] = [];
	            _this.observers[event][id].push(callback);
	        };
	        /**
	         * @ngdoc method
	         * @name ObserverService#detachById
	         * @methodOf sdt.models:ObserverService
	         * @param {string} id unique id for the object that is listening i.e. namespace
	         * @description removes all events for a specific id from the observers object
	         */
	        _this.detachById = function (id) {
	            id = id.toLowerCase();
	            for (var event in _this.observers) {
	                _this.detachByEventAndId(event, id);
	            }
	        };
	        /**
	         * @ngdoc method
	         * @name ObserverService#detachById
	         * @methodOf sdt.models:ObserverService
	         * @param {string} event name of the event
	         * @description removes removes all the event from the observer object
	         */
	        _this.detachByEvent = function (event) {
	            event = event.toLowerCase();
	            if (event in _this.observers) {
	                delete _this.observers[event];
	            }
	        };
	        /**
	         * @ngdoc method
	         * @name ObserverService#detachByEventAndId
	         * @methodOf sdt.models:ObserverService
	         * @param {string} event name of the event
	         * @param {string} id unique id for the object that is listening i.e. namespace
	         * @description removes removes all callbacks for an id in a specific event from the observer object
	         */
	        _this.detachByEventAndId = function (event, id) {
	            event = event.toLowerCase();
	            id = id.toLowerCase();
	            if (event in _this.observers) {
	                if (id in _this.observers[event]) {
	                    delete _this.observers[event][id];
	                }
	            }
	        };
	        /**
	         * @ngdoc method
	         * @name ObserverService#notify
	         * @methodOf sdt.models:ObserverService
	         * @param {string} event name of the event
	         * @param {string|object|Array|number} parameters pass whatever your listener is expecting
	         * @description notifies all observers of a specific event
	         */
	        _this.notify = function (event, parameters) {
	            console.warn(event);
	            event = event.toLowerCase();
	            return _this.$timeout(function () {
	                for (var id in _this.observers[event]) {
	                    for (var _i = 0, _a = _this.observers[event][id]; _i < _a.length; _i++) {
	                        var callback = _a[_i];
	                        callback(parameters);
	                    }
	                }
	            });
	        };
	        /**
	         * @ngdoc method
	         * @name ObserverService#notifyById
	         * @methodOf sdt.models:ObserverService
	         * @param {string} event name of the event
	         * @param {string} eventId unique id for the object that is listening i.e. namespace
	         * @param {string|object|Array|number} parameters pass whatever your listener is expecting
	         * @description notifies observers of a specific event by id
	         */
	        _this.notifyById = function (event, eventId, parameters) {
	            event = event.toLowerCase();
	            eventId = eventId.toLowerCase();
	            return _this.$timeout(function () {
	                for (var id in _this.observers[event]) {
	                    if (id != eventId)
	                        continue;
	                    angular.forEach(_this.observers[event][id], function (callback) {
	                        callback(parameters);
	                    });
	                }
	            });
	        };
	        _this.notifyAndRecord = function (event, parameters) {
	            return _this.notify(event, parameters).then(function () {
	                _this.historyService.recordHistory(event, parameters, true);
	            });
	        };
	        _this.observers = {};
	        return _this;
	    }
	    return ObserverService;
	}(baseservice_1.BaseService));
	exports.ObserverService = ObserverService;


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var baseentityservice_1 = __webpack_require__(9);
	var OrderService = (function (_super) {
	    __extends(OrderService, _super);
	    //@ngInject
	    function OrderService($injector, $hibachi, utilityService) {
	        var _this = _super.call(this, $injector, $hibachi, utilityService, 'Order') || this;
	        _this.$injector = $injector;
	        _this.$hibachi = $hibachi;
	        _this.utilityService = utilityService;
	        _this.newOrder_AddOrderPayment = function () {
	            return _this.newProcessObject('Order_AddOrderPayment');
	        };
	        return _this;
	    }
	    return OrderService;
	}(baseentityservice_1.BaseEntityService));
	exports.OrderService = OrderService;


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var baseentityservice_1 = __webpack_require__(9);
	var OrderPaymentService = (function (_super) {
	    __extends(OrderPaymentService, _super);
	    //@ngInject
	    function OrderPaymentService($injector, $hibachi, utilityService) {
	        var _this = _super.call(this, $injector, $hibachi, utilityService, 'OrderPayment') || this;
	        _this.$injector = $injector;
	        _this.$hibachi = $hibachi;
	        _this.utilityService = utilityService;
	        return _this;
	    }
	    return OrderPaymentService;
	}(baseentityservice_1.BaseEntityService));
	exports.OrderPaymentService = OrderPaymentService;


/***/ },
/* 31 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var Form = (function () {
	    //@ngInject
	    function Form(name, object, editing) {
	        this.$addControl = function (control) { };
	        this.$removeControl = function (control) { };
	        this.$setValidity = function (validationErrorKey, isValid, control) { };
	        this.$setDirty = function () { };
	        this.$setPristine = function () { };
	        this.$commitViewValue = function () { };
	        this.$rollbackViewValue = function () { };
	        this.$setSubmitted = function () { };
	        this.$setUntouched = function () { };
	        this.name = name;
	        this.object = object;
	        this.editing = editing;
	    }
	    return Form;
	}());
	var FormService = (function () {
	    function FormService($log) {
	        var _this = this;
	        this.$log = $log;
	        this.setPristinePropertyValue = function (property, value) {
	            _this._pristinePropertyValue[property] = value;
	        };
	        this.getPristinePropertyValue = function (property) {
	            return _this._pristinePropertyValue[property];
	        };
	        this.setForm = function (form) {
	            _this._forms[form.name] = form;
	        };
	        this.getForm = function (formName) {
	            return _this._forms[formName];
	        };
	        this.getForms = function () {
	            return _this._forms;
	        };
	        this.getFormsByObjectName = function (objectName) {
	            var forms = [];
	            for (var f in _this._forms) {
	                if (angular.isDefined(_this._forms[f].$$swFormInfo.object) && _this._forms[f].$$swFormInfo.object.metaData.className === objectName) {
	                    forms.push(_this._forms[f]);
	                }
	            }
	            return forms;
	        };
	        this.createForm = function (name, object, editing) {
	            var _form = new Form(name, object, editing);
	            _this.setForm(_form);
	            return _form;
	        };
	        this.resetForm = function (form) {
	            _this.$log.debug('resetting form');
	            _this.$log.debug(form);
	            for (var key in form) {
	                if (angular.isDefined(form[key])
	                    && typeof form[key].$setViewValue == 'function'
	                    && angular.isDefined(form[key].$viewValue)) {
	                    _this.$log.debug(form[key]);
	                    if (angular.isDefined(_this.getPristinePropertyValue(key))) {
	                        form[key].$setViewValue(_this.getPristinePropertyValue(key));
	                    }
	                    else {
	                        form[key].$setViewValue('');
	                    }
	                    form[key].$setUntouched(true);
	                    form[key].$render();
	                    _this.$log.debug(form[key]);
	                }
	            }
	            form.$submitted = false;
	            form.$setPristine();
	            form.$setUntouched();
	        };
	        this.$log = $log;
	        this._forms = {};
	        this._pristinePropertyValue = {};
	    }
	    return FormService;
	}());
	FormService.$inject = ['$log'];
	exports.FormService = FormService;


/***/ },
/* 32 */
/***/ function(module, exports) {

	"use strict";
	var FilterService = (function () {
	    //ngInject
	    function FilterService() {
	        this.filterMatch = function (valueToCompareAgainst, comparisonOperator, comparisonValue) {
	            switch (comparisonOperator) {
	                case "!=":
	                    if (valueToCompareAgainst != comparisonValue) {
	                        return true;
	                    }
	                    break;
	                case ">":
	                    if (valueToCompareAgainst > comparisonValue) {
	                        return true;
	                    }
	                    break;
	                case ">=":
	                    if (valueToCompareAgainst >= comparisonValue) {
	                        return true;
	                    }
	                    break;
	                case "<":
	                    if (valueToCompareAgainst < comparisonValue) {
	                        return true;
	                    }
	                    break;
	                case "<=":
	                    if (valueToCompareAgainst <= comparisonValue) {
	                        return true;
	                    }
	                    break;
	                case "is":
	                    if (valueToCompareAgainst == comparisonValue) {
	                        return true;
	                    }
	                    break;
	                case "is not":
	                    if (valueToCompareAgainst != comparisonValue) {
	                        return true;
	                    }
	                    break;
	                default:
	                    //= case
	                    if (valueToCompareAgainst == comparisonValue) {
	                        return true;
	                    }
	                    break;
	            }
	            return false;
	        };
	    }
	    return FilterService;
	}());
	exports.FilterService = FilterService;


/***/ },
/* 33 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var ExpandableService = (function () {
	    //ngInject
	    function ExpandableService() {
	        var _this = this;
	        this.recordStates = {};
	        this.addRecord = function (recordID, state) {
	            if (angular.isUndefined(state)) {
	                state = { isLoaded: true };
	            }
	            _this.recordStates[recordID] = state;
	        };
	        this.updateState = function (recordID, state) {
	            if (angular.isUndefined(_this.recordStates[recordID])) {
	                _this.recordStates[recordID] = {};
	            }
	            for (var key in state) {
	                _this.recordStates[recordID][key] = state[key];
	            }
	        };
	        this.getState = function (recordID, key) {
	            if (angular.isDefined(_this.recordStates[recordID]) && angular.isDefined(key)) {
	                var dataToReturn = _this.recordStates[recordID][key];
	            }
	            else {
	                var dataToReturn = _this.recordStates[recordID];
	            }
	            if (angular.isDefined(dataToReturn)) {
	                return dataToReturn;
	            }
	            return false;
	        };
	    }
	    return ExpandableService;
	}());
	exports.ExpandableService = ExpandableService;


/***/ },
/* 34 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var MetaDataService = (function () {
	    //@ngInject
	    function MetaDataService($filter, $log) {
	        var _this = this;
	        this.$filter = $filter;
	        this.$log = $log;
	        this.getPropertyHintByObjectAndPropertyIdentifier = function (object, propertyIdentifier) {
	            var hint = "";
	            if (_this.hasPropertyByEntityNameAndPropertyIdentifier(object, propertyIdentifier)) {
	                if (_this.isAttributePropertyByEntityAndPropertyIdentifier(object, propertyIdentifier)) {
	                    hint = object.metaData && object.metaData[propertyIdentifier].attributeHint;
	                }
	                else {
	                    hint = object.metaData.$$getPropertyHint(propertyIdentifier);
	                }
	            }
	            return hint;
	        };
	        this.getPropertyTitle = function (object, propertyIdentifier) {
	            var title = "";
	            if (_this.hasPropertyByEntityNameAndPropertyIdentifier(object, propertyIdentifier)) {
	                if (_this.isAttributePropertyByEntityAndPropertyIdentifier(object, propertyIdentifier)) {
	                    title = object.metaData && object.metaData[propertyIdentifier].attributeName;
	                }
	                else {
	                    title = object.metaData.$$getPropertyTitle(propertyIdentifier);
	                }
	            }
	            return title;
	        };
	        this.getPropertyFieldType = function (object, propertyIdentifier) {
	            var fieldType = "";
	            if (_this.hasPropertyByEntityNameAndPropertyIdentifier(object, propertyIdentifier)) {
	                if (_this.isAttributePropertyByEntityAndPropertyIdentifier(object, propertyIdentifier)) {
	                    fieldType = object.metaData && object.metaData[propertyIdentifier].attributeInputType;
	                }
	                else {
	                    fieldType = object.metaData.$$getPropertyFieldType(propertyIdentifier);
	                }
	            }
	            return fieldType;
	        };
	        this.isAttributePropertyByEntityAndPropertyIdentifier = function (object, propertyIdentifier) {
	            return object.metaData && object.metaData[propertyIdentifier] && object.metaData[propertyIdentifier].attributeCode == propertyIdentifier;
	        };
	        this.hasPropertyByEntityNameAndPropertyIdentifier = function (object, propertyIdentifier) {
	            return object.metaData && object.metaData[propertyIdentifier];
	        };
	        this.getPropertiesList = function () {
	            return _this._propertiesList;
	        };
	        this.getPropertiesListByBaseEntityAlias = function (baseEntityAlias) {
	            return _this._propertiesList[baseEntityAlias];
	        };
	        this.setPropertiesList = function (value, key) {
	            _this._propertiesList[key] = value;
	        };
	        this.formatPropertiesList = function (propertiesList, propertyIdentifier) {
	            var simpleGroup = {
	                $$group: 'simple',
	            };
	            propertiesList.data.push(simpleGroup);
	            var drillDownGroup = {
	                $$group: 'drilldown',
	            };
	            propertiesList.data.push(drillDownGroup);
	            var compareCollections = {
	                $$group: 'compareCollections',
	            };
	            propertiesList.data.push(compareCollections);
	            var attributeCollections = {
	                $$group: 'attribute',
	            };
	            propertiesList.data.push(attributeCollections);
	            for (var i in propertiesList.data) {
	                if (angular.isDefined(propertiesList.data[i].ormtype)) {
	                    if (angular.isDefined(propertiesList.data[i].attributeID)) {
	                        propertiesList.data[i].$$group = 'attribute';
	                    }
	                    else {
	                        propertiesList.data[i].$$group = 'simple';
	                    }
	                }
	                if (angular.isDefined(propertiesList.data[i].fieldtype)) {
	                    if (propertiesList.data[i].fieldtype === 'id') {
	                        propertiesList.data[i].$$group = 'simple';
	                    }
	                    if (propertiesList.data[i].fieldtype === 'many-to-one') {
	                        propertiesList.data[i].$$group = 'drilldown';
	                    }
	                    if (propertiesList.data[i].fieldtype === 'many-to-many' || propertiesList.data[i].fieldtype === 'one-to-many') {
	                        propertiesList.data[i].$$group = 'compareCollections';
	                    }
	                }
	                var divider = '_';
	                if (propertiesList.data[i].$$group == 'simple' || propertiesList.data[i].$$group == 'attribute') {
	                    divider = '.';
	                }
	                propertiesList.data[i].propertyIdentifier = propertyIdentifier + divider + propertiesList.data[i].name;
	            }
	            //propertiesList.data = _orderBy(propertiesList.data,['displayPropertyIdentifier'],false);
	            //--------------------------------Removes empty lines from dropdown.
	            var temp = [];
	            for (var i_1 = 0; i_1 <= propertiesList.data.length - 1; i_1++) {
	                if (propertiesList.data[i_1].propertyIdentifier.indexOf(".undefined") != -1 || propertiesList.data[i_1].propertyIdentifier.indexOf("_undefined") != -1) {
	                    _this.$log.debug("removing: " + propertiesList.data[i_1].displayPropertyIdentifier);
	                    propertiesList.data[i_1].displayPropertyIdentifier = "hide";
	                }
	                else {
	                    temp.push(propertiesList.data[i_1]);
	                    _this.$log.debug(propertiesList.data[i_1]);
	                }
	            }
	            temp.sort;
	            propertiesList.data = temp;
	            _this.$log.debug("----------------------PropertyList\n\n\n\n\n");
	            propertiesList.data = _this._orderBy(propertiesList.data, ['propertyIdentifier'], false);
	            //--------------------------------End remove empty lines.
	        };
	        this.orderBy = function (propertiesList, predicate, reverse) {
	            return _this._orderBy(propertiesList, predicate, reverse);
	        };
	        this.$filter = $filter;
	        this.$log = $log;
	        this._propertiesList = {};
	        this._orderBy = $filter('orderBy');
	    }
	    return MetaDataService;
	}());
	MetaDataService.$inject = [
	    '$filter',
	    '$log'
	];
	exports.MetaDataService = MetaDataService;


/***/ },
/* 35 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var RbKeyService = (function () {
	    //@ngInject
	    function RbKeyService($http, $q, appConfig, resourceBundles) {
	        var _this = this;
	        this.$http = $http;
	        this.$q = $q;
	        this.appConfig = appConfig;
	        this.resourceBundles = resourceBundles;
	        this._resourceBundle = {};
	        this._resourceBundleLastModified = '';
	        this._loadingResourceBundle = false;
	        this._loadedResourceBundle = false;
	        this.getRBLoaded = function () {
	            return _this._loadedResourceBundle;
	        };
	        this.rbKey = function (key, replaceStringData) {
	            ////$log.debug('rbkey');
	            ////$log.debug(key);
	            ////$log.debug(this.getConfig().rbLocale);
	            var keyValue = _this.getRBKey(key, _this.appConfig.rbLocale);
	            ////$log.debug(keyValue);
	            return keyValue;
	        };
	        this.getRBKey = function (key, locale, checkedKeys, originalKey) {
	            ////$log.debug('getRBKey');
	            ////$log.debug('loading:'+this._loadingResourceBundle);
	            ////$log.debug('loaded'+this._loadedResourceBundle);
	            if (_this.resourceBundles) {
	                key = key.toLowerCase();
	                checkedKeys = checkedKeys || "";
	                locale = locale || 'en_us';
	                ////$log.debug('locale');
	                ////$log.debug(locale);
	                var keyListArray = key.split(',');
	                ////$log.debug('keylistAray');
	                ////$log.debug(keyListArray);
	                if (keyListArray.length > 1) {
	                    var keyValue = "";
	                    for (var i = 0; i < keyListArray.length; i++) {
	                        keyValue = _this.getRBKey(keyListArray[i], locale, keyValue);
	                        //$log.debug('keyvalue:'+keyValue);
	                        if (keyValue.slice(-8) != "_missing") {
	                            break;
	                        }
	                    }
	                    return keyValue;
	                }
	                var bundle = _this.resourceBundles[locale];
	                if (angular.isDefined(bundle[key])) {
	                    //$log.debug('rbkeyfound:'+bundle[key]);
	                    return bundle[key];
	                }
	                var checkedKeysListArray = checkedKeys.split(',');
	                checkedKeysListArray.push(key + '_' + locale + '_missing');
	                checkedKeys = checkedKeysListArray.join(",");
	                if (angular.isUndefined(originalKey)) {
	                    originalKey = key;
	                }
	                //$log.debug('originalKey:'+key);
	                //$log.debug(checkedKeysListArray);
	                var localeListArray = locale.split('_');
	                //$log.debug(localeListArray);
	                if (localeListArray.length === 2) {
	                    bundle = _this.resourceBundles[localeListArray[0]];
	                    if (angular.isDefined(bundle[key])) {
	                        //$log.debug('rbkey found:'+bundle[key]);
	                        return bundle[key];
	                    }
	                    checkedKeysListArray.push(key + '_' + localeListArray[0] + '_missing');
	                    checkedKeys = checkedKeysListArray.join(",");
	                }
	                var keyDotListArray = key.split('.');
	                if (keyDotListArray.length >= 3
	                    && keyDotListArray[keyDotListArray.length - 2] === 'define') {
	                    var newKey = key.replace(keyDotListArray[keyDotListArray.length - 3] + '.define', 'define');
	                    //$log.debug('newkey1:'+newKey);
	                    return _this.getRBKey(newKey, locale, checkedKeys, originalKey);
	                }
	                else if (keyDotListArray.length >= 2 && keyDotListArray[keyDotListArray.length - 2] !== 'define') {
	                    var newKey = key.replace(keyDotListArray[keyDotListArray.length - 2] + '.', 'define.');
	                    //$log.debug('newkey:'+newKey);
	                    return _this.getRBKey(newKey, locale, checkedKeys, originalKey);
	                }
	                //$log.debug(localeListArray);
	                if (localeListArray[0] !== "en") {
	                    return _this.getRBKey(originalKey, 'en', checkedKeys);
	                }
	                return checkedKeys;
	            }
	            return '';
	        };
	        this.$q = $q;
	        this.$http = $http;
	        this.appConfig = appConfig;
	        this.resourceBundles = resourceBundles;
	    }
	    return RbKeyService;
	}());
	exports.RbKeyService = RbKeyService;


/***/ },
/* 36 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var TypeaheadService = (function () {
	    //@ngInject
	    function TypeaheadService($timeout, observerService) {
	        var _this = this;
	        this.$timeout = $timeout;
	        this.observerService = observerService;
	        this.typeaheadData = {};
	        this.typeaheadPromises = {};
	        this.typeaheadStates = {};
	        this.getTypeaheadSelectionUpdateEvent = function (key) {
	            return "typeaheadSelectionUpdated" + key;
	        };
	        this.attachTypeaheadSelectionUpdateEvent = function (key, callback) {
	            _this.observerService.attach(callback, _this.getTypeaheadSelectionUpdateEvent(key));
	        };
	        this.notifyTypeaheadSelectionUpdateEvent = function (key) {
	            _this.observerService.notify(_this.getTypeaheadSelectionUpdateEvent(key));
	        };
	        this.setTypeaheadState = function (key, state) {
	            _this.typeaheadStates[key] = state;
	        };
	        this.getTypeaheadState = function (key) {
	            return _this.typeaheadStates[key];
	        };
	        this.getTypeaheadPrimaryIDPropertyName = function (key) {
	            return _this.getTypeaheadState(key).primaryIDPropertyName;
	        };
	        this.getIndexOfSelection = function (key, data) {
	            for (var j = 0; j < _this.getData(key).length; j++) {
	                if (angular.isDefined(data[_this.getTypeaheadPrimaryIDPropertyName(key)]) &&
	                    data[_this.getTypeaheadPrimaryIDPropertyName(key)] == _this.getData(key)[j][_this.getTypeaheadPrimaryIDPropertyName(key)]) {
	                    return j;
	                }
	                else if (_this.checkAgainstFallbackProperties(key, _this.getData(key)[j], data)) {
	                    return j;
	                }
	            }
	            return -1;
	        };
	        this.addSelection = function (key, data) {
	            if (angular.isUndefined(_this.typeaheadData[key])) {
	                _this.typeaheadData[key] = [];
	            }
	            _this.typeaheadData[key].push(data);
	            _this.notifyTypeaheadSelectionUpdateEvent(key);
	        };
	        this.removeSelection = function (key, index, data) {
	            if (angular.isUndefined(index) &&
	                angular.isDefined(data)) {
	                index = _this.getIndexOfSelection(key, data);
	            }
	            if (angular.isDefined(index) &&
	                angular.isDefined(_this.typeaheadData[key]) &&
	                index != -1) {
	                _this.updateSelections(key);
	                var removedItem = _this.typeaheadData[key].splice(index, 1)[0]; //this will always be an array of 1 element
	                _this.notifyTypeaheadSelectionUpdateEvent(key);
	                return removedItem;
	            }
	        };
	        this.initializeSelections = function (key, selectedCollectionConfig) {
	            selectedCollectionConfig.setAllRecords(true);
	            _this.typeaheadPromises[key] = selectedCollectionConfig.getEntity();
	            _this.typeaheadPromises[key].then(function (data) {
	                for (var j = 0; j < data.records.length; j++) {
	                    _this.addSelection(key, data.records[j]);
	                }
	            }, function (reason) {
	                throw ("typeaheadservice had trouble intializing selections for " + key + " because " + reason);
	            });
	        };
	        this.updateSelections = function (key) {
	            if (angular.isDefined(_this.getData(key)) && _this.getData(key).length) {
	                for (var j = 0; j < _this.getTypeaheadState(key).results.length; j++) {
	                    for (var i = 0; i < _this.getData(key).length; i++) {
	                        if (_this.getData(key)[i][_this.getTypeaheadPrimaryIDPropertyName(key)] == _this.getTypeaheadState(key).results[j][_this.getTypeaheadPrimaryIDPropertyName(key)]) {
	                            _this.markResultSelected(_this.getTypeaheadState(key).results[j], i);
	                            break;
	                        }
	                        var found = _this.checkAgainstFallbackProperties(key, _this.getData(key)[i], _this.getTypeaheadState(key).results[j], i);
	                        if (found) {
	                            break;
	                        }
	                    }
	                }
	            }
	        };
	        this.markResultSelected = function (result, index) {
	            result.selected = true;
	            result.selectedIndex = index;
	        };
	        this.checkAgainstFallbackProperties = function (key, selection, result, selectionIndex) {
	            var resultPrimaryID = result[_this.getTypeaheadPrimaryIDPropertyName(key)];
	            //is there a singular property to compare against
	            if (angular.isDefined(_this.getTypeaheadState(key).propertyToCompare) &&
	                _this.getTypeaheadState(key).propertyToCompare.length) {
	                if (angular.isDefined(selection[_this.getTypeaheadState(key).propertyToCompare]) &&
	                    selection[_this.getTypeaheadState(key).propertyToCompare] == resultPrimaryID) {
	                    if (angular.isDefined(selectionIndex)) {
	                        _this.markResultSelected(result, selectionIndex);
	                    }
	                    return true;
	                }
	                if (angular.isDefined(selection[_this.getTypeaheadState(key).propertyToCompare]) &&
	                    angular.isDefined(result[_this.getTypeaheadState(key).propertyToCompare]) &&
	                    selection[_this.getTypeaheadState(key).propertyToCompare] == result[_this.getTypeaheadState(key).propertyToCompare]) {
	                    if (angular.isDefined(selectionIndex)) {
	                        _this.markResultSelected(result, selectionIndex);
	                    }
	                    return true;
	                }
	            }
	            //check the defined fallback properties to see if theres a match
	            if (_this.getTypeaheadState(key).fallbackPropertyArray.length > 0) {
	                for (var j = 0; j < _this.getTypeaheadState(key).fallbackPropertyArray.length; j++) {
	                    var property = _this.getTypeaheadState(key).fallbackPropertyArray[j];
	                    if (angular.isDefined(selection[property])) {
	                        if (selection[property] == resultPrimaryID) {
	                            if (angular.isDefined(selectionIndex)) {
	                                _this.markResultSelected(result, selectionIndex);
	                            }
	                            return true;
	                        }
	                        if (angular.isDefined(result[property]) &&
	                            selection[property] == result[property]) {
	                            if (angular.isDefined(selectionIndex)) {
	                                _this.markResultSelected(result, selectionIndex);
	                            }
	                            return true;
	                        }
	                    }
	                }
	            }
	            return false;
	        };
	        this.updateSelectionList = function (key) {
	            var selectionIDArray = [];
	            if (angular.isDefined(_this.getData(key))) {
	                for (var j = 0; j < _this.getData(key).length; j++) {
	                    var selection = _this.getData(key)[j];
	                    var primaryID = selection[_this.getTypeaheadPrimaryIDPropertyName(key)];
	                    if (angular.isDefined(primaryID)) {
	                        selectionIDArray.push(primaryID);
	                    }
	                    else if (angular.isDefined(_this.getTypeaheadState(key).propertyToCompare) &&
	                        angular.isDefined(selection[_this.getTypeaheadState(key).propertyToCompare])) {
	                        selectionIDArray.push(selection[_this.getTypeaheadState(key).propertyToCompare]);
	                    }
	                    else if (angular.isDefined(_this.getTypeaheadState(key).fallbackPropertyArray)) {
	                        var fallbackPropertyArray = _this.getTypeaheadState(key).fallbackPropertyArray;
	                        for (var i = 0; i < fallbackPropertyArray.length; i++) {
	                            var fallbackProperty = fallbackPropertyArray[i];
	                            if (angular.isDefined(selection[fallbackProperty])) {
	                                selectionIDArray.push(selection[fallbackProperty]);
	                                break;
	                            }
	                        }
	                    }
	                }
	            }
	            return selectionIDArray.join(",");
	        };
	        this.getData = function (key) {
	            if (key in _this.typeaheadPromises) {
	                //wait until it's been intialized
	                _this.typeaheadPromises[key].then().finally(function () {
	                    return _this.typeaheadData[key] || [];
	                });
	                delete _this.typeaheadPromises[key];
	            }
	            else {
	                return _this.typeaheadData[key] || [];
	            }
	        };
	        //strips out dangerous directives that cause infinite compile errors 
	        // - this probably belongs in a different service but is used for typeahead only at the moment
	        this.stripTranscludedContent = function (transcludedContent) {
	            for (var i = 0; i < transcludedContent.length; i++) {
	                if (angular.isDefined(transcludedContent[i].localName) &&
	                    transcludedContent[i].localName == 'ng-transclude') {
	                    transcludedContent = transcludedContent.children();
	                }
	            }
	            //prevent collection config from being recompiled
	            for (var i = 0; i < transcludedContent.length; i++) {
	                if (angular.isDefined(transcludedContent[i].localName) &&
	                    transcludedContent[i].localName == 'sw-collection-config') {
	                    transcludedContent.splice(i, 1);
	                }
	            }
	            return transcludedContent;
	        };
	    }
	    return TypeaheadService;
	}());
	exports.TypeaheadService = TypeaheadService;


/***/ },
/* 37 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	// interface ISlatwallRootScopeService extends ng.IRootScopeService{
	//     loadedResourceBundle:boolean;
	// 	loadingResourceBundle:boolean;
	// }
	var HibachiService = (function () {
	    //@ngInject
	    function HibachiService($window, $q, $http, $timeout, $log, $rootScope, $location, $anchorScroll, requestService, utilityService, formService, rbkeyService, appConfig, _config, _jsEntities, _jsEntityInstances) {
	        var _this = this;
	        this.$window = $window;
	        this.$q = $q;
	        this.$http = $http;
	        this.$timeout = $timeout;
	        this.$log = $log;
	        this.$rootScope = $rootScope;
	        this.$location = $location;
	        this.$anchorScroll = $anchorScroll;
	        this.requestService = requestService;
	        this.utilityService = utilityService;
	        this.formService = formService;
	        this.rbkeyService = rbkeyService;
	        this.appConfig = appConfig;
	        this._config = _config;
	        this._jsEntities = _jsEntities;
	        this._jsEntityInstances = _jsEntityInstances;
	        this._deferred = {};
	        this._resourceBundle = {};
	        this.buildUrl = function (action, queryString) {
	            //actionName example: slatAction. defined in FW1 and populated to config
	            var actionName = _this.appConfig.action;
	            var baseUrl = _this.appConfig.baseURL;
	            queryString = queryString || '';
	            if (angular.isDefined(queryString) && queryString.length) {
	                if (queryString.indexOf('&') !== 0) {
	                    queryString = '&' + queryString;
	                }
	            }
	            return baseUrl + '?' + actionName + '=' + action + queryString;
	        };
	        this.getUrlWithActionPrefix = function () {
	            return _this.appConfig.baseURL + '/index.cfm/?' + _this.appConfig.action + "=";
	        };
	        this.getJsEntities = function () {
	            return _this._jsEntities;
	        };
	        this.setJsEntities = function (jsEntities) {
	            _this._jsEntities = jsEntities;
	        };
	        this.getJsEntityInstances = function () {
	            return _this._jsEntityInstances;
	        };
	        this.setJsEntityInstances = function (jsEntityInstances) {
	            _this._jsEntityInstances = jsEntityInstances;
	        };
	        this.getEntityExample = function (entityName) {
	            return _this._jsEntityInstances[entityName];
	        };
	        this.getEntityMetaData = function (entityName) {
	            return _this._jsEntityInstances[entityName].metaData;
	        };
	        this.getPropertyByEntityNameAndPropertyName = function (entityName, propertyName) {
	            return _this.getEntityMetaData(entityName)[propertyName];
	        };
	        this.getPrimaryIDPropertyNameByEntityName = function (entityName) {
	            return _this.getEntityExample(entityName).$$getIDName();
	        };
	        this.getEntityHasPropertyByEntityName = function (entityName, propertyName) {
	            return angular.isDefined(_this.getEntityMetaData(entityName)[propertyName]);
	        };
	        this.getBaseEntityAliasFromName = function (entityName) {
	            return '_' + entityName;
	        };
	        this.getPropertyIsObjectByEntityNameAndPropertyIdentifier = function (entityName, propertyIdentifier) {
	            var lastEntity = _this.getLastEntityNameInPropertyIdentifier(entityName, propertyIdentifier);
	            var entityMetaData = _this.getEntityMetaData(lastEntity);
	            return angular.isDefined(entityMetaData[_this.utilityService.listLast(propertyIdentifier, '.')].cfc);
	        };
	        this.getLastEntityNameInPropertyIdentifier = function (entityName, propertyIdentifier) {
	            if (!entityName) {
	                throw ('No entity name was supplied to getLastEntityNameInPropertyIdentifier in hibachi service.');
	            }
	            //strip alias if it exists and convert everything to be periods
	            if (propertyIdentifier.charAt(0) === '_') {
	                propertyIdentifier = _this.utilityService.listRest(propertyIdentifier.replace(/_/g, '.'), '.');
	            }
	            var propertyIdentifierArray = propertyIdentifier.split('.');
	            if (propertyIdentifierArray[0] === entityName.toLowerCase()) {
	                propertyIdentifierArray.shift();
	            }
	            if (propertyIdentifierArray.length > 1) {
	                var propertiesStruct = _this.getEntityMetaData(entityName);
	                var currentProperty = propertyIdentifierArray.shift();
	                if (!propertiesStruct[currentProperty] ||
	                    !propertiesStruct[currentProperty].cfc) {
	                    throw ("The Property Identifier " + propertyIdentifier + " is invalid for the entity " + entityName);
	                }
	                var currentEntityName = propertiesStruct[currentProperty].cfc;
	                var currentPropertyIdentifier = propertyIdentifierArray.join('.');
	                return _this.getLastEntityNameInPropertyIdentifier(currentEntityName, currentPropertyIdentifier);
	            }
	            return entityName;
	        };
	        //helper method to inflate a new entity with data
	        this.populateEntity = function (entityName, data) {
	            var newEntity = _this.newEntity(entityName);
	            angular.extend(newEntity.data, data);
	            return newEntity;
	        };
	        //service method used to transform collection data to collection objects based on a collectionconfig
	        this.populateCollection = function (collectionData, collectionConfig) {
	            //create array to hold objects
	            var entities = [];
	            //loop over all collection data to create objects
	            var hibachiService = _this;
	            angular.forEach(collectionData, function (collectionItemData, key) {
	                //create base Entity
	                var entity = hibachiService['new' + collectionConfig.baseEntityName.replace('Slatwall', '')]();
	                //populate entity with data based on the collectionConfig
	                angular.forEach(collectionConfig.columns, function (column, key) {
	                    //get objects base properties
	                    var propertyIdentifier = column.propertyIdentifier.replace(collectionConfig.baseEntityAlias.toLowerCase(), '');
	                    propertyIdentifier = _this.utilityService.replaceAll(propertyIdentifier, '_', '.');
	                    if (propertyIdentifier.charAt(0) === '.') {
	                        propertyIdentifier = propertyIdentifier.slice(1);
	                    }
	                    console.log(propertyIdentifier);
	                    var propertyIdentifierArray = propertyIdentifier.split('.');
	                    var propertyIdentifierKey = propertyIdentifier.replace(/\./g, '_');
	                    console.log(propertyIdentifierKey);
	                    var currentEntity = entity;
	                    angular.forEach(propertyIdentifierArray, function (property, key) {
	                        if (key === propertyIdentifierArray.length - 1) {
	                            //if we are on the last item in the array
	                            if (angular.isObject(collectionItemData[propertyIdentifierKey]) && currentEntity.metaData[property].fieldtype === 'many-to-one') {
	                                var relatedEntity = hibachiService['new' + currentEntity.metaData[property].cfc]();
	                                relatedEntity.$$init(collectionItemData[propertyIdentifierKey][0]);
	                                currentEntity['$$set' + currentEntity.metaData[property].name.charAt(0).toUpperCase() + currentEntity.metaData[property].name.slice(1)](relatedEntity);
	                            }
	                            else if (angular.isArray(collectionItemData[propertyIdentifierKey]) && (currentEntity.metaData[property].fieldtype === 'one-to-many')) {
	                                angular.forEach(collectionItemData[propertyIdentifierKey], function (arrayItem, key) {
	                                    var relatedEntity = hibachiService['new' + currentEntity.metaData[property].cfc]();
	                                    relatedEntity.$$init(arrayItem);
	                                    currentEntity['$$add' + currentEntity.metaData[property].singularname.charAt(0).toUpperCase() + currentEntity.metaData[property].singularname.slice(1)](relatedEntity);
	                                });
	                            }
	                            else {
	                                currentEntity.data[property] = collectionItemData[propertyIdentifierKey];
	                            }
	                        }
	                        else {
	                            var propertyMetaData = currentEntity.metaData[property];
	                            if (angular.isUndefined(currentEntity.data[property])) {
	                                if (propertyMetaData.fieldtype === 'one-to-many') {
	                                    relatedEntity = [];
	                                }
	                                else {
	                                    relatedEntity = hibachiService['new' + propertyMetaData.cfc]();
	                                }
	                            }
	                            else {
	                                relatedEntity = currentEntity.data[property];
	                            }
	                            currentEntity['$$set' + propertyMetaData.name.charAt(0).toUpperCase() + propertyMetaData.name.slice(1)](relatedEntity);
	                            currentEntity = relatedEntity;
	                        }
	                    });
	                });
	                entities.push(entity);
	            });
	            return entities;
	        };
	        /*basic entity getter where id is optional, returns a promise*/
	        this.getDefer = function (deferKey) {
	            return _this._deferred[deferKey];
	        };
	        this.cancelPromise = function (deferKey) {
	            var deferred = _this.getDefer(deferKey);
	            if (angular.isDefined(deferred)) {
	                deferred.resolve({ messages: [{ messageType: 'error', message: 'User Cancelled' }] });
	            }
	        };
	        this.newEntity = function (entityName) {
	            var entityServiceName = entityName.charAt(0).toLowerCase() + entityName.slice(1) + 'Service';
	            if (angular.element(document.body).injector().has(entityServiceName)) {
	                var entityService = angular.element(document.body).injector().get(entityServiceName);
	                return entityService['new' + entityName]();
	            }
	            return new _this._jsEntities[entityName];
	        };
	        this.getEntityDefinition = function (entityName) {
	            return _this._jsEntities[entityName];
	        };
	        /*basic entity getter where id is optional, returns a promise*/
	        this.getEntity = function (entityName, options) {
	            /*
	            *
	            * getEntity('Product', '12345-12345-12345-12345');
	            * getEntity('Product', {keywords='Hello'});
	            *
	            */
	            var apiSubsystemName = _this.appConfig.apiSubsystemName || "api";
	            if (angular.isUndefined(options)) {
	                options = {};
	            }
	            if (angular.isDefined(options.deferKey)) {
	                _this.cancelPromise(options.deferKey);
	            }
	            var params = {};
	            if (typeof options === 'string') {
	                var urlString = _this.getUrlWithActionPrefix() + apiSubsystemName + ':' + 'main.get&entityName=' + entityName + '&entityID=' + options;
	            }
	            else {
	                params['P:Current'] = options.currentPage || 1;
	                params['P:Show'] = options.pageShow || 10;
	                params.keywords = options.keywords || '';
	                params.columnsConfig = options.columnsConfig || '';
	                params.filterGroupsConfig = options.filterGroupsConfig || '';
	                params.joinsConfig = options.joinsConfig || '';
	                params.orderByConfig = options.orderByConfig || '';
	                params.groupBysConfig = options.groupBysConfig || '';
	                params.isDistinct = options.isDistinct || false;
	                params.propertyIdentifiersList = options.propertyIdentifiersList || '';
	                params.allRecords = options.allRecords || false;
	                params.defaultColumns = options.defaultColumns || true;
	                params.processContext = options.processContext || '';
	                var urlString = _this.getUrlWithActionPrefix() + apiSubsystemName + ':' + 'main.get&entityName=' + entityName;
	            }
	            if (angular.isDefined(options.id)) {
	                urlString += '&entityId=' + options.id;
	            }
	            var transformResponse = function (data) {
	                if (angular.isString(data)) {
	                    data = JSON.parse(data);
	                }
	                return data;
	            };
	            //check if we are using a service to transform the response
	            if (angular.isDefined(options.transformResponse)) {
	                transformResponse = function (data) {
	                    var data = JSON.parse(data);
	                    if (angular.isDefined(data.records)) {
	                        data = options.transformResponse(data.records);
	                    }
	                    return data;
	                };
	            }
	            var request = _this.requestService.newAdminRequest(urlString, params);
	            if (options.deferKey) {
	                _this._deferred[options.deferKey] = request;
	            }
	            return request.promise;
	        };
	        this.getResizedImageByProfileName = function (profileName, skuIDs) {
	            var urlString = _this.getUrlWithActionPrefix() + 'api:main.getResizedImageByProfileName&context=getResizedImageByProfileName&profileName=' + profileName + '&skuIDs=' + skuIDs;
	            var request = _this.requestService.newPublicRequest(urlString);
	            return request.promise;
	        };
	        this.getEventOptions = function (entityName) {
	            var urlString = _this.getUrlWithActionPrefix() + 'api:main.getEventOptionsByEntityName&entityName=' + entityName;
	            var request = _this.requestService.newAdminRequest(urlString);
	            return request.promise;
	        };
	        this.getProcessOptions = function (entityName) {
	            var urlString = _this.getUrlWithActionPrefix() + 'api:main.getProcessMethodOptionsByEntityName&entityName=' + entityName;
	            var request = _this.requestService.newAdminRequest(urlString);
	            return request.promise;
	        };
	        this.checkUniqueOrNullValue = function (object, property, value) {
	            var objectName = object.metaData.className;
	            var objectID = object.$$getID();
	            return _this.$http.get(_this.getUrlWithActionPrefix() + 'api:main.getValidationPropertyStatus&object=' + objectName + '&objectID=' + objectID + '&propertyidentifier=' + property +
	                '&value=' + escape(value)).then(function (results) {
	                return results.data.uniqueStatus;
	            });
	        };
	        this.checkUniqueValue = function (object, property, value) {
	            var objectName = object.metaData.className;
	            var objectID = object.$$getID();
	            return _this.$http.get(_this.getUrlWithActionPrefix() + 'api:main.getValidationPropertyStatus&object=' + objectName + '&objectID=' + objectID + '&propertyidentifier=' + property +
	                '&value=' + escape(value)).then(function (results) {
	                return results.data.uniqueStatus;
	            });
	        };
	        this.getPropertyDisplayData = function (entityName, options) {
	            var urlString = _this.getUrlWithActionPrefix() + 'api:main.getPropertyDisplayData&entityName=' + entityName;
	            var params = {};
	            params.propertyIdentifiersList = options.propertyIdentifiersList || '';
	            var request = _this.requestService.newAdminRequest(urlString, params);
	            return request.promise;
	        };
	        this.getPropertyDisplayOptions = function (entityName, options) {
	            var urlString = _this.getUrlWithActionPrefix() + 'api:main.getPropertyDisplayOptions&entityName=' + entityName;
	            var params = {};
	            params.property = options.property || '';
	            if (angular.isDefined(options.argument1)) {
	                params.argument1 = options.argument1;
	            }
	            var request = _this.requestService.newAdminRequest(urlString, params);
	            return request.promise;
	        };
	        this.getPropertyTitle = function (propertyName, metaData) {
	            var propertyMetaData = metaData[propertyName];
	            if (angular.isDefined(propertyMetaData['hb_rbkey'])) {
	                return metaData.$$getRBKey(propertyMetaData['hb_rbkey']);
	            }
	            else if (angular.isUndefined(propertyMetaData['persistent'])) {
	                if (angular.isDefined(propertyMetaData['fieldtype'])
	                    && angular.isDefined(propertyMetaData['cfc'])
	                    && ["one-to-many", "many-to-many"].indexOf(propertyMetaData.fieldtype) > -1) {
	                    return metaData.$$getRBKey("entity." + metaData.className.toLowerCase() + "." + propertyName + ',entity.' + propertyMetaData.cfc + '_plural');
	                }
	                else if (angular.isDefined(propertyMetaData.fieldtype)
	                    && angular.isDefined(propertyMetaData.cfc)
	                    && ["many-to-one"].indexOf(propertyMetaData.fieldtype) > -1) {
	                    return metaData.$$getRBKey("entity." + metaData.className.toLowerCase() + '.' + propertyName.toLowerCase() + ',entity.' + propertyMetaData.cfc);
	                }
	                return metaData.$$getRBKey('entity.' + metaData.className.toLowerCase() + '.' + propertyName.toLowerCase());
	            }
	            else if (metaData.isProcessObject) {
	                if (angular.isDefined(propertyMetaData.fieldtype)
	                    && angular.isDefined(propertyMetaData.cfc)
	                    && ["one-to-many", "many-to-many"].indexOf(propertyMetaData.fieldtype) > -1) {
	                    return metaData.$$getRBKey('processObject.' + metaData.className.toLowerCase() + '.' + propertyName.toLowerCase() + ',entity.' + propertyMetaData.cfc.toLowerCase() + '_plural');
	                }
	                else if (angular.isDefined(propertyMetaData.fieldtype)
	                    && angular.isDefined(propertyMetaData.cfc)) {
	                    return metaData.$$getRBKey('processObject.' + metaData.className.toLowerCase() + '.' + propertyName.toLowerCase() + ',entity.' + propertyMetaData.cfc.toLowerCase());
	                }
	                return metaData.$$getRBKey('processObject.' + metaData.className.toLowerCase() + '.' + propertyName.toLowerCase());
	            }
	            return metaData.$$getRBKey('object.' + metaData.className.toLowerCase() + '.' + propertyName.toLowerCase());
	        };
	        this.saveEntity = function (entityName, id, params, context) {
	            var urlString = _this.getUrlWithActionPrefix() + 'api:main.post';
	            if (angular.isDefined(entityName)) {
	                params.entityName = entityName;
	            }
	            if (angular.isDefined(id)) {
	                params.entityID = id;
	            }
	            if (angular.isDefined(context)) {
	                params.context = context;
	            }
	            var request = _this.requestService.newAdminRequest(urlString, params);
	            return request.promise;
	        };
	        this.getExistingCollectionsByBaseEntity = function (entityName) {
	            var urlString = _this.getUrlWithActionPrefix() + 'api:main.getExistingCollectionsByBaseEntity&entityName=' + entityName;
	            var request = _this.requestService.newAdminRequest(urlString);
	            return request.promise;
	        };
	        this.getFilterPropertiesByBaseEntityName = function (entityName, includeNonPersistent) {
	            if (includeNonPersistent === void 0) { includeNonPersistent = false; }
	            var urlString = _this.getUrlWithActionPrefix() + 'api:main.getFilterPropertiesByBaseEntityName&EntityName=' + entityName + '&includeNonPersistent=' + includeNonPersistent;
	            var request = _this.requestService.newAdminRequest(urlString);
	            return request.promise;
	        };
	        this.login = function (emailAddress, password) {
	            var urlString = _this.appConfig.baseURL + '/index.cfm/api/auth/login';
	            var params = {
	                emailAddress: emailAddress,
	                password: password
	            };
	            var request = _this.requestService.newAdminRequest(urlString, params);
	            return request.promise;
	        };
	        this.getResourceBundle = function (locale) {
	            var locale = locale || _this.appConfig.rbLocale;
	            if (_this._resourceBundle[locale]) {
	                return _this._resourceBundle[locale];
	            }
	            var urlString = _this.getUrlWithActionPrefix() + 'api:main.getResourceBundle&instantiationKey=' + _this.appConfig.instantiationKey + '&locale=' + locale;
	            var request = _this.requestService.newAdminRequest(urlString);
	            return request.promise;
	        };
	        this.getCurrencies = function () {
	            var urlString = _this.getUrlWithActionPrefix() + 'api:main.getCurrencies&instantiationKey=' + _this.appConfig.instantiationKey;
	            var request = _this.requestService.newAdminRequest(urlString);
	            return request.promise;
	        };
	        this.getConfig = function () {
	            return _this._config;
	        };
	        this.getConfigValue = function (key) {
	            return _this._config[key];
	        };
	        this.setConfigValue = function (key, value) {
	            _this._config[key] = value;
	        };
	        this.setConfig = function (config) {
	            _this._config = config;
	        };
	        this.$window = $window;
	        this.$q = $q;
	        this.$http = $http;
	        this.$timeout = $timeout;
	        this.$log = $log;
	        this.$rootScope = $rootScope;
	        this.$location = $location;
	        this.$anchorScroll = $anchorScroll;
	        this.requestService = requestService;
	        this.utilityService = utilityService;
	        this.formService = formService;
	        this.rbkeyService = rbkeyService;
	        this.appConfig = appConfig;
	        this._config = _config;
	        this._jsEntities = _jsEntities;
	        this._jsEntityInstances = _jsEntityInstances;
	    }
	    return HibachiService;
	}());
	exports.HibachiService = HibachiService;
	var $Hibachi = (function () {
	    //@ngInject
	    function $Hibachi(appConfig) {
	        var _this = this;
	        this._config = {};
	        this.angular = angular;
	        this.setJsEntities = function (jsEntities) {
	            _this._jsEntities = jsEntities;
	        };
	        this.getConfig = function () {
	            return _this._config;
	        };
	        this.getConfigValue = function (key) {
	            return _this._config[key];
	        };
	        this.setConfigValue = function (key, value) {
	            _this._config[key] = value;
	        };
	        this.setConfig = function (config) {
	            _this._config = config;
	        };
	        this._config = appConfig;
	        this.$get.$inject = [
	            '$window',
	            '$q',
	            '$http',
	            '$timeout',
	            '$log',
	            '$rootScope',
	            '$location',
	            '$anchorScroll',
	            'requestService',
	            'utilityService',
	            'formService',
	            'rbkeyService',
	            'appConfig'
	        ];
	    }
	    $Hibachi.prototype.$get = function ($window, $q, $http, $timeout, $log, $rootScope, $location, $anchorScroll, requestService, utilityService, formService, rbkeyService, appConfig) {
	        return new HibachiService($window, $q, $http, $timeout, $log, $rootScope, $location, $anchorScroll, requestService, utilityService, formService, rbkeyService, appConfig, this._config, this._jsEntities, this._jsEntityInstances);
	    };
	    return $Hibachi;
	}());
	exports.$Hibachi = $Hibachi;


/***/ },
/* 38 */
/***/ function(module, exports) {

	"use strict";
	var HistoryService = (function () {
	    //ngInject
	    function HistoryService() {
	        var _this = this;
	        this.histories = {};
	        this.recordHistory = function (key, data, overwrite) {
	            if (overwrite === void 0) { overwrite = false; }
	            if (angular.isUndefined(_this.histories[key]) || overwrite) {
	                _this.histories[key] = [];
	            }
	            _this.histories[key].push(data);
	        };
	        this.hasHistory = function (key) {
	            return angular.isDefined(_this.histories[key]);
	        };
	        this.getHistory = function (key) {
	            if (angular.isDefined(_this.histories[key])) {
	                return _this.histories[key];
	            }
	        };
	        this.deleteHistory = function (key) {
	            _this.histories[key] = [];
	        };
	    }
	    return HistoryService;
	}());
	exports.HistoryService = HistoryService;


/***/ },
/* 39 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var LocalStorageService = (function () {
	    //@ngInject
	    function LocalStorageService($window) {
	        var _this = this;
	        this.$window = $window;
	        this.hasItem = function (key) {
	            //try catch to handle safari in private mode which does not allow localstorage
	            try {
	                return (_this.$window.localStorage.getItem(key)
	                    && _this.$window.localStorage.getItem(key) !== null
	                    && _this.$window.localStorage.getItem(key) !== "undefined");
	            }
	            catch (e) {
	                return false;
	            }
	        };
	        this.getItem = function (key) {
	            var value = _this.$window.localStorage.getItem(key);
	            if (value.charAt(0) === '{' || value.charAt(0) === '[') {
	                value = angular.fromJson(value);
	            }
	            return value;
	        };
	        this.setItem = function (key, data) {
	            //try catch to handle safari in private mode which does not allow localstorage
	            try {
	                if (angular.isObject(data) || angular.isArray(data)) {
	                    data = angular.toJson(data);
	                }
	                _this.$window.localStorage.setItem(key, data);
	            }
	            catch (e) {
	            }
	        };
	        this.$window = $window;
	    }
	    return LocalStorageService;
	}());
	exports.LocalStorageService = LocalStorageService;


/***/ },
/* 40 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var HibachiServiceDecorator = (function () {
	    //@ngInject
	    function HibachiServiceDecorator($delegate, $http, $timeout, $log, $rootScope, $location, $anchorScroll, $q, utilityService, formService, rbkeyService, appConfig, observerService, hibachiValidationService, attributeMetaData) {
	        var _deferred = {};
	        var _config = appConfig;
	        var _jsEntities = {};
	        var _jsEntityInstances = {};
	        var entities = appConfig.modelConfig.entities, validations = appConfig.modelConfig.validations, defaultValues = appConfig.modelConfig.defaultValues;
	        angular.forEach(entities, function (entity) {
	            if (attributeMetaData[entity.className]) {
	                var relatedAttributes = attributeMetaData[entity.className];
	                for (var attributeSetCode in relatedAttributes) {
	                    var attributeSet = relatedAttributes[attributeSetCode];
	                    for (var attributeCode in attributeSet.attributes) {
	                        var attribute = attributeSet.attributes[attributeCode];
	                        attribute.attributeSet = attributeSet;
	                        attribute.isAttribute = true;
	                        entity[attributeCode] = attribute;
	                    }
	                }
	            }
	            $delegate['get' + entity.className] = function (options) {
	                var entityInstance = $delegate.newEntity(entity.className);
	                var entityDataPromise = $delegate.getEntity(entity.className, options);
	                entityDataPromise.then(function (response) {
	                    if (angular.isDefined(response.processData)) {
	                        entityInstance.$$init(response.data);
	                        var processObjectInstance = $delegate['new' + entity.className + '_' + options.processContext.charAt(0).toUpperCase() + options.processContext.slice(1)]();
	                        processObjectInstance.$$init(response.processData);
	                        processObjectInstance.data[entity.className.charAt(0).toLowerCase() + entity.className.slice(1)] = entityInstance;
	                        entityInstance.processObject = processObjectInstance;
	                    }
	                    else {
	                        if (entityInstance.populate) {
	                            entityInstance.populate(response);
	                        }
	                        else {
	                            entityInstance.$$init(response);
	                        }
	                    }
	                });
	                return {
	                    promise: entityDataPromise,
	                    value: entityInstance
	                };
	            };
	            $delegate['new' + entity.className] = function () {
	                //if we have the service then get the new instance from that
	                var entityName = entity.className;
	                var serviceName = entityName.charAt(0).toLowerCase() + entityName.slice(1) + 'Service';
	                if (angular.element(document.body).injector().has(serviceName)) {
	                    var entityService = angular.element(document.body).injector().get(serviceName);
	                    return entityService['new' + entity.className]();
	                }
	                return $delegate.newEntity(entity.className);
	            };
	            entity.isProcessObject = entity.className.indexOf('_') >= 0;
	            _jsEntities[entity.className] = function () {
	                this.validations = validations[entity.className];
	                this.metaData = entity;
	                this.metaData.className = entity.className;
	                if (relatedAttributes) {
	                    this.attributeMetaData = relatedAttributes;
	                }
	                if (entity.hb_parentPropertyName) {
	                    this.metaData.hb_parentPropertyName = entity.hb_parentPropertyName;
	                }
	                if (entity.hb_childPropertyName) {
	                    this.metaData.hb_childPropertyName = entity.hb_childPropertyName;
	                }
	                this.metaData.$$getRBKey = function (rbKey, replaceStringData) {
	                    return rbkeyService.rbKey(rbKey, replaceStringData);
	                };
	                this.metaData.$$getPropertyTitle = function (propertyName) {
	                    return _getPropertyTitle(propertyName, this);
	                };
	                this.metaData.$$getPropertyHint = function (propertyName) {
	                    return _getPropertyHint(propertyName, this);
	                };
	                this.metaData.$$getManyToManyName = function (singularname) {
	                    var metaData = this;
	                    for (var i in metaData) {
	                        if (metaData[i].singularname === singularname) {
	                            return metaData[i].name;
	                        }
	                    }
	                };
	                this.metaData.$$getPropertyFieldType = function (propertyName) {
	                    return _getPropertyFieldType(propertyName, this);
	                };
	                this.metaData.$$getPropertyFormatType = function (propertyName) {
	                    if (this[propertyName])
	                        return _getPropertyFormatType(propertyName, this);
	                };
	                this.metaData.$$getDetailTabs = function () {
	                    var deferred = $q.defer();
	                    var urlString = _config.baseURL + '/index.cfm/?' + appConfig.action + '=api:main.getDetailTabs&entityName=' + this.className;
	                    var detailTabs = [];
	                    $http.get(urlString)
	                        .success(function (data) {
	                        deferred.resolve(data);
	                    }).error(function (reason) {
	                        deferred.reject(reason);
	                    });
	                    return deferred.promise;
	                };
	                this.$$getFormattedValue = function (propertyName, formatType) {
	                    return _getFormattedValue(propertyName, formatType, this);
	                };
	                this.data = {};
	                this.modifiedData = {};
	                var jsEntity = this;
	                if (entity.isProcessObject) {
	                    (function (entity) {
	                        _jsEntities[entity.className].prototype = {
	                            $$getID: function () {
	                                return '';
	                            },
	                            $$getIDName: function () {
	                                var IDNameString = '';
	                                return IDNameString;
	                            }
	                        };
	                    })(entity);
	                }
	                angular.forEach(entity, function (property) {
	                    if (angular.isObject(property) && angular.isDefined(property.name)) {
	                        if (angular.isDefined(defaultValues[entity.className][property.name])) {
	                            jsEntity.data[property.name] = angular.copy(defaultValues[entity.className][property.name]);
	                        }
	                        else {
	                            jsEntity.data[property.name] = undefined;
	                        }
	                    }
	                });
	            };
	            _jsEntities[entity.className].prototype = {
	                $$getPropertyByName: function (propertyName) {
	                    return this['$$get' + propertyName.charAt(0).toUpperCase() + propertyName.slice(1)]();
	                },
	                $$isPersisted: function () {
	                    return this.$$getID() !== '';
	                },
	                $$init: function (data) {
	                    _init(this, data);
	                },
	                $$save: function () {
	                    return _save(this);
	                },
	                $$delete: function () {
	                    return _delete(this);
	                },
	                $$getValidationsByProperty: function (property) {
	                    return _getValidationsByProperty(this, property);
	                },
	                $$getValidationByPropertyAndContext: function (property, context) {
	                    return _getValidationByPropertyAndContext(this, property, context);
	                },
	                $$getTitleByPropertyIdentifier: function (propertyIdentifier) {
	                    if (propertyIdentifier.split('.').length > 1) {
	                        var listFirst = utilityService.listFirst(propertyIdentifier, '.');
	                        var relatedEntityName = this.metaData[listFirst].cfc;
	                        var exampleEntity = $delegate.newEntity(relatedEntityName);
	                        return exampleEntity.$$getTitleByPropertyIdentifier(propertyIdentifier.replace(listFirst, ''));
	                    }
	                    return this.metaData.$$getPropertyTitle(propertyIdentifier);
	                },
	                $$getMetaData: function (propertyName) {
	                    if (propertyName === undefined) {
	                        return this.metaData;
	                    }
	                    else {
	                        if (angular.isDefined(this.metaData[propertyName].name) && angular.isUndefined(this.metaData[propertyName].nameCapitalCase)) {
	                            this.metaData[propertyName].nameCapitalCase = this.metaData[propertyName].name.charAt(0).toUpperCase() + this.metaData[propertyName].name.slice(1);
	                        }
	                        if (angular.isDefined(this.metaData[propertyName].cfc) && angular.isUndefined(this.metaData[propertyName].cfcProperCase)) {
	                            this.metaData[propertyName].cfcProperCase = this.metaData[propertyName].cfc.charAt(0).toLowerCase() + this.metaData[propertyName].cfc.slice(1);
	                        }
	                        return this.metaData[propertyName];
	                    }
	                }
	            };
	            angular.forEach(relatedAttributes, function (attributeSet) {
	                angular.forEach(attributeSet.attributes, function (attribute) {
	                    if (attribute && attribute.attributeCode) {
	                        Object.defineProperty(_jsEntities[entity.className].prototype, attribute.attributeCode, {
	                            configurable: true,
	                            enumerable: false,
	                            get: function () {
	                                if (attribute != null && this.data[attribute.attributeCode] == null) {
	                                    return undefined;
	                                }
	                                return this.data[attribute.attributeCode];
	                            },
	                            set: function (value) {
	                                this.data[attribute.attributeCode] = value;
	                            }
	                        });
	                    }
	                });
	            });
	            angular.forEach(entity, function (property) {
	                if (angular.isObject(property) && angular.isDefined(property.name)) {
	                    //if(angular.isUndefined(property.persistent)){
	                    if (angular.isDefined(property.fieldtype)) {
	                        if (['many-to-one'].indexOf(property.fieldtype) >= 0) {
	                            _jsEntities[entity.className].prototype['$$get' + property.name.charAt(0).toUpperCase() + property.name.slice(1)] = function () {
	                                var thisEntityInstance = this;
	                                if (angular.isDefined(this['$$get' + this.$$getIDName().charAt(0).toUpperCase() + this.$$getIDName().slice(1)]())) {
	                                    var options = {
	                                        columnsConfig: angular.toJson([
	                                            {
	                                                "propertyIdentifier": "_" + this.metaData.className.toLowerCase() + "_" + property.name
	                                            }
	                                        ]),
	                                        joinsConfig: angular.toJson([
	                                            {
	                                                "associationName": property.name,
	                                                "alias": "_" + this.metaData.className.toLowerCase() + "_" + property.name
	                                            }
	                                        ]),
	                                        filterGroupsConfig: angular.toJson([{
	                                                "filterGroup": [
	                                                    {
	                                                        "propertyIdentifier": "_" + this.metaData.className.toLowerCase() + "." + this.$$getIDName(),
	                                                        "comparisonOperator": "=",
	                                                        "value": this.$$getID()
	                                                    }
	                                                ]
	                                            }]),
	                                        allRecords: true
	                                    };
	                                    var collectionPromise = $delegate.getEntity(entity.className, options);
	                                    collectionPromise.then(function (response) {
	                                        for (var i in response.records) {
	                                            var entityInstance = $delegate.newEntity(thisEntityInstance.metaData[property.name].cfc);
	                                            //Removed the array index here at the end of local.property.name.
	                                            if (angular.isArray(response.records[i][property.name])) {
	                                                entityInstance.$$init(response.records[i][property.name][0]);
	                                            }
	                                            else {
	                                                entityInstance.$$init(response.records[i][property.name]); //Shouldn't have the array index'
	                                            }
	                                            thisEntityInstance['$$set' + property.name.charAt(0).toUpperCase() + property.name.slice(1)](entityInstance);
	                                        }
	                                    });
	                                    return collectionPromise;
	                                }
	                                return null;
	                            };
	                            _jsEntities[entity.className].prototype['$$set' + property.name.charAt(0).toUpperCase() + property.name.slice(1)] = function (entityInstance) {
	                                var thisEntityInstance = this;
	                                var metaData = this.metaData;
	                                var manyToManyName = '';
	                                //if entityInstance is not passed in, clear related object
	                                if (angular.isUndefined(entityInstance)) {
	                                    if (angular.isDefined(thisEntityInstance.data[property.name])) {
	                                        delete thisEntityInstance.data[property.name];
	                                    }
	                                    if (!thisEntityInstance.parents) {
	                                        return;
	                                    }
	                                    for (var i = 0; i <= thisEntityInstance.parents.length; i++) {
	                                        if (angular.isDefined(thisEntityInstance.parents[i]) && thisEntityInstance.parents[i].name == property.name.charAt(0).toLowerCase() + property.name.slice(1)) {
	                                            thisEntityInstance.parents.splice(i, 1);
	                                        }
	                                    }
	                                    return;
	                                }
	                                if (property.name === 'parent' + this.metaData.className) {
	                                    var childName = 'child' + this.metaData.className;
	                                    manyToManyName = entityInstance.metaData.$$getManyToManyName(childName);
	                                }
	                                else if (entityInstance.metaData) {
	                                    manyToManyName = entityInstance.metaData.$$getManyToManyName(metaData.className.charAt(0).toLowerCase() + metaData.className.slice(1));
	                                }
	                                // else{
	                                //     manyToManyName = entityInstance.metaData.$$getManyToManyName(metaData.className.charAt(0).toLowerCase() + metaData.className.slice(1));
	                                // }
	                                if (angular.isUndefined(thisEntityInstance.parents)) {
	                                    thisEntityInstance.parents = [];
	                                }
	                                thisEntityInstance.parents.push(thisEntityInstance.metaData[property.name]);
	                                if (angular.isDefined(manyToManyName) && manyToManyName.length) {
	                                    if (angular.isUndefined(entityInstance.children)) {
	                                        entityInstance.children = [];
	                                    }
	                                    var child = entityInstance.metaData[manyToManyName];
	                                    if (entityInstance.children.indexOf(child) === -1) {
	                                        entityInstance.children.push(child);
	                                    }
	                                    if (angular.isUndefined(entityInstance.data[manyToManyName])) {
	                                        entityInstance.data[manyToManyName] = [];
	                                    }
	                                    entityInstance.data[manyToManyName].push(thisEntityInstance);
	                                }
	                                thisEntityInstance.data[property.name] = entityInstance;
	                            };
	                            if (property.name !== 'data' && property.name !== 'validations') {
	                                Object.defineProperty(_jsEntities[entity.className].prototype, property.name, {
	                                    configurable: true,
	                                    enumerable: false,
	                                    get: function () {
	                                        if (this.data[property.name] == null) {
	                                            return undefined;
	                                        }
	                                        return this.data[property.name];
	                                    },
	                                    set: function (value) {
	                                        this['$$set' + property.name.charAt(0).toUpperCase() + property.name.slice(1)](value);
	                                    }
	                                });
	                            }
	                        }
	                        else if (['one-to-many', 'many-to-many'].indexOf(property.fieldtype) >= 0) {
	                            _jsEntities[entity.className].prototype['$$add' + property.singularname.charAt(0).toUpperCase() + property.singularname.slice(1)] = function (entityInstance) {
	                                if (angular.isUndefined(entityInstance)) {
	                                    var entityInstance = $delegate.newEntity(this.metaData[property.name].cfc);
	                                }
	                                var metaData = this.metaData;
	                                if (metaData[property.name].fieldtype === 'one-to-many') {
	                                    entityInstance.data[metaData[property.name].fkcolumn.slice(0, -2)] = this;
	                                }
	                                else if (metaData[property.name].fieldtype === 'many-to-many') {
	                                    var manyToManyName = entityInstance.metaData.$$getManyToManyName(metaData.className.charAt(0).toLowerCase() + this.metaData.className.slice(1));
	                                    if (angular.isUndefined(entityInstance.data[manyToManyName])) {
	                                        entityInstance.data[manyToManyName] = [];
	                                    }
	                                    entityInstance.data[manyToManyName].push(this);
	                                }
	                                if (angular.isDefined(metaData[property.name])) {
	                                    if (angular.isDefined(entityInstance.metaData[metaData[property.name].fkcolumn.slice(0, -2)])) {
	                                        if (angular.isUndefined(entityInstance.parents)) {
	                                            entityInstance.parents = [];
	                                        }
	                                        entityInstance.parents.push(entityInstance.metaData[metaData[property.name].fkcolumn.slice(0, -2)]);
	                                    }
	                                    if (angular.isUndefined(this.children)) {
	                                        this.children = [];
	                                    }
	                                    var child = metaData[property.name];
	                                    if (this.children.indexOf(child) === -1) {
	                                        this.children.push(child);
	                                    }
	                                }
	                                if (angular.isUndefined(this.data[property.name])) {
	                                    this.data[property.name] = [];
	                                }
	                                this.data[property.name].push(entityInstance);
	                                return entityInstance;
	                            };
	                            _jsEntities[entity.className].prototype['$$get' + property.name.charAt(0).toUpperCase() + property.name.slice(1)] = function () {
	                                var thisEntityInstance = this;
	                                if (angular.isDefined(this['$$get' + this.$$getIDName().charAt(0).toUpperCase() + this.$$getIDName().slice(1)])) {
	                                    var options = {
	                                        filterGroupsConfig: angular.toJson([{
	                                                "filterGroup": [
	                                                    {
	                                                        "propertyIdentifier": "_" + property.cfc.toLowerCase() + "." + property.fkcolumn.replace('ID', '') + "." + this.$$getIDName(),
	                                                        "comparisonOperator": "=",
	                                                        "value": this.$$getID()
	                                                    }
	                                                ]
	                                            }]),
	                                        allRecords: true
	                                    };
	                                    var collectionPromise = $delegate.getEntity(property.cfc, options);
	                                    collectionPromise.then(function (response) {
	                                        var entityInstances = [];
	                                        for (var i in response.records) {
	                                            var entityInstance = thisEntityInstance['$$add' + property.singularname.charAt(0).toUpperCase() + property.singularname.slice(1)]();
	                                            entityInstance.$$init(response.records[i]);
	                                            if (angular.isUndefined(thisEntityInstance[property.name])) {
	                                                thisEntityInstance[property.name] = [];
	                                            }
	                                            entityInstances.push(entityInstance);
	                                        }
	                                        thisEntityInstance.data[property.name] = entityInstances;
	                                    });
	                                    return collectionPromise;
	                                }
	                            };
	                            Object.defineProperty(_jsEntities[entity.className].prototype, property.name, {
	                                configurable: true,
	                                enumerable: false,
	                                get: function () {
	                                    if (this.data[property.name] == null) {
	                                        return undefined;
	                                    }
	                                    return this.data[property.name];
	                                },
	                                set: function (value) {
	                                    this.data[property.name] = [];
	                                    if (angular.isArray(value)) {
	                                        for (var i = 0; i < value.length; i++) {
	                                            var item = value[i];
	                                            var entityInstance = $delegate.newEntity(this.metaData[property.name].cfc);
	                                            entityInstance.$$init(item);
	                                            this['$$add' + property.singularname.charAt(0).toUpperCase() + property.singularname.slice(1)](entityInstance);
	                                        }
	                                    }
	                                    else {
	                                        var entityInstance = $delegate.newEntity(this.metaData[property.name].cfc);
	                                        entityInstance.$$init(value);
	                                        this['$$add' + property.singularname.charAt(0).toUpperCase() + property.singularname.slice(1)](entityInstance);
	                                    }
	                                }
	                            });
	                        }
	                        else {
	                            if (['id'].indexOf(property.fieldtype) >= 0) {
	                                _jsEntities[entity.className].prototype['$$getID'] = function () {
	                                    //this should retreive id from the metadata
	                                    return this.data[this.$$getIDName()];
	                                };
	                                _jsEntities[entity.className].prototype['$$getIDName'] = function () {
	                                    var IDNameString = property.name;
	                                    return IDNameString;
	                                };
	                            }
	                            if (property.name !== 'data' && property.name !== 'validations') {
	                                Object.defineProperty(_jsEntities[entity.className].prototype, property.name, {
	                                    configurable: true,
	                                    enumerable: false,
	                                    get: function () {
	                                        if (this.data[property.name] == null) {
	                                            return undefined;
	                                        }
	                                        return this.data[property.name];
	                                    },
	                                    set: function (value) {
	                                        this.data[property.name] = value;
	                                    }
	                                });
	                            }
	                            _jsEntities[entity.className].prototype['$$get' + property.name.charAt(0).toUpperCase() + property.name.slice(1)] = function () {
	                                return this.data[property.name];
	                            };
	                        }
	                    }
	                    else {
	                        if (property.name !== 'data' && property.name !== 'validations') {
	                            Object.defineProperty(_jsEntities[entity.className].prototype, property.name, {
	                                configurable: true,
	                                enumerable: false,
	                                get: function () {
	                                    if (this.data[property.name] == null) {
	                                        return undefined;
	                                    }
	                                    return this.data[property.name];
	                                },
	                                set: function (value) {
	                                    this.data[property.name] = value;
	                                }
	                            });
	                        }
	                        _jsEntities[entity.className].prototype['$$get' + property.name.charAt(0).toUpperCase() + property.name.slice(1)] = function () {
	                            return this.data[property.name];
	                        };
	                    }
	                }
	            });
	        });
	        $delegate.setJsEntities(_jsEntities);
	        angular.forEach(_jsEntities, function (jsEntity) {
	            var jsEntityInstance = new jsEntity;
	            _jsEntityInstances[jsEntityInstance.metaData.className] = jsEntityInstance;
	        });
	        $delegate.setJsEntityInstances(_jsEntityInstances);
	        var _init = function (entityInstance, data) {
	            hibachiValidationService.init(entityInstance, data);
	        };
	        var _getPropertyTitle = function (propertyName, metaData) {
	            return $delegate.getPropertyTitle(propertyName, metaData);
	        };
	        var _getPropertyHint = function (propertyName, metaData) {
	            var propertyMetaData = metaData[propertyName];
	            var keyValue = '';
	            if (angular.isDefined(propertyMetaData['hb_rbkey'])) {
	                keyValue = metaData.$$getRBKey(propertyMetaData['hb_rbkey'] + '_hint');
	            }
	            else if (angular.isUndefined(propertyMetaData['persistent']) || (angular.isDefined(propertyMetaData['persistent']) && propertyMetaData['persistent'] === true)) {
	                keyValue = metaData.$$getRBKey('entity.' + metaData.className.toLowerCase() + '.' + propertyName.toLowerCase() + '_hint');
	            }
	            else {
	                keyValue = metaData.$$getRBKey('object.' + metaData.className.toLowerCase() + '.' + propertyName.toLowerCase());
	            }
	            if (keyValue.slice(-8) !== '_missing') {
	                return keyValue;
	            }
	            return '';
	        };
	        var _getPropertyFieldType = function (propertyName, metaData) {
	            var propertyMetaData = metaData[propertyName];
	            if (angular.isDefined(propertyMetaData['hb_formfieldtype'])) {
	                return propertyMetaData['hb_formfieldtype'];
	            }
	            if (angular.isUndefined(propertyMetaData.fieldtype) || propertyMetaData.fieldtype === 'column') {
	                var dataType = "";
	                if (angular.isDefined(propertyMetaData.ormtype)) {
	                    dataType = propertyMetaData.ormtype;
	                }
	                else if (angular.isDefined(propertyMetaData.type)) {
	                    dataType = propertyMetaData.type;
	                }
	                if (["boolean", "yes_no", "true_false"].indexOf(dataType) > -1) {
	                    return "yesno";
	                }
	                else if (["date", "timestamp"].indexOf(dataType) > -1) {
	                    return "dateTime";
	                }
	                else if ("array" === dataType) {
	                    return "select";
	                }
	                else if ("struct" === dataType) {
	                    return "checkboxgroup";
	                }
	                else if (propertyName.indexOf('password') > -1) {
	                    return "password";
	                }
	            }
	            else if (angular.isDefined(propertyMetaData.fieldtype) && propertyMetaData.fieldtype === 'many-to-one') {
	                return 'select';
	            }
	            else if (angular.isDefined(propertyMetaData.fieldtype) && propertyMetaData.fieldtype === 'one-to-many') {
	                return 'There is no property field type for one-to-many relationship properties, which means that you cannot get a fieldtype for ' + propertyName;
	            }
	            else if (angular.isDefined(propertyMetaData.fieldtype) && propertyMetaData.fieldtype === 'many-to-many') {
	                return "listingMultiselect";
	            }
	            return "text";
	        };
	        var _getPropertyFormatType = function (propertyName, metaData) {
	            if (!propertyName || !metaData) {
	                return 'none';
	            }
	            var propertyMetaData = metaData[propertyName];
	            if (propertyMetaData['hb_formattype']) {
	                return propertyMetaData['hb_formattype'];
	            }
	            else if (angular.isUndefined(propertyMetaData.fieldtype) || propertyMetaData.fieldtype === 'column') {
	                var dataType = "";
	                if (angular.isDefined(propertyMetaData.ormtype)) {
	                    dataType = propertyMetaData.ormtype;
	                }
	                else if (angular.isDefined(propertyMetaData.type)) {
	                    dataType = propertyMetaData.type;
	                }
	                if (["boolean", "yes_no", "true_false"].indexOf(dataType) > -1) {
	                    return "yesno";
	                }
	                else if (["date", "timestamp"].indexOf(dataType) > -1) {
	                    return "dateTime";
	                }
	                else if (["big_decimal"].indexOf(dataType) > -1 && propertyName.slice(-6) === 'weight') {
	                    return "weight";
	                }
	                else if (["big_decimal"].indexOf(dataType) > -1) {
	                    return "currency";
	                }
	            }
	            return 'none';
	        };
	        var _isSimpleValue = function (value) {
	            return !!(angular.isString(value) || angular.isNumber(value)
	                || angular.isDate(value) || value === false || value === true);
	        };
	        var _getFormattedValue = function (propertyName, formatType, entityInstance) {
	            var value = entityInstance.$$getPropertyByName(propertyName);
	            if (angular.isUndefined(formatType)) {
	                formatType = entityInstance.metaData.$$getPropertyFormatType(propertyName);
	            }
	            if (formatType === "custom") {
	            }
	            else if (formatType === "rbkey") {
	                if (angular.isDefined(value)) {
	                    return entityInstance.$$getRBKey('entity.' + entityInstance.metaData.className.toLowerCase() + '.' + propertyName.toLowerCase() + '.' + value);
	                }
	                else {
	                    return '';
	                }
	            }
	            if (angular.isUndefined(value)) {
	                var propertyMeta = entityInstance.metaData[propertyName];
	                if (angular.isDefined(propertyMeta['hb_nullRBKey'])) {
	                    return entityInstance.$$getRbKey(propertyMeta['hb_nullRBKey']);
	                }
	                return "";
	            }
	            else if (_isSimpleValue(value)) {
	                var formatDetails = {};
	                if (angular.isDefined(entityInstance.data['currencyCode'])) {
	                    formatDetails.currencyCode = entityInstance.$$getCurrencyCode();
	                }
	                return utilityService.formatValue(value, formatType, formatDetails, entityInstance);
	            }
	        };
	        var _delete = function (entityInstance) {
	            var entityName = entityInstance.metaData.className;
	            var entityID = entityInstance.$$getID();
	            var context = 'delete';
	            return $delegate.saveEntity(entityName, entityID, {}, context);
	        };
	        var _setValueByPropertyPath = function (obj, path, value) {
	            var a = path.split('.');
	            var context = obj;
	            var selector;
	            var myregexp = /([a-zA-Z]+)(\[(\d)\])+/; // matches:  item[0]
	            var match = null;
	            for (var i = 0; i < a.length - 1; i += 1) {
	                match = myregexp.exec(a[i]);
	                if (match !== null)
	                    context = context[match[1]][match[3]];
	                else
	                    context = context[a[i]];
	            }
	            // check for ending item[xx] syntax
	            match = myregexp.exec([a[a.length - 1]]);
	            if (match !== null)
	                context[match[1]][match[3]] = value;
	            else
	                context[a[a.length - 1]] = value;
	        };
	        var _getValueByPropertyPath = function (obj, path) {
	            var paths = path.split('.'), current = obj, i;
	            for (i = 0; i < paths.length; ++i) {
	                if (current[paths[i]] == undefined) {
	                    return undefined;
	                }
	                else {
	                    current = current[paths[i]];
	                }
	            }
	            return current;
	        };
	        var _addReturnedIDs = function (returnedIDs, entityInstance) {
	            for (var key in returnedIDs) {
	                if (angular.isArray(returnedIDs[key])) {
	                    var arrayItems = returnedIDs[key];
	                    var entityInstanceArray = entityInstance.data[key];
	                    for (var i in arrayItems) {
	                        var arrayItem = arrayItems[i];
	                        var entityInstanceArrayItem = entityInstance.data[key][i];
	                        _addReturnedIDs(arrayItem, entityInstanceArrayItem);
	                    }
	                }
	                else if (angular.isObject(returnedIDs[key])) {
	                    for (var k in returnedIDs[key]) {
	                        _addReturnedIDs(returnedIDs[key][k], entityInstance.data[key][k]);
	                    }
	                }
	                else {
	                    entityInstance.data[key] = returnedIDs[key];
	                }
	            }
	        };
	        var _save = function (entityInstance) {
	            var deferred = $q.defer();
	            $timeout(function () {
	                //$log.debug('save begin');
	                //$log.debug(entityInstance);
	                var entityID = entityInstance.$$getID();
	                var modifiedData = _getModifiedData(entityInstance);
	                //$log.debug('modifiedData complete');
	                //$log.debug(modifiedData);
	                //timeoutPromise.valid = modifiedData.valid;
	                if (modifiedData.valid) {
	                    var params = {};
	                    params.serializedJsonData = utilityService.toJson(modifiedData.value);
	                    //if we have a process object then the context is different from the standard save
	                    var entityName = '';
	                    var context = 'save';
	                    if (entityInstance.metaData.isProcessObject === 1) {
	                        var processStruct = modifiedData.objectLevel.metaData.className.split('_');
	                        entityName = processStruct[0];
	                        context = processStruct[1];
	                    }
	                    else {
	                        entityName = modifiedData.objectLevel.metaData.className;
	                    }
	                    var savePromise = $delegate.saveEntity(entityName, entityID, params, context);
	                    savePromise.then(function (response) {
	                        var returnedIDs = response.data;
	                        if ((angular.isDefined(response.SUCCESS) && response.SUCCESS === true)
	                            || (angular.isDefined(response.success) && response.success === true)) {
	                            if ($location.url() == '/entity/' + entityName + '/create' && response.data[modifiedData.objectLevel.$$getIDName()]) {
	                                $location.path('/entity/' + entityName + '/' + response.data[modifiedData.objectLevel.$$getIDName()], false);
	                            }
	                            _addReturnedIDs(returnedIDs, modifiedData.objectLevel);
	                            deferred.resolve(returnedIDs);
	                            observerService.notify('saveSuccess', returnedIDs);
	                            observerService.notify('saveSuccess' + entityName, returnedIDs);
	                        }
	                        else {
	                            deferred.reject(angular.isDefined(response.messages) ? response.messages : response);
	                            observerService.notify('saveFailed', response);
	                            observerService.notify('saveFailed' + entityName, response);
	                        }
	                    }, function (reason) {
	                        deferred.reject(reason);
	                        observerService.notify('saveFailed', reason);
	                        observerService.notify('saveFailed' + entityName, reason);
	                    });
	                }
	                else {
	                    //select first, visible, and enabled input with a class of ng-invalid
	                    var target = $('input.ng-invalid:first:visible:enabled');
	                    if (angular.isDefined(target)) {
	                        target.focus();
	                        var targetID = target.attr('id');
	                        $anchorScroll();
	                    }
	                    deferred.reject('Input is invalid.');
	                    observerService.notify('validationFailed');
	                    observerService.notify('validationFailed' + entityName);
	                }
	            });
	            //return timeoutPromise;
	            return deferred.promise;
	            /*

	            */
	        };
	        var _getModifiedData = function (entityInstance) {
	            var modifiedData = {};
	            modifiedData = getModifiedDataByInstance(entityInstance);
	            return modifiedData;
	        };
	        var getObjectSaveLevel = function (entityInstance) {
	            return hibachiValidationService.getObjectSaveLevel(entityInstance);
	        };
	        var validateObject = function (entityInstance) {
	            return hibachiValidationService.validateObject;
	        };
	        var validateChildren = function (entityInstance) {
	            return hibachiValidationService.validateChildren(entityInstance);
	        };
	        var processChild = function (entityInstance, entityInstanceParent) {
	            return hibachiValidationService.processChild(entityInstance, entityInstanceParent);
	        };
	        var processParent = function (entityInstance) {
	            return hibachiValidationService.processParent(entityInstance);
	        };
	        var processForm = function (form, entityInstance) {
	            return hibachiValidationService.processForm(form, entityInstance);
	        };
	        var getDataFromParents = function (entityInstance, entityInstanceParents) {
	            return hibachiValidationService.getDataFromParents(entityInstance, entityInstanceParents);
	        };
	        var getDataFromChildren = function (entityInstance) {
	            return hibachiValidationService.getDataFromChildren(entityInstance);
	        };
	        var getModifiedDataByInstance = function (entityInstance) {
	            return hibachiValidationService.getModifiedDataByInstance(entityInstance);
	        };
	        var _getValidationsByProperty = function (entityInstance, property) {
	            return hibachiValidationService.getValidationsByProperty(entityInstance, property);
	        };
	        var _getValidationByPropertyAndContext = function (entityInstance, property, context) {
	            return hibachiValidationService.getValidationByPropertyAndContext(entityInstance, property, context);
	        };
	        return $delegate;
	    }
	    return HibachiServiceDecorator;
	}());
	exports.HibachiServiceDecorator = HibachiServiceDecorator;


/***/ },
/* 41 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var HibachiScope = (function () {
	    //@ngInject
	    function HibachiScope(appConfig) {
	        var _this = this;
	        this.loginDisplayed = false;
	        this.isValidToken = true;
	        this.setToken = function (token) {
	            _this.token = token;
	            var stringArray = token.split('.');
	            try {
	                _this.jwtInfo = angular.fromJson(window.atob(stringArray[0]).trim());
	                _this.session = angular.fromJson(window.atob(stringArray[1]).trim());
	            }
	            catch (err) {
	                _this.isValidToken = false;
	            }
	        };
	        this.config = appConfig;
	    }
	    return HibachiScope;
	}());
	exports.HibachiScope = HibachiScope;


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var adminrequest_1 = __webpack_require__(43);
	var publicrequest_1 = __webpack_require__(45);
	var RequestService = (function () {
	    //@ngInject
	    function RequestService($injector, observerService) {
	        var _this = this;
	        this.$injector = $injector;
	        this.observerService = observerService;
	        this.newAdminRequest = function (url, data, method, headers, $injector, observerService) {
	            if (method === void 0) { method = "post"; }
	            if (headers === void 0) { headers = { 'Content-Type': "application/json" }; }
	            if ($injector === void 0) { $injector = _this.$injector; }
	            if (observerService === void 0) { observerService = _this.observerService; }
	            return new adminrequest_1.AdminRequest(url, data, method, headers, $injector, observerService);
	        };
	        this.newPublicRequest = function (url, data, method, headers, $injector, observerService) {
	            if (method === void 0) { method = "post"; }
	            if (headers === void 0) { headers = { 'Content-Type': "application/x-www-form-urlencoded" }; }
	            if ($injector === void 0) { $injector = _this.$injector; }
	            if (observerService === void 0) { observerService = _this.observerService; }
	            return new publicrequest_1.PublicRequest(url, data, method, headers, $injector, observerService);
	        };
	        this.$injector = $injector;
	        this.observerService = observerService;
	    }
	    return RequestService;
	}());
	exports.RequestService = RequestService;


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path='../../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../../typings/tsd.d.ts' />
	var request_1 = __webpack_require__(44);
	var AdminRequest = (function (_super) {
	    __extends(AdminRequest, _super);
	    function AdminRequest(url, data, method, headers, $injector, observerService) {
	        if (method === void 0) { method = "post"; }
	        if (headers === void 0) { headers = { 'Content-Type': "application/json" }; }
	        var _this = _super.call(this, url, data, method, headers, $injector) || this;
	        _this.observerService = observerService;
	        _this.observerService = observerService;
	        _this.promise.then(function (result) {
	            //identify that it is an object save
	            if (url.indexOf('api:main.post') != -1 && data.entityName) {
	                var eventNameBase = data.entityName + data.context.charAt(0).toUpperCase() + data.context.slice(0);
	                if (result.errors) {
	                    _this.observerService.notify(eventNameBase + 'Failure', result.data);
	                }
	                else {
	                    _this.observerService.notify(eventNameBase + 'Success', result.data);
	                }
	            }
	            _this.messages = result.messages;
	        }).catch(function (response) {
	        });
	        return _this;
	    }
	    return AdminRequest;
	}(request_1.Request));
	exports.AdminRequest = AdminRequest;


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path='../../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../../typings/tsd.d.ts' />
	var basetransient_1 = __webpack_require__(14);
	var Request = (function (_super) {
	    __extends(Request, _super);
	    function Request(url, data, method, headers, $injector) {
	        var _this = _super.call(this, $injector) || this;
	        _this.loading = true;
	        _this.errors = {};
	        _this.processResponse = function (response) {
	            _this.loading = false;
	            if (response.errors) {
	                _this.errors = response.errors;
	            }
	            if (response.messages) {
	                _this.messages = response.messages;
	            }
	        };
	        //returns hibachiAction value from url and data;
	        _this.getAction = function () {
	            var config = _this.getAppConfig();
	            //typically hibachiAction
	            var actionName = config.action;
	            var params = _this.utilityService.getQueryParamsFromUrl(_this.url);
	            if (params[actionName]) {
	                return params[actionName];
	            }
	            if (_this.data && _this.data[actionName]) {
	                return _this.data[actionName];
	            }
	            if (_this.url.indexOf('api/scope/') > 0) {
	                return _this.extractPublicAction(_this.url);
	            }
	        };
	        _this.extractPublicAction = function (url) {
	            //get in between api/scope and / or ? or end of word
	            var regex = /\api\/scope\/(.*?)(?=\/|\?|$)/;
	            var arr = regex.exec(url);
	            return arr[1];
	        };
	        _this.processSuccess = function (response) {
	            _this.processResponse(response);
	        };
	        _this.processError = function (response) {
	            _this.processResponse(response);
	        };
	        /** used to turn data into a correct format for the post */
	        _this.toFormParams = function (data) {
	            if (data) {
	                return $.param(data);
	            }
	            else {
	                return "";
	            }
	            //return data = this.serializeData(data) || "";
	        };
	        _this.serializeData = function (data) {
	            // If this is not an object, defer to native stringification.
	            if (!angular.isObject(data)) {
	                return ((data == null) ? "" : data.toString());
	            }
	            var buffer = [];
	            // Serialize each key in the object.
	            for (var name in data) {
	                if (!data.hasOwnProperty(name)) {
	                    continue;
	                }
	                var value = data[name];
	                buffer.push(encodeURIComponent(name) + "=" + encodeURIComponent((value == null) ? "" : value));
	            }
	            // Serialize the buffer and clean it up for transportation.
	            var source = buffer.join("&").replace(/%20/g, "+");
	            return (source);
	        };
	        _this.headers = headers;
	        _this.$q = _this.getService('$q');
	        _this.$http = _this.getService('$http');
	        _this.$window = _this.getService('$window');
	        _this.url = url;
	        _this.data = data;
	        _this.method = method;
	        _this.utilityService = _this.getService('utilityService');
	        if (!method) {
	            if (data == undefined) {
	                method = "get";
	            }
	            else {
	                method = "post";
	            }
	        }
	        var deferred = _this.$q.defer();
	        if (method == "post") {
	            if (_this.headers['Content-Type'] !== "application/json") {
	                data = _this.toFormParams(data);
	            }
	            //post
	            var promise = _this.$http({
	                url: url, data: data, headers: _this.headers, method: 'post'
	            })
	                .success(function (result) {
	                _this.processSuccess(result);
	                deferred.resolve(result);
	            }).error(function (response) {
	                _this.processError(response);
	                deferred.reject(response);
	            });
	            _this.promise = deferred.promise;
	        }
	        else {
	            //get
	            _this.$http({ url: url, method: 'get' })
	                .success(function (result) {
	                _this.processSuccess(result);
	                deferred.resolve(result);
	            }).error(function (reason) {
	                _this.processError(reason);
	                deferred.reject(reason);
	            });
	            _this.promise = deferred.promise;
	        }
	        return _this;
	    }
	    return Request;
	}(basetransient_1.BaseTransient));
	exports.Request = Request;


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path='../../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../../typings/tsd.d.ts' />
	var request_1 = __webpack_require__(44);
	var PublicRequest = (function (_super) {
	    __extends(PublicRequest, _super);
	    function PublicRequest(url, data, method, headers, $injector, observerService) {
	        if (headers === void 0) { headers = { 'Content-Type': "application/x-www-form-urlencoded" }; }
	        var _this = _super.call(this, url, data, method, headers, $injector) || this;
	        _this.observerService = observerService;
	        _this.failureActions = [];
	        _this.successfulActions = [];
	        _this.messages = [];
	        _this.hasSuccessfulAction = function () {
	            return _this.successfulActions.length > 0;
	        };
	        _this.hasFailureAction = function () {
	            return _this.failureActions.length > 0;
	        };
	        _this.observerService = observerService;
	        _this.promise.then(function (result) {
	            _this.successfulActions = result.successfulActions;
	            for (var i in _this.successfulActions) {
	                var successfulAction = _this.successfulActions[i];
	                _this.observerService.notify(successfulAction.split('.')[1] + 'Success', result.data);
	            }
	            _this.failureActions = result.failureActions;
	            for (var i in _this.failureActions) {
	                var failureAction = _this.failureActions[i];
	                _this.observerService.notify(failureAction.split('.')[1] + 'Failure', result.data);
	            }
	            _this.messages = result.messages;
	        }).catch(function (response) {
	        });
	        return _this;
	    }
	    return PublicRequest;
	}(request_1.Request));
	exports.PublicRequest = PublicRequest;


/***/ },
/* 46 */
/***/ function(module, exports) {

	"use strict";
	var ScopeService = (function () {
	    //ngInject
	    function ScopeService() {
	        var _this = this;
	        this.getRootParentScope = function (scope, targetScopeName) {
	            var currentScope = scope;
	            while (currentScope != null && angular.isUndefined(currentScope[targetScopeName])) {
	                if (angular.isDefined(currentScope.$parent)) {
	                    currentScope = currentScope.$parent;
	                }
	                else {
	                    break;
	                }
	            }
	            if (currentScope != null && angular.isDefined(currentScope[targetScopeName])) {
	                return currentScope;
	            }
	        };
	        this.hasParentScope = function (scope, targetScopeName) {
	            if (_this.getRootParentScope(scope, targetScopeName) != null) {
	                return true;
	            }
	            return false;
	        };
	    }
	    return ScopeService;
	}());
	exports.ScopeService = ScopeService;


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var baseentityservice_1 = __webpack_require__(9);
	var SkuService = (function (_super) {
	    __extends(SkuService, _super);
	    //@ngInject
	    function SkuService($injector, $hibachi, utilityService) {
	        var _this = _super.call(this, $injector, $hibachi, utilityService, 'Sku') || this;
	        _this.$injector = $injector;
	        _this.$hibachi = $hibachi;
	        _this.utilityService = utilityService;
	        return _this;
	    }
	    return SkuService;
	}(baseentityservice_1.BaseEntityService));
	exports.SkuService = SkuService;


/***/ },
/* 48 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var HibachiValidationService = (function () {
	    //@ngInject
	    function HibachiValidationService($log) {
	        var _this = this;
	        this.$log = $log;
	        this.getObjectSaveLevel = function (entityInstance) {
	            var objectLevel = entityInstance;
	            var entityID = entityInstance.$$getID();
	            angular.forEach(entityInstance.parents, function (parentObject) {
	                if (angular.isDefined(entityInstance.data[parentObject.name]) && entityInstance.data[parentObject.name].$$getID() === '' && (angular.isUndefined(entityID) || !entityID.trim().length)) {
	                    var parentEntityInstance = entityInstance.data[parentObject.name];
	                    var parentEntityID = parentEntityInstance.$$getID();
	                    if (parentEntityID === '' && parentEntityInstance.forms) {
	                        objectLevel = _this.getObjectSaveLevel(parentEntityInstance);
	                    }
	                }
	            });
	            return objectLevel;
	        };
	        this.getModifiedDataByInstance = function (entityInstance) {
	            var modifiedData = {};
	            var objectSaveLevel = _this.getObjectSaveLevel(entityInstance);
	            _this.$log.debug('objectSaveLevel : ' + objectSaveLevel);
	            var valueStruct = _this.validateObject(objectSaveLevel);
	            _this.$log.debug('validateObject data');
	            _this.$log.debug(valueStruct.value);
	            modifiedData = {
	                objectLevel: objectSaveLevel,
	                value: valueStruct.value,
	                valid: valueStruct.valid
	            };
	            return modifiedData;
	        };
	        this.getValidationByPropertyAndContext = function (entityInstance, property, context) {
	            var validations = _this.getValidationsByProperty(entityInstance, property);
	            for (var i in validations) {
	                var contexts = validations[i].contexts.split(',');
	                for (var j in contexts) {
	                    if (contexts[j] === context) {
	                        return validations[i];
	                    }
	                }
	            }
	        };
	        this.getValidationsByProperty = function (entityInstance, property) {
	            return entityInstance.validations.properties[property];
	        };
	        this.validateObject = function (entityInstance) {
	            var modifiedData = {};
	            var valid = true;
	            var forms = entityInstance.forms;
	            _this.$log.debug('process base level data');
	            for (var f in forms) {
	                var form = forms[f];
	                form.$setSubmitted(); //Sets the form to submitted for the validation errors to pop up.
	                if (form.$dirty && form.$valid) {
	                    for (var key in form) {
	                        _this.$log.debug('key:' + key);
	                        if (key.charAt(0) !== '$' && angular.isObject(form[key])) {
	                            var inputField = form[key];
	                            if (typeof inputField.$modelValue != 'undefined' && inputField.$modelValue !== '') {
	                                inputField.$dirty = true;
	                            }
	                            if (angular.isDefined(inputField.$valid) && inputField.$valid === true && (inputField.$dirty === true || (form.autoDirty && form.autoDirty == true))) {
	                                if (angular.isDefined(entityInstance.metaData[key])
	                                    && angular.isDefined(entityInstance.metaData[key].hb_formfieldtype)
	                                    && entityInstance.metaData[key].hb_formfieldtype === 'json') {
	                                    modifiedData[key] = angular.toJson(inputField.$modelValue);
	                                }
	                                else {
	                                    modifiedData[key] = inputField.$modelValue;
	                                }
	                            }
	                        }
	                    }
	                }
	                else {
	                    if (!form.$valid) {
	                        valid = false;
	                    }
	                }
	            }
	            modifiedData[entityInstance.$$getIDName()] = entityInstance.$$getID();
	            _this.$log.debug(modifiedData);
	            _this.$log.debug('process parent data');
	            if (angular.isDefined(entityInstance.parents)) {
	                for (var p in entityInstance.parents) {
	                    var parentObject = entityInstance.parents[p];
	                    var parentInstance = entityInstance.data[parentObject.name];
	                    if (angular.isUndefined(modifiedData[parentObject.name])) {
	                        modifiedData[parentObject.name] = {};
	                    }
	                    var forms = parentInstance.forms;
	                    for (var f in forms) {
	                        var form = forms[f];
	                        form.$setSubmitted();
	                        if (form.$dirty && form.$valid) {
	                            for (var key in form) {
	                                if (key.charAt(0) !== '$' && angular.isObject(form[key])) {
	                                    var inputField = form[key];
	                                    if (typeof inputField.$modelValue != 'undefined' && inputField.$modelValue !== '') {
	                                        inputField.$dirty = true;
	                                    }
	                                    if (angular.isDefined(inputField) && angular.isDefined(inputField.$valid) && inputField.$valid === true && (inputField.$dirty === true || (form.autoDirty && form.autoDirty == true))) {
	                                        if (angular.isDefined(parentInstance.metaData[key])
	                                            && angular.isDefined(parentInstance.metaData[key].hb_formfieldtype)
	                                            && parentInstance.metaData[key].hb_formfieldtype === 'json') {
	                                            modifiedData[parentObject.name][key] = angular.toJson(inputField.$modelValue);
	                                        }
	                                        else {
	                                            modifiedData[parentObject.name][key] = inputField.$modelValue;
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                        else {
	                            if (!form.$valid) {
	                                valid = false;
	                            }
	                        }
	                    }
	                    modifiedData[parentObject.name][parentInstance.$$getIDName()] = parentInstance.$$getID();
	                }
	            }
	            _this.$log.debug(modifiedData);
	            _this.$log.debug('begin child data');
	            var childrenData = _this.validateChildren(entityInstance);
	            _this.$log.debug('child Data');
	            _this.$log.debug(childrenData);
	            angular.extend(modifiedData, childrenData);
	            return {
	                valid: valid,
	                value: modifiedData
	            };
	        };
	        this.validateChildren = function (entityInstance) {
	            var data = {};
	            if (angular.isDefined(entityInstance.children) && entityInstance.children.length) {
	                data = _this.getDataFromChildren(entityInstance);
	            }
	            return data;
	        };
	        this.init = function (entityInstance, data) {
	            for (var key in data) {
	                if (key.charAt(0) !== '$' && angular.isDefined(entityInstance.metaData[key])) {
	                    var propertyMetaData = entityInstance.metaData[key];
	                    if (angular.isDefined(propertyMetaData) && angular.isDefined(propertyMetaData.hb_formfieldtype) && propertyMetaData.hb_formfieldtype === 'json') {
	                        if (data[key].trim() !== '') {
	                            entityInstance.data[key] = angular.fromJson(data[key]);
	                        }
	                    }
	                    else {
	                        entityInstance.data[key] = data[key];
	                    }
	                }
	            }
	        };
	        this.processForm = function (form, entityInstance) {
	            _this.$log.debug('begin process form');
	            var data = {};
	            form.$setSubmitted();
	            for (var key in form) {
	                if (key.charAt(0) !== '$' && angular.isObject(form[key])) {
	                    var inputField = form[key];
	                    if (inputField.$modelValue) {
	                        inputField.$dirty = true;
	                    }
	                    if (angular.isDefined(inputField) && angular.isDefined(inputField) && inputField.$valid === true && (inputField.$dirty === true || (form.autoDirty && form.autoDirty == true))) {
	                        if (angular.isDefined(entityInstance.metaData[key]) && angular.isDefined(entityInstance.metaData[key].hb_formfieldtype) && entityInstance.metaData[key].hb_formfieldtype === 'json') {
	                            data[key] = angular.toJson(inputField.$modelValue);
	                        }
	                        else {
	                            data[key] = inputField.$modelValue;
	                        }
	                    }
	                }
	            }
	            data[entityInstance.$$getIDName()] = entityInstance.$$getID();
	            _this.$log.debug('process form data');
	            _this.$log.debug(data);
	            return data;
	        };
	        this.processParent = function (entityInstance) {
	            var data = {};
	            if (entityInstance.$$getID() !== '') {
	                data[entityInstance.$$getIDName()] = entityInstance.$$getID();
	            }
	            _this.$log.debug('processParent');
	            _this.$log.debug(entityInstance);
	            var forms = entityInstance.forms;
	            for (var f in forms) {
	                var form = forms[f];
	                data = angular.extend(data, _this.processForm(form, entityInstance));
	            }
	            return data;
	        };
	        this.processChild = function (entityInstance, entityInstanceParent) {
	            var data = {};
	            var forms = entityInstance.forms;
	            for (var f in forms) {
	                var form = forms[f];
	                angular.extend(data, _this.processForm(form, entityInstance));
	            }
	            if (angular.isDefined(entityInstance.children) && entityInstance.children.length) {
	                var childData = _this.getDataFromChildren(entityInstance);
	                angular.extend(data, childData);
	            }
	            if (angular.isDefined(entityInstance.parents) && entityInstance.parents.length) {
	                var parentData = _this.getDataFromParents(entityInstance, entityInstanceParent);
	                angular.extend(data, parentData);
	            }
	            return data;
	        };
	        this.getDataFromParents = function (entityInstance, entityInstanceParent) {
	            var data = {};
	            for (var c in entityInstance.parents) {
	                var parentMetaData = entityInstance.parents[c];
	                if (angular.isDefined(parentMetaData)) {
	                    var parent = entityInstance.data[parentMetaData.name];
	                    if (angular.isObject(parent) && entityInstanceParent !== parent && parent.$$getID() !== '') {
	                        if (angular.isUndefined(data[parentMetaData.name])) {
	                            data[parentMetaData.name] = {};
	                        }
	                        var parentData = _this.processParent(parent);
	                        _this.$log.debug('parentData:' + parentMetaData.name);
	                        _this.$log.debug(parentData);
	                        angular.extend(data[parentMetaData.name], parentData);
	                    }
	                    else {
	                    }
	                }
	            }
	            ;
	            return data;
	        };
	        this.getDataFromChildren = function (entityInstance) {
	            var data = {};
	            _this.$log.debug('childrenFound');
	            _this.$log.debug(entityInstance.children);
	            for (var c in entityInstance.children) {
	                var childMetaData = entityInstance.children[c];
	                var children = entityInstance.data[childMetaData.name];
	                _this.$log.debug(childMetaData);
	                _this.$log.debug(children);
	                if (angular.isArray(entityInstance.data[childMetaData.name])) {
	                    if (angular.isUndefined(data[childMetaData.name])) {
	                        data[childMetaData.name] = [];
	                    }
	                    angular.forEach(entityInstance.data[childMetaData.name], function (child, key) {
	                        _this.$log.debug('process child array item');
	                        var childData = _this.processChild(child, entityInstance);
	                        _this.$log.debug('process child return');
	                        _this.$log.debug(childData);
	                        data[childMetaData.name].push(childData);
	                    });
	                }
	                else {
	                    if (angular.isUndefined(data[childMetaData.name])) {
	                        data[childMetaData.name] = {};
	                    }
	                    var child = entityInstance.data[childMetaData.name];
	                    _this.$log.debug('begin process child');
	                    var childData = _this.processChild(child, entityInstance);
	                    _this.$log.debug('process child return');
	                    _this.$log.debug(childData);
	                    angular.extend(data, childData);
	                }
	            }
	            _this.$log.debug('returning child data');
	            _this.$log.debug(data);
	            return data;
	        };
	        this.$log = $log;
	    }
	    return HibachiValidationService;
	}());
	exports.HibachiValidationService = HibachiValidationService;


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var baseentityservice_1 = __webpack_require__(9);
	var EntityService = (function (_super) {
	    __extends(EntityService, _super);
	    //@ngInject
	    function EntityService($injector, $hibachi, utilityService) {
	        var _this = _super.call(this, $injector, $hibachi, utilityService) || this;
	        _this.$injector = $injector;
	        _this.$hibachi = $hibachi;
	        _this.utilityService = utilityService;
	        return _this;
	    }
	    return EntityService;
	}(baseentityservice_1.BaseEntityService));
	exports.EntityService = EntityService;


/***/ },
/* 50 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var GlobalSearchController = (function () {
	    //@ngInject
	    function GlobalSearchController($scope, $log, $window, $timeout, $hibachi, rbkeyService) {
	        $scope.keywords = '';
	        $scope.searchResultsOpen = false;
	        $scope.sidebarClass = 'sidebar';
	        $scope.loading = false; //Set loading wheel to false
	        $scope.resultsFound = true; // Set the results Found to true because no search has been done yet
	        $scope.searchResults = {
	            'product': {
	                'title': 'Products',
	                'resultNameFilter': function (data) {
	                    return data['productName'];
	                },
	                'results': [],
	                'id': function (data) {
	                    return data['productID'];
	                }
	            },
	            'order': {
	                'title': rbkeyService.getRBKey('entity.order_plural'),
	                'resultNameFilter': function (data) {
	                    return data['orderNumber'];
	                },
	                'results': [],
	                'id': function (data) {
	                    return data['orderID'];
	                }
	            },
	            'brand': {
	                'title': rbkeyService.getRBKey('entity.brand_plural'),
	                'resultNameFilter': function (data) {
	                    return data['brandName'];
	                },
	                'results': [],
	                'id': function (data) {
	                    return data['brandID'];
	                }
	            },
	            'account': {
	                'title': 'Accounts',
	                'resultNameFilter': function (data) {
	                    return data['firstName'] + ' ' + data['lastName'];
	                },
	                'results': [],
	                'id': function (data) {
	                    return data['accountID'];
	                }
	            },
	            'vendor': {
	                'title': 'Vendors',
	                'resultNameFilter': function (data) {
	                    return data['vendorName'];
	                },
	                'results': [],
	                'id': function (data) {
	                    return data['vendorID'];
	                }
	            }
	        };
	        var _timeoutPromise;
	        var _loadingCount = 0;
	        $scope.updateSearchResults = function () {
	            $scope.loading = true;
	            $scope.showResults();
	            if (_timeoutPromise) {
	                $timeout.cancel(_timeoutPromise);
	            }
	            _timeoutPromise = $timeout(function () {
	                // If no keywords, then set everything back to their defaults
	                if ($scope.keywords === '') {
	                    $scope.hideResults();
	                }
	                else {
	                    $scope.showResults();
	                    // Set the loadingCount to the number of AJAX Calls we are about to do
	                    _loadingCount = Object.keys($scope.searchResults).length;
	                    for (var entityName in $scope.searchResults) {
	                        (function (entityName) {
	                            var searchPromise = $hibachi.getEntity(entityName, { keywords: $scope.keywords, pageShow: 4, deferkey: 'global-search-' + entityName });
	                            searchPromise.then(function (data) {
	                                // Clear out the old Results
	                                $scope.searchResults[entityName].results = [];
	                                $scope.searchResults[entityName].title = rbkeyService.getRBKey('entity.' + entityName.toLowerCase() + '_plural');
	                                // push in the new results
	                                for (var i in data.pageRecords) {
	                                    $scope.searchResults[entityName].results.push({
	                                        'name': $scope.searchResults[entityName].resultNameFilter(data.pageRecords[i]),
	                                        'link': $hibachi.buildUrl('entity.detail' + entityName) + '&' + entityName + 'ID=' + $scope.searchResults[entityName].id(data.pageRecords[i]),
	                                    });
	                                }
	                                // Increment Down The Loading Count
	                                _loadingCount--;
	                                // If the loadingCount drops to 0, then we can update scope
	                                if (_loadingCount == 0) {
	                                    $scope.loading = false;
	                                    var _foundResults = false;
	                                    for (var _thisEntityName in $scope.searchResults) {
	                                        if ($scope.searchResults[_thisEntityName].results.length) {
	                                            _foundResults = true;
	                                            break;
	                                        }
	                                    }
	                                    $scope.resultsFound = _foundResults;
	                                }
	                            });
	                        })(entityName);
	                    }
	                }
	            }, 500);
	        };
	        $scope.showResults = function () {
	            $scope.searchResultsOpen = true;
	            $scope.sidebarClass = 'sidebar s-search-width';
	            $window.onclick = function (event) {
	                var _targetClassOfSearch = event.target.parentElement.offsetParent.classList.contains('sidebar');
	                if (!_targetClassOfSearch) {
	                    $scope.hideResults();
	                    $scope.$apply();
	                }
	            };
	        };
	        $scope.hideResults = function () {
	            $scope.searchResultsOpen = false;
	            $scope.sidebarClass = 'sidebar';
	            $scope.search.$setPristine();
	            $scope.keywords = "";
	            $window.onclick = null;
	            $scope.loading = false;
	            $scope.resultsFound = true;
	            for (var entityName in $scope.searchResults) {
	                $scope.searchResults[entityName].results = [];
	            }
	        };
	    }
	    return GlobalSearchController;
	}());
	exports.GlobalSearchController = GlobalSearchController;


/***/ },
/* 51 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var PercentageFilter = (function () {
	    function PercentageFilter() {
	    }
	    PercentageFilter.Factory = function () {
	        return function (input, decimals, suffix) {
	            decimals = angular.isNumber(decimals) ? decimals : 3;
	            suffix = suffix || '%';
	            if (isNaN(input)) {
	                return '';
	            }
	            return Math.round(input * Math.pow(10, decimals + 2)) / Math.pow(10, decimals) + suffix;
	        };
	    };
	    return PercentageFilter;
	}());
	exports.PercentageFilter = PercentageFilter;


/***/ },
/* 52 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var EntityRBKey = (function () {
	    function EntityRBKey() {
	    }
	    //@ngInject
	    EntityRBKey.Factory = function (rbkeyService) {
	        return function (text) {
	            if (angular.isDefined(text) && angular.isString(text)) {
	                text = text.replace('_', '').toLowerCase();
	                text = rbkeyService.getRBKey('entity.' + text);
	            }
	            return text;
	        };
	    };
	    return EntityRBKey;
	}());
	exports.EntityRBKey = EntityRBKey;


/***/ },
/* 53 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWTrim = (function () {
	    function SWTrim() {
	    }
	    //@ngInject
	    SWTrim.Factory = function (rbkeyService) {
	        return function (text, max, wordwise, tail) {
	            if (wordwise === void 0) { wordwise = true; }
	            if (tail === void 0) { tail = "..."; }
	            if (angular.isDefined(text) && angular.isString(text)) {
	                if (!text)
	                    return '';
	                max = parseInt(max, 10);
	                if (!max)
	                    return text;
	                if (text.length <= max)
	                    return text;
	                text = text.substr(0, max);
	                if (wordwise) {
	                    var lastSpace = text.lastIndexOf(' ');
	                    if (lastSpace != -1) {
	                        text = text.substr(0, lastSpace);
	                    }
	                }
	                return text + tail;
	            }
	            return text;
	        };
	    };
	    return SWTrim;
	}());
	exports.SWTrim = SWTrim;


/***/ },
/* 54 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWUnique = (function () {
	    function SWUnique() {
	    }
	    //@ngInject
	    SWUnique.Factory = function () {
	        var filterStub;
	        filterStub = function (items, filterOn) {
	            if (filterOn === false) {
	                return items;
	            }
	            if ((filterOn || angular.isUndefined(filterOn)) && angular.isArray(items)) {
	                var hashCheck = {}, newItems = [];
	                var extractValueToCompare = function (item) {
	                    if (angular.isDefined(item) && item[filterOn] != null) {
	                        return item[filterOn];
	                    }
	                    return item;
	                };
	                angular.forEach(items, function (item) {
	                    var isDuplicate = false;
	                    for (var i = 0; i < newItems.length; i++) {
	                        if (extractValueToCompare(newItems[i]) == extractValueToCompare(item)) {
	                            isDuplicate = true;
	                            break;
	                        }
	                    }
	                    if (!isDuplicate) {
	                        newItems.push(item);
	                    }
	                });
	            }
	            return newItems;
	        };
	        //filterStub.$stateful = true;
	        return filterStub;
	    };
	    return SWUnique;
	}());
	exports.SWUnique = SWUnique;


/***/ },
/* 55 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var DateFilter = (function () {
	    function DateFilter() {
	    }
	    //@ngInject
	    DateFilter.Factory = function ($filter) {
	        return function (date, dateString) {
	            return $filter('date')(new Date(date), dateString);
	        };
	    };
	    return DateFilter;
	}());
	exports.DateFilter = DateFilter;


/***/ },
/* 56 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWActionCallerController = (function () {
	    //@ngInject
	    function SWActionCallerController($scope, $element, $templateRequest, $compile, $timeout, corePartialsPath, utilityService, $hibachi, rbkeyService, hibachiPathBuilder) {
	        var _this = this;
	        this.$scope = $scope;
	        this.$element = $element;
	        this.$templateRequest = $templateRequest;
	        this.$compile = $compile;
	        this.$timeout = $timeout;
	        this.corePartialsPath = corePartialsPath;
	        this.utilityService = utilityService;
	        this.$hibachi = $hibachi;
	        this.rbkeyService = rbkeyService;
	        this.$onInit = function () {
	            //Check if is NOT a ngRouter
	            if (angular.isUndefined(_this.isAngularRoute)) {
	                _this.isAngularRoute = _this.utilityService.isAngularRoute();
	            }
	            if (!_this.isAngularRoute) {
	                _this.actionUrl = _this.$hibachi.buildUrl(_this.action, _this.queryString);
	            }
	            else {
	                _this.actionUrl = '#!/entity/' + _this.action + '/' + _this.queryString.split('=')[1];
	            }
	            //			this.class = this.utilityService.replaceAll(this.utilityService.replaceAll(this.getAction(),':',''),'.','') + ' ' + this.class;
	            _this.type = _this.type || 'link';
	            if (angular.isDefined(_this.titleRbKey)) {
	                _this.title = _this.rbkeyService.getRBKey(_this.titleRbKey);
	            }
	            if (angular.isUndefined(_this.text)) {
	                _this.text = _this.title;
	            }
	            if (_this.type == "button") {
	                //handle submit.
	                /** in order to attach the correct controller to local vm, we need a watch to bind */
	                var unbindWatcher = _this.$scope.$watch(function () { return _this.formController; }, function (newValue, oldValue) {
	                    if (newValue !== undefined) {
	                        _this.formController = newValue;
	                    }
	                    unbindWatcher();
	                });
	            }
	            //			this.actionItem = this.getActionItem();
	            //			this.actionItemEntityName = this.getActionItemEntityName();
	            //			this.text = this.getText();
	            //			if(this.getDisabled()){
	            //				this.getDisabledText();
	            //			}else if(this.getConfirm()){
	            //				this.getConfirmText();
	            //			}
	            //
	            //			if(this.modalFullWidth && !this.getDisabled()){
	            //				this.class = this.class + " modalload-fullwidth";
	            //			}
	            //
	            //			if(this.modal && !this.getDisabled() && !this.modalFullWidth){
	            //				this.class = this.class + " modalload";
	            //			}
	            /*need authentication lookup by api to disable
	            <cfif not attributes.hibachiScope.authenticateAction(action=attributes.action)>
	                <cfset attributes.class &= " disabled" />
	            </cfif>
	            */
	        };
	        this.submit = function () {
	            _this.$timeout(function () {
	                if (_this.form.$valid) {
	                    _this.formController.submit(_this.action);
	                }
	                _this.form.$submitted = true;
	            });
	        };
	        this.getAction = function () {
	            return _this.action || '';
	        };
	        this.getActionItem = function () {
	            return _this.utilityService.listLast(_this.getAction(), '.');
	        };
	        this.getActionItemEntityName = function () {
	            var firstFourLetters = _this.utilityService.left(_this.actionItem, 4);
	            var firstSixLetters = _this.utilityService.left(_this.actionItem, 6);
	            var minus4letters = _this.utilityService.right(_this.actionItem, 4);
	            var minus6letters = _this.utilityService.right(_this.actionItem, 6);
	            var actionItemEntityName = "";
	            if (firstFourLetters === 'list' && _this.actionItem.length > 4) {
	                actionItemEntityName = minus4letters;
	            }
	            else if (firstFourLetters === 'edit' && _this.actionItem.length > 4) {
	                actionItemEntityName = minus4letters;
	            }
	            else if (firstFourLetters === 'save' && _this.actionItem.length > 4) {
	                actionItemEntityName = minus4letters;
	            }
	            else if (firstSixLetters === 'create' && _this.actionItem.length > 6) {
	                actionItemEntityName = minus6letters;
	            }
	            else if (firstSixLetters === 'detail' && _this.actionItem.length > 6) {
	                actionItemEntityName = minus6letters;
	            }
	            else if (firstSixLetters === 'delete' && _this.actionItem.length > 6) {
	                actionItemEntityName = minus6letters;
	            }
	            return actionItemEntityName;
	        };
	        this.getTitle = function () {
	            //if title is undefined then use text
	            if (angular.isUndefined(_this.title) || !_this.title.length) {
	                _this.title = _this.getText();
	            }
	            return _this.title;
	        };
	        this.getTextByRBKeyByAction = function (actionItemType, plural) {
	            if (plural === void 0) { plural = false; }
	            var navRBKey = _this.rbkeyService.getRBKey('admin.define.' + actionItemType + '_nav');
	            var entityRBKey = '';
	            var replaceKey = '';
	            if (plural) {
	                entityRBKey = _this.rbkeyService.getRBKey('entity.' + _this.actionItemEntityName + '_plural');
	                replaceKey = '${itemEntityNamePlural}';
	            }
	            else {
	                entityRBKey = _this.rbkeyService.getRBKey('entity.' + _this.actionItemEntityName);
	                replaceKey = '${itemEntityName}';
	            }
	            return _this.utilityService.replaceAll(navRBKey, replaceKey, entityRBKey);
	        };
	        this.getText = function () {
	            //if we don't have text then make it up based on rbkeys
	            if (angular.isUndefined(_this.text) || (angular.isDefined(_this.text) && !_this.text.length)) {
	                _this.text = _this.rbkeyService.getRBKey(_this.utilityService.replaceAll(_this.getAction(), ":", ".") + '_nav');
	                var minus8letters = _this.utilityService.right(_this.text, 8);
	                //if rbkey is still missing. then can we infer it
	                if (minus8letters === '_missing') {
	                    var firstFourLetters = _this.utilityService.left(_this.actionItem, 4);
	                    var firstSixLetters = _this.utilityService.left(_this.actionItem, 6);
	                    var minus4letters = _this.utilityService.right(_this.actionItem, 4);
	                    var minus6letters = _this.utilityService.right(_this.actionItem, 6);
	                    if (firstFourLetters === 'list' && _this.actionItem.length > 4) {
	                        _this.text = _this.getTextByRBKeyByAction('list', true);
	                    }
	                    else if (firstFourLetters === 'edit' && _this.actionItem.length > 4) {
	                        _this.text = _this.getTextByRBKeyByAction('edit', false);
	                    }
	                    else if (firstFourLetters === 'save' && _this.actionItem.length > 4) {
	                        _this.text = _this.getTextByRBKeyByAction('save', false);
	                    }
	                    else if (firstSixLetters === 'create' && _this.actionItem.length > 6) {
	                        _this.text = _this.getTextByRBKeyByAction('create', false);
	                    }
	                    else if (firstSixLetters === 'detail' && _this.actionItem.length > 6) {
	                        _this.text = _this.getTextByRBKeyByAction('detail', false);
	                    }
	                    else if (firstSixLetters === 'delete' && _this.actionItem.length > 6) {
	                        _this.text = _this.getTextByRBKeyByAction('delete', false);
	                    }
	                }
	                if (_this.utilityService.right(_this.text, 8)) {
	                    _this.text = _this.rbkeyService.getRBKey(_this.utilityService.replaceAll(_this.getAction(), ":", "."));
	                }
	            }
	            if (!_this.title || (_this.title && !_this.title.length)) {
	                _this.title = _this.text;
	            }
	            return _this.text;
	        };
	        this.getDisabled = function () {
	            //if item is disabled
	            if (angular.isDefined(_this.disabled) && _this.disabled) {
	                return true;
	            }
	            else {
	                return false;
	            }
	        };
	        this.getDisabledText = function () {
	            if (_this.getDisabled()) {
	                //and no disabled text specified
	                if (angular.isUndefined(_this.disabledtext) || !_this.disabledtext.length) {
	                    var disabledrbkey = _this.utilityService.replaceAll(_this.action, ':', '.') + '_disabled';
	                    _this.disabledtext = _this.rbkeyService.getRBKey(disabledrbkey);
	                }
	                //add disabled class
	                _this.class += " btn-disabled";
	                _this.confirm = false;
	                return _this.disabledtext;
	            }
	            return "";
	        };
	        this.getConfirm = function () {
	            if (angular.isDefined(_this.confirm) && _this.confirm) {
	                return true;
	            }
	            else {
	                return false;
	            }
	        };
	        this.getConfirmText = function () {
	            if (_this.getConfirm()) {
	                if (angular.isUndefined(_this.confirmtext) && _this.confirmtext.length) {
	                    var confirmrbkey = _this.utilityService.replaceAll(_this.action, ':', '.') + '_confirm';
	                    _this.confirmtext = _this.rbkeyService.getRBKey(confirmrbkey);
	                }
	                _this.class += " alert-confirm";
	                return _this.confirm;
	            }
	            return "";
	        };
	        this.$scope = $scope;
	        this.$element = $element;
	        this.$timeout = $timeout;
	        this.$templateRequest = $templateRequest;
	        this.$compile = $compile;
	        this.rbkeyService = rbkeyService;
	        this.$hibachi = $hibachi;
	        this.utilityService = utilityService;
	        this.hibachiPathBuilder = hibachiPathBuilder;
	        this.$templateRequest(this.hibachiPathBuilder.buildPartialsPath(corePartialsPath) + "actioncaller.html").then(function (html) {
	            var template = angular.element(html);
	            _this.$element.parent().append(template);
	            $compile(template)($scope);
	            //need to perform init after promise completes
	            //this.init();
	        });
	    }
	    return SWActionCallerController;
	}());
	exports.SWActionCallerController = SWActionCallerController;
	var SWActionCaller = (function () {
	    function SWActionCaller(partialsPath, utiltiyService, $hibachi) {
	        this.partialsPath = partialsPath;
	        this.utiltiyService = utiltiyService;
	        this.$hibachi = $hibachi;
	        this.restrict = 'EA';
	        this.scope = {};
	        this.bindToController = {
	            action: "@",
	            text: "@",
	            type: "@",
	            queryString: "@",
	            title: "@?",
	            titleRbKey: "@?",
	            'class': "@",
	            icon: "@",
	            iconOnly: "=",
	            name: "@",
	            confirm: "=",
	            confirmtext: "@",
	            disabled: "=",
	            disabledtext: "@",
	            modal: "=",
	            modalFullWidth: "=",
	            id: "@",
	            isAngularRoute: "=?"
	        };
	        this.require = { formController: "^?swForm", form: "^?form" };
	        this.controller = SWActionCallerController;
	        this.controllerAs = "swActionCaller";
	        this.link = function (scope, element, attrs) {
	            if (angular.isDefined(scope.swActionCaller.formController)) {
	                scope.formController = scope.swActionCaller.formController;
	            }
	        };
	    }
	    SWActionCaller.Factory = function () {
	        var directive = function (partialsPath, utiltiyService, $hibachi) { return new SWActionCaller(partialsPath, utiltiyService, $hibachi); };
	        directive.$inject = [
	            'partialsPath',
	            'utilityService',
	            '$hibachi'
	        ];
	        return directive;
	    };
	    return SWActionCaller;
	}());
	exports.SWActionCaller = SWActionCaller;


/***/ },
/* 57 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWTypeaheadSearchController = (function () {
	    // @ngInject
	    function SWTypeaheadSearchController($scope, $q, $transclude, $hibachi, $timeout, utilityService, observerService, rbkeyService, collectionConfigService, typeaheadService) {
	        var _this = this;
	        this.$scope = $scope;
	        this.$q = $q;
	        this.$transclude = $transclude;
	        this.$hibachi = $hibachi;
	        this.$timeout = $timeout;
	        this.utilityService = utilityService;
	        this.observerService = observerService;
	        this.rbkeyService = rbkeyService;
	        this.collectionConfigService = collectionConfigService;
	        this.typeaheadService = typeaheadService;
	        this.results = [];
	        this.columns = [];
	        this.filters = [];
	        this.searchableColumns = [];
	        this.initialSearchableColumnsState = [];
	        this.searchableColumnSelection = 'All';
	        this.fallbackPropertyArray = [];
	        this.clearSearch = function () {
	            _this.searchText = "";
	            _this.hideSearch = true;
	            if (angular.isDefined(_this.addFunction)) {
	                _this.addFunction()(undefined);
	            }
	        };
	        this.toggleOptions = function () {
	            if (_this.hideSearch && !_this.searchText.length) {
	                _this.search(_this.searchText);
	            }
	            _this.hideSearch = !_this.hideSearch;
	        };
	        this.search = function (search) {
	            if (_this._timeoutPromise) {
	                _this.$timeout.cancel(_this._timeoutPromise);
	            }
	            _this.collectionConfig.setKeywords(search);
	            if (angular.isDefined(_this.filterGroupsConfig)) {
	                //allows for filtering on search text
	                var filterConfig = _this.filterGroupsConfig.replace("replaceWithSearchString", search);
	                filterConfig = filterConfig.trim();
	                _this.collectionConfig.loadFilterGroups(JSON.parse(filterConfig));
	            }
	            _this._timeoutPromise = _this.$timeout(function () {
	                var promise = _this.collectionConfig.getEntity();
	                promise.then(function (response) {
	                    _this.results = response.pageRecords || response.records;
	                    _this.updateSelections();
	                }).finally(function () {
	                    _this.resultsDeferred.resolve();
	                    _this.hideSearch = (_this.results.length == 0);
	                });
	            }, 500);
	        };
	        this.updateSelections = function () {
	            _this.typeaheadService.updateSelections(_this.typeaheadDataKey);
	        };
	        this.updateSearchableProperties = function (column) {
	            if (angular.isString(column) && column == 'all') {
	                angular.copy(_this.initialSearchableColumnsState, _this.searchableColumns); //need to insure that these changes are actually on the collectionconfig
	                _this.searchableColumnSelection = 'All';
	            }
	            else {
	                angular.forEach(_this.searchableColumns, function (value, key) {
	                    value.isSearchable = false;
	                });
	                column.isSearchable = true;
	                _this.searchableColumnSelection = column.title;
	            }
	            //probably need to refetch the collection
	        };
	        this.addOrRemoveItem = function (item) {
	            var remove = item.selected || false;
	            if (!_this.hideSearch && !_this.multiselectMode) {
	                _this.hideSearch = true;
	            }
	            if (!_this.multiselectMode) {
	                if (angular.isDefined(_this.propertyToShow)) {
	                    _this.searchText = item[_this.propertyToShow];
	                }
	                else if (angular.isDefined(_this.columns) &&
	                    _this.columns.length &&
	                    angular.isDefined(_this.columns[0].propertyIdentifier)) {
	                    _this.searchText = item[_this.columns[0].propertyIdentifier];
	                }
	            }
	            if (!remove && angular.isDefined(_this.addFunction)) {
	                _this.addFunction()(item);
	            }
	            if (remove && angular.isDefined(_this.removeFunction)) {
	                _this.removeFunction()(item.selectedIndex);
	                item.selected = false;
	                item.selectedIndex = undefined;
	            }
	            _this.updateSelections();
	        };
	        this.addButtonItem = function () {
	            if (!_this.hideSearch) {
	                _this.hideSearch = true;
	            }
	            if (angular.isDefined(_this.addButtonFunction)) {
	                _this.addButtonFunction()(_this.searchText);
	            }
	        };
	        this.viewButtonClick = function () {
	            _this.viewFunction()();
	        };
	        this.closeThis = function (clickOutsideArgs) {
	            _this.hideSearch = true;
	            if (angular.isDefined(clickOutsideArgs)) {
	                for (var callBackAction in clickOutsideArgs.callBackActions) {
	                    clickOutsideArgs.callBackActions[callBackAction]();
	                }
	            }
	        };
	        this.getSelections = function () {
	            return _this.typeaheadService.getData(_this.typeaheadDataKey);
	        };
	        //populates all needed variables
	        this.$transclude($scope, function () { });
	        this.resultsDeferred = $q.defer();
	        this.resultsPromise = this.resultsDeferred.promise;
	        if (angular.isUndefined(this.typeaheadDataKey)) {
	            this.typeaheadDataKey = this.utilityService.createID(32);
	        }
	        if (angular.isUndefined(this.disabled)) {
	            this.disabled = false;
	        }
	        if (angular.isUndefined(this.multiselectMode)) {
	            this.multiselectMode = false;
	        }
	        if (angular.isUndefined(this.searchText) || this.searchText == null) {
	            this.searchText = "";
	        }
	        else {
	            this.search(this.searchText);
	        }
	        if (angular.isUndefined(this.validateRequired)) {
	            this.validateRequired = false;
	        }
	        if (angular.isUndefined(this.hideSearch)) {
	            this.hideSearch = true;
	        }
	        if (angular.isUndefined(this.collectionConfig)) {
	            if (angular.isDefined(this.entity)) {
	                this.collectionConfig = collectionConfigService.newCollectionConfig(this.entity);
	            }
	            else {
	                throw ("You did not pass the correct collection config data to swTypeaheadSearch");
	            }
	        }
	        if (angular.isDefined(this.collectionConfig)) {
	            this.primaryIDPropertyName = $hibachi.getPrimaryIDPropertyNameByEntityName(this.collectionConfig.baseEntityName);
	        }
	        if (angular.isDefined(this.fallbackPropertiesToCompare) &&
	            this.fallbackPropertiesToCompare.length) {
	            this.fallbackPropertyArray = this.fallbackPropertiesToCompare.split(",");
	        }
	        if (angular.isDefined(this.placeholderRbKey)) {
	            this.placeholderText = this.rbkeyService.getRBKey(this.placeholderRbKey);
	        }
	        else if (angular.isUndefined(this.placeholderText)) {
	            this.placeholderText = this.rbkeyService.getRBKey('define.search');
	        }
	        //init timeoutPromise for link
	        this._timeoutPromise = this.$timeout(function () { }, 500);
	        if (angular.isDefined(this.propertiesToDisplay)) {
	            this.collectionConfig.addDisplayProperty(this.propertiesToDisplay.split(","));
	        }
	        angular.forEach(this.columns, function (column) {
	            _this.collectionConfig.addDisplayProperty(column.propertyIdentifier, '', column);
	        });
	        angular.forEach(this.filters, function (filter) {
	            _this.collectionConfig.addFilter(filter.propertyIdentifier, filter.comparisonValue, filter.comparisonOperator, filter.logicalOperator, filter.hidden);
	        });
	        if (angular.isUndefined(this.allRecords)) {
	            this.allRecords = this.collectionConfig.allRecords;
	        }
	        this.collectionConfig.setAllRecords(this.allRecords);
	        if (angular.isDefined(this.maxRecords)) {
	            this.collectionConfig.setPageShow(this.maxRecords);
	        }
	        if (angular.isDefined(this.initialEntityId) && this.initialEntityId.length) {
	            this.initialEntityCollectionConfig = collectionConfigService.newCollectionConfig(this.collectionConfig.baseEntityName);
	            this.initialEntityCollectionConfig.loadColumns(this.collectionConfig.columns);
	            var primaryIDProperty = $hibachi.getPrimaryIDPropertyNameByEntityName(this.initialEntityCollectionConfig.baseEntityName);
	            this.initialEntityCollectionConfig.addFilter(primaryIDProperty, this.initialEntityId, "=");
	            var promise = this.initialEntityCollectionConfig.getEntity();
	            promise.then(function (response) {
	                _this.results = response.pageRecords;
	                if (_this.results.length) {
	                    _this.addOrRemoveItem(_this.results[0]);
	                }
	            });
	        }
	        angular.forEach(this.collectionConfig.columns, function (value, key) {
	            if (value.isSearchable) {
	                _this.searchableColumns.push(value);
	            }
	        });
	        //need to insure that these changes are actually on the collectionconfig
	        angular.copy(this.searchableColumns, this.initialSearchableColumnsState);
	        this.typeaheadService.setTypeaheadState(this.typeaheadDataKey, this);
	        this.observerService.attach(this.clearSearch, this.typeaheadDataKey + 'clearSearch');
	    }
	    return SWTypeaheadSearchController;
	}());
	exports.SWTypeaheadSearchController = SWTypeaheadSearchController;
	var SWTypeaheadSearch = (function () {
	    // @ngInject
	    function SWTypeaheadSearch($compile, typeaheadService, corePartialsPath, hibachiPathBuilder) {
	        var _this = this;
	        this.$compile = $compile;
	        this.typeaheadService = typeaheadService;
	        this.corePartialsPath = corePartialsPath;
	        this.transclude = true;
	        this.restrict = "EA";
	        this.scope = {};
	        this.bindToController = {
	            collectionConfig: "=?",
	            entity: "@?",
	            properties: "@?",
	            propertiesToDisplay: "@?",
	            filterGroupsConfig: "@?",
	            placeholderText: "@?",
	            placeholderRbKey: "@?",
	            propertyToCompare: "@?",
	            fallbackPropertiesToCompare: "@?",
	            searchText: "=?",
	            results: "=?",
	            addFunction: "&?",
	            removeFunction: "&?",
	            addButtonFunction: "&?",
	            viewFunction: "&?",
	            showAddButton: "=?",
	            showViewButton: "=?",
	            validateRequired: "=?",
	            clickOutsideArguments: "=?",
	            propertyToShow: "=?",
	            hideSearch: "=?",
	            allRecords: "=?",
	            maxRecords: "=?",
	            disabled: "=?",
	            initialEntityId: "@",
	            multiselectMode: "=?",
	            typeaheadDataKey: "@?",
	            rightContentPropertyIdentifier: "@?"
	        };
	        this.controller = SWTypeaheadSearchController;
	        this.controllerAs = "swTypeaheadSearch";
	        this.compile = function (element, attrs, transclude) {
	            return {
	                pre: function ($scope, element, attrs) {
	                    if (angular.isDefined(attrs.addButtonFunction) && angular.isUndefined(attrs.showAddButton)) {
	                        $scope.swTypeaheadSearch.showAddButton = true;
	                    }
	                    else if (angular.isUndefined(attrs.showAddButton)) {
	                        $scope.swTypeaheadSearch.showAddButton = false;
	                    }
	                    if (angular.isDefined(attrs.viewFunction) && angular.isUndefined(attrs.showViewButton)) {
	                        $scope.swTypeaheadSearch.showViewButton = true;
	                    }
	                    else if (angular.isUndefined(attrs.showViewButton)) {
	                        $scope.swTypeaheadSearch.showViewButton = false;
	                    }
	                },
	                post: function ($scope, element, attrs) {
	                    var target = element.find(".dropdown-menu");
	                    var listItemTemplateString = "\n                    <li ng-repeat=\"item in swTypeaheadSearch.results\" ng-class=\"{'s-selected':item.selected}\"></li>\n                ";
	                    var anchorTemplateString = "\n                    <a ng-click=\"swTypeaheadSearch.addOrRemoveItem(item)\">\n                ";
	                    if (angular.isDefined($scope.swTypeaheadSearch.rightContentPropertyIdentifier)) {
	                        var rightContentTemplateString = "<span class=\"s-right-content\" ng-bind=\"item[swTypeaheadSearch.rightContentPropertyIdentifier]\"></span></a>";
	                    }
	                    else {
	                        var rightContentTemplateString = "</a>";
	                    }
	                    anchorTemplateString = anchorTemplateString + rightContentTemplateString;
	                    var listItemTemplate = angular.element(listItemTemplateString);
	                    var anchorTemplate = angular.element(anchorTemplateString);
	                    anchorTemplate.append(_this.typeaheadService.stripTranscludedContent(transclude($scope, function () { })));
	                    listItemTemplate.append(anchorTemplate);
	                    $scope.swTypeaheadSearch.resultsPromise.then(function () {
	                        target.append(_this.$compile(listItemTemplate)($scope));
	                    });
	                }
	            };
	        };
	        this.templateUrl = hibachiPathBuilder.buildPartialsPath(corePartialsPath) + "typeaheadsearch.html";
	    }
	    SWTypeaheadSearch.Factory = function () {
	        var directive = function ($compile, typeaheadService, corePartialsPath, hibachiPathBuilder) { return new SWTypeaheadSearch($compile, typeaheadService, corePartialsPath, hibachiPathBuilder); };
	        directive.$inject = ["$compile", "typeaheadService", "corePartialsPath",
	            'hibachiPathBuilder'];
	        return directive;
	    };
	    return SWTypeaheadSearch;
	}());
	exports.SWTypeaheadSearch = SWTypeaheadSearch;


/***/ },
/* 58 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWTypeaheadInputFieldController = (function () {
	    // @ngInject
	    function SWTypeaheadInputFieldController($scope, $transclude, collectionConfigService) {
	        var _this = this;
	        this.$scope = $scope;
	        this.$transclude = $transclude;
	        this.collectionConfigService = collectionConfigService;
	        this.columns = [];
	        this.filters = [];
	        this.addFunction = function (value) {
	            _this.modelValue = value[_this.propertyToSave];
	        };
	        if (angular.isUndefined(this.typeaheadCollectionConfig)) {
	            if (angular.isDefined(this.entityName)) {
	                this.typeaheadCollectionConfig = collectionConfigService.newCollectionConfig(this.entityName);
	            }
	            else {
	                throw ("You did not pass the correct collection config data to swTypeaheadInputField");
	            }
	        }
	        if (angular.isUndefined(this.validateRequired)) {
	            this.validateRequired = false;
	        }
	        //get the collection config
	        this.$transclude($scope, function () { });
	        if (angular.isUndefined(this.propertyToSave)) {
	            throw ("You must select a property to save for the input field directive");
	        }
	        if (angular.isDefined(this.propertiesToLoad)) {
	            this.typeaheadCollectionConfig.addDisplayProperty(this.propertiesToLoad);
	        }
	        angular.forEach(this.columns, function (column) {
	            _this.typeaheadCollectionConfig.addDisplayProperty(column.propertyIdentifier, '', column);
	        });
	        angular.forEach(this.filters, function (filter) {
	            _this.typeaheadCollectionConfig.addFilter(filter.propertyIdentifier, filter.comparisonValue, filter.comparisonOperator, filter.logicalOperator, filter.hidden);
	        });
	        if (angular.isDefined(this.initialEntityId) && this.initialEntityId.length) {
	            this.modelValue = this.initialEntityId;
	        }
	    }
	    return SWTypeaheadInputFieldController;
	}());
	exports.SWTypeaheadInputFieldController = SWTypeaheadInputFieldController;
	var SWTypeaheadInputField = (function () {
	    // @ngInject
	    function SWTypeaheadInputField(corePartialsPath, hibachiPathBuilder) {
	        this.corePartialsPath = corePartialsPath;
	        this.transclude = true;
	        this.restrict = "EA";
	        this.scope = {};
	        this.bindToController = {
	            fieldName: "@",
	            entityName: "@",
	            typeaheadCollectionConfig: "=?",
	            propertiesToLoad: "@?",
	            placeholderRbKey: "@?",
	            propertyToShow: "@",
	            propertyToSave: "@",
	            initialEntityId: "@",
	            allRecords: "=?",
	            validateRequired: "=?",
	            maxRecords: "@"
	        };
	        this.controller = SWTypeaheadInputFieldController;
	        this.controllerAs = "swTypeaheadInputField";
	        this.templateUrl = hibachiPathBuilder.buildPartialsPath(corePartialsPath) + "typeaheadinputfield.html";
	    }
	    SWTypeaheadInputField.Factory = function () {
	        var directive = function (corePartialsPath, hibachiPathBuilder) { return new SWTypeaheadInputField(corePartialsPath, hibachiPathBuilder); };
	        directive.$inject = ["corePartialsPath", 'hibachiPathBuilder'];
	        return directive;
	    };
	    return SWTypeaheadInputField;
	}());
	exports.SWTypeaheadInputField = SWTypeaheadInputField;


/***/ },
/* 59 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWTypeaheadMultiselectController = (function () {
	    // @ngInject
	    function SWTypeaheadMultiselectController($scope, $transclude, $hibachi, listingService, typeaheadService, utilityService, collectionConfigService) {
	        var _this = this;
	        this.$scope = $scope;
	        this.$transclude = $transclude;
	        this.$hibachi = $hibachi;
	        this.listingService = listingService;
	        this.typeaheadService = typeaheadService;
	        this.utilityService = utilityService;
	        this.collectionConfigService = collectionConfigService;
	        this.addSelection = function (item) {
	            _this.typeaheadService.addSelection(_this.typeaheadDataKey, item);
	            if (_this.inListingDisplay) {
	                _this.listingService.insertListingPageRecord(_this.listingId, item);
	            }
	        };
	        this.removeSelection = function (index) {
	            var itemRemoved = _this.typeaheadService.removeSelection(_this.typeaheadDataKey, index);
	            if (_this.inListingDisplay) {
	                _this.listingService.removeListingPageRecord(_this.listingId, itemRemoved);
	            }
	        };
	        this.getSelections = function () {
	            return _this.typeaheadService.getData(_this.typeaheadDataKey);
	        };
	        this.updateSelectionList = function () {
	            _this.selectionList = _this.typeaheadService.updateSelectionList(_this.typeaheadDataKey);
	        };
	        if (angular.isUndefined(this.typeaheadDataKey)) {
	            this.typeaheadDataKey = this.utilityService.createID(32);
	        }
	        if (angular.isUndefined(this.disabled)) {
	            this.disabled = false;
	        }
	        if (angular.isUndefined(this.showSelections)) {
	            this.showSelections = false;
	        }
	        if (angular.isUndefined(this.multiselectMode)) {
	            this.multiselectMode = true;
	        }
	        if (angular.isUndefined(this.hasAddButtonFunction)) {
	            this.hasAddButtonFunction = false;
	        }
	        if (angular.isUndefined(this.hasViewFunction)) {
	            this.hasViewFunction = false;
	        }
	        if (angular.isDefined(this.selectedCollectionConfig)) {
	            this.typeaheadService.initializeSelections(this.typeaheadDataKey, this.selectedCollectionConfig);
	        }
	        this.typeaheadService.attachTypeaheadSelectionUpdateEvent(this.typeaheadDataKey, this.updateSelectionList);
	    }
	    return SWTypeaheadMultiselectController;
	}());
	exports.SWTypeaheadMultiselectController = SWTypeaheadMultiselectController;
	var SWTypeaheadMultiselect = (function () {
	    // @ngInject
	    function SWTypeaheadMultiselect($compile, scopeService, typeaheadService, corePartialsPath, hibachiPathBuilder) {
	        var _this = this;
	        this.$compile = $compile;
	        this.scopeService = scopeService;
	        this.typeaheadService = typeaheadService;
	        this.corePartialsPath = corePartialsPath;
	        this.transclude = true;
	        this.restrict = "EA";
	        this.scope = {};
	        this.bindToController = {
	            placeholderRbKey: "@",
	            collectionConfig: "=?",
	            selectedCollectionConfig: "=?",
	            typeaheadDataKey: "@?",
	            multiselectModeOn: "=?multiselectMode",
	            showSelections: "=?",
	            dataTarget: "=?",
	            dataTargetIndex: "=?",
	            addButtonFunction: "&?",
	            viewFunction: "&?",
	            inListingDisplay: "=?",
	            listingId: "@?",
	            propertyToCompare: "@?",
	            fallbackPropertiesToCompare: "@?",
	            rightContentPropertyIdentifier: "@?",
	            selectionFieldName: "@?",
	            disabled: "=?"
	        };
	        this.controller = SWTypeaheadMultiselectController;
	        this.controllerAs = "swTypeaheadMultiselect";
	        this.compile = function (element, attrs, transclude) {
	            return {
	                pre: function ($scope, element, attrs) {
	                    //because callbacks are defined even when they're not passed in, this needs to be communicated to the typeahead
	                    if (angular.isDefined(attrs.addButtonFunction)) {
	                        $scope.swTypeaheadMultiselect.hasAddButtonFunction = true;
	                    }
	                    else {
	                        $scope.swTypeaheadMultiselect.hasAddButtonFunction = false;
	                    }
	                    if (angular.isDefined(attrs.viewFunction)) {
	                        $scope.swTypeaheadMultiselect.viewFunction = true;
	                    }
	                    else {
	                        $scope.swTypeaheadMultiselect.viewFunction = false;
	                    }
	                    if (angular.isUndefined($scope.swTypeaheadMultiselect.inListingDisplay)) {
	                        $scope.swTypeaheadMultiselect.inListingDisplay = false;
	                    }
	                    if ($scope.swTypeaheadMultiselect.inListingDisplay && _this.scopeService.hasParentScope($scope, "swListingDisplay")) {
	                        var listingDisplayScope = _this.scopeService.getRootParentScope($scope, "swListingDisplay")["swListingDisplay"];
	                        $scope.swTypeaheadMultiselect.listingId = listingDisplayScope.tableID;
	                        listingDisplayScope.typeaheadDataKey = $scope.swTypeaheadMultiselect.typeaheadDataKey;
	                    }
	                },
	                post: function ($scope, element, attrs) {
	                    var target = element.find(".s-selected-list");
	                    var selectedItemTemplate = angular.element('<div class="alert s-selected-item" ng-repeat="item in swTypeaheadMultiselect.getSelections() track by $index">');
	                    var closeButton = angular.element('<button ng-click="swTypeaheadMultiselect.removeSelection($index)" type="button" class="close"><span>×</span><span class="sr-only" sw-rbkey="&apos;define.close&apos;"></span></button>');
	                    selectedItemTemplate.append(closeButton);
	                    selectedItemTemplate.append(_this.typeaheadService.stripTranscludedContent(transclude($scope, function () { })));
	                    target.append(_this.$compile(selectedItemTemplate)($scope));
	                }
	            };
	        };
	        this.templateUrl = hibachiPathBuilder.buildPartialsPath(corePartialsPath) + "typeaheadmultiselect.html";
	    }
	    SWTypeaheadMultiselect.Factory = function () {
	        var directive = function ($compile, scopeService, typeaheadService, corePartialsPath, hibachiPathBuilder) { return new SWTypeaheadMultiselect($compile, scopeService, typeaheadService, corePartialsPath, hibachiPathBuilder); };
	        directive.$inject = ["$compile", "scopeService", "typeaheadService", "corePartialsPath", 'hibachiPathBuilder'];
	        return directive;
	    };
	    return SWTypeaheadMultiselect;
	}());
	exports.SWTypeaheadMultiselect = SWTypeaheadMultiselect;


/***/ },
/* 60 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	"use strict";
	var SWTypeaheadSearchLineItemController = (function () {
	    function SWTypeaheadSearchLineItemController() {
	    }
	    return SWTypeaheadSearchLineItemController;
	}());
	exports.SWTypeaheadSearchLineItemController = SWTypeaheadSearchLineItemController;
	var SWTypeaheadSearchLineItem = (function () {
	    //@ngInject
	    function SWTypeaheadSearchLineItem($compile) {
	        this.$compile = $compile;
	        this.restrict = 'EA';
	        this.scope = true;
	        this.bindToController = {
	            propertyIdentifier: "@",
	            isSearchable: "@?",
	        };
	        this.controller = SWTypeaheadSearchLineItemController;
	        this.controllerAs = "swTypeaheadSearchLineItem";
	        this.compile = function (element, attrs, transclude) {
	            return {
	                pre: function (scope, element, attrs) {
	                    var innerHTML = '<span ng-bind="item.' + scope.swTypeaheadSearchLineItem.propertyIdentifier + '"></span>';
	                    element.append(innerHTML);
	                },
	                post: function (scope, element, attrs) { }
	            };
	        };
	    }
	    SWTypeaheadSearchLineItem.Factory = function () {
	        var directive = function ($compile) { return new SWTypeaheadSearchLineItem($compile); };
	        directive.$inject = [
	            '$compile'
	        ];
	        return directive;
	    };
	    return SWTypeaheadSearchLineItem;
	}());
	exports.SWTypeaheadSearchLineItem = SWTypeaheadSearchLineItem;


/***/ },
/* 61 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWTypeaheadRemoveSelectionController = (function () {
	    function SWTypeaheadRemoveSelectionController($scope, listingService, scopeService, typeaheadService, utilityService) {
	        var _this = this;
	        this.$scope = $scope;
	        this.listingService = listingService;
	        this.scopeService = scopeService;
	        this.typeaheadService = typeaheadService;
	        this.utilityService = utilityService;
	        this.updatePageRecord = function () {
	            if (_this.scopeService.hasParentScope(_this.$scope, "pageRecord")) {
	                var pageRecordScope = _this.scopeService.getRootParentScope(_this.$scope, "pageRecord")["pageRecord"];
	                _this.pageRecord = pageRecordScope;
	            }
	        };
	        this.removeSelection = function () {
	            if (!_this.disabled) {
	                _this.typeaheadService.removeSelection(_this.typeaheadDataKey, undefined, _this.pageRecord);
	                _this.listingService.removeListingPageRecord(_this.listingId, _this.pageRecord);
	            }
	        };
	        this.listingService.attachToListingPageRecordsUpdate(this.listingId, this.updatePageRecord, this.utilityService.createID(32));
	        if (angular.isUndefined(this.disabled)) {
	            this.disabled = false;
	        }
	    }
	    return SWTypeaheadRemoveSelectionController;
	}());
	exports.SWTypeaheadRemoveSelectionController = SWTypeaheadRemoveSelectionController;
	var SWTypeaheadRemoveSelection = (function () {
	    // @ngInject
	    function SWTypeaheadRemoveSelection(scopeService, corePartialsPath, hibachiPathBuilder) {
	        var _this = this;
	        this.scopeService = scopeService;
	        this.corePartialsPath = corePartialsPath;
	        this.transclude = true;
	        this.restrict = "EA";
	        this.scope = {};
	        this.bindToController = {
	            typeaheadDataKey: "@?",
	            index: "@?",
	            disabled: "=?"
	        };
	        this.controller = SWTypeaheadRemoveSelectionController;
	        this.controllerAs = "swTypeaheadRemoveSelection";
	        this.link = function (scope, element, attrs) {
	            if (_this.scopeService.hasParentScope(scope, "swListingDisplay")) {
	                var listingDisplayScope = _this.scopeService.getRootParentScope(scope, "swListingDisplay")["swListingDisplay"];
	                scope.swTypeaheadRemoveSelection.typeaheadDataKey = listingDisplayScope.typeaheadDataKey;
	                scope.swTypeaheadRemoveSelection.listingId = listingDisplayScope.tableID;
	            }
	            if (_this.scopeService.hasParentScope(scope, "pageRecord")) {
	                var pageRecordScope = _this.scopeService.getRootParentScope(scope, "pageRecord")["pageRecord"];
	                scope.swTypeaheadRemoveSelection.pageRecord = pageRecordScope;
	            }
	        };
	        this.templateUrl = hibachiPathBuilder.buildPartialsPath(corePartialsPath) + "typeaheadremoveselection.html";
	    }
	    SWTypeaheadRemoveSelection.Factory = function () {
	        var directive = function (scopeService, corePartialsPath, hibachiPathBuilder) { return new SWTypeaheadRemoveSelection(scopeService, corePartialsPath, hibachiPathBuilder); };
	        directive.$inject = ["scopeService", "corePartialsPath", 'hibachiPathBuilder'];
	        return directive;
	    };
	    return SWTypeaheadRemoveSelection;
	}());
	exports.SWTypeaheadRemoveSelection = SWTypeaheadRemoveSelection;


/***/ },
/* 62 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	"use strict";
	var SWCollectionConfigController = (function () {
	    //@ngInject
	    function SWCollectionConfigController($transclude, $q, collectionConfigService) {
	        this.$transclude = $transclude;
	        this.$q = $q;
	        this.collectionConfigService = collectionConfigService;
	        this.filters = [];
	        this.columns = [];
	        this.orderBys = [];
	        this.keywordColumns = [];
	        this.columnsDeferred = this.$q.defer();
	        this.columnsPromise = this.columnsDeferred.promise;
	        this.filtersDeferred = this.$q.defer();
	        this.filtersPromise = this.filtersDeferred.promise;
	        this.orderBysDeferred = this.$q.defer();
	        this.orderBysPromise = this.columnsDeferred.promise;
	    }
	    return SWCollectionConfigController;
	}());
	exports.SWCollectionConfigController = SWCollectionConfigController;
	var SWCollectionConfig = (function () {
	    // @ngInject
	    function SWCollectionConfig(collectionConfigService, listingService, scopeService, $q) {
	        var _this = this;
	        this.collectionConfigService = collectionConfigService;
	        this.listingService = listingService;
	        this.scopeService = scopeService;
	        this.$q = $q;
	        this.restrict = 'EA';
	        this.scope = true;
	        this.transclude = {
	            columns: "?swCollectionColumns",
	            filters: "?swCollectionFilters",
	            orderBys: "?swCollectionOrderBys"
	        };
	        this.bindToController = {
	            allRecords: "=?",
	            collectionConfigProperty: "@?",
	            distinct: "=?",
	            entityName: "@",
	            filterFlag: "=?",
	            inListingDisplay: "=?",
	            multiCollectionConfigProperty: "@?",
	            pageShow: "@?",
	            parentDirectiveControllerAsName: "@?",
	            parentDeferredProperty: "@?"
	        };
	        this.controller = SWCollectionConfigController;
	        this.controllerAs = "swCollectionConfig";
	        this.template = " \n        <div ng-transclude=\"columns\"></div>\n        <div ng-transclude=\"filters\"></div>\n        <div ng-transclude=\"orderBys\"></div>\n    ";
	        this.link = function (scope, element, attrs) {
	            //some automatic configuration for listing display
	            if (angular.isUndefined(scope.swCollectionConfig.inListingDisplay)) {
	                scope.swCollectionConfig.inListingDisplay = false;
	            }
	            if (scope.swCollectionConfig.inListingDisplay) {
	                scope.swCollectionConfig.parentDirectiveControllerAsName = "swListingDisplay";
	                scope.swCollectionConfig.parentDeferredProperty = "singleCollectionDeferred";
	            }
	            if (angular.isUndefined(scope.swCollectionConfig.entityName)) {
	                throw ("You must provide an entityname to swCollectionConfig");
	            }
	            if (angular.isUndefined(scope.swCollectionConfig.parentDirectiveControllerAsName) && !scope.swCollectionConfig.inListingDisplay) {
	                throw ("You must provide the parent directives Controller-As Name to swCollectionConfig");
	            }
	            if (angular.isUndefined(scope.swCollectionConfig.collectionConfigProperty)) {
	                scope.swCollectionConfig.collectionConfigProperty = "collectionConfig";
	            }
	            if (angular.isUndefined(scope.swCollectionConfig.allRecords)) {
	                scope.swCollectionConfig.allRecords = false;
	            }
	            if (angular.isUndefined(scope.swCollectionConfig.pageShow)) {
	                scope.swCollectionConfig.pageShow = 10;
	            }
	            if (angular.isUndefined(scope.swCollectionConfig.distinct)) {
	                scope.swCollectionConfig.distinct = false;
	            }
	            if (angular.isUndefined(scope.swCollectionConfig.filterFlag)) {
	                scope.swCollectionConfig.filterFlag = true; //assume there are filters
	            }
	            var allCollectionConfigPromises = [];
	            var currentScope = scope;
	            //we want to wait for all sibling scopes before pushing the collection config
	            while (angular.isDefined(currentScope)) {
	                if (angular.isDefined(currentScope.swCollectionConfig)) {
	                    allCollectionConfigPromises.push(currentScope.swCollectionConfig.columnsPromise);
	                    if (scope.swCollectionConfig.filterFlag) {
	                        allCollectionConfigPromises.push(currentScope.swCollectionConfig.filtersPromise);
	                    }
	                }
	                currentScope = currentScope.$$nextSibling;
	                if (currentScope == null) {
	                    break;
	                }
	            }
	            var newCollectionConfig = _this.collectionConfigService.newCollectionConfig(scope.swCollectionConfig.entityName);
	            newCollectionConfig.setAllRecords(scope.swCollectionConfig.allRecords);
	            newCollectionConfig.setDistinct(scope.swCollectionConfig.distinct);
	            newCollectionConfig.setPageShow(scope.swCollectionConfig.pageShow);
	            var currentScope = _this.scopeService.getRootParentScope(scope, scope.swCollectionConfig.parentDirectiveControllerAsName);
	            if (currentScope[scope.swCollectionConfig.parentDirectiveControllerAsName]) {
	                var parentDirective = currentScope[scope.swCollectionConfig.parentDirectiveControllerAsName];
	            }
	            else {
	                throw ("swCollectionConfig was unable to find a parent scope");
	            }
	            scope.swCollectionConfig.columnsPromise.then(function () {
	                angular.forEach(scope.swCollectionConfig.columns, function (column) {
	                    newCollectionConfig.addDisplayProperty(column.propertyIdentifier, '', column);
	                });
	            });
	            scope.swCollectionConfig.filtersPromise.then(function () {
	                angular.forEach(scope.swCollectionConfig.filters, function (filter) {
	                    newCollectionConfig.addFilter(filter.propertyIdentifier, filter.comparisonValue, filter.comparisonOperator, filter.logicalOperator, filter.hidden);
	                });
	            });
	            scope.swCollectionConfig.orderBysPromise.then(function () {
	                angular.forEach(scope.swCollectionConfig.orderBys, function (orderBy) {
	                    newCollectionConfig.addOrderBy(orderBy);
	                });
	            });
	            _this.$q.all(allCollectionConfigPromises).then(function () {
	                if (angular.isDefined(parentDirective)) {
	                    if (angular.isDefined(scope.swCollectionConfig.multiCollectionConfigProperty)
	                        && angular.isDefined(parentDirective[scope.swCollectionConfig.multiCollectionConfigProperty])) {
	                        parentDirective[scope.swCollectionConfig.multiCollectionConfigProperty].push(newCollectionConfig);
	                    }
	                    else if (angular.isDefined(parentDirective[scope.swCollectionConfig.collectionConfigProperty])) {
	                        parentDirective[scope.swCollectionConfig.collectionConfigProperty] = newCollectionConfig;
	                    }
	                    else {
	                        throw ("swCollectionConfig could not locate a collection config property to bind it's collection to");
	                    }
	                    if (angular.isDefined(parentDirective[scope.swCollectionConfig.parentDeferredProperty])) {
	                        parentDirective[scope.swCollectionConfig.parentDeferredProperty].resolve();
	                    }
	                    else {
	                    }
	                }
	            }, function (reason) {
	                throw ("SWCollectionConfig is having some issues.");
	            });
	        };
	    }
	    SWCollectionConfig.Factory = function () {
	        var directive = function (collectionConfigService, listingService, scopeService, $q) { return new SWCollectionConfig(collectionConfigService, listingService, scopeService, $q); };
	        directive.$inject = [
	            'collectionConfigService',
	            'listingService',
	            'scopeService',
	            '$q'
	        ];
	        return directive;
	    };
	    return SWCollectionConfig;
	}());
	exports.SWCollectionConfig = SWCollectionConfig;


/***/ },
/* 63 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	"use strict";
	var SWCollectionFilterController = (function () {
	    function SWCollectionFilterController() {
	    }
	    return SWCollectionFilterController;
	}());
	exports.SWCollectionFilterController = SWCollectionFilterController;
	var SWCollectionFilter = (function () {
	    //@ngInject
	    function SWCollectionFilter(scopeService, utilityService) {
	        var _this = this;
	        this.scopeService = scopeService;
	        this.utilityService = utilityService;
	        this.restrict = 'EA';
	        this.scope = true;
	        this.bindToController = {
	            propertyIdentifier: "@",
	            comparisonOperator: "@?",
	            comparisonValue: "@?",
	            logicalOperator: "@?",
	            hidden: "@?"
	        };
	        this.controller = SWCollectionFilterController;
	        this.controllerAs = "SWCollectionFilter";
	        this.template = "";
	        this.link = function (scope, element, attrs) {
	            var filter = {
	                propertyIdentifier: scope.SWCollectionFilter.propertyIdentifier,
	                comparisonOperator: scope.SWCollectionFilter.comparisonOperator,
	                comparisonValue: scope.SWCollectionFilter.comparisonValue,
	                logicalOperator: scope.SWCollectionFilter.logicalOperator,
	                hidden: scope.SWCollectionFilter.hidden
	            };
	            var currentScope = _this.scopeService.getRootParentScope(scope, "swCollectionConfig");
	            if (angular.isDefined(currentScope.swCollectionConfig)) {
	                currentScope.swCollectionConfig.filters.push(filter);
	                currentScope.swCollectionConfig.filtersDeferred.resolve();
	            }
	            else {
	                throw ("could not find swCollectionConfig in the parent scope from swcollectionfilter");
	            }
	        };
	    }
	    SWCollectionFilter.Factory = function () {
	        var directive = function (scopeService, utilityService) { return new SWCollectionFilter(scopeService, utilityService); };
	        directive.$inject = [
	            'scopeService',
	            'utilityService'
	        ];
	        return directive;
	    };
	    return SWCollectionFilter;
	}());
	exports.SWCollectionFilter = SWCollectionFilter;


/***/ },
/* 64 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	"use strict";
	var SWCollectionOrderByController = (function () {
	    function SWCollectionOrderByController() {
	    }
	    return SWCollectionOrderByController;
	}());
	exports.SWCollectionOrderByController = SWCollectionOrderByController;
	var SWCollectionOrderBy = (function () {
	    //@ngInject
	    function SWCollectionOrderBy(scopeService) {
	        var _this = this;
	        this.scopeService = scopeService;
	        this.restrict = 'EA';
	        this.scope = true;
	        this.bindToController = {
	            orderBy: "@"
	        };
	        this.controller = SWCollectionOrderByController;
	        this.controllerAs = "SWCollectionOrderBy";
	        this.template = "";
	        this.link = function (scope, element, attrs) {
	            var orderBy = scope.SWCollectionOrderBy.orderBy;
	            var currentScope = _this.scopeService.getRootParentScope(scope, "swCollectionConfig");
	            if (angular.isDefined(currentScope.swCollectionConfig)) {
	                currentScope.swCollectionConfig.orderBys.push(orderBy);
	                currentScope.swCollectionConfig.orderBysDeferred.resolve();
	            }
	            else {
	                throw ("could not find swCollectionConfig in the parent scope from swcollectionorderby");
	            }
	        };
	    }
	    SWCollectionOrderBy.Factory = function () {
	        var directive = function (scopeService) { return new SWCollectionOrderBy(scopeService); };
	        directive.$inject = [
	            'scopeService'
	        ];
	        return directive;
	    };
	    return SWCollectionOrderBy;
	}());
	exports.SWCollectionOrderBy = SWCollectionOrderBy;


/***/ },
/* 65 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	"use strict";
	var SWCollectionColumnController = (function () {
	    function SWCollectionColumnController() {
	    }
	    return SWCollectionColumnController;
	}());
	exports.SWCollectionColumnController = SWCollectionColumnController;
	var SWCollectionColumn = (function () {
	    //@ngInject
	    function SWCollectionColumn(scopeService, utilityService) {
	        var _this = this;
	        this.scopeService = scopeService;
	        this.utilityService = utilityService;
	        this.restrict = 'EA';
	        this.scope = true;
	        this.bindToController = {
	            propertyIdentifier: "@",
	            fallbackPropertyIdentifiers: "@?",
	            isVisible: "=?",
	            isSearchable: "=?",
	            isDeletable: "=?",
	            isExportable: "=?",
	            isKeywordColumn: "=?",
	            isOnlyKeywordColumn: "=?",
	            tdclass: "@?",
	            hidden: "=?"
	        };
	        this.controller = SWCollectionColumn;
	        this.controllerAs = "swCollectionColumn";
	        this.template = "";
	        this.link = function (scope, element, attrs) {
	            if (angular.isUndefined(scope.swCollectionColumn.isKeywordColumn)) {
	                scope.swCollectionColumn.isKeywordColumn = false;
	            }
	            if (angular.isUndefined(scope.swCollectionColumn.isOnlyKeywordColumn)) {
	                scope.swCollectionColumn.isOnlyKeywordColumn = scope.swCollectionColumn.isKeywordColumn;
	            }
	            if (angular.isUndefined(scope.swCollectionColumn.isVisible)) {
	                scope.swCollectionColumn.isVisible = true;
	            }
	            if (angular.isUndefined(scope.swCollectionColumn.isSearchable)) {
	                scope.swCollectionColumn.isSearchable = false;
	            }
	            if (angular.isUndefined(scope.swCollectionColumn.isDeletable)) {
	                scope.swCollectionColumn.isDeletable = false;
	            }
	            if (angular.isUndefined(scope.swCollectionColumn.isExportable)) {
	                scope.swCollectionColumn.isExportable = true;
	            }
	            var column = {
	                propertyIdentifier: scope.swCollectionColumn.propertyIdentifier,
	                fallbackPropertyIdentifiers: scope.swCollectionColumn.fallbackPropertyIdentifiers,
	                isVisible: scope.swCollectionColumn.isVisible,
	                isSearchable: scope.swCollectionColumn.isSearchable,
	                isDeletable: scope.swCollectionColumn.isDeletable,
	                isExportable: scope.swCollectionColumn.isExportable,
	                hidden: scope.swCollectionColumn.hidden,
	                tdclass: scope.swCollectionColumn.tdclass,
	                isKeywordColumn: scope.swCollectionColumn.isKeywordColumn,
	                isOnlyKeywordColumn: scope.swCollectionColumn.isOnlyKeywordColumn
	            };
	            console.log("column", column);
	            var currentScope = _this.scopeService.getRootParentScope(scope, "swCollectionConfig");
	            if (angular.isDefined(currentScope.swCollectionConfig)) {
	                //push directly here because we've already built the column object
	                currentScope.swCollectionConfig.columns.push(column);
	                currentScope.swCollectionConfig.columnsDeferred.resolve();
	            }
	            else {
	                throw ("Could not find swCollectionConfig in the parent scope from swcollectioncolumn");
	            }
	        };
	    }
	    SWCollectionColumn.Factory = function () {
	        var directive = function (scopeService, utilityService) { return new SWCollectionColumn(scopeService, utilityService); };
	        directive.$inject = [
	            'scopeService',
	            'utilityService'
	        ];
	        return directive;
	    };
	    return SWCollectionColumn;
	}());
	exports.SWCollectionColumn = SWCollectionColumn;


/***/ },
/* 66 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWActionCallerDropdownController = (function () {
	    function SWActionCallerDropdownController() {
	        this.title = this.title || '';
	        this.icon = this.icon || 'plus';
	        this.type = this.type || 'button';
	        this.dropdownClass = this.dropdownClass || '';
	        this.dropdownId = this.dropdownId || '';
	        this.buttonClass = this.buttonClass || 'btn-primary';
	    }
	    return SWActionCallerDropdownController;
	}());
	exports.SWActionCallerDropdownController = SWActionCallerDropdownController;
	var SWActionCallerDropdown = (function () {
	    function SWActionCallerDropdown(corePartialsPath, hibachiPathBuilder) {
	        this.corePartialsPath = corePartialsPath;
	        this.restrict = 'E';
	        this.scope = {};
	        this.transclude = true;
	        this.bindToController = {
	            title: "@",
	            icon: "@",
	            type: "=",
	            dropdownClass: "@",
	            dropdownId: "@",
	            buttonClass: "@"
	        };
	        this.controller = SWActionCallerDropdownController;
	        this.controllerAs = "swActionCallerDropdown";
	        this.link = function (scope, element, attrs) {
	        };
	        this.templateUrl = hibachiPathBuilder.buildPartialsPath(corePartialsPath) + 'actioncallerdropdown.html';
	    }
	    SWActionCallerDropdown.Factory = function () {
	        var directive = function (corePartialsPath, hibachiPathBuilder) { return new SWActionCallerDropdown(corePartialsPath, hibachiPathBuilder); };
	        directive.$inject = ['corePartialsPath', 'hibachiPathBuilder'];
	        return directive;
	    };
	    return SWActionCallerDropdown;
	}());
	exports.SWActionCallerDropdown = SWActionCallerDropdown;


/***/ },
/* 67 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWColumnSorter = (function () {
	    //@ngInject
	    function SWColumnSorter($log, observerService, corePartialsPath, hibachiPathBuilder) {
	        return {
	            restrict: 'AE',
	            scope: {
	                column: "=",
	            },
	            templateUrl: hibachiPathBuilder.buildPartialsPath(corePartialsPath) + "columnsorter.html",
	            link: function (scope, element, attrs) {
	                var orderBy = {
	                    "propertyIdentifier": scope.column.propertyIdentifier,
	                };
	                scope.sortAsc = function () {
	                    orderBy.direction = 'Asc';
	                    this.observerService.notify('sortByColumn', orderBy);
	                };
	                scope.sortDesc = function () {
	                    orderBy.direction = 'Desc';
	                    observerService.notify('sortByColumn', orderBy);
	                };
	            }
	        };
	    }
	    SWColumnSorter.Factory = function () {
	        var directive = function ($log, observerService, corePartialsPath, hibachiPathBuilder) { return new SWColumnSorter($log, observerService, corePartialsPath, hibachiPathBuilder); };
	        directive.$inject = [
	            '$log',
	            'observerService',
	            'corePartialsPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWColumnSorter;
	}());
	exports.SWColumnSorter = SWColumnSorter;


/***/ },
/* 68 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	/**
	 * <------------------------------------------------------------------------------------------------------------------------------------>
	 *   This directive can be used to prompt the user with a confirmation dialog.
	 *
	 *   Example Usage 1:
	 *   <a swconfirm
	 *   						use-rb-key=true
	 * 							yes-text="define.yes"
	 * 							no-text="define.no"
	 * 							confirm-text="define.confirm"
	 * 							message-text="define.delete.message"
	 * 							callback="someFunction()">
	 *   </a>
	 *   Alternate Version (No Rbkeys):
	 *   <a swconfirm
	 *   						use-rb-key=false
	 * 							yes-text="Sure"
	 * 							no-text="Not Sure!"
	 * 							confirm-text="Sure"
	 * 							message-text="Are you sure?"
	 * 							callback="sure()">
	 *   </a>
	 *
	 *   Note: Because the template is dynamic, the following keywords can not be used anywhere in the text for this modal.
	 *
	 *   [yes] [no] [confirm] [message] [callback]
	 *
	 *   The above words in upper-case can be used - just not those words inside square brackets.
	 *   Note: Your callback function on-confirm should return true;
	 *<------------------------------------------------------------------------------------------------------------------------------------->
	 */
	"use strict";
	var SWConfirm = (function () {
	    //@ngInject
	    function SWConfirm($hibachi, $log, $compile, $modal, partialsPath) {
	        var buildConfirmationModal = function (simple, useRbKey, confirmText, messageText, noText, yesText) {
	            /* Keys */
	            var confirmKey = "[confirm]";
	            var messageKey = "[message]";
	            var noKey = "[no]";
	            var yesKey = "[yes]";
	            var swRbKey = "sw-rbkey=";
	            /* Values */
	            var confirmVal = "<confirm>";
	            var messageVal = "<message>";
	            var noVal = "<no>";
	            var yesVal = "<yes>";
	            /* Parse Tags */
	            var startTag = "\"'";
	            var endTag = "'\"";
	            var startParen = "'";
	            var endParen = "'";
	            var empty = "";
	            /* Modal String */
	            var parsedKeyString = "";
	            var finishedString = "";
	            //Figure out which version of this tag we are using
	            var templateString = "<div>" +
	                "<div class='modal-header'><a class='close' data-dismiss='modal' ng-click='cancel()'>×</a><h3 [confirm]><confirm></h3></div>" +
	                "<div class='modal-body' [message]>" + "<message>" + "</div>" +
	                "<div class='modal-footer'>" +
	                "<button class='btn btn-sm btn-default btn-inverse' ng-click='cancel()' [no]><no></button>" +
	                "<button class='btn btn-sm btn-default btn-primary' ng-click='fireCallback(callback)' [yes]><yes></button></div></div></div>";
	            /* Use RbKeys or Not? */
	            if (useRbKey === "true") {
	                $log.debug("Using RbKey? " + useRbKey);
	                /* Then decorate the template with the keys. */
	                confirmText = swRbKey + startTag + confirmText + endTag;
	                messageText = swRbKey + startTag + messageText + endTag;
	                yesText = swRbKey + startTag + yesText + endTag;
	                noText = swRbKey + startTag + noText + endTag;
	                parsedKeyString = templateString.replace(confirmKey, confirmText)
	                    .replace(messageText, messageText)
	                    .replace(noKey, noText)
	                    .replace(yesKey, yesText);
	                $log.debug(finishedString);
	                finishedString = parsedKeyString.replace(confirmKey, empty)
	                    .replace(messageVal, empty)
	                    .replace(noVal, empty)
	                    .replace(yesVal, empty);
	                $log.debug(finishedString);
	                return finishedString;
	            }
	            else {
	                /* Then decorate the template without the keys. */
	                $log.debug("Using RbKey? " + useRbKey);
	                parsedKeyString = templateString.replace(confirmVal, confirmText)
	                    .replace(messageVal, messageText)
	                    .replace(noVal, noText)
	                    .replace(yesVal, yesText);
	                finishedString = parsedKeyString.replace(confirmKey, empty)
	                    .replace(messageKey, empty)
	                    .replace(noKey, empty)
	                    .replace(yesKey, empty);
	                $log.debug(finishedString);
	                return finishedString;
	            }
	        };
	        return {
	            restrict: 'EA',
	            scope: {
	                callback: "&",
	                entity: "="
	            },
	            link: function (scope, element, attr) {
	                /* Grab the template and build the modal on click */
	                $log.debug("Modal is: ");
	                $log.debug($modal);
	                element.bind('click', function () {
	                    /* Default Values */
	                    var useRbKey = attr.useRbKey || "false";
	                    var simple = attr.simple || false;
	                    var yesText = attr.yesText || "define.yes";
	                    var noText = attr.noText || "define.no";
	                    var confirmText = attr.confirmText || "define.delete";
	                    var messageText = attr.messageText || "define.delete_message";
	                    var templateString = buildConfirmationModal(simple, useRbKey, confirmText, messageText, noText, yesText);
	                    var modalInstance = $modal.open({
	                        template: templateString,
	                        controller: 'confirmationController',
	                        scope: scope
	                    });
	                    /**
	                        * Handles the result - callback or dismissed
	                        */
	                    modalInstance.result.then(function (result) {
	                        $log.debug("Result:" + result);
	                        return true;
	                    }, function () {
	                        //There was an error
	                    });
	                }); //<--end bind
	            }
	        };
	    }
	    SWConfirm.Factory = function () {
	        var directive = function ($hibachi, $log, $compile, $modal, partialsPath) { return new SWConfirm($hibachi, $log, $compile, $modal, partialsPath); };
	        directive.$inject = ['$hibachi', '$log', '$compile', '$modal', 'partialsPath'];
	        return directive;
	    };
	    return SWConfirm;
	}());
	exports.SWConfirm = SWConfirm;


/***/ },
/* 69 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWDraggableController = (function () {
	    //@ngInject
	    function SWDraggableController() {
	        if (angular.isUndefined(this.draggable)) {
	            this.draggable = false;
	        }
	    }
	    return SWDraggableController;
	}());
	var SWDraggable = (function () {
	    //@ngInject
	    function SWDraggable(corePartialsPath, utilityService, draggableService, hibachiPathBuilder) {
	        var _this = this;
	        this.corePartialsPath = corePartialsPath;
	        this.utilityService = utilityService;
	        this.draggableService = draggableService;
	        this.hibachiPathBuilder = hibachiPathBuilder;
	        this.restrict = 'EA';
	        this.scope = {};
	        this.bindToController = {
	            //all fields required
	            draggable: "=",
	            draggableRecord: "=",
	            draggableKey: "="
	        };
	        this.controller = SWDraggableController;
	        this.controllerAs = "swDraggable";
	        this.link = function (scope, element, attrs) {
	            angular.element(element).attr("draggable", "true");
	            var id = angular.element(element).attr("id");
	            if (!id) {
	                id = _this.utilityService.createID(32);
	            }
	            element.bind("dragstart", function (e) {
	                e = e.originalEvent || e;
	                e.stopPropagation();
	                if (!scope.swDraggable.draggable)
	                    return false;
	                element.addClass("s-dragging");
	                scope.swDraggable.draggableRecord.draggableStartKey = scope.swDraggable.draggableKey;
	                e.dataTransfer.setData("application/json", angular.toJson(scope.swDraggable.draggableRecord));
	                e.dataTransfer.effectAllowed = "move";
	                e.dataTransfer.setDragImage(element[0], 0, 0);
	            });
	            element.bind("dragend", function (e) {
	                e = e.originalEvent || e;
	                e.stopPropagation();
	                element.removeClass("s-dragging");
	            });
	            /*element.on('dragenter', function (e) {
	                e = e.originalEvent || e;
	                e.stopPropagation();
	            });
	    
	            element.on('dragover', function(e) {
	                e = e.originalEvent || e;
	                e.stopPropagation();
	            });
	    
	            element.on('drop', function(e) {
	                e = e.originalEvent || e;
	                e.stopPropagation();
	            });
	    
	            element.on('dragleave', function(e) {
	                e = e.originalEvent || e;
	                e.stopPropagation();
	            });*/
	        };
	    }
	    SWDraggable.Factory = function () {
	        var directive = function (corePartialsPath, utilityService, draggableService, hibachiPathBuilder) { return new SWDraggable(corePartialsPath, utilityService, draggableService, hibachiPathBuilder); };
	        directive.$inject = [
	            'corePartialsPath',
	            'utilityService',
	            'draggableService',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWDraggable;
	}());
	exports.SWDraggable = SWDraggable;


/***/ },
/* 70 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWDraggableContainerController = (function () {
	    //@ngInject
	    function SWDraggableContainerController(draggableService) {
	        this.draggableService = draggableService;
	        if (angular.isUndefined(this.draggable)) {
	            this.draggable = false;
	        }
	    }
	    return SWDraggableContainerController;
	}());
	var SWDraggableContainer = (function () {
	    //@ngInject
	    function SWDraggableContainer($timeout, corePartialsPath, utilityService, listingService, observerService, draggableService, hibachiPathBuilder) {
	        var _this = this;
	        this.$timeout = $timeout;
	        this.corePartialsPath = corePartialsPath;
	        this.utilityService = utilityService;
	        this.listingService = listingService;
	        this.observerService = observerService;
	        this.draggableService = draggableService;
	        this.hibachiPathBuilder = hibachiPathBuilder;
	        this.restrict = 'EA';
	        this.scope = {};
	        this.bindToController = {
	            draggable: "=?",
	            draggableRecords: "=?",
	            dropEventName: "@?",
	            listingId: "@?"
	        };
	        this.controller = SWDraggableContainerController;
	        this.controllerAs = "swDraggableContainer";
	        this.link = function (scope, element, attrs) {
	            angular.element(element).attr("draggable", "true");
	            var placeholderElement = angular.element("<tr class='s-placeholder'><td>placeholder</td><td>placeholder</td><td>placeholder</td><td>placeholder</td><td>placeholder</td><td></td></tr>"); //temporarirly hardcoding tds so it will show up
	            var id = angular.element(element).attr("id");
	            if (!id) {
	                id = _this.utilityService.createID(32);
	            }
	            var listNode = element[0];
	            var placeholderNode = placeholderElement[0];
	            placeholderElement.remove();
	            element.on('drop', function (e) {
	                e = e.originalEvent || e;
	                e.preventDefault();
	                if (!_this.draggableService.isDropAllowed(e))
	                    return true;
	                var record = e.dataTransfer.getData("application/json") || e.dataTransfer.getData("text/plain");
	                var parsedRecord = JSON.parse(record);
	                var index = Array.prototype.indexOf.call(listNode.children, placeholderNode);
	                if (index < parsedRecord.draggableStartKey) {
	                    parsedRecord.draggableStartKey++;
	                }
	                _this.$timeout(function () {
	                    scope.swDraggableContainer.draggableRecords.splice(index, 0, parsedRecord);
	                    scope.swDraggableContainer.draggableRecords.splice(parsedRecord.draggableStartKey, 1);
	                }, 0);
	                if (angular.isDefined(scope.swDraggableContainer.listingId)) {
	                    _this.listingService.notifyListingPageRecordsUpdate(scope.swDraggableContainer.listingId);
	                }
	                else if (angular.isDefined(scope.swDraggableContainer.dropEventName)) {
	                    _this.observerService.notify(scope.swDraggableContainer.dropEventName);
	                }
	                placeholderElement.remove();
	                e.stopPropagation();
	                return false;
	            });
	            element.on('dragenter', function (e) {
	                e = e.originalEvent || e;
	                if (!_this.draggableService.isDropAllowed(e))
	                    return true;
	                e.preventDefault();
	            });
	            element.on('dragleave', function (e) {
	                e = e.originalEvent || e;
	                if (e.pageX != 0 || e.pageY != 0) {
	                    return false;
	                }
	                return false;
	            });
	            element.on('dragover', function (e) {
	                e = e.originalEvent || e;
	                e.stopPropagation();
	                if (placeholderNode.parentNode != listNode) {
	                    element.append(placeholderElement);
	                }
	                if (e.target !== listNode) {
	                    var listItemNode = e.target;
	                    while (listItemNode.parentNode !== listNode && listItemNode.parentNode) {
	                        listItemNode = listItemNode.parentNode;
	                    }
	                    if (listItemNode.parentNode === listNode && listItemNode !== placeholderNode) {
	                        if (_this.draggableService.isMouseInFirstHalf(e, listItemNode)) {
	                            listNode.insertBefore(placeholderNode, listItemNode);
	                        }
	                        else {
	                            listNode.insertBefore(placeholderNode, listItemNode.nextSibling);
	                        }
	                    }
	                }
	                element.addClass("s-dragged-over");
	                return false;
	            });
	        };
	    }
	    SWDraggableContainer.Factory = function () {
	        var directive = function ($timeout, corePartialsPath, utilityService, listingService, observerService, draggableService, hibachiPathBuilder) { return new SWDraggableContainer($timeout, corePartialsPath, utilityService, listingService, observerService, draggableService, hibachiPathBuilder); };
	        directive.$inject = [
	            '$timeout',
	            'corePartialsPath',
	            'utilityService',
	            'listingService',
	            'observerService',
	            'draggableService',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWDraggableContainer;
	}());
	exports.SWDraggableContainer = SWDraggableContainer;


/***/ },
/* 71 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWEntityActionBarController = (function () {
	    //@ngInject
	    function SWEntityActionBarController(rbkeyService) {
	        var _this = this;
	        this.rbkeyService = rbkeyService;
	        this.init = function () {
	            if (angular.isDefined(_this.pageTitleRbKey)) {
	                _this.pageTitle = _this.rbkeyService.getRBKey(_this.pageTitleRbKey);
	            }
	        };
	        this.init();
	    }
	    return SWEntityActionBarController;
	}());
	var SWEntityActionBar = (function () {
	    //@ngInject
	    function SWEntityActionBar(corePartialsPath, hibachiPathBuilder) {
	        this.corePartialsPath = corePartialsPath;
	        this.restrict = 'E';
	        this.scope = {};
	        this.transclude = true;
	        this.bindToController = {
	            /*Core settings*/
	            type: "@",
	            object: "=",
	            pageTitle: "@?",
	            pageTitleRbKey: "@?",
	            edit: "=",
	            /*Action Callers (top buttons)*/
	            showcancel: "=",
	            showcreate: "=",
	            showedit: "=",
	            showdelete: "=",
	            /*Basic Action Caller Overrides*/
	            createModal: "=",
	            createAction: "=",
	            createQueryString: "=",
	            backAction: "=",
	            backQueryString: "=",
	            cancelAction: "=",
	            cancelQueryString: "=",
	            deleteAction: "=",
	            deleteQueryString: "=",
	            /*Process Specific Values*/
	            processAction: "=",
	            processContext: "="
	        };
	        this.controller = SWEntityActionBarController;
	        this.controllerAs = "swEntityActionBar";
	        this.link = function (scope, element, attrs) {
	        };
	        this.templateUrl = hibachiPathBuilder.buildPartialsPath(corePartialsPath) + 'entityactionbar.html';
	    }
	    SWEntityActionBar.Factory = function () {
	        var directive = function (corePartialsPath, hibachiPathBuilder) { return new SWEntityActionBar(corePartialsPath, hibachiPathBuilder); };
	        directive.$inject = ['corePartialsPath', 'hibachiPathBuilder'];
	        return directive;
	    };
	    return SWEntityActionBar;
	}());
	exports.SWEntityActionBar = SWEntityActionBar;
	//	angular.module('slatwalladmin').directive('swEntityActionBar',['corePartialsPath',(corePartialsPath) => new SWEntityActionBar(corePartialsPath)]);


/***/ },
/* 72 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWEntityActionBarButtonGroupController = (function () {
	    function SWEntityActionBarButtonGroupController() {
	    }
	    return SWEntityActionBarButtonGroupController;
	}());
	var SWEntityActionBarButtonGroup = (function () {
	    //@ngInject
	    function SWEntityActionBarButtonGroup(corePartialsPath, hibachiPathBuilder) {
	        this.corePartialsPath = corePartialsPath;
	        this.restrict = 'E';
	        this.scope = {};
	        this.transclude = true;
	        this.bindToController = {};
	        this.controller = SWEntityActionBarButtonGroupController;
	        this.controllerAs = "swEntityActionBarButtonGroup";
	        this.link = function (scope, element, attrs) {
	        };
	        this.templateUrl = hibachiPathBuilder.buildPartialsPath(corePartialsPath) + 'entityactionbarbuttongroup.html';
	    }
	    SWEntityActionBarButtonGroup.Factory = function () {
	        var directive = function (corePartialsPath, hibachiPathBuilder) { return new SWEntityActionBarButtonGroup(corePartialsPath, hibachiPathBuilder); };
	        directive.$inject = ['corePartialsPath',
	            'hibachiPathBuilder'];
	        return directive;
	    };
	    return SWEntityActionBarButtonGroup;
	}());
	exports.SWEntityActionBarButtonGroup = SWEntityActionBarButtonGroup;


/***/ },
/* 73 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWExpandableRecordController = (function () {
	    //@ngInject
	    function SWExpandableRecordController($timeout, $hibachi, utilityService, collectionConfigService, expandableService, listingService, observerService) {
	        var _this = this;
	        this.$timeout = $timeout;
	        this.$hibachi = $hibachi;
	        this.utilityService = utilityService;
	        this.collectionConfigService = collectionConfigService;
	        this.expandableService = expandableService;
	        this.listingService = listingService;
	        this.observerService = observerService;
	        this.childrenLoaded = false;
	        this.childrenOpen = false;
	        this.children = [];
	        this.refreshChildren = function () {
	            _this.getEntity();
	        };
	        this.setupChildCollectionConfig = function () {
	            _this.childCollectionConfig = _this.collectionConfigService.newCollectionConfig(_this.entity.metaData.className);
	            //set up parent
	            var parentName = _this.entity.metaData.hb_parentPropertyName;
	            var parentCFC = _this.entity.metaData[parentName].cfc;
	            _this.parentIDName = _this.$hibachi.getEntityExample(parentCFC).$$getIDName();
	            //set up child
	            var childName = _this.entity.metaData.hb_childPropertyName;
	            var childCFC = _this.entity.metaData[childName].cfc;
	            var childIDName = _this.$hibachi.getEntityExample(childCFC).$$getIDName();
	            _this.childCollectionConfig.clearFilterGroups();
	            _this.childCollectionConfig.collection = _this.entity;
	            _this.childCollectionConfig.addFilter(parentName + '.' + _this.parentIDName, _this.parentId);
	            _this.childCollectionConfig.setAllRecords(true);
	            angular.forEach(_this.collectionConfig.columns, function (column) {
	                _this.childCollectionConfig.addColumn(column.propertyIdentifier, column.title, column);
	            });
	            angular.forEach(_this.collectionConfig.joins, function (join) {
	                _this.childCollectionConfig.addJoin(join);
	            });
	            _this.childCollectionConfig.groupBys = _this.collectionConfig.groupBys;
	        };
	        this.getEntity = function () {
	            _this.collectionPromise.then(function (data) {
	                _this.collectionData = data;
	                _this.collectionData.pageRecords = _this.collectionData.pageRecords || _this.collectionData.records;
	                if (_this.collectionData.pageRecords.length) {
	                    angular.forEach(_this.collectionData.pageRecords, function (pageRecord) {
	                        _this.expandableService.addRecord(pageRecord[_this.parentIDName], true);
	                        pageRecord.dataparentID = _this.recordID;
	                        pageRecord.depth = _this.recordDepth || 0;
	                        pageRecord.depth++;
	                        //push the children into the listing display
	                        _this.children.push(pageRecord);
	                        _this.records.splice(_this.recordIndex + 1, 0, pageRecord);
	                    });
	                }
	                _this.childrenLoaded = true;
	            });
	        };
	        this.toggleChild = function () {
	            _this.$timeout(function () {
	                _this.childrenOpen = !_this.childrenOpen;
	                _this.expandableService.updateState(_this.recordID, { isOpen: _this.childrenOpen });
	                if (!_this.childrenLoaded) {
	                    if (_this.childCollectionConfig == null) {
	                        _this.setupChildCollectionConfig();
	                    }
	                    if (angular.isFunction(_this.childCollectionConfig.getEntity)) {
	                        _this.collectionPromise = _this.childCollectionConfig.getEntity();
	                    }
	                    _this.getEntity();
	                }
	                angular.forEach(_this.children, function (child) {
	                    child.dataIsVisible = _this.childrenOpen;
	                    var entityPrimaryIDName = _this.entity.$$getIDName();
	                    var idsToCheck = [];
	                    idsToCheck.push(child[entityPrimaryIDName]);
	                    _this.expandableService.updateState(child[entityPrimaryIDName], { isOpen: _this.childrenOpen });
	                    //close all children of the child if we are closing
	                    var childrenTraversed = false;
	                    var recordLength = _this.records.length;
	                    while (!childrenTraversed && idsToCheck.length > 0) {
	                        var found = false;
	                        var idToCheck = idsToCheck.pop();
	                        for (var i = 0; i < recordLength; i++) {
	                            var record = _this.records[i];
	                            if (record['dataparentID'] == idToCheck) {
	                                idsToCheck.push(record[entityPrimaryIDName]);
	                                _this.expandableService.updateState(record[entityPrimaryIDName], { isOpen: _this.childrenOpen });
	                                record.dataIsVisible = _this.childrenOpen;
	                                found = true;
	                            }
	                        }
	                        if (!found) {
	                            childrenTraversed = true;
	                        }
	                    }
	                });
	            });
	        };
	        this.recordID = this.parentId; //this is what parent is initalized to in the listing display
	        expandableService.addRecord(this.recordID);
	        if (angular.isDefined(this.refreshChildrenEvent) && this.refreshChildrenEvent.length) {
	            this.observerService.attach(this.refreshChildren, this.refreshChildrenEvent);
	        }
	    }
	    return SWExpandableRecordController;
	}());
	var SWExpandableRecord = (function () {
	    //@ngInject
	    function SWExpandableRecord($compile, $templateRequest, $timeout, corePartialsPath, utilityService, expandableService, hibachiPathBuilder) {
	        var _this = this;
	        this.$compile = $compile;
	        this.$templateRequest = $templateRequest;
	        this.$timeout = $timeout;
	        this.corePartialsPath = corePartialsPath;
	        this.utilityService = utilityService;
	        this.expandableService = expandableService;
	        this.hibachiPathBuilder = hibachiPathBuilder;
	        this.restrict = 'EA';
	        this.scope = {};
	        this.bindToController = {
	            recordValue: "=",
	            link: "@",
	            expandable: "=?",
	            parentId: "=",
	            entity: "=",
	            collectionConfig: "=?",
	            childCollectionConfig: "=?",
	            refreshChildrenEvent: "=?",
	            listingId: "@?",
	            records: "=",
	            pageRecord: "=",
	            recordIndex: "=",
	            recordDepth: "=",
	            childCount: "=",
	            autoOpen: "=",
	            multiselectIdPaths: "=",
	            expandableRules: "="
	        };
	        this.controller = SWExpandableRecordController;
	        this.controllerAs = "swExpandableRecord";
	        this.link = function (scope, element, attrs) {
	            if (scope.swExpandableRecord.expandable && scope.swExpandableRecord.childCount) {
	                if (scope.swExpandableRecord.recordValue) {
	                    var id = scope.swExpandableRecord.records[scope.swExpandableRecord.recordIndex][scope.swExpandableRecord.entity.$$getIDName()];
	                    if (scope.swExpandableRecord.multiselectIdPaths && scope.swExpandableRecord.multiselectIdPaths.length) {
	                        var multiselectIdPathsArray = scope.swExpandableRecord.multiselectIdPaths.split(',');
	                        if (!scope.swExpandableRecord.childrenLoaded) {
	                            angular.forEach(multiselectIdPathsArray, function (multiselectIdPath) {
	                                var position = _this.utilityService.listFind(multiselectIdPath, id, '/');
	                                var multiSelectIDs = multiselectIdPath.split('/');
	                                var multiselectPathLength = multiSelectIDs.length;
	                                if (position !== -1 && position < multiselectPathLength - 1 && !_this.expandableService.getState(id, "isOpen")) {
	                                    _this.expandableService.updateState(id, { isOpen: true });
	                                    scope.swExpandableRecord.toggleChild();
	                                }
	                            });
	                        }
	                    }
	                }
	                _this.$templateRequest(_this.hibachiPathBuilder.buildPartialsPath(_this.corePartialsPath) + "expandablerecord.html").then(function (html) {
	                    var template = angular.element(html);
	                    //get autoopen reference to ensure only the root is autoopenable
	                    var autoOpen = angular.copy(scope.swExpandableRecord.autoOpen);
	                    scope.swExpandableRecord.autoOpen = false;
	                    template = _this.$compile(template)(scope);
	                    element.html(template);
	                    element.on('click', scope.swExpandableRecord.toggleChild);
	                    if (autoOpen) {
	                        scope.swExpandableRecord.toggleChild();
	                    }
	                });
	            }
	        };
	        this.$compile = $compile;
	        this.$templateRequest = $templateRequest;
	        this.corePartialsPath = corePartialsPath;
	        this.$timeout = $timeout;
	        this.utilityService = utilityService;
	        this.expandableService = expandableService;
	        this.hibachiPathBuilder = hibachiPathBuilder;
	    }
	    SWExpandableRecord.Factory = function () {
	        var directive = function ($compile, $templateRequest, $timeout, corePartialsPath, utilityService, expandableService, hibachiPathBuilder) { return new SWExpandableRecord($compile, $templateRequest, $timeout, corePartialsPath, utilityService, expandableService, hibachiPathBuilder); };
	        directive.$inject = [
	            '$compile',
	            '$templateRequest',
	            '$timeout',
	            'corePartialsPath',
	            'utilityService',
	            'expandableService',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWExpandableRecord;
	}());
	exports.SWExpandableRecord = SWExpandableRecord;


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var md5 = __webpack_require__(75);
	var SWGravatarController = (function () {
	    // @ngInject
	    function SWGravatarController() {
	        this.gravatarURL = "http://www.gravatar.com/avatar/" + md5(this.emailAddress.toLowerCase().trim());
	    }
	    return SWGravatarController;
	}());
	exports.SWGravatarController = SWGravatarController;
	var SWGravatar = (function () {
	    function SWGravatar() {
	        this.template = "<img src='{{swGravatar.gravatarURL}}' />";
	        this.transclude = false;
	        this.restrict = "E";
	        this.scope = {};
	        this.bindToController = {
	            emailAddress: "@"
	        };
	        this.controller = SWGravatarController;
	        this.controllerAs = "swGravatar";
	        this.link = function (scope, element, attrs, controller, transclude) {
	        };
	    }
	    SWGravatar.Factory = function () {
	        var directive = function () { return new SWGravatar(); };
	        directive.$inject = [];
	        return directive;
	    };
	    return SWGravatar;
	}());
	SWGravatar.$inject = ["$hibachi", "$timeout", "collectionConfigService", "corePartialsPath",
	    'hibachiPathBuilder'];
	exports.SWGravatar = SWGravatar;


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	(function(){
	  var crypt = __webpack_require__(76),
	      utf8 = __webpack_require__(77).utf8,
	      isBuffer = __webpack_require__(78),
	      bin = __webpack_require__(77).bin,

	  // The core
	  md5 = function (message, options) {
	    // Convert to byte array
	    if (message.constructor == String)
	      if (options && options.encoding === 'binary')
	        message = bin.stringToBytes(message);
	      else
	        message = utf8.stringToBytes(message);
	    else if (isBuffer(message))
	      message = Array.prototype.slice.call(message, 0);
	    else if (!Array.isArray(message))
	      message = message.toString();
	    // else, assume byte array already

	    var m = crypt.bytesToWords(message),
	        l = message.length * 8,
	        a =  1732584193,
	        b = -271733879,
	        c = -1732584194,
	        d =  271733878;

	    // Swap endian
	    for (var i = 0; i < m.length; i++) {
	      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |
	             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;
	    }

	    // Padding
	    m[l >>> 5] |= 0x80 << (l % 32);
	    m[(((l + 64) >>> 9) << 4) + 14] = l;

	    // Method shortcuts
	    var FF = md5._ff,
	        GG = md5._gg,
	        HH = md5._hh,
	        II = md5._ii;

	    for (var i = 0; i < m.length; i += 16) {

	      var aa = a,
	          bb = b,
	          cc = c,
	          dd = d;

	      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);
	      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);
	      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);
	      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);
	      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);
	      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);
	      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);
	      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);
	      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);
	      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);
	      c = FF(c, d, a, b, m[i+10], 17, -42063);
	      b = FF(b, c, d, a, m[i+11], 22, -1990404162);
	      a = FF(a, b, c, d, m[i+12],  7,  1804603682);
	      d = FF(d, a, b, c, m[i+13], 12, -40341101);
	      c = FF(c, d, a, b, m[i+14], 17, -1502002290);
	      b = FF(b, c, d, a, m[i+15], 22,  1236535329);

	      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);
	      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);
	      c = GG(c, d, a, b, m[i+11], 14,  643717713);
	      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);
	      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);
	      d = GG(d, a, b, c, m[i+10],  9,  38016083);
	      c = GG(c, d, a, b, m[i+15], 14, -660478335);
	      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);
	      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);
	      d = GG(d, a, b, c, m[i+14],  9, -1019803690);
	      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);
	      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);
	      a = GG(a, b, c, d, m[i+13],  5, -1444681467);
	      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);
	      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);
	      b = GG(b, c, d, a, m[i+12], 20, -1926607734);

	      a = HH(a, b, c, d, m[i+ 5],  4, -378558);
	      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);
	      c = HH(c, d, a, b, m[i+11], 16,  1839030562);
	      b = HH(b, c, d, a, m[i+14], 23, -35309556);
	      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);
	      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);
	      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);
	      b = HH(b, c, d, a, m[i+10], 23, -1094730640);
	      a = HH(a, b, c, d, m[i+13],  4,  681279174);
	      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);
	      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);
	      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);
	      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);
	      d = HH(d, a, b, c, m[i+12], 11, -421815835);
	      c = HH(c, d, a, b, m[i+15], 16,  530742520);
	      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);

	      a = II(a, b, c, d, m[i+ 0],  6, -198630844);
	      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);
	      c = II(c, d, a, b, m[i+14], 15, -1416354905);
	      b = II(b, c, d, a, m[i+ 5], 21, -57434055);
	      a = II(a, b, c, d, m[i+12],  6,  1700485571);
	      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);
	      c = II(c, d, a, b, m[i+10], 15, -1051523);
	      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);
	      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);
	      d = II(d, a, b, c, m[i+15], 10, -30611744);
	      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);
	      b = II(b, c, d, a, m[i+13], 21,  1309151649);
	      a = II(a, b, c, d, m[i+ 4],  6, -145523070);
	      d = II(d, a, b, c, m[i+11], 10, -1120210379);
	      c = II(c, d, a, b, m[i+ 2], 15,  718787259);
	      b = II(b, c, d, a, m[i+ 9], 21, -343485551);

	      a = (a + aa) >>> 0;
	      b = (b + bb) >>> 0;
	      c = (c + cc) >>> 0;
	      d = (d + dd) >>> 0;
	    }

	    return crypt.endian([a, b, c, d]);
	  };

	  // Auxiliary functions
	  md5._ff  = function (a, b, c, d, x, s, t) {
	    var n = a + (b & c | ~b & d) + (x >>> 0) + t;
	    return ((n << s) | (n >>> (32 - s))) + b;
	  };
	  md5._gg  = function (a, b, c, d, x, s, t) {
	    var n = a + (b & d | c & ~d) + (x >>> 0) + t;
	    return ((n << s) | (n >>> (32 - s))) + b;
	  };
	  md5._hh  = function (a, b, c, d, x, s, t) {
	    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
	    return ((n << s) | (n >>> (32 - s))) + b;
	  };
	  md5._ii  = function (a, b, c, d, x, s, t) {
	    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
	    return ((n << s) | (n >>> (32 - s))) + b;
	  };

	  // Package private blocksize
	  md5._blocksize = 16;
	  md5._digestsize = 16;

	  module.exports = function (message, options) {
	    if (message === undefined || message === null)
	      throw new Error('Illegal argument ' + message);

	    var digestbytes = crypt.wordsToBytes(md5(message, options));
	    return options && options.asBytes ? digestbytes :
	        options && options.asString ? bin.bytesToString(digestbytes) :
	        crypt.bytesToHex(digestbytes);
	  };

	})();


/***/ },
/* 76 */
/***/ function(module, exports) {

	(function() {
	  var base64map
	      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

	  crypt = {
	    // Bit-wise rotation left
	    rotl: function(n, b) {
	      return (n << b) | (n >>> (32 - b));
	    },

	    // Bit-wise rotation right
	    rotr: function(n, b) {
	      return (n << (32 - b)) | (n >>> b);
	    },

	    // Swap big-endian to little-endian and vice versa
	    endian: function(n) {
	      // If number given, swap endian
	      if (n.constructor == Number) {
	        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
	      }

	      // Else, assume array and swap all items
	      for (var i = 0; i < n.length; i++)
	        n[i] = crypt.endian(n[i]);
	      return n;
	    },

	    // Generate an array of any length of random bytes
	    randomBytes: function(n) {
	      for (var bytes = []; n > 0; n--)
	        bytes.push(Math.floor(Math.random() * 256));
	      return bytes;
	    },

	    // Convert a byte array to big-endian 32-bit words
	    bytesToWords: function(bytes) {
	      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
	        words[b >>> 5] |= bytes[i] << (24 - b % 32);
	      return words;
	    },

	    // Convert big-endian 32-bit words to a byte array
	    wordsToBytes: function(words) {
	      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
	        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
	      return bytes;
	    },

	    // Convert a byte array to a hex string
	    bytesToHex: function(bytes) {
	      for (var hex = [], i = 0; i < bytes.length; i++) {
	        hex.push((bytes[i] >>> 4).toString(16));
	        hex.push((bytes[i] & 0xF).toString(16));
	      }
	      return hex.join('');
	    },

	    // Convert a hex string to a byte array
	    hexToBytes: function(hex) {
	      for (var bytes = [], c = 0; c < hex.length; c += 2)
	        bytes.push(parseInt(hex.substr(c, 2), 16));
	      return bytes;
	    },

	    // Convert a byte array to a base-64 string
	    bytesToBase64: function(bytes) {
	      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
	        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
	        for (var j = 0; j < 4; j++)
	          if (i * 8 + j * 6 <= bytes.length * 8)
	            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
	          else
	            base64.push('=');
	      }
	      return base64.join('');
	    },

	    // Convert a base-64 string to a byte array
	    base64ToBytes: function(base64) {
	      // Remove non-base-64 characters
	      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

	      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
	          imod4 = ++i % 4) {
	        if (imod4 == 0) continue;
	        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
	            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
	            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
	      }
	      return bytes;
	    }
	  };

	  module.exports = crypt;
	})();


/***/ },
/* 77 */
/***/ function(module, exports) {

	var charenc = {
	  // UTF-8 encoding
	  utf8: {
	    // Convert a string to a byte array
	    stringToBytes: function(str) {
	      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
	    },

	    // Convert a byte array to a string
	    bytesToString: function(bytes) {
	      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
	    }
	  },

	  // Binary encoding
	  bin: {
	    // Convert a string to a byte array
	    stringToBytes: function(str) {
	      for (var bytes = [], i = 0; i < str.length; i++)
	        bytes.push(str.charCodeAt(i) & 0xFF);
	      return bytes;
	    },

	    // Convert a byte array to a string
	    bytesToString: function(bytes) {
	      for (var str = [], i = 0; i < bytes.length; i++)
	        str.push(String.fromCharCode(bytes[i]));
	      return str.join('');
	    }
	  }
	};

	module.exports = charenc;


/***/ },
/* 78 */
/***/ function(module, exports) {

	/*!
	 * Determine if an object is a Buffer
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */

	// The _isBuffer check is for Safari 5-7 support, because it's missing
	// Object.prototype.constructor. Remove this eventually
	module.exports = function (obj) {
	  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
	}

	function isBuffer (obj) {
	  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	}

	// For Node v0.10 support. Remove this eventually.
	function isSlowBuffer (obj) {
	  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
	}


/***/ },
/* 79 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWLoginController = (function () {
	    //@ngInject
	    function SWLoginController($route, $log, $window, corePartialsPath, $hibachi, dialogService, hibachiScope) {
	        var _this = this;
	        this.$route = $route;
	        this.$log = $log;
	        this.$window = $window;
	        this.corePartialsPath = corePartialsPath;
	        this.$hibachi = $hibachi;
	        this.dialogService = dialogService;
	        this.hibachiScope = hibachiScope;
	        this.login = function () {
	            var loginPromise = _this.$hibachi.login(_this.account_login.data.emailAddress, _this.account_login.data.password);
	            loginPromise.then(function (loginResponse) {
	                if (loginResponse && loginResponse.data && loginResponse.data.token) {
	                    _this.$window.localStorage.setItem('token', loginResponse.data.token);
	                    _this.hibachiScope.loginDisplayed = false;
	                    _this.$route.reload();
	                    _this.dialogService.removeCurrentDialog();
	                }
	            }, function (rejection) {
	            });
	        };
	        this.$hibachi = $hibachi;
	        this.$window = $window;
	        this.$route = $route;
	        this.hibachiScope = hibachiScope;
	        this.account_login = $hibachi.newEntity('Account_Login');
	    }
	    return SWLoginController;
	}());
	var SWLogin = (function () {
	    //@ngInject
	    function SWLogin($route, $log, $window, corePartialsPath, $hibachi, dialogService, hibachiPathBuilder) {
	        this.$route = $route;
	        this.$log = $log;
	        this.$window = $window;
	        this.corePartialsPath = corePartialsPath;
	        this.$hibachi = $hibachi;
	        this.dialogService = dialogService;
	        this.restrict = 'E';
	        this.scope = {};
	        this.bindToController = {};
	        this.controller = SWLoginController;
	        this.controllerAs = "SwLogin";
	        this.link = function (scope, element, attrs) {
	        };
	        this.templateUrl = hibachiPathBuilder.buildPartialsPath(this.corePartialsPath + '/login.html');
	    }
	    SWLogin.Factory = function () {
	        var directive = function ($route, $log, $window, corePartialsPath, $hibachi, dialogService, hibachiPathBuilder) { return new SWLogin($route, $log, $window, corePartialsPath, $hibachi, dialogService, hibachiPathBuilder); };
	        directive.$inject = [
	            '$route',
	            '$log',
	            '$window',
	            'corePartialsPath',
	            '$hibachi',
	            'dialogService',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWLogin;
	}());
	exports.SWLogin = SWLogin;


/***/ },
/* 80 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWModalLauncherController = (function () {
	    // @ngInject
	    function SWModalLauncherController() {
	        var _this = this;
	        this.hasSaveAction = false;
	        this.hasCancelAction = false;
	        this.hasDeleteAction = false;
	        this.launchModal = function () {
	            //activate the necessary modal
	            _this.showModal = true;
	        };
	        this.saveCallback = function () {
	            //the passed save action must return a promise
	            if (_this.hasSaveAction) {
	                var savePromise = _this.saveAction()();
	            }
	            savePromise.then(function (response) {
	                //if the action was sucessful
	                $("#" + _this.modalName).modal('hide');
	            }, function (reason) {
	                //if the action failed
	            });
	        };
	        this.deleteCallback = function () {
	            //the passed save action must return a promise
	            if (_this.hasDeleteAction) {
	                var deletePromise = _this.saveAction()();
	            }
	            deletePromise.then(function (response) {
	                //if the action was sucessful
	                $("#" + _this.modalName).modal('hide');
	            }, function (reason) {
	                //if the action failed
	            });
	        };
	        this.cancelCallback = function () {
	            if (_this.hasCancelAction) {
	                _this.cancelAction()();
	            }
	        };
	        if (angular.isUndefined(this.showModal)) {
	            this.showModal = false;
	        }
	    }
	    return SWModalLauncherController;
	}());
	exports.SWModalLauncherController = SWModalLauncherController;
	var SWModalLauncher = (function () {
	    // @ngInject
	    function SWModalLauncher($compile, corePartialsPath, hibachiPathBuilder) {
	        this.$compile = $compile;
	        this.corePartialsPath = corePartialsPath;
	        this.transclude = {
	            button: '?swModalButton',
	            staticButton: '?swModalStaticButton',
	            content: '?swModalContent'
	        };
	        this.restrict = "EA";
	        this.scope = {};
	        this.bindToController = {
	            showModal: "=?",
	            modalName: "@",
	            title: "@",
	            saveAction: "&?",
	            deleteAction: "&?",
	            cancelAction: "&?"
	        };
	        this.controller = SWModalLauncherController;
	        this.controllerAs = "swModalLauncher";
	        this.compile = function (element, attrs, transclude) {
	            return {
	                pre: function ($scope, element, attrs) {
	                    if (angular.isDefined(attrs.saveAction)) {
	                        $scope.swModalLauncher.hasSaveAction = true;
	                    }
	                    if (angular.isDefined(attrs.deleteAction)) {
	                        $scope.swModalLauncher.hasDeleteAction = true;
	                    }
	                    if (angular.isDefined(attrs.cancelAction)) {
	                        $scope.swModalLauncher.hasCancelAction = true;
	                    }
	                },
	                post: function ($scope, element, attrs) {
	                }
	            };
	        };
	        this.templateUrl = hibachiPathBuilder.buildPartialsPath(corePartialsPath) + "modallauncher.html";
	    }
	    SWModalLauncher.Factory = function () {
	        var directive = function ($compile, corePartialsPath, hibachiPathBuilder) { return new SWModalLauncher($compile, corePartialsPath, hibachiPathBuilder); };
	        directive.$inject = ["$compile", "corePartialsPath",
	            'hibachiPathBuilder'];
	        return directive;
	    };
	    return SWModalLauncher;
	}());
	exports.SWModalLauncher = SWModalLauncher;


/***/ },
/* 81 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWModalWindowController = (function () {
	    // @ngInject
	    function SWModalWindowController() {
	        if (angular.isUndefined(this.modalName)) {
	            console.warn("You did not pass a modal title to SWModalWindowController");
	            this.modalName = "";
	        }
	    }
	    return SWModalWindowController;
	}());
	exports.SWModalWindowController = SWModalWindowController;
	var SWModalWindow = (function () {
	    // @ngInject
	    function SWModalWindow($compile, corePartialsPath, hibachiPathBuilder) {
	        this.$compile = $compile;
	        this.corePartialsPath = corePartialsPath;
	        this.transclude = {
	            modalBody: "?swModalBody"
	        };
	        this.restrict = "EA";
	        this.scope = {};
	        this.bindToController = {
	            modalName: "@",
	            title: "@",
	            hasSaveAction: "=?",
	            saveAction: "&?",
	            hasDeleteAction: "=?",
	            deleteAction: "&?",
	            hasCancelAction: "=?",
	            cancelAction: "&?"
	        };
	        this.controller = SWModalWindowController;
	        this.controllerAs = "swModalWindow";
	        this.compile = function (element, attrs, transclude) {
	            return {
	                pre: function ($scope, element, attrs) {
	                },
	                post: function ($scope, element, attrs) {
	                }
	            };
	        };
	        this.templateUrl = hibachiPathBuilder.buildPartialsPath(corePartialsPath) + "modalwindow.html";
	    }
	    SWModalWindow.Factory = function () {
	        var directive = function ($compile, corePartialsPath, hibachiPathBuilder) { return new SWModalWindow($compile, corePartialsPath, hibachiPathBuilder); };
	        directive.$inject = ["$compile", "corePartialsPath",
	            'hibachiPathBuilder'];
	        return directive;
	    };
	    return SWModalWindow;
	}());
	exports.SWModalWindow = SWModalWindow;


/***/ },
/* 82 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWNumbersOnly = (function () {
	    function SWNumbersOnly() {
	        this.restrict = "A";
	        this.require = "ngModel";
	        this.scope = {
	            ngModel: '=',
	            minNumber: '=?',
	            maxNumber: '=?'
	        };
	        this.link = function ($scope, element, attrs, modelCtrl) {
	            modelCtrl.$parsers.unshift(function (inputValue) {
	                var modelValue = modelCtrl.$modelValue;
	                if (inputValue != "" && !isNaN(Number(inputValue))) {
	                    if (angular.isDefined($scope.minNumber)) {
	                        if (Number(inputValue) >= $scope.minNumber || !angular.isDefined($scope.minNumber)) {
	                            modelCtrl.$setValidity("minNumber", true);
	                        }
	                        else if (angular.isDefined($scope.minNumber)) {
	                            modelCtrl.$setValidity("minNumber", false);
	                        }
	                    }
	                    if (angular.isDefined($scope.maxNumber)) {
	                        if (Number(inputValue) <= $scope.maxNumber || !angular.isDefined($scope.maxNumber)) {
	                            modelCtrl.$setValidity("maxNumber", true);
	                        }
	                        else if (angular.isDefined($scope.maxNumber)) {
	                            modelCtrl.$setValidity("maxNumber", false);
	                        }
	                    }
	                    if (modelCtrl.$valid) {
	                        modelValue = Number(inputValue);
	                    }
	                    else {
	                        modelValue = $scope.minNumber;
	                    }
	                }
	                return modelValue;
	            });
	        };
	    }
	    SWNumbersOnly.Factory = function () {
	        var directive = function () { return new SWNumbersOnly(); };
	        directive.$inject = [];
	        return directive;
	    };
	    return SWNumbersOnly;
	}());
	exports.SWNumbersOnly = SWNumbersOnly;


/***/ },
/* 83 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWLoading = (function () {
	    function SWLoading($log, corePartialsPath, hibachiPathBuilder) {
	        return {
	            restrict: 'A',
	            transclude: true,
	            templateUrl: hibachiPathBuilder.buildPartialsPath(corePartialsPath) + 'loading.html',
	            scope: {
	                swLoading: '='
	            },
	            link: function (scope, attrs, element) {
	            }
	        };
	    }
	    SWLoading.Factory = function () {
	        var directive = function ($log, corePartialsPath, hibachiPathBuilder) { return new SWLoading($log, corePartialsPath, hibachiPathBuilder); };
	        directive.$inject = [
	            '$log',
	            'corePartialsPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWLoading;
	}());
	exports.SWLoading = SWLoading;


/***/ },
/* 84 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWScrollTrigger = (function () {
	    function SWScrollTrigger($rootScope, $window, $timeout) {
	        return {
	            link: function (scope, elem, attrs) {
	                var checkWhenEnabled, handler, scrollDistance, scrollEnabled;
	                $window = angular.element($window);
	                scrollDistance = 0;
	                if (attrs.infiniteScrollDistance != null) {
	                    scope
	                        .$watch(attrs.infiniteScrollDistance, function (value) {
	                        return scrollDistance = parseInt(value, 10);
	                    });
	                }
	                scrollEnabled = true;
	                checkWhenEnabled = false;
	                if (attrs.infiniteScrollDisabled != null) {
	                    scope
	                        .$watch(attrs.infiniteScrollDisabled, function (value) {
	                        scrollEnabled = !value;
	                        if (scrollEnabled
	                            && checkWhenEnabled) {
	                            checkWhenEnabled = false;
	                            return handler();
	                        }
	                    });
	                }
	                handler = function () {
	                    var elementBottom, remaining, shouldScroll, windowBottom;
	                    windowBottom = $window.height()
	                        + $window.scrollTop();
	                    elementBottom = elem.offset().top
	                        + elem.height();
	                    remaining = elementBottom
	                        - windowBottom;
	                    shouldScroll = remaining <= $window
	                        .height()
	                        * scrollDistance;
	                    if (shouldScroll && scrollEnabled) {
	                        if ($rootScope.$$phase) {
	                            return scope
	                                .$eval(attrs.infiniteScroll);
	                        }
	                        else {
	                            return scope
	                                .$apply(attrs.infiniteScroll);
	                        }
	                    }
	                    else if (shouldScroll) {
	                        return checkWhenEnabled = true;
	                    }
	                };
	                $window.on('scroll', handler);
	                scope.$on('$destroy', function () {
	                    return $window.off('scroll', handler);
	                });
	                return $timeout((function () {
	                    if (attrs.infiniteScrollImmediateCheck) {
	                        if (scope
	                            .$eval(attrs.infiniteScrollImmediateCheck)) {
	                            return handler();
	                        }
	                    }
	                    else {
	                        return handler();
	                    }
	                }), 0);
	            }
	        };
	    }
	    SWScrollTrigger.Factory = function () {
	        var directive = function ($rootScope, $window, $timeout) { return new SWScrollTrigger($rootScope, $window, $timeout); };
	        directive.$inject = [
	            '$rootScope',
	            '$window',
	            '$timeout'
	        ];
	        return directive;
	    };
	    return SWScrollTrigger;
	}());
	exports.SWScrollTrigger = SWScrollTrigger;


/***/ },
/* 85 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWTabGroupController = (function () {
	    // @ngInject
	    function SWTabGroupController(utilityService, rbkeyService, observerService) {
	        var _this = this;
	        this.utilityService = utilityService;
	        this.rbkeyService = rbkeyService;
	        this.observerService = observerService;
	        this.hasActiveTab = false;
	        this.initTab = function () {
	            for (var i = 0; i < _this.tabs.length; i++) {
	                if (!_this.tabs[i].hide) {
	                    _this.tabs[i].active = true;
	                    _this.tabs[i].loaded = true;
	                    break;
	                }
	            }
	        };
	        this.switchTab = function (tabToActivate) {
	            _this.observerService.notify(_this.switchTabGroupEventName);
	            for (var i = 0; i < _this.tabs.length; i++) {
	                _this.tabs[i].active = false;
	            }
	            tabToActivate.active = true;
	            tabToActivate.loaded = true;
	        };
	        this.getTabByName = function (name) {
	            for (var i = 0; i < _this.tabs.length; i++) {
	                if (_this.tabs[i].name == name) {
	                    return _this.tabs[i];
	                }
	            }
	        };
	        if (angular.isUndefined(this.tabs)) {
	            this.tabs = [];
	        }
	        this.tabGroupID = "TG" + this.utilityService.createID(30);
	        this.switchTabGroupEventName = "SwitchTabGroup" + this.tabGroupID;
	        this.initTabEventName = "InitTabForTabGroup" + this.tabGroupID;
	        this.observerService.attach(this.initTab, this.initTabEventName);
	        if (angular.isUndefined(this.switchTabEventName)) {
	            this.switchTabEventName = this.tabGroupID + "SwitchTabTo";
	        }
	        this.observerService.attach(this.switchTab, this.switchTabEventName);
	    }
	    return SWTabGroupController;
	}());
	exports.SWTabGroupController = SWTabGroupController;
	var SWTabGroup = (function () {
	    // @ngInject
	    function SWTabGroup($compile, corePartialsPath, hibachiPathBuilder) {
	        this.$compile = $compile;
	        this.corePartialsPath = corePartialsPath;
	        this.transclude = true;
	        this.restrict = "EA";
	        this.scope = {};
	        this.bindToController = {
	            switchTabEventName: "@?"
	        };
	        this.controller = SWTabGroupController;
	        this.controllerAs = "swTabGroup";
	        this.compile = function (element, attrs, transclude) {
	            return {
	                pre: function ($scope, element, attrs) { },
	                post: function ($scope, element, attrs) { }
	            };
	        };
	        this.templateUrl = hibachiPathBuilder.buildPartialsPath(corePartialsPath) + "tabgroup.html";
	    }
	    SWTabGroup.Factory = function () {
	        var directive = function ($compile, corePartialsPath, hibachiPathBuilder) { return new SWTabGroup($compile, corePartialsPath, hibachiPathBuilder); };
	        directive.$inject = ["$compile", "corePartialsPath",
	            'hibachiPathBuilder'];
	        return directive;
	    };
	    return SWTabGroup;
	}());
	exports.SWTabGroup = SWTabGroup;


/***/ },
/* 86 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWTabContentController = (function () {
	    // @ngInject
	    function SWTabContentController($scope, $q, $transclude, $hibachi, $timeout, utilityService, rbkeyService, collectionConfigService) {
	        this.$scope = $scope;
	        this.$q = $q;
	        this.$transclude = $transclude;
	        this.$hibachi = $hibachi;
	        this.$timeout = $timeout;
	        this.utilityService = utilityService;
	        this.rbkeyService = rbkeyService;
	        this.collectionConfigService = collectionConfigService;
	        if (angular.isUndefined(this.active)) {
	            this.active = false;
	        }
	        if (angular.isUndefined(this.loaded)) {
	            this.loaded = false;
	        }
	        if (angular.isUndefined(this.hide)) {
	            this.hide = false;
	        }
	        if (angular.isUndefined(this.id)) {
	            this.id = utilityService.createID(16);
	        }
	        if (angular.isUndefined(this.name)) {
	            this.name = this.id;
	        }
	        //make a tab service? 
	    }
	    return SWTabContentController;
	}());
	exports.SWTabContentController = SWTabContentController;
	var SWTabContent = (function () {
	    // @ngInject
	    function SWTabContent($compile, scopeService, observerService, corePartialsPath, hibachiPathBuilder) {
	        var _this = this;
	        this.$compile = $compile;
	        this.scopeService = scopeService;
	        this.observerService = observerService;
	        this.corePartialsPath = corePartialsPath;
	        this.transclude = true;
	        this.restrict = "EA";
	        this.scope = {};
	        this.bindToController = {
	            active: "=?",
	            loaded: "=?",
	            hide: "=?",
	            name: "@?"
	        };
	        this.controller = SWTabContentController;
	        this.controllerAs = "swTabContent";
	        this.compile = function (element, attrs, transclude) {
	            return {
	                pre: function ($scope, element, attrs) {
	                },
	                post: function ($scope, element, attrs) {
	                    var parentDirective = _this.scopeService.getRootParentScope($scope, "swTabGroup")["swTabGroup"];
	                    if (angular.isDefined(parentDirective) && angular.isDefined(parentDirective.tabs)) {
	                        parentDirective.tabs.push($scope.swTabContent);
	                        _this.observerService.notify(parentDirective.initTabEventName);
	                    }
	                }
	            };
	        };
	        this.templateUrl = hibachiPathBuilder.buildPartialsPath(corePartialsPath) + "tabcontent.html";
	    }
	    SWTabContent.Factory = function () {
	        var directive = function ($compile, scopeService, observerService, corePartialsPath, hibachiPathBuilder) { return new SWTabContent($compile, scopeService, observerService, corePartialsPath, hibachiPathBuilder); };
	        directive.$inject = ["$compile",
	            "scopeService",
	            "observerService",
	            "corePartialsPath",
	            "hibachiPathBuilder"];
	        return directive;
	    };
	    return SWTabContent;
	}());
	exports.SWTabContent = SWTabContent;


/***/ },
/* 87 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWTooltipController = (function () {
	    // @ngInject
	    function SWTooltipController(rbkeyService) {
	        var _this = this;
	        this.rbkeyService = rbkeyService;
	        this.showTooltip = false;
	        this.show = function () {
	            _this.showTooltip = true;
	        };
	        this.hide = function () {
	            _this.showTooltip = false;
	        };
	        if (angular.isDefined(this.rbKey)) {
	            this.text = rbkeyService.getRBKey(this.rbKey);
	        }
	        if (angular.isUndefined(this.position)) {
	            this.position = "top";
	        }
	    }
	    return SWTooltipController;
	}());
	exports.SWTooltipController = SWTooltipController;
	var SWTooltip = (function () {
	    // @ngInject
	    function SWTooltip($document, corePartialsPath, hibachiPathBuilder) {
	        this.$document = $document;
	        this.corePartialsPath = corePartialsPath;
	        this.transclude = true;
	        this.restrict = "EA";
	        this.scope = {};
	        this.bindToController = {
	            rbKey: "@?",
	            text: "@?",
	            position: "@?",
	            showTooltip: "=?"
	        };
	        this.controller = SWTooltipController;
	        this.controllerAs = "swTooltip";
	        this.link = function (scope, element, attrs, controller, transclude) {
	            var tooltip = element.find(".tooltip");
	            var elementPosition = element.position();
	            var tooltipStyle = tooltip[0].style;
	            if (attrs && attrs.position) {
	                switch (attrs.position.toLowerCase()) {
	                    case 'top':
	                        tooltipStyle.top = "0px";
	                        tooltipStyle.left = "0px";
	                        break;
	                    case 'bottom':
	                        //where the element is rendered to begin with
	                        break;
	                    case 'left':
	                        tooltipStyle.top = (elementPosition.top + element[0].offsetHeight - 5) + "px";
	                        tooltipStyle.left = (-1 * (elementPosition.left + element[0].offsetLeft - 5)) + "px";
	                        element.find(".tooltip-inner")[0].style.maxWidth = "none";
	                        break;
	                    default:
	                        //right is the default
	                        tooltipStyle.top = (elementPosition.top + element[0].offsetHeight - 5) + "px";
	                        tooltipStyle.left = (elementPosition.left + element[0].offsetWidth - 5) + "px";
	                }
	            }
	        };
	        this.templateUrl = hibachiPathBuilder.buildPartialsPath(corePartialsPath) + "tooltip.html";
	    }
	    SWTooltip.Factory = function () {
	        var directive = function ($document, corePartialsPath, hibachiPathBuilder) { return new SWTooltip($document, corePartialsPath, hibachiPathBuilder); };
	        directive.$inject = ["$document", "corePartialsPath", "hibachiPathBuilder"];
	        return directive;
	    };
	    return SWTooltip;
	}());
	exports.SWTooltip = SWTooltip;


/***/ },
/* 88 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWRbKey = (function () {
	    function SWRbKey($hibachi, observerService, utilityService, $rootScope, $log, rbkeyService) {
	        return {
	            restrict: 'A',
	            scope: {
	                swRbkey: "="
	            },
	            link: function (scope, element, attrs) {
	                var rbKeyValue = scope.swRbkey;
	                var bindRBKey = function () {
	                    if (angular.isDefined(rbKeyValue) && angular.isString(rbKeyValue)) {
	                        element.text(rbkeyService.getRBKey(rbKeyValue));
	                    }
	                };
	                bindRBKey();
	            }
	        };
	    }
	    SWRbKey.Factory = function () {
	        var directive = function ($hibachi, observerService, utilityService, $rootScope, $log, rbkeyService) { return new SWRbKey($hibachi, observerService, utilityService, $rootScope, $log, rbkeyService); };
	        directive.$inject = [
	            '$hibachi',
	            'observerService',
	            'utilityService',
	            '$rootScope',
	            '$log',
	            'rbkeyService'
	        ];
	        return directive;
	    };
	    return SWRbKey;
	}());
	exports.SWRbKey = SWRbKey;


/***/ },
/* 89 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWOptions = (function () {
	    function SWOptions($log, $hibachi, observerService, corePartialsPath, hibachiPathBuilder) {
	        return {
	            restrict: 'AE',
	            scope: {
	                objectName: '@'
	            },
	            templateUrl: hibachiPathBuilder.buildPartialsPath(corePartialsPath) + "options.html",
	            link: function (scope, element, attrs) {
	                scope.swOptions = {};
	                scope.swOptions.objectName = scope.objectName;
	                //sets up drop down options via collections
	                scope.getOptions = function () {
	                    scope.swOptions.object = $hibachi['new' + scope.swOptions.objectName]();
	                    var columnsConfig = [
	                        {
	                            "propertyIdentifier": scope.swOptions.objectName.charAt(0).toLowerCase() + scope.swOptions.objectName.slice(1) + 'Name'
	                        },
	                        {
	                            "propertyIdentifier": scope.swOptions.object.$$getIDName()
	                        }
	                    ];
	                    $hibachi.getEntity(scope.swOptions.objectName, { allRecords: true, columnsConfig: angular.toJson(columnsConfig) })
	                        .then(function (value) {
	                        scope.swOptions.options = value.records;
	                        observerService.notify('optionsLoaded');
	                    });
	                };
	                scope.getOptions();
	                var selectOption = function (option) {
	                    if (option) {
	                        scope.swOptions.selectOption(option);
	                    }
	                    else {
	                        scope.swOptions.selectOption(scope.swOptions.options[0]);
	                    }
	                };
	                observerService.attach(selectOption, 'selectOption', 'selectOption');
	                //use by ng-change to record changes
	                scope.swOptions.selectOption = function (selectedOption) {
	                    scope.swOptions.selectedOption = selectedOption;
	                    observerService.notify('optionsChanged', selectedOption);
	                };
	            }
	        };
	    }
	    SWOptions.Factory = function () {
	        var directive = function ($log, $hibachi, observerService, corePartialsPath, hibachiPathBuilder) { return new SWOptions($log, $hibachi, observerService, corePartialsPath, hibachiPathBuilder); };
	        directive.$inject = [
	            '$log',
	            '$hibachi',
	            'observerService',
	            'corePartialsPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWOptions;
	}());
	exports.SWOptions = SWOptions;


/***/ },
/* 90 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWSelectionController = (function () {
	    //@ngInject
	    function SWSelectionController(selectionService, observerService) {
	        var _this = this;
	        this.selectionService = selectionService;
	        this.observerService = observerService;
	        this.updateSelectValue = function (res) {
	            if (_this.isRadio && (res.action == 'check')) {
	                _this.toggleValue == _this.selection;
	            }
	            else if (res.action == 'clear') {
	                _this.toggleValue = false;
	            }
	            else if (res.action == 'selectAll') {
	                _this.toggleValue = true;
	            }
	            else if (res.selection == _this.selection) {
	                _this.toggleValue = (res.action == 'check');
	            }
	        };
	        this.toggleSelection = function (toggleValue, selectionid, selection) {
	            if (_this.isRadio) {
	                _this.selectionService.radioSelection(selectionid, selection);
	                _this.toggleValue = toggleValue;
	            }
	            else {
	                if (toggleValue) {
	                    _this.selectionService.addSelection(selectionid, selection);
	                }
	                else {
	                    _this.selectionService.removeSelection(selectionid, selection);
	                }
	            }
	        };
	        if (angular.isUndefined(this.name)) {
	            this.name = 'selection';
	        }
	        if (selectionService.isAllSelected(this.selectionid)) {
	            this.toggleValue = !selectionService.hasSelection(this.selectionid, this.selection);
	        }
	        else {
	            this.toggleValue = selectionService.hasSelection(this.selectionid, this.selection);
	        }
	        //attach observer so we know when a selection occurs
	        observerService.attach(this.updateSelectValue, 'swSelectionToggleSelection' + this.selectionid);
	        if (angular.isDefined(this.initSelected) && this.initSelected) {
	            this.toggleValue = this.selection;
	            this.toggleSelection(this.toggleValue, this.selectionid, this.selection);
	        }
	    }
	    return SWSelectionController;
	}());
	var SWSelection = (function () {
	    function SWSelection(collectionPartialsPath, hibachiPathBuilder) {
	        this.collectionPartialsPath = collectionPartialsPath;
	        this.hibachiPathBuilder = hibachiPathBuilder;
	        this.restrict = 'E';
	        this.scope = {};
	        this.bindToController = {
	            selection: "=",
	            selectionid: "@",
	            id: "=",
	            isRadio: "=",
	            name: "@",
	            disabled: "=",
	            initSelected: "="
	        };
	        this.controller = SWSelectionController;
	        this.controllerAs = 'swSelection';
	        this.templateUrl = this.hibachiPathBuilder.buildPartialsPath(this.collectionPartialsPath) + "selection.html";
	    }
	    SWSelection.Factory = function () {
	        var directive = function (corePartialsPath, hibachiPathBuilder) { return new SWSelection(corePartialsPath, hibachiPathBuilder); };
	        directive.$inject = ['corePartialsPath', 'hibachiPathBuilder'];
	        return directive;
	    };
	    return SWSelection;
	}());
	SWSelection.$inject = ['corePartialsPath', 'hibachiPathBuilder'];
	exports.SWSelection = SWSelection;


/***/ },
/* 91 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWClickOutside = (function () {
	    //@ngInject
	    function SWClickOutside($document, $timeout, utilityService) {
	        var _this = this;
	        this.$document = $document;
	        this.$timeout = $timeout;
	        this.utilityService = utilityService;
	        this.restrict = 'A';
	        this.scope = {
	            swClickOutside: '&'
	        };
	        this.link = function (scope, elem, attr) {
	            _this.$document.on('click', function (e) {
	                if (!e || !e.target)
	                    return;
	                //check if our element already hidden
	                if (angular.element(elem).hasClass("ng-hide")) {
	                    return;
	                }
	                if (e.target !== elem && elem && elem[0] && !_this.utilityService.isDescendantElement(elem[0], e.target)) {
	                    _this.$timeout(function () {
	                        scope.swClickOutside();
	                    });
	                }
	            });
	        };
	        this.$document = $document;
	        this.$timeout = $timeout;
	        this.utilityService = utilityService;
	    }
	    SWClickOutside.Factory = function () {
	        var directive = function ($document, $timeout, utilityService) { return new SWClickOutside($document, $timeout, utilityService); };
	        directive.$inject = [
	            '$document', '$timeout', 'utilityService'
	        ];
	        return directive;
	    };
	    return SWClickOutside;
	}());
	exports.SWClickOutside = SWClickOutside;


/***/ },
/* 92 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWDirective = (function () {
	    //@ngInject
	    function SWDirective($compile, utilityService) {
	        return {
	            restrict: 'AE',
	            //replace:true,
	            scope: {
	                variables: "=",
	                directiveTemplate: "="
	            },
	            controllerAs: "swDirective",
	            link: function (scope, element, attrs) {
	                var tempVariables = {};
	                angular.forEach(scope.variables, function (value, key) {
	                    if (key.toString().charAt(0) != "$" && value !== " ") {
	                        tempVariables[utilityService.keyToAttributeString(key)] = value;
	                    }
	                });
	                scope.variables = tempVariables;
	                var template = '<' + scope.directiveTemplate + ' ';
	                if (angular.isDefined(scope.variables)) {
	                    angular.forEach(scope.variables, function (value, key) {
	                        if (!angular.isString(value) && !angular.isNumber(value)) {
	                            template += ' ' + key + '="swDirective.' + 'variables.' + key + '" ';
	                        }
	                        else {
	                            template += ' ' + key + '="' + value + '" ';
	                        }
	                    });
	                }
	                template += '>';
	                template += '</' + scope.directiveTemplate + '>';
	                // Render the template.
	                element.html($compile(template)(scope));
	            }
	        };
	    }
	    SWDirective.Factory = function () {
	        var directive = function ($compile, utilityService) { return new SWDirective($compile, utilityService); };
	        directive.$inject = [
	            '$compile',
	            'utilityService'
	        ];
	        return directive;
	    };
	    return SWDirective;
	}());
	exports.SWDirective = SWDirective;


/***/ },
/* 93 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWExportAction = (function () {
	    //@ngInject
	    function SWExportAction($log, corePartialsPath, hibachiPathBuilder) {
	        return {
	            restrict: 'A',
	            templateUrl: hibachiPathBuilder.buildPartialsPath(corePartialsPath) + 'exportaction.html',
	            scope: {},
	            link: function (scope, element, attrs) {
	            }
	        };
	    }
	    SWExportAction.Factory = function () {
	        var directive = function ($log, corePartialsPath, hibachiPathBuilder) { return new SWExportAction($log, corePartialsPath, hibachiPathBuilder); };
	        directive.$inject = [
	            '$log',
	            'corePartialsPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWExportAction;
	}());
	exports.SWExportAction = SWExportAction;


/***/ },
/* 94 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWHref = (function () {
	    function SWHref() {
	        return {
	            restrict: 'A',
	            scope: {
	                swHref: "@"
	            },
	            link: function (scope, element, attrs) {
	                /*convert link to use hashbang*/
	                var hrefValue = attrs.swHref;
	                hrefValue = '?ng#!' + hrefValue;
	                element.attr('href', hrefValue);
	            }
	        };
	    }
	    SWHref.Factory = function () {
	        var directive = function () { return new SWHref(); };
	        directive.$inject = [];
	        return directive;
	    };
	    return SWHref;
	}());
	exports.SWHref = SWHref;


/***/ },
/* 95 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWProcessCallerController = (function () {
	    //@ngInject
	    function SWProcessCallerController(rbkeyService, $templateRequest, $compile, corePartialsPath, $scope, $element, $transclude, utilityService, hibachiPathBuilder) {
	        var _this = this;
	        this.rbkeyService = rbkeyService;
	        this.$templateRequest = $templateRequest;
	        this.$compile = $compile;
	        this.corePartialsPath = corePartialsPath;
	        this.$scope = $scope;
	        this.$element = $element;
	        this.$transclude = $transclude;
	        this.$templateRequest = $templateRequest;
	        this.$compile = $compile;
	        this.corePartialsPath = corePartialsPath;
	        this.utilityService = utilityService;
	        this.type = this.type || 'link';
	        this.queryString = this.queryString || '';
	        this.$scope = $scope;
	        this.$element = $element;
	        this.$transclude = this.$transclude;
	        this.$templateRequest(hibachiPathBuilder.buildPartialsPath(this.corePartialsPath) + "processcaller.html").then(function (html) {
	            var template = angular.element(html);
	            _this.$element.parent().append(template);
	            $compile(template)(_this.$scope);
	        });
	        if (angular.isDefined(this.titleRbKey)) {
	            this.title = this.rbkeyService.getRBKey(this.titleRbKey);
	        }
	        if (angular.isUndefined(this.text)) {
	            this.text = this.title;
	        }
	    }
	    return SWProcessCallerController;
	}());
	var SWProcessCaller = (function () {
	    function SWProcessCaller(corePartialsPath, utilityService) {
	        this.corePartialsPath = corePartialsPath;
	        this.utilityService = utilityService;
	        this.restrict = 'E';
	        this.scope = {};
	        this.bindToController = {
	            action: "@",
	            entity: "@",
	            processContext: "@",
	            hideDisabled: "=",
	            type: "@",
	            queryString: "@",
	            text: "@",
	            title: "@?",
	            titleRbKey: "@?",
	            'class': "@",
	            icon: "=",
	            iconOnly: "=",
	            submit: "=",
	            confirm: "=",
	            disabled: "=",
	            disabledText: "@",
	            modal: "="
	        };
	        this.controller = SWProcessCallerController;
	        this.controllerAs = "swProcessCaller";
	        this.link = function (scope, element, attrs) {
	        };
	        this.corePartialsPath = corePartialsPath;
	        this.utilityService = utilityService;
	    }
	    SWProcessCaller.Factory = function () {
	        var directive = function (corePartialsPath, utilityService) { return new SWProcessCaller(corePartialsPath, utilityService); };
	        directive.$inject = [
	            'corePartialsPath', 'utilityService'
	        ];
	        return directive;
	    };
	    return SWProcessCaller;
	}());
	SWProcessCaller.$inject = ['corePartialsPath', 'utilityService'];
	exports.SWProcessCaller = SWProcessCaller;


/***/ },
/* 96 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWSortable = (function () {
	    function SWSortable(expression, compiledElement) {
	        return function (linkElement) {
	            var scope = this;
	            linkElement.sortable({
	                placeholder: "placeholder",
	                opacity: 0.8,
	                axis: "y",
	                update: function (event, ui) {
	                    // get model
	                    var model = scope.$apply(expression);
	                    // remember its length
	                    var modelLength = model.length;
	                    // rember html nodes
	                    var items = [];
	                    // loop through items in new order
	                    linkElement.children().each(function (index) {
	                        var item = $(this);
	                        // get old item index
	                        var oldIndex = parseInt(item.attr("sw:sortable-index"), 10);
	                        // add item to the end of model
	                        model.push(model[oldIndex]);
	                        if (item.attr("sw:sortable-index")) {
	                            // items in original order to restore dom
	                            items[oldIndex] = item;
	                            // and remove item from dom
	                            item.detach();
	                        }
	                    });
	                    model.splice(0, modelLength);
	                    // restore original dom order, so angular does not get confused
	                    linkElement.append.apply(linkElement, items);
	                    // notify angular of the change
	                    scope.$digest();
	                }
	            });
	        };
	    }
	    SWSortable.Factory = function () {
	        var directive = function (expression, compiledElement) { return new SWSortable(expression, compiledElement); };
	        directive.$inject = ['expression', 'compiledElement'];
	        return directive;
	    };
	    return SWSortable;
	}());
	exports.SWSortable = SWSortable;


/***/ },
/* 97 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWOrderByControlsController = (function () {
	    // @ngInject
	    function SWOrderByControlsController(listingService, observerService, utilityService) {
	        var _this = this;
	        this.listingService = listingService;
	        this.observerService = observerService;
	        this.utilityService = utilityService;
	        this.sortCode = "ASC";
	        this.updateSortOrderProperty = function () {
	            if (angular.isDefined(_this.selectedPropertyIdentifier)) {
	                _this.propertyNotChosen = false;
	            }
	            else {
	                _this.propertyNotChosen = true;
	            }
	            _this.updateOrderBy();
	        };
	        this.updateOrderBy = function () {
	            if (angular.isDefined(_this.selectedPropertyIdentifier) && _this.selectedPropertyIdentifier.length > 0) {
	                var propertyIdentifier = _this.selectedPropertyIdentifier;
	            }
	            switch (_this.sortCode) {
	                case "ASC":
	                    _this.disabled = false;
	                    if (propertyIdentifier != null) {
	                        if (angular.isDefined(_this.collectionConfig)) {
	                            _this.collectionConfig.toggleOrderBy(propertyIdentifier, true); //single column mode true
	                        }
	                        if (_this.inListingDisplay) {
	                            _this.listingService.setSingleColumnOrderBy(_this.listingId, propertyIdentifier, "ASC");
	                        }
	                    }
	                    if (_this.inListingDisplay)
	                        _this.listingService.setManualSort(_this.listingId, false);
	                    break;
	                case "DESC":
	                    _this.disabled = false;
	                    if (propertyIdentifier != null) {
	                        if (angular.isDefined(_this.collectionConfig)) {
	                            _this.collectionConfig.toggleOrderBy(propertyIdentifier, true); //single column mode true
	                        }
	                        if (_this.inListingDisplay) {
	                            _this.listingService.setSingleColumnOrderBy(_this.listingId, propertyIdentifier, "DESC");
	                        }
	                        if (_this.inListingDisplay)
	                            _this.listingService.setManualSort(_this.listingId, false);
	                    }
	                    break;
	                case "MANUAL":
	                    //flip listing
	                    _this.disabled = true;
	                    if (_this.inListingDisplay) {
	                        _this.listingService.setManualSort(_this.listingId, true);
	                    }
	                    break;
	            }
	        };
	        this.sortAscending = function () {
	            _this.sortCode = 'ASC';
	            _this.updateOrderBy();
	        };
	        this.sortDescending = function () {
	            _this.sortCode = 'DESC';
	            _this.updateOrderBy();
	        };
	        this.manualSort = function () {
	            _this.sortCode = 'MANUAL';
	            _this.updateOrderBy();
	        };
	        if (angular.isUndefined(this.edit)) {
	            this.edit = true;
	        }
	        if (angular.isDefined(this.collectionConfig)) {
	            this.columns = this.collectionConfig.columns;
	        }
	        if (angular.isDefined(this.initialSortDefaultDirection) && this.initialSortDefaultDirection.length > 0) {
	            this.sortCode = this.initialSortDefaultDirection;
	        }
	        if (angular.isDefined(this.initialSortProperty) && this.initialSortProperty.length > 0) {
	            this.selectedPropertyIdentifier = this.initialSortProperty;
	        }
	        this.id = this.utilityService.createID(32);
	    }
	    return SWOrderByControlsController;
	}());
	exports.SWOrderByControlsController = SWOrderByControlsController;
	var SWOrderByControls = (function () {
	    // @ngInject
	    function SWOrderByControls($compile, scopeService, listingService, corePartialsPath, hibachiPathBuilder) {
	        var _this = this;
	        this.$compile = $compile;
	        this.scopeService = scopeService;
	        this.listingService = listingService;
	        this.corePartialsPath = corePartialsPath;
	        this.transclude = true;
	        this.restrict = "EA";
	        this.scope = {};
	        this.bindToController = {
	            collectionConfig: "=?",
	            selectedOrderByColumn: "=?",
	            inListingDisplay: "=?",
	            toggleCollectionConfig: "=?",
	            initialSortProperty: "@?",
	            initialSortDefaultDirection: "@?",
	            sortPropertyFieldName: "@?",
	            sortDefaultDirectionFieldName: "@?",
	            edit: "=?"
	        };
	        this.controller = SWOrderByControlsController;
	        this.controllerAs = "swOrderByControls";
	        this.compile = function (element, attrs, transclude) {
	            return {
	                pre: function ($scope, element, attrs) {
	                    if ($scope.swOrderByControls.inListingDisplay &&
	                        _this.scopeService.hasParentScope($scope, "swListingDisplay")) {
	                        var listingDisplayScope = _this.scopeService.getRootParentScope($scope, "swListingDisplay")["swListingDisplay"];
	                        $scope.swOrderByControls.listingId = listingDisplayScope.tableID;
	                        _this.listingService.attachToListingInitiated($scope.swOrderByControls.listingId, $scope.swOrderByControls.updateOrderBy);
	                        if ($scope.swOrderByControls.collectionConfig == null &&
	                            listingDisplayScope.collectionConfig != null) {
	                            $scope.swOrderByControls.collectionConfig = listingDisplayScope.collectionConfig;
	                        }
	                    }
	                },
	                post: function ($scope, element, attrs) {
	                }
	            };
	        };
	        this.templateUrl = hibachiPathBuilder.buildPartialsPath(corePartialsPath) + "orderbycontrols.html";
	    }
	    SWOrderByControls.Factory = function () {
	        var directive = function ($compile, scopeService, listingService, corePartialsPath, hibachiPathBuilder) { return new SWOrderByControls($compile, scopeService, listingService, corePartialsPath, hibachiPathBuilder); };
	        directive.$inject = ["$compile", "scopeService", "listingService", "corePartialsPath",
	            "hibachiPathBuilder"];
	        return directive;
	    };
	    return SWOrderByControls;
	}());
	exports.SWOrderByControls = SWOrderByControls;


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/// <reference path='../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../typings/tsd.d.ts' />
	//controllers
	var alertcontroller_1 = __webpack_require__(99);
	//services
	var alertservice_1 = __webpack_require__(100);
	var alertmodule = angular.module('hibachi.alert', [])
	    .controller('alertController', alertcontroller_1.AlertController)
	    .service('alertService', alertservice_1.AlertService);
	exports.alertmodule = alertmodule;


/***/ },
/* 99 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var AlertController = (function () {
	    //@ngInject
	    function AlertController($scope, alertService) {
	        $scope.$id = "alertController";
	        $scope.alerts = alertService.getAlerts();
	    }
	    return AlertController;
	}());
	exports.AlertController = AlertController;


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	//import Alert = require('../model/alert');
	var alert_1 = __webpack_require__(101);
	var AlertService = (function () {
	    function AlertService($timeout, alerts) {
	        var _this = this;
	        this.$timeout = $timeout;
	        this.alerts = alerts;
	        this.newAlert = function () {
	            return new alert_1.Alert();
	        };
	        this.get = function () {
	            return _this.alerts || [];
	        };
	        this.addAlert = function (alert) {
	            _this.alerts.push(alert);
	            _this.$timeout(function () {
	                _this.removeAlert(alert);
	            }, 3500);
	        };
	        this.addAlerts = function (alerts) {
	            angular.forEach(alerts, function (alert) {
	                _this.addAlert(alert);
	            });
	        };
	        this.removeAlert = function (alert) {
	            var index = _this.alerts.indexOf(alert, 0);
	            if (index != undefined) {
	                _this.alerts.splice(index, 1);
	            }
	        };
	        this.getAlerts = function () {
	            return _this.alerts;
	        };
	        this.formatMessagesToAlerts = function (messages) {
	            var alerts = [];
	            if (messages && messages.length) {
	                for (var message in messages) {
	                    var alert = new alert_1.Alert(messages[message].message, messages[message].messageType);
	                    alerts.push(alert);
	                    if (alert.type === 'success' || alert.type === 'error') {
	                        _this.$timeout(function () {
	                            alert.fade = true;
	                        }, 3500);
	                        alert.dismissable = false;
	                    }
	                    else {
	                        alert.fade = false;
	                        alert.dismissable = true;
	                    }
	                }
	            }
	            return alerts;
	        };
	        this.removeOldestAlert = function () {
	            _this.alerts.splice(0, 1);
	        };
	        this.alerts = [];
	    }
	    return AlertService;
	}());
	AlertService.$inject = [
	    '$timeout'
	];
	exports.AlertService = AlertService;


/***/ },
/* 101 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	//model
	var Alert = (function () {
	    function Alert(msg, type, fade, dismissable) {
	        this.fade = false;
	        this.dismissable = false;
	        this.msg = msg;
	        this.type = type;
	        this.fade = fade;
	        this.dismissable = dismissable;
	    }
	    return Alert;
	}());
	exports.Alert = Alert;


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path='../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../typings/tsd.d.ts' />
	"use strict";
	//services
	var dialogservice_1 = __webpack_require__(103);
	//controllers
	var pagedialog_1 = __webpack_require__(104);
	var dialogmodule = angular.module('hibachi.dialog', []).config(function () {
	})
	    .service('dialogService', dialogservice_1.DialogService)
	    .controller('pageDialog', pagedialog_1.PageDialogController)
	    .constant('dialogPartials', 'dialog/components/');
	exports.dialogmodule = dialogmodule;


/***/ },
/* 103 */
/***/ function(module, exports) {

	"use strict";
	var DialogService = (function () {
	    function DialogService(hibachiPathBuilder) {
	        var _this = this;
	        this.hibachiPathBuilder = hibachiPathBuilder;
	        this.get = function () {
	            return _this._pageDialogs || [];
	        };
	        this.addPageDialog = function (name, params) {
	            var newDialog = {
	                'path': name + '.html',
	                'params': params
	            };
	            _this._pageDialogs.push(newDialog);
	        };
	        this.removePageDialog = function (index) {
	            _this._pageDialogs.splice(index, 1);
	        };
	        this.getPageDialogs = function () {
	            return _this._pageDialogs;
	        };
	        this.removeCurrentDialog = function () {
	            _this._pageDialogs.splice(_this._pageDialogs.length - 1, 1);
	        };
	        this.getCurrentDialog = function () {
	            return _this._pageDialogs[_this._pageDialogs.length - 1];
	        };
	        this._pageDialogs = [];
	        this.hibachiPathBuilder = hibachiPathBuilder;
	    }
	    return DialogService;
	}());
	DialogService.$inject = [
	    'hibachiPathBuilder'
	];
	exports.DialogService = DialogService;


/***/ },
/* 104 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var PageDialogController = (function () {
	    //@ngInject
	    function PageDialogController($scope, $location, $log, $anchorScroll, $hibachi, dialogService) {
	        $scope.$id = 'pageDialogController';
	        //get url param to retrieve collection listing
	        $scope.pageDialogs = dialogService.getPageDialogs();
	        $scope.scrollToTopOfDialog = function () {
	            $location.hash('/#topOfPageDialog');
	            $anchorScroll();
	        };
	        $scope.pageDialogStyle = { "z-index": 3000 };
	    }
	    return PageDialogController;
	}());
	exports.PageDialogController = PageDialogController;


/***/ },
/* 105 */
/***/ function(module, exports) {

	module.exports = {
		"data": {
			"dateFormat": "mmm dd, yyyy",
			"debugFlag": true,
			"applicationKey": "Slatwall",
			"action": "slatAction",
			"instantiationKey": "8E7ECAC7-084F-B86E-ADB603F47C77E23C",
			"baseURL": "",
			"timeFormat": "hh:mm tt",
			"rbLocale": "en_us"
		}
	};

/***/ },
/* 106 */
/***/ function(module, exports) {

	module.exports = {
		"admin.entity.promotionreward.discounttype.percentageoff": "Percentage Off",
		"entity.orderitemgiftrecipient_plural": "Gift Recipients",
		"entity.vendororder.billtolocation": "Bill To Location",
		"validate.create.product_create.purchaseenddatetime.gtnow": "Purchase End Date must occur in the future",
		"define.emailaddressconfirm": "Confirm Email Address",
		"entity.setting.settingid": "settingID",
		"entity.taxcategoryrate.taxcategoryrateid": "Tax Category Rate ID",
		"define.onthe": "on the",
		"entity.permission.allowactionflag": "Allow Action Flag",
		"entity.alternateskucode.alternateskucode": "Sku Code",
		"entity.setting.settingvalue": "Setting Value",
		"admin.report.default.builtinreports": "Built In Reports",
		"entity.report.dynamicdaterangetype.quarters": "Quarter(s)",
		"entity.roundingrule": "Rounding Rule",
		"entity.physicalcount.physicalcountid": "Physical Count ID",
		"entity.orderdelivery.trackingnumber": "Tracking Number",
		"entity.attributevalue.orderfulfillment": "Order Fulfillment",
		"entity.setting.subscriptionterm": "Subscription Term",
		"validate.createreturn.order_createreturn.orderitems.haspositiveorderitemquantity": "You must define at least one order item to return with a quantity greater than 0.",
		"entity.orderitem_plural": "Order Items",
		"entity.report.dynamicdaterangetype.monthtodate": "Month to Date",
		"entity.orderitem.orderitemtype": "Order Item Type",
		"entity.vendor.accountnumber": "Account Number",
		"admin.entity.createreport_nav": "Save As New Report",
		"define.ofthemonth": "of the month",
		"entity.accountloyaltyredemption.redemptiontype.cashcouponcreation": "Cash Coupon Creation",
		"entity.vendoraddress.address": "address",
		"entity.account": "Account",
		"setting.shippingmethodrateminimumamount": "Minimum Rate Amount",
		"define.transactiontype": "Transaction Type",
		"admin.entity.order.addorderpayment_error": "There was an error adding the Order Payment",
		"admin.entity.imagetabs.image": "Image",
		"setting.globallogmessages": "Slatwall Application Logging",
		"entity.vendorskustock.lastupdateddatetime": "lastUpdatedDateTime",
		"entity.attribute.attributecode": "Attribute Code",
		"entity.shippingmethodrate.shippingmethodrateid": "Shipping Method Rate ID",
		"setting.integrationmuralegacyshoppingcart_hint": "If you have upgraded from a previous version of Slatwall that used the filename hooks, and the 'frontend' subsystem, then the filename of that page should be in this field",
		"entity.audit.audittype.rollback": "Rollback",
		"admin.entity.detailorder.payments": "Payments",
		"entity.productschedule.reservationendtime": "Reservation end time",
		"entity.promotionqualifier.excludedbrands": "Excluded Brands",
		"entity.paymentmethod.sortorder": "Sort Order",
		"entity.attribute.attributeinputtype.attextbox": "Text Box",
		"entity.account.process.forgotpassword": "Forgot Password",
		"entity.option.defaultimage": "Default Image",
		"setting.skuallowwaitlistingflag_hint": "Indicate whether waitlisting is allowed on this event",
		"entity.promotionqualifier.options": "Options",
		"setting.siteorderorigin": "Order Origin",
		"entity.taxcategory": "Tax Category",
		"entity.type.childtypes": "Child Types",
		"entity.sku.price": "Price",
		"entity.option.optiongroup.optiongroupname": "Option Group Name",
		"entity.sku.qia": "QIA",
		"entity.physical.brands": "Physical Brands",
		"admin.entity.processsite.create_error": "There was a problem saving site",
		"validate.edit.physical.physicalstatustypesystemcode.inlist": "The physical cannot be edited as the physical count has been commited.",
		"admin.account.processsubscriptionusage.renewsubscription_nav": "Renew Subscription",
		"processobject.account_setupinitialadmin.adminaccessflag": "Admin Access",
		"entity.eventregistration.eventregistrationid": "Event Registration ID",
		"entity.accountloyaltyredemption.redemptiontype.pricegroupassignment": "Price Group Assignment",
		"setting.skubundleinventory": "Bundle Inventory",
		"entity.vendoraccount.account": "Account",
		"entity.orderfulfillment.fulfillmentcharge": "Fulfillment Charge",
		"entity.stock": "Stock",
		"entity.promotionperiod.promotionrewards": "Promotion Rewards",
		"entity.product.process.updateskus": "Update Skus",
		"entity.define.expirationmonth": "Expiration Month",
		"entity.promotionreward.maximumuseperorder_hint": "This defines the maximum number of times that this reward can be applied to an order.",
		"permission.product.detailproductreview": "Product Review - Detail",
		"entity.sku.promotionrewards": "Promotion Rewards",
		"define.text": "Text",
		"define.december": "December",
		"define.giftcard": "Gift Card",
		"entity.paymenttransaction.authorizationcode": "Auth. Code",
		"admin.entity.processproduct.create_success": "The product has been successfully created.",
		"permission.account.saveaccount": "Account - Save",
		"setting.integrationpayleapusername": "User Name",
		"setting.globaldisplayintegrationprocessingerrors": "Display Integration Processing Errors",
		"entity.vendorphone.vendorphonetype": "vendorPhoneType",
		"entity.paymentmethod.process.processgiftcardpayment": "Process Gift Card Payment",
		"admin.entity.shippingmethodtabs.shippingmethodsettings": "Shipping Method Settings",
		"setting.integrationendiciasyncftpsiteport": "FTP Sync Port",
		"entity.shippingmethodrate.minimumshipmentquantity": "Min Fulfillment Quantity",
		"admin.entity.subscriptionusagetabs.usagebenifits": "Subscription Usage Benefits",
		"entity.accountpaymentmethod.giftcardnumberencrypted": "Gift Card Number",
		"entity.account.process.lock": "Lock",
		"validate.account.accessid": "The access ID you provided is invalid.",
		"entity.permission.item": "Item",
		"admin.entity.processsubscriptionusage.renew_success": "The subscription has been renewed successfully.",
		"admin.entity.createpromotionqualifiermerchandise": "Merchandise Item Qualifier",
		"entity.promotionqualifier.products": "Products",
		"define.print": "Print",
		"entity.category.childcategories": "Child Categories",
		"entity.sku.shippingweight": "Shipping Weight",
		"setting.integrationuspspackagelength": "Package Length",
		"permission.setting.detailtask": "Task - Detail",
		"entity.vendororder.vendororderid": "Vendor Order ID",
		"validate.changeeventdates.sku_changeeventdates.eventendtime.gtdatetimeproperty": "",
		"entity.pricegrouprate.displayname": "Name",
		"entity.sku.qea": "QEA",
		"entity.integration.dataactiveflag": "Data Integration Active",
		"entity.product.activeflag_hint": "Item is available for utilization in the back-end",
		"processobject.subscriptionusage_renew.renewalpaymenttype.none": "No Payment, Just Create Invoice",
		"entity.taxapplied.taxcountrycode": "Tax Country Code",
		"define.dimensions": "Dimensions",
		"entity.giftcard.owneremailaddress": "Email Address",
		"entity.orderdeliveryitem.stock": "Stock",
		"entity.subscriptionusage.initialproduct": "Initial Product",
		"permission.order.listorderfullfillment": "Order Fulfillment - List",
		"entity.attribute.validationregex": "Validation Regex",
		"admin.entity.attributesettabs.description": "Attribute Set Description",
		"admin.entity.updateproductcache_success": "Product Cache Update Started",
		"setting.integrationfullcirclecompanycode_hint": "Full Circle Company Code",
		"processobject.subscriptionusage_renew.prorateexpirationdate": "New Expiration Date",
		"permission.setting.deletemeasurementunit": "Measurement Unit - Delete",
		"entity.promotionqualifier": "Promotion Qualifier",
		"entity.account.termaccountavailablecredit": "Term Account Available Credit",
		"validate.save.promotionrewardcurrency.currencycode.neqproperty.promotionreward.currencycode": "This default promotion reward currency cannot be edited, if you would like to change the amount in this currency then just update the value on the promotion reward itself.",
		"entity.taxcategoryrate.taxaddresslookup.shipping": "Shipping Only",
		"entity.sku.promotionrewardexclusions": "Promotion Reward Exclusions",
		"entity.permissiongroup.permissiongroupid": "Permission Group ID",
		"entity.sku.webwholesaleqexp": "webWholesaleQEXP",
		"entity.country.countryisonumber": "Country ISO Number",
		"permission.setting.savesetting": "Setting - Save",
		"entity.paymentmethod.paymentmethodtype.giftcard": "Gift Card",
		"entity.stockadjustment_plural": "Stock Adjustments",
		"define.quantityshipped": "Shipped",
		"validate.define.pricemustbenumeric": "Price Must Be Numeric",
		"entity.addresszone": "Address Zone",
		"define.benefits": "Benefits",
		"entity.pricegroup.accounts": "Accounts",
		"define.notconfirmed": "The value that was entered does not match the 'confirm' value.",
		"setting.integrationorbitalpassword": "Password",
		"validate.account.accountauthenticationexists": "There is already an admin account authorized.",
		"entity.orderreturn.process.receivereturn": "Receive Order Return",
		"entity.option": "Option",
		"entity.updatescript.loadorder": "Load Order",
		"entity.subscriptionterm.subscriptionbenefits": "Subscription Benefits",
		"entity.paymentmethod.process.processexternalpayment": "Process External Payment",
		"setting.globalpageorderstatus": "Order Status Page",
		"entity.subscriptionbenefit.excludedcategories": "Excluded Categories",
		"admin.entity.processproduct.updateskus_success": "Skus Updated Successfully",
		"validate.edit.giftcard.giftcardcode.caneditordelete": "You cannot edit a gift card once it has been issued.",
		"entity.email.emailfailto": "Email Fail To",
		"entity.loyaltyterm.loyaltytermid": "Loyalty Term ID",
		"permission.schedule": "Schedule",
		"entity.attributeoption.sortorder": "Sort Order",
		"admin.entity.processaudit.rollback_error": "There was an error during the rollback",
		"admin.entity.processeventregistration.attend_success": "Registration has been changed to Attended.",
		"entity.option.promotionqualifierexclusions": "Promotion Qualifier Exclusions",
		"frontend.checkout.detail": "Checkout",
		"setting.integrationelavonpin": "Pin",
		"entity.entityqueue.entityqueueid": "Entity Queue ID",
		"entity.collection.collectioncode": "Collection Code",
		"entity.integration.process.test": "Test Integration",
		"admin.entity.createlocationtransferadjustment": "Location Transfer Adjustment",
		"entity.collection.collectionobject": "Collection Type",
		"entity.order.process.placeorder.fulfillmentrequirementerror": "The order could not be placed because it was missing valid fulfillment infomation",
		"define.recurring": "Recurring",
		"entity.country.streetaddresslabel": "Street Address Label",
		"admin.main.update": "Slatwall Update Utility",
		"entity.order.process.takeoffhold": "Take Order Off Hold",
		"entity.accountpayment.bankaccountnumberencrypted": "Bank Account Number Encrypted",
		"entity.orderitem.calculatedextendedpriceafterdiscount": "Extended Price After Discount",
		"entity.orderpayment.referencedorderpayment": "Referenced Order Payment",
		"entity.accountloyaltytransaction.expirationdatetime": "Expiration Date Time",
		"entity.physicalcount.physicalcountitems": "Physical Count Items",
		"entity.form.process.addformquestion": "Add Form Question",
		"entity.term.renewalsubscriptionusageterms": "Renewal Subscription Usage Terms",
		"validate.addeventschedule.product_addeventschedule.eventenddatetime.gtnow": "Event end date must occur in the future.",
		"entity.order.totalnondepositamount": "Total Amount Required For Non-deposit eligible Items",
		"admin.entity.promotionqualifier.edit_disabled": "This promotion period cannot be edited because it has expired.",
		"entity.orderfulfillment.subtotal": "Subtotal",
		"processobject.sku_changeeventdates.eventstarttime": "New start time",
		"setting.integrationvirtualmerchanttestuserid": "Test Virtual Merchant User ID",
		"entity.product.calculatedsaleprice": "Calculated Sale Price",
		"entity.paymentmethod.paymentmethodtype.check": "Check",
		"validate.processorder_forceitemquantityupdate.forceditemquantityadjusted": "${sku.product.title} - ${sku.skuDefinition} on your order had the quantity updated from ${oldQuantity} to ${newQuantity} because of inventory constraints.",
		"entity.permission.allowprocessflag": "Allow Process Flag",
		"setting.integrationmuralegacycreateaccount_hint": "If you have upgraded from a previous version of Slatwall that used the filename hooks, and the 'frontend' subsystem, then the filename of that page should be in this field",
		"validate.save.account.primaryemailaddress.getprimaryemailaddressesnotinuseflag": "You cannot set that email address as the primary email address because it is the primary email address of another account.",
		"entity.sku.saleprice": "Sale Price",
		"entity.productimage.imagename": "Image Name",
		"entity.image.options": "Options",
		"entity.order.paymentamountdueaftergiftcards": "Payment Amount Due After Gift Card Charges",
		"validate.create.orderdelivery_create.giftcardcodes.hasallgiftcardcodes": "You don not have enough gift card numbers to fulfill these items.",
		"define.sec": "Sec.",
		"entity.attributeset_plural": "Attribute Sets",
		"entity.filerelationship.baseid": "Base ID",
		"entity.term.graceperiodsubscriptionusageterms": "Grace Period Subscription Usage Terms",
		"admin.main.sendpasswordreset": "Send Password Reset",
		"entity.promotion.delete_success": "Promotion Deleted",
		"setting.accountfailedadminloginattemptcount_hint": "This is the max number of login attempts than an admin user gets before their account is locked.",
		"define.failure": "Failure",
		"setting.accountdisplaytemplate_hint": "The content object that you would like to use as the template for displaying account on the front-end.  Typically this is a page in your CMS or Custom Application",
		"admin.entity.processorder.addpromotioncode_success": "Promotion Code Applied",
		"admin.entity.preprocesseventregistration_include.changestatuscomment": "Add comment (optional)",
		"define.bar": "Bar",
		"validate.addorderitem.order_addorderitem.quantity.lteproperty.sku.qats": "The quantity that you have added to your cart is greater than the amount available.",
		"entity.subscriptionusage.autopayflag": "Auto Pay",
		"admin.entity.accounttabs.subscriptionusage": "Subscription Usage",
		"entity.order.process.removeorderitem": "Remove Order Item",
		"entity.attributevalue.profile": "profile",
		"admin.entity.contenttabs.settings": "Settings",
		"entity.promotionqualifier.excludedoptions": "Excluded Options",
		"entity.orderreturn.orderreturnitems": "Order Return Items",
		"setting.integrationmuralegacymyaccount_hint": "If you have upgraded from a previous version of Slatwall that used the filename hooks, and the 'frontend' subsystem, then the filename of that page should be in this field",
		"entity.inventory.stockreceiveritem": "Stock Receiver Item",
		"entity.currencyrate.currencyrateid": "Currency Rate ID",
		"entity.vendorphonenumber.phonenumber": "Phone Number",
		"processobject.account_create.createauthenticationflag": "Create Account Password",
		"entity.account.organizationflag": "Organization Flag",
		"entity.loyaltyaccruement.expirationterm": "Expiration Term",
		"admin.entity.processsku.removelocation_success": "Location removed successfully.",
		"entity.account.remotecontactid": "Remote Contact ID",
		"entity.loyaltyaccruement.loyaltyaccruementid": "Loyalty Program Accruement ID",
		"define.count": "Count",
		"admin.define.or": "OR",
		"setting.globalpageorderconfirmation": "Order Confirmation Page",
		"entity.accountauthentication.account": "Account",
		"setting.integrationavataxtaxexemptpropertyidentifier": "Tax Exempt Property Identifier",
		"validate.define.minlength": "${propertyName} must be ${constraintValue} or more characters long",
		"define.qmin": "QMIN",
		"entity.productbundlegroup.skupricepercentagedecrease": "Sku Price Percentage Decrease",
		"admin.entity.createpromotionrewardcurrency": "Add Promotion Reward Currency",
		"entity.address.middlename": "Middle Name",
		"define.salutationmiss": "Miss.",
		"entity.locationaddress.location": "Location",
		"entity.skucurrency.skucurrencyid": "Sku Currency ID",
		"setting.productdisplaytemplate_hint": "The content object that you would like to use as the template for displaying product on the front-end.  Typically this is a page in your CMS or Custom Application",
		"admin.orderdetail.orderitems.details": "Details",
		"entity.site.sitecode": "Site Code",
		"entity.location.locationaddresses": "Location Addresses",
		"entity.productrelationship.productrelationshipid": "Product Relationship ID",
		"entity.integration.shippingreadyflag": "Shipping Ready Flag",
		"define.radiogroup": "Radio Group",
		"entity.accountattributeset": "Account Attribute Set",
		"entity.loyaltyredemption.autoredemptiontype": "Auto Redemption Type",
		"entity.promotionqualifier.rewardmatchingtype.product": "Product",
		"entity.product.delete_success": "The Product was successfully deleted.",
		"entity.producttype.physicals": "Physicals",
		"entity.workflowtask.activeflag": "Active",
		"entity.roundingrule.roundingruleexpression_hint": "This sting allows you to define how you would like to round a value.  For example to round to the nearest .49 or .99 this would be your rounding ule expression: .49,.99",
		"entity.content.fulltitle": "Content Title",
		"entity.loyaltyredemption.activeflag": "Active Flag",
		"entity.promotionreward.excludedoptions": "Option Exclusions",
		"entity.promotionreward.rewardtype.product": "Product",
		"entity.subscriptionusage.mostrecentorderitem": "Most Recent Order Item",
		"entity.vendor.vendorphonenumbers": "Vendor Phone Numbers",
		"setting.skucurrency_hint": "Skus can be sold in multiple currencies, however this setting dictates the currency that is stored as the primary price.",
		"define.expired": "Expired",
		"processobject.order_createreturn.fulfillmentrefundamount": "Fulfillment Refund Amount",
		"entity.attribute.attributeinputtype.atradiogroup": "Radio Group",
		"entity.profiletemplate.profiletemplatename": "profileTemplateName",
		"entity.addresszone_plural": "Address Zones",
		"admin.entity.editorderitem_disabled": "Cannot edit an orderitem which is part of a processed order.",
		"entity.subscriptionorderitem.subscriptionorderitemtype": "Subscription Order Item Type",
		"entity.loyaltyaccruement.pointquantity": "Point Ratio",
		"entity.accountloyaltytransaction.orderfulfillment": "Order Fulfillment",
		"entity.type.parenttype": "parentType",
		"entity.commentrelationship.account": "Account",
		"define.expires": "Expires",
		"setting.integrationmerchantesolutionstestapiurl": "Test API URL",
		"admin.entity.promotionrewardtabs.products": "Products",
		"entity.vendororderitem.quantityunreceived": "Qty. Unreceived",
		"entity.address.salutation": "Salutation",
		"entity.content_plural": "Content",
		"admin.entity.updatefrontendviews": "Update All Frontend Views",
		"processobject.order_addorderitem.saveshippingaccountaddressflag": "Save as Account Address",
		"entity.order.subtotal": "Subtotal",
		"entity.subscriptionusage.nextreminderemaildate": "Next Reminder Email",
		"processobject.sku_addeventregistration.newaccountflag": "New Account?",
		"entity.taskhistory.successflag": "Task Success",
		"entity.vendororderitem.stock": "Stock",
		"setting.emailtoaddress": "Email To Address",
		"entity.pricegrouprate.pricegrouprateid": "Price Group Rate ID",
		"setting.integrationavataxtaxexemptrequirescompanypaymentmethodflag_hint": "Even if the propertyIdentifier says that this order should be tax exempt this will further require that the company payment method is a corporate payment method",
		"entity.orderitem.extendedpriceafterdiscount": "Total",
		"admin.entity.listeventregistration": "Event Registrations",
		"entity.address.locality": "Locality",
		"setting.subscriptionusagerenewalreminderdays": "Renewal Reminder Day(s)",
		"admin.metaremoved_info": "The /meta directory has been removed!",
		"validate.save.accountemailaddress.emailaddress.getprimaryemailaddressnotinuseflag": "The email address that you have entered is already in use as the primary email address for another account.",
		"entity.serverinstance": "Server Instance",
		"entity.define.creditcardtype": "Credit Card Type",
		"admin.entity.settingstabs.producttype": "Product Type Settings",
		"admin.main.update.currentreleasetype": "Current Release Type",
		"setting.skuorderminimumquantity_hint": "Minimum per SKU Qty. allowed on order",
		"entity.image.imagetype": "Image Type",
		"entity.product.delete_validateordered": "This product cannot be deleted because it has been ordered.",
		"entity.pricegroup.pricegroupid": "Price Group ID",
		"entity.orderdeliveryitem.referencingorderitems": "Referencing Order Items",
		"setting.emailsmtppassword": "SMTP Password",
		"admin.entity_permission": "Additional Misc",
		"processobject.orderdelivery_create.useshippingintegrationfortrackingnumber": "Use Integration to get tracking number?",
		"entity.orderpayment.termpaymentaccount": "Term Payment Account",
		"entity.vendor.vendorwebsite_hint": "The vendor website must begin with http:// or https://",
		"defaultmessage_collectionsize_between": "{1} size is not between {2} and {3}.",
		"entity.workflowtask.workflowtaskid": "Workflow Task ID",
		"event.onapplicationrequestend": "On Application Request End",
		"entity.promotionreward.rewardtype": "Reward Type",
		"entity.promotionaccount.enddatetime": "End Date Time",
		"setting.integrationvertexwebservicestrustedid_hint": "Authentication ID used instead of Username / Password",
		"permission.product.deleteproduct": "Product - Delete",
		"admin.define.termpaymentdetails": "Term Payment Details",
		"validate.save.orderpayment.amount.lteproperty.maximumpaymentmethodpaymentamount": "The order payment amount exceeds the allowable percentage for this payment method",
		"entity.audit.changedetails.property": "Property",
		"entity.vendororder.process.addvendororderitem": "Add Item",
		"permission.pricing.savepricegroup": "Price Group - Save",
		"entity.vendororderitem.stockreceiveritems": "Stock Receiver Items",
		"entity.optiongroup.options": "Options",
		"define.unlimited": "Unlimited",
		"entity.order.account": "Customer Account",
		"entity.emailtemplate.emailtemplatename": "Template Name",
		"entity.address.calculatedaddressname": "Address Name",
		"entity.loyaltyaccruement.excludedskus": "Excluded Skus",
		"entity.product.price_hint": "The everyday price at which this product will be sold on your site (do not appy sales/promotions here).",
		"entity.paymentmethod.placeordercredittransactiontype_hint": "This type of transaction will be run for all 'credit' order payments when the order is placed.",
		"setting.integrationauthorizenettestserverflag_hint": "This should be set to YES if your authorize.net account is a test account at http://sandbox.authorize.net",
		"entity.pricegrouprate.amounttype": "Rate Type",
		"entity.orderitem.order": "Order",
		"entity.updatescript.successfulexecutioncount": "Successful Execution Count",
		"mura.main.updateviews_permission": "Update Views",
		"processobject.subscriptionusage_renew.renewalpaymenttype.orderpayment": "Previous Subscription Payment",
		"entity.taskhistory_plural": "Task Histories",
		"setting.accountfailedpublicloginattemptcount": "Max Public Failed Login Attempts",
		"entity.stockadjustment.stockadjustmentstatustype": "Status",
		"frontend.cart.update": "Update Cart",
		"permission.report.order": "Orders",
		"entity.image_plural": "Images",
		"entity.define.publicremoteid": "Public Remote ID",
		"define.qnrovo.full": "Not Received On Vendor Order",
		"entity.attributevalue.image": "Image",
		"entity.accountloyalty.accountloyaltytransactions": "Account Loyalty Transactions",
		"permission.setting.createcontent": "Content - Create",
		"entity.sku.process.logattendance": "Log Attendance",
		"entity.subscriptionusage.subscriptionterm": "Subscription Term",
		"entity.vendororderitem.extendedcost": "Extended Cost",
		"setting.globaluseshippingintegrationfortrackingnumberoption": "Use Shipping Integration For Tracking Number Option",
		"entity.stockreceiver_plural": "Stock Receivers",
		"setting.globalpageshoppingcart": "Shopping Cart Page",
		"entity.stockhold": "Stock Hold",
		"entity.orderaccount": "Account",
		"entity.location.locationidpath": "Location ID Path",
		"admin.entity.settingstabs.account": "Account Settings",
		"admin.entity.processsku.breakupbundledskus_success": "Bundled sku breakup was successful.",
		"validate.define.url": "The ${propertyName} is not valid url, be sure to inclide http:// or https:// at the begining of the URL.",
		"entity.emailbounce.emailbounceid": "Email Bounce ID",
		"setting.skueligibleorderorigins": "Eligible Order Origins",
		"entity.product.gendertype": "genderType",
		"entity.eventregistration.process_exire": "Expire",
		"entity.order.fulfillmenttotal": "Delivery Charges",
		"entity.workflowtrigger_plural": "Triggers",
		"entity.vendor.primaryphonenumber": "Primary Phone Number",
		"permission.setting.listterm": "Term - List",
		"setting.contentrestrictedcontentdisplaytemplate_hint": "When a public user does not have access to this page, they will be redirected to the setting defined here.  You can add more pages to this list by creating content and setting the 'Template Type' to 'Barrier Page'",
		"entity.productreview.reviewername": "Reviewer Name",
		"setting.integrationuspspackageheight": "Package Height",
		"entity.accountaddress.account": "account",
		"entity.vendor.vendorname": "Vendor Name",
		"setting.globalmissingimagepath": "Missing Image Path",
		"entity.producttype.systemcode": "System Code",
		"entity.promotionqualifier.maximumprice": "Maximum Item Price",
		"entity.productschedule.monthlyrepeatbytype": "Repeat Monthly On",
		"entity.account.process.generateapiaccesskey": "Generate API Access Key",
		"admin.frontendexample": "Frontend Example",
		"entity.accountrelationship.account": "account",
		"entity.vendorskustock_plural": "Vendor Sku Stocks",
		"admin.entity.deletereport_nav": "Delete Saved Report",
		"entity.sku.webqc": "webQC",
		"entity.accountrelationshiprole": "Account Relationship Role",
		"setting.accountdisplaytemplate": "Account Display Template",
		"admin.entity.shippingmethodtabs.shippingmethodrates": "Shipping Rates",
		"entity.loyaltyaccruement.skus": "Skus",
		"entity.state.statename": "State Name",
		"admin.entity.listcartandquote": "Carts & Quotes",
		"permission.product.detailproducttype": "Product Type - Detail",
		"entity.workflowtaskaction.emailtemplate": "Email Template",
		"entity.paymentmethod.paymentmethodtype.termpayment": "Term Payment",
		"setting.integrationmuralegacyshoppingcart": "Legacy Shopping Cart Filename",
		"entity.taxapplied.taximpositionname": "Tax Imposition Name",
		"admin.define.delete_confirm": "Are you sure you would like to delete this ${itemEntityName}?",
		"setting.integrationavataxtaxexemptnumberpropertyidentifier": "Tax Exemption Number Property Identifier",
		"entity.pricegrouprate.skus": "Include SKUs",
		"processobject.product_addeventschedule.sellindividualskuflag": "Sell individual sku?",
		"permission.setting.saveorderorigin": "Order Origin - Save",
		"define.receiveoffline": "Receive Offline",
		"entity.order.process.updateorderamount": "Update Order Amounts",
		"define.process": "Process",
		"setting.emailfailtoaddress": "Bounced Email Reply Address",
		"entity.order.process.changecurrencycode": "Change Currency Code",
		"define.login": "Login",
		"entity.promotionreward.options": "Options",
		"admin.entity.producttypetabs.producttypedescription": "Product Type Description",
		"entity.pricegroup.parentpricegroup_hint": "Selecting a Parent Price group to inherit rates from allows you to setup a broad price group and then override / add only the rates that are different.",
		"entity.vendororderitem.cost": "Cost",
		"setting.globalallowedoutsideredirectsites": "Allowed Outside Redirect Sites",
		"entity.schedule.frequencyendtime": "End Time",
		"entity.taxapplied.orderitem": "Order Item",
		"permission.setting.savecategory": "Category - Save",
		"admin.entity.processorderfulfillment.manualfulfillmentcharge_success": "Fulfillment Charge Updated",
		"admin.entity.ordertabs.orderitems": "Order Items",
		"setting.integrationclickandbuyprojectdescription": "Project description",
		"admin.entity.detailpromotion": "Promotion Detail",
		"admin.main.dashboard.recentproductupdates": "Recently Updated Products",
		"entity.orderitem.orderreturn": "Order Return",
		"entity.currency.currencyrates": "Currency Rates",
		"entity.vendoremail.email": "Email",
		"entity.editpromotionrewardcurrency_disabled": "You cannot edit this currency.",
		"entity.giftcard.giftcardtransactions": "Transactions",
		"entity.audit.rollbackpoint": "Rollback Point",
		"entity.product.process.addskubundle": "Add Sku Bundle",
		"entity.taskschedule.schedule": "Schedule",
		"entity.stockhold.orderitem": "Order Item",
		"validate.account.forgotloginmessage": "Enter your email address, and we will send you a link to reset your password.",
		"entity.email.emailreplyto": "Email Reply To",
		"entity.orderdeliveryitem_plural": "Order Delivery Items",
		"entity.workflow.workflowobject": "Object",
		"entity.option.optioncode": "Option Code",
		"validate.promotioncode.invalidaccount": "The promotion code that you have entered is valid, but the account that you are currently using is not a valid account to use this promotion code.  If you are not logged in, then please log in and try again.",
		"entity.productbundlegroup.minimumquantity_hint": "This defines the minimum quantity of items that can be selected for this group on a per bundle build up basis.  Set this to 0 or leave blank if you would like this group to be optional, set this to 1 or greater if an item is required for this group",
		"entity.sku.imagefile": "Image File Name",
		"admin.entity.imagetabs.options": "Options",
		"admin.entity.createsubscriptionproducttype_nav": "New Subscription Product Type",
		"entity.locationconfiguration": "Location Configuration",
		"setting.taskfailureemailtemplate": "Task Failure Email Template",
		"admin.entity.emailtemplatetabs.emailsettings": "Email Settings",
		"define.notapplicable": "N/A",
		"define.receive": "Receive",
		"entity.accountloyaltytransaction.redemptiontype": "Redemption Type",
		"entity.image.promotion": "Promotion",
		"entity.taxapplied.taxstatecode": "Tax State Code",
		"entity.accountpaymentmethod.giftcardbalanceamount": "Gift Card Balance",
		"define.generatetoken": "Generate Token",
		"validation.define.numeric": "This must be a numeric value.",
		"setting.integrationfedexshippercountrycode": "Shipping From Country Code ",
		"entity.orderitem_plura": "Order Items",
		"entity.user.murauserid": "muraUserID",
		"permission.setting.savepaymentmethod": "Payment Method - Save",
		"define.toassign": "to assign",
		"setting.integrationfullcirclefcftpport_hint": "Port to connect to FTP over",
		"entity.sku.loyaltyaccruementexclusions": "Loyalty Accruement Exclusions",
		"entity.physicalcountitem_plural": "Physical Count Items",
		"admin.main.log_nav": "Slatwall Log",
		"entity.vendororder.vendor": "Vendor",
		"entity.productschedule.scheduleenddatewithouttime": "Schedule End",
		"entity.paymenttransaction_plural": "Payment Transactions",
		"entity.account.type": "Type",
		"admin.editfilteritem.definefilter": "Define Filter",
		"processobject.product_addsubscriptionterm.subscriptiontermid": "Subscription Term",
		"entity.collection.missingfilter": "No filter property has been selected",
		"entity.paymentmethod.placeorderchargetransactiontype_hint": "This type of transaction will be run for all 'charge' order payments when the order is placed.",
		"admin.entity.processphysical.addphysicalcount_error": "The file you uploaded had no valid rows to be imported.",
		"admin.entity.processphysical_addphysicalcount.additems_title": "Add Physical Count Items",
		"entity.orderitem.calculateddiscountamount": "Discount Amount",
		"entity.brand.brandwebsite": "Brand Website",
		"entity.category.cmscategoryid": "CMS Category ID",
		"entity.emailverification.emailverificationid": "Email Verification ID",
		"entity.physical.physicalstatustype": "Physical Status Type",
		"entity.content.allowpurchaseflag": "Sell This Content",
		"setting.integrationpayflowproaccountpaymentcommenttwotemplate_hint": "This template will be string replaced based on the order payment, and then passed as custom comment 2 to PayFlow Pro.  An Example would be: ${accountPaymentID} or ${myCustomAccountPaymentAttributeCode}.  Plain text works as well",
		"permission.setting.detailmeasurementunit": "Measurement Unit - Detail",
		"admin.define.list": "${itemEntityNamePlural}",
		"processobject.task_updatecalculatedproperties.updatestockskuproductflag": "Update Stocks / Skus / Products",
		"entity.sku.delete_success": "The SKU was deleted successfully.",
		"define.sum": "Sum",
		"validate.edit.physicalcountitem.physicalstatustypesystemcode.inlist": "The physical count Item cannot be edited as the physical count has been commited.",
		"defaultmessage_isvalidobjectsimplevalue": "validation failed because a valid object cannot be a simple value.",
		"setting.integrationfedexaccountno": "FedEx Account Number",
		"define.qiats": "QIATS",
		"validate.save.orderpayment.amount.lteproperty.termpaymentaccount.termaccountavailablecredit": "The order payment amount exceeds the available credit for this account",
		"entity.stock.location": "location",
		"validate.save.country.countrycode3digit.minlength": "Country Code 3 Digit must be 3 characters",
		"entity.audit.auditarchiveenddatetime": "End Date",
		"admin.pricing.createpromotionrewardcontentaccess": "Create Promotion Reward Content Access",
		"entity.account_plural": "Accounts",
		"entity.order.total": "Total",
		"entity.promotioncode.accounts": "Accounts",
		"setting.accounteligiblepaymentterms": "Eligible Payment Terms",
		"frontend.checkout.processorder": "Place Order",
		"entity.workflowtaskaction.norecordsfound": "No actions have been created",
		"define.exchange": "Exchange",
		"entity.vendor.primaryemailaddress": "Primary Email Address",
		"entity.productreview_plural": "Product Reviews",
		"define.months": "Months",
		"entity.giftcard.giftcardid": "Gift Card ID",
		"validate.duplicatecontent.content.urltitlepath.isuniqueurltitlepathbysite": "Url Title Path must be unique for this Site",
		"permission.setting.savetype": "Type - Save",
		"define.repcaptchafailed": "Invalid Captcha",
		"setting.imagealtstring": "Missing Image Alt String",
		"admin.entity.createproduct.selectsubscriptionterms": "Select Subscription Terms",
		"entity.pricegroup.inheritsfrom": "Inherits From",
		"processobject.order_createreturn.stocklossflag": "Stock Loss?",
		"entity.brand.loyaltyaccruementexclusions": "Loyalty Accruement Exclusions",
		"entity.pricegrouprate.globalflag": "Global Rate",
		"entity.address.city_validaterequired": "Please enter a valid City",
		"setting.integrationfullcirclelocaltransferurlusername_hint": "If the transfer URL sits behind a Username or Password then please specify it here.",
		"entity.shippingmethod_plural": "Shipping Methods",
		"entity.define.amountreceived": "Amount Received",
		"entity.sku.qoh": "QOH",
		"entity.account.firstname": "First Name",
		"entity.permission.propertyname": "Property Name",
		"entity.loyalty": "Loyalty Program",
		"entity.vendor.vendoraddresses": "Vendor Addresses",
		"admin.entity.producttypetabs.attributesets": "Attribute Sets",
		"entity.product.ontermsale": "onTermSale",
		"entity.account.fullname": "Name",
		"entity.content.excludefromsearch": "Exclude From Search",
		"entity.subscriptionbenefit.excludedcontents": "Excluded Contents",
		"entity.content.process.duplicatecontent": "Duplicate Content",
		"entity.promotionaccount.startdatetime": "Start Date Time",
		"entity.stockreceiveritem.orderitem": "Order Item",
		"entity.attributevalue.attributeid": "Attribute ID",
		"entity.content.templateflag": "Template",
		"define.qndoo.full": "Not Delivered On Order",
		"entity.pricegroupratecurrency": "Price Group Currency Rate",
		"validate.delete.sku.skuid.isnotdefaultsku": "The default sku cannot be deleted.",
		"entity.sku.attendedquantity": "Attended Quantity",
		"setting.accounttermcreditlimit_hint": "This value represents the maximum amount of open unpaid term payments that are allowed for a given account.",
		"entity.printtemplate.printcontent": "Print Content",
		"entity.subscriptionterm.autopayflag_hint": "If this is set to 'Yes' then when a renewal order is created, it will automatically use the payment method on file to renew the order",
		"frontend.account.editpassword": "Edit Password",
		"setting.fulfillmentmethodemailcc": "Email CC",
		"entity.orderitem.calculatedextendedunitprice": "Extended Unit Price",
		"entity.currency.formattedexample": "Formatted Example",
		"entity.physicalcountitem.stock": "Stock",
		"setting.integrationfedexshipperstreet": "Shipping From Street Address",
		"admin.entity.createaccountemailaddress": "Add Email Address",
		"entity.profiletemplateattribute.profiletemplate": "profileTemplate",
		"permission.setting": "Setting",
		"validate.edit.orderpayment.orderstatuscode.inlist": "The order payment cannot be edited as the order has been placed.",
		"admin.entity.promotionperiod.editdisabled_info": "This promotion period cannot be edited because it has expired.",
		"permission.setting.listattributeset": "Attribute Set - List",
		"validate.define.telephone": "The ${propertyName} is not a valid phone number. Valid phone numbers are 10 digits long.",
		"entity.audit.title": "Title",
		"setting.integrationclickandbuyconsumerlanguage": "Consumer language (ISO 639-1)",
		"entity.attribute.attributetype": "Input Type",
		"entity.country.postalcoderequiredflag": "Require Postal Code",
		"entity.content.listingproducts": "Listing Products",
		"entity.accountpayment.paymenttransactions": "Payment Transactions",
		"entity.category.categoryid": "Category ID",
		"entity.product.shippingweight_hint": "Weight (in lbs) to be used to calculate shipping charges.",
		"entity.paymenttransaction.transactionsuccessflag": "Success",
		"entity.define.modifiedbyaccountid": "Modified By AccountID",
		"entity.promotionreward.delete_success": "Promotion Reward Deleted",
		"entity.term.paymentterms": "Payment Terms",
		"admin.default.integrations_nav": "Integrations",
		"entity.account.pricegroups": "Price Groups",
		"entity.orderfulfillment.accountloyaltytransactions": "Account Loyalty Transactions",
		"admin.entity.subscriptionusagetabs.subscriptionusageaccounts": "Accounts",
		"entity.alternateskucode.sku": "Sku",
		"entity.accountcollection.collection": "Collection",
		"entity.integration.installedflag": "Installed Flag",
		"admin.define.creditcarddetails": "Credit Card Details",
		"entity.define.shippingaddress": "Shipping Address",
		"setting.integrationpaypalexpresspaypalaccountuser": "PayPal Classic API  User",
		"entity.orderpayment.billingaccountaddress": "Billing Account Address",
		"entity.fulfillmentbatch_plural": "Fulfillment Batches",
		"admin.warehouse.detailstockadjustment.tolocationname": "To Location Name",
		"entity.shippingmethodoptionsplitshipment": "Shipping Method Option Split Shipment",
		"processobject.sku_addeventregistration.createorderflag": "Create Order?",
		"entity.task.notificationemails": "Notification Emails",
		"admin.entity.ordertabs.accountdetails": "Account Details",
		"entity.order.orderclosedatetime": "Date Closed",
		"setting.addressdisplaytemplate": "Address Display Template",
		"entity.stockreceiver.boxcount": "Box Count",
		"entity.accountpaymentmethod.orderpayments": "Order Payments",
		"entity.promotionqualifier.minimumitemprice": "Minimum Item Price",
		"entity.giftcard.giftcardcode": "Gift Card Code",
		"validate.account.forgotnotvalid": "The email you provided is invalid",
		"entity.workflowtrigger.objectpropertyidentifier": "Object Property Identifier",
		"entity.sku.availableseatcount": "Available Seats",
		"processobject.product_create.redemptionamount": "Redemption Amount",
		"setting.integrationstripelivepublickey": "Live Publishable Key",
		"setting.integrationgigyasitename": "Site Name",
		"processobject.product_addsubscriptionsku.listprice": "List Price",
		"entity.subscriptionorderitem.subscriptionusage": "Subscription Usage",
		"entity.taskhistory.message": "Message",
		"permission.setting.deletepaymentmethod": "Payment Method - Delete",
		"entity.profiletemplateattribute.attribute": "attribute",
		"entity.subscriptionusagebenefit_plural": "Subscription Usage Benefits",
		"entity.loyalty.loyaltyaccruements": "Loyalty Accruements",
		"entity.locationaddress.address": "Address",
		"entity.permission.accesstype": "Access Type",
		"entity.pricegrouprate.producttypes": "Include Product Types",
		"entity.loyaltyredemption.redemptiontype.pointpurchase": "Point Purchase",
		"entity.taxapplied.taxjurisdictiontype": "Tax Jurisdiction Type",
		"entity.product.productid": "Product ID",
		"entity.eventregistration.process.pendingapproval": "Change to Pending Approval",
		"define.select": "Select",
		"entity.optiongroup_plural": "Option Groups",
		"entity.orderitem.itemtotal": "Item Total",
		"entity.account.accountloyalties": "Account Loyalty Programs",
		"entity.taxapplied.taxcategoryrate": "Tax Category Rate",
		"entity.skucurrency.renewalprice": "Renewel Price",
		"setting.contentrequirepurchaseflag_hint": "If this option is selected, then the only way a person will have access to this page is if they have purchased acess via content access product.",
		"entity.workflow_plural": "Workflows",
		"entity.orderitem.stockreceiveritems": "Stock Receiver Items",
		"entity.subscriptionusagebenefit.subscriptionusagebenefitaccounts": "Subscription Usage Benefit Accounts",
		"entity.order.process.placeorder.paymentprocessingerror": "There was an error processing order payment information.",
		"entity.promotionreward.shippingmethod": "Shipping Method",
		"entity.schedule.scheduleid": "Schedule ID",
		"entity.sku.process.move.warning": "If the Sku you're moving is the only sku the product will be deleted.",
		"entity.comment.parentcomment": "Related Parent Comment",
		"entity.productimage.imagefile": "Image",
		"admin.entity.producttabs.productdescription": "Product Description",
		"entity.taskschedule_plural": "Task Schedules",
		"entity.stock.sku": "sku",
		"validate.placeorder.orderfulfillment.shippingmethod.hasvalidshippingmethodrate": "Order Fulfillment does not have a valid Shipping Method Rate",
		"entity.fulfillmentmethod.autofulfillflag": "Auto Fulfill",
		"setting.integrationmerchantesolutionsprofilekey": "Merchant Key",
		"event.onsessionaccountlogout": "On Account Logout",
		"entity.order.billingaccountaddress": "Billing Account Address",
		"admin.main.update.stable": "Stable",
		"entity.term.termid": "Term ID",
		"entity.permission.section": "Section",
		"admin.define.edit_permission": "${itemEntityName} - Edit Existing",
		"entity.category.restrictaccessflag": "Restrict Access",
		"permission.product.deletesubscriptionterm": "Subscription Term - Delete",
		"entity.stockreceivervendororder_plural": "Stock Receivers",
		"entity.taskhistory": "Task History",
		"entity.order.process.placeorder.paymentrequirementerror": "The order could not be placed because it was missing valid payment infomation",
		"permission.integration.createintegration": "Integration - Create",
		"entity.accountauthentication.integrationaccesstokenexpiration": "Integration Access Token Expiration",
		"entity.physical": "Physical",
		"admin.entity.processorderitem.addrecipientstoorderitem_success": "Added Gift Recipients Successfully",
		"admin.entity.listloyalty": "Loyalty Program",
		"entity.orderdelivery_plural": "Order Deliveries",
		"setting.integrationavataxaccountno": "Avatax Account Number",
		"entity.stockadjustment.status": "Status",
		"entity.promotionreward.brands": "Brands",
		"setting.skubundleautomakeupinventoryonsaleflag": "Bundle Auto Makeup Inventory On Sale",
		"entity.task.timeout": "Timeout",
		"entity.paymentterm.paymenttermname": "Payment Term Name",
		"entity.product.purchaseenddatetime": "Purchase End Date",
		"admin.entity.vendortabs.vendoraddresses": "Vendor Addresses",
		"entity.order.process.clear": "Clear",
		"admin.entity.createaccountphonenumber": "Add Phone Number",
		"validate.account_authorizeaccount.emailaddress.notfound": "There is no account with the Email address that was provided.",
		"entity.productschedule.eventenddatetime": "Event Start",
		"permission.account.deleteaccount": "Account - Delete",
		"entity.attributevalue.attributevaluetype": "Attribute Value Type",
		"setting.contentrestrictedcontentdisplaytemplate": "No Access Template",
		"validate.save.skucurrency.listprice.minvalue": "The sku currency list price cannot be a negative value.",
		"entity.accountemailaddress.isprimary": "isPrimary",
		"entity.orderitem.orderitemid": "Order Item ID",
		"entity.promotionreward.shippingaddresszones": "Shipping Address Zones",
		"admin.entity.sku.subscriptionbenefits": "Subscription Benefits",
		"entity.stockadjustmentdeliveryitem": "Stock Adjustment Delivery Item",
		"admin.entity.detailorderpayment.dynamiccharge": "Dynamic Charge Amount",
		"entity.promotionperiod.promotionperiodname": "Promotion Period Name",
		"entity.file_plural": "Files",
		"entity.producttype.childproducttypes": "Child Product Types",
		"validate.addeventschedule.product_addeventschedule.eventenddatetime.gtdatetimeproperty": "Event end date must occur after start date.",
		"admin.define.delete_title": "Delete ${itemEntityName}",
		"entity.schedule.daysofmonthtorun": "Days of Month",
		"entity.taxcategory.taxcategoryrate": "Tax Category Rate",
		"entity.taskhistory.taskschedule": "Task Schedule",
		"setting.integrationfullcirclefcftpusername": "Full Circle FTP Username",
		"entity.attribute.attributetype.atrichtexteditor": "Rich Text Editor",
		"permission.setting.deletecountry": "Country - Delete",
		"entity.measurementunit.unitcode": "Unit Code",
		"entity.promotion.startdatetime": "Start Date/Time",
		"permission.integration.listintegration": "Integration - List",
		"setting.integrationfullcirclefcftpaddress_hint": "Full Circle FTP Address",
		"entity.orderitem.orderdeliveryitems": "Order Delivery Items",
		"admin.entity.skutabs.bundledskus": "Bundled Skus",
		"entity.stockadjustmentitem.fromstock": "From Stock",
		"setting.productmetakeywordsstring": "Product Meta Keywords String",
		"entity.attributeset.attributesetobject": "Attribute Set Object",
		"admin.entity.promotiontabs.promotionsummary": "Summary",
		"entity.session": "Session",
		"entity.stockadjustmentdeliveryitem.stockadjustmentdeliveryitemid": "Stock Adjustment Delivery Item ID",
		"define.salutationmr": "Mr.",
		"define.salutationms": "Ms.",
		"entity.vendororder.process.addorderitems": "Add Order Items",
		"processobject.order_createreturn.refundorderpaymentid": "Refund Payment",
		"report.orderitemreport.revenue": "Revenue",
		"setting.branddisplaytemplate_hint": "The content object that you would like to use as the template for displaying product on the front-end.  Typically this is a page in your CMS or Custom Application",
		"setting.globalcurrencylocale": "Currency Locale",
		"setting.integrationmurasuperusersyncflag_hint": "If set to 'yes' then any S2 Super User accounts in mura will get added to the super user group in Slatwall.  This setting will only apply if the Account Sync Type is set to 'all' or 'systemUserOnly'.",
		"permission.account.listpermissiongroup": "Permission Group - List",
		"setting.integrationorbitalterminalid": "Terminal ID",
		"entity.content.parentcontent": "Parent Content",
		"define.save": "Save",
		"entity.access.subscriptionusagebenefitaccount": "Subscription Usage Benefit Account",
		"entity.profile.profilename": "profileName",
		"admin.entity.accounttabs.accountpayments": "Account Payments",
		"permission.setting.editsetting": "Setting - Edit",
		"setting.integrationfullcirclelocaltransferurlpath": "Local Transfer URL Path",
		"entity.attribute.validationmessage": "Validation Message",
		"entity.vendorphonenumber.vendor": "Vendor",
		"define.bundleproduct": "Bundle Product",
		"entity.accountpaymentmethod.paymentmethod": "Payment Method",
		"entity.productimage_plural": "Product Images",
		"admin.entity.ordertabs.orderfulfillments": "Order Fulfillments",
		"entity.orderitem.calculatedextendedunitpriceafterdiscount": "Extended Unit Price After Discount",
		"entity.accountauthentication.authenticationdescription": "Description",
		"setting.tasksuccessemailtemplate_hint": "This email template will be used to send out success notifications in the event that a task runs successfully.",
		"define.tax": "Tax",
		"entity.product.qexp": "QEXP",
		"admin.default.tools_nav": "Tools",
		"entity.order.referencedordertype": "Order Reference Type",
		"permission.setting.editmeasurementunit": "Measurement Unit - Edit",
		"define.qvomin.full": "Min Per Order",
		"entity.currencyrate.conversioncurrencycode": "Conversion Currency Code",
		"define.qhb.full": "Held Back",
		"entity.eventregistration.waitlistqueuedatetime": "Waitlist Queue Date Time",
		"entity.accountpayment.process.offlinetransaction": "Offline Transaction",
		"setting.integrationvirtualmerchantuserid": "Virtual Merchant User ID",
		"report.productperformancereport": "Product Performance",
		"entity.orderpayment.paymentmethod": "Payment Method",
		"validate.account_authorizeaccount.password.incorrect": "Account Password Incorrect",
		"admin.account.processsubscriptionusage.updatesubscription_nav": "Update Subscription",
		"entity.profiletemplateattribute.profiletemplateattributeid": "profileTemplateAttributeID",
		"entity.taskschedule.nextrundatetime": "Next Run Time",
		"setting.integrationstripegeneratetokenbehavior": "Generate Token Behavior",
		"define.summary": "Summary",
		"entity.productreview.productreviewid": "Product Review ID",
		"entity.content.templateflag_hint": "Use this as a template for Product/Brand/Product Type",
		"admin.entity.processproduct.addoptiongroup_success": "The option group has been successfully added to the sku.",
		"permission.setting.saveroundingrule": "Rounding Rule - Save",
		"setting.integrationsagepaytestmode": "Test Mode",
		"entity.email.emailcc": "CC",
		"entity.shippingmethod.sortorder": "Sort Order",
		"entity.define.nextestimateddeliverydatetime": "Next Order Estimated Delivery Date time",
		"setting.addresshtmltitlestring": "Address HTML Title String",
		"processobject.account_setupinitialadmin.sitedomains": "Site Domains",
		"entity.attribute": "Attribute",
		"entity.orderpayment.paymenttransactions": "Payment Transactions",
		"validate.define.unique": "${propertyName} must be unique",
		"admin.entity.updateprice_nav": "Update Price",
		"entity.subscriptionorderitem_plural": "Subscription Order Item",
		"admin.entity.vendortabs.vendorbrands": "Brands",
		"admin.entity.promotiontabs.promotiondescription": "Description",
		"define.percentage": "Percentage",
		"admin.entity.addorderitemgiftrecipient.invalid": "Please Specify an email address with a first and last name for this recipient.",
		"admin.main.about_permission": "About Page",
		"processobject.account_setupinitialadmin.slatwallascmsflag": "Use Slatwall as a CMS",
		"permission.product.detailoptiongroup": "Option Group - Detail",
		"validate.createpassword.account.accountemailaddressesnotinuseflag.eq": "You can not create a password for this account because one or more of the email addresses are already associated with another account.",
		"validate.delete.physicalcountitem.physicalstatustypesystemcode.inlist": "The physical count Item cannot be deleted as the physical count has been commited.",
		"permission.setting.listfulfillmentmethod": "Fulfillment Method - list",
		"entity.loyalty.loyaltyname": "Loyalty Program Name",
		"entity.alternateskucode.alternateskucodetype": "Sku Code Type",
		"entity.skubundle.bundledquantity": "Bundled Quantity",
		"entity.stockadjustmentitem.stockadjustmentitemid": "Stock Adjustment Item ID",
		"permission.integration.saveintegration": "Integration - Save",
		"entity.attribute.relatedobject": "Related Object",
		"entity.location.locationid": "Location ID",
		"setting.integrationgigyaapikey": "API Key",
		"entity.productschedule.reservationstarttime": "Reservation start time",
		"setting.integrationpaypalexpresspaypalaccountemail": "PayPal Account Email Address",
		"setting.integrationpaypalexpresspaypalaccountpassword": "PayPal Classic API Password",
		"define.week": "Week",
		"define.basic": "Basic",
		"setting.integrationmuraaccountsynctype": "Account Sync Type",
		"entity.brand.promotionrewards": "Promotion Rewards",
		"entity.emailbounce.rejectedemailbody": "Rejected Email Body",
		"defaultmessage_false": "{1} must be false.",
		"entity.report.reportdatetimegroupby": "Report Date Time Group By",
		"entity.orderfulfillment.fulfillmentmethod": "Fulfillment Method",
		"entity.shippingmethodoption.shiptostatecode": "Ship To State Code",
		"permission.report": "Report",
		"define.qnrovo": "QNROVO",
		"admin.entity.processorder.create_success": "The new order was created successfully.",
		"entity.taxapplied.integrationtaxratetype": "Integration Tax Rate Type",
		"entity.attribute.attributeinputtype.attextarea": "Text Area",
		"entity.stockreceiveritem.vendororderitem": "Vendor Order Item",
		"entity.orderpayment.process.processtransaction": "Process Transaction",
		"setting.integrationvertexorigincurrencycode": "Origin Currency Code",
		"entity.orderorigin.orderoriginname": "Order Origin Name",
		"permission.product.savesubscriptionbenefit": "Subscription Benefit - Save",
		"validate.changeeventdates.sku_changeeventdates.eventstartdatetime.gtnow": "The event start date cannot be before now.",
		"validate.changeeventdates.sku_changeeventdates.endreservationdatetime.gtnow": "The end reservation date cannot be before now.",
		"entity.product.publishedflag": "Published",
		"entity.report.dynamicdaterangeflag": "Dynamic Date Range",
		"permission.setting.createcategory": "Category - Create",
		"entity.file.download.filemissingerror": "The file no longer exists or could not be located in file system",
		"permission.product.editoptiongroup": "Option Group - Edit",
		"entity.shortreference": "Short Reference",
		"admin.entity.shippingmethodtabs.shippingmethodratesettings": "Shipping Rate Settings",
		"entity.order.shippingaddress": "Shipping Address",
		"setting.integrationpaypalexpresscancelurl": "Cancel URL",
		"define.weight": "Weight",
		"setting.integrationparcel2goapikey": "API Key",
		"entity.sku.process.addeventregistration": "Add Event Registration",
		"admin.entity.ordertabs.returnorderitems": "Return Order Items",
		"entity.attributeset.additionalcharge": "Additional Charge",
		"entity.giftcard.process.offlinetransaction": "Adjust Balance",
		"entity.productschedule.schedulestartdatewithouttime": "Schedule Start",
		"entity.promotioncode.startdatetime": "Start Date/Time",
		"entity.workflowtask.workflowtaskactions": "Task Workflow Actions",
		"permission.pricing.detailpricegroup": "Price Group - Delete",
		"permission.setting.deletecategory": "Category - Delete",
		"entity.accountpaymentapplied.accountpaymenttype": "Account Payment Type",
		"entity.state.countrycode": "Country Code",
		"entity.stock.stockid": "stockID",
		"entity.pricegroup.loyaltyredemptions": "Loyalty Redemptions",
		"entity.order.process.duplicateorder": "Duplicate Order",
		"permission.pricing.editpricegroup": "Price Group - Edit",
		"admin.define.create_permission": "${itemEntityName} - Create New",
		"entity.entityqueue.processmethod": "Process Method",
		"validate.save.orderfulfillment.fulfillmentcharge.minvalue": "You must set the fulfillment charge to a number of 0 or larger.",
		"entity.paymentmethod.paymentintegration": "Payment Service",
		"entity.define.nameoncreditcard": "Name On Credit Card",
		"define.qats.full": "Available To Sell",
		"setting.shippingmethodratemaximumamount": "Maximum Rate Amount",
		"entity.setting.content": "Content",
		"entity.workflowtaskaction.email": "Email",
		"entity.subscriptionusage.renewalterm": "Renewal Term",
		"entity.category.parentcategory": "Parent Category",
		"setting.branddisplaytemplate": "Brand Display Template",
		"entity.fulfillmentbatchitem.quantityfulfilled": "Quantity Fulfilled",
		"entity.product.define.productcode": "Product Code",
		"setting.emailccaddress": "Email CC Address",
		"admin.entity.editphysical_disabled": "The physical count cannot be edited as it has been committed.",
		"entity.subscriptionterm.billedondayofmonth_hint": "This value is used in conjunction with the pro-rate option",
		"permission.order.deleteorderfullfillment": "Order Fulfillment - Delete",
		"frontend.account.listorders": "List Orders",
		"entity.attribute.attributetype.atradiogroup": "Radio Group",
		"entity.orderpayment.accountpaymentmethod": "Account Payment Method",
		"setting.integrationfedexmeterno": "Meter Number",
		"setting.producttypemetakeywordsstring": "Product Type Meta Keywords String",
		"setting.fulfillmentmethodshippingoptionsorttype": "Sort Shipping Options By",
		"entity.site": "Site",
		"entity.location.physicals": "Physicals",
		"admin.entity.processsku.makeupbundledskus_success": "Bundled sku makeup was successful.",
		"entity.paymentmethod.paymentmethodtype.creditcard": "Credit Card",
		"entity.optiongroup.optiongroupimage": "Option Group Image",
		"permission.product.detailsubscriptionbenefit": "Subscription Benefit - Detail",
		"validate.promotioncode.invalid": "The promotion code that you have entered is invalid.",
		"entity.promotionreward.rewardtype.shipping": "Shipping",
		"entity.account.lastname": "Last Name",
		"admin.entity.processsku.addeventregistration_success": "Event Registration add successfully.",
		"validate.define.email": "The ${propertyName} is not a valid email address.  Email addresses should follow an example like john.doe@gmail.com.",
		"define.qnrosa": "QNROSA",
		"define.0": 0,
		"validate.resetpassword.account_resetpassword.password.regex": "Admin passwords should include at least 1 letter, 1 number, and be 7 or more characters long.",
		"admin.entity.processeventregistration.waitlist_success": "Registration has been Wait Listed.",
		"admin.entity.createaddresszone": "Create New Address Zone",
		"entity.accountpaymentmethod.giftcardbalanceamountformatted": "Gift Card Balance",
		"admin.entity.settingstabs.subscriptionusage": "Subscription Usage Settings",
		"define.qnroro": "QNRORO",
		"entity.subscriptionbenefit.contents": "Content",
		"entity.eventregistration.lastname": "Last Name",
		"admin.entity.accounttabs.addresses": "Addresses",
		"setting.globalauditcommitmode": "Audit Commit Mode",
		"entity.term.initialsubscriptionterms": "Initial Subscription Terms",
		"setting.integrationstripetestpublickey": "Test Publishable Key",
		"admin.entity.createmanualinadjustment": "Manual In Adjustment",
		"entity.product.skus": "Skus",
		"event.onapplicationrequeststart": "On Application Request Start",
		"setting.globalorderplacedemailbcc": "New Order Placed Email BCC",
		"entity.promotionreward.shippingamountoff": "Shipping Rate Amount Off",
		"entity.promotioncode.maximumusecount": "Max. Use Count",
		"entity.orderitem.referencingorderitems": "Referencing Order Items",
		"admin.define.edit": "Edit ${itemEntityName}",
		"entity.eventregistration.eventregistrationstatustype": "Registration Status",
		"setting.globalencryptionkeygenerator": "Encryption Key Generator",
		"defaultmessage_minlength": "{1} must be at least {2} characters long.",
		"setting.producttypedisplaytemplate": "Product Type Display Template",
		"entity.addresszonelocation": "Address Zone Location",
		"admin.entity.detailstockadjustment.tolocationname": "To Location",
		"entity.sku.process.breakupbundledskus": "Breakup Sku Bundle",
		"admin.define.delete_success": "The ${itemEntityName} was deleted successfully.",
		"entity.accountpaymentmethod.paymentmethod.select": "Please select a payment method...",
		"setting.accounttermcreditlimit": "Term Account Credit Limit",
		"admin.define.edit_disabled": "This item can not be edited",
		"endicia.main.syncpull_permission": "FTP Sync Pull",
		"entity.emailbounce": "Email Bounce",
		"entity.baseentity.errorbean": "errorBean",
		"entity.vendororderitem.vendororder": "Vendor Order",
		"entity.order.process.placeorder": "Place Order",
		"entity.brand.delete_success": "Brand deleted",
		"setting.integrationelavontestgatewayurl": "Test API Gateway URL",
		"entity.giftcard.ownerlastname": "Last Name",
		"entity.setting.task": "Task",
		"define.temporary": "Temporary",
		"admin.entity.editorderfulfillment_disabled": "The order fulfillment cannot be edited as the order has been placed.",
		"admin.entity.processsku.move_success": "The Sku has been successfully moved to the destination product.",
		"entity.commentrelationship.physical": "Physical",
		"entity.product.listingpages": "Listing Pages",
		"entity.orderfulfillment": "Order Fulfillment",
		"entity.roundingrule.pricegrouprates": "Price Group Rates",
		"setting.globalcopycarttonewsessiononlogout": "Copy users cart to new session when the user logs out.",
		"entity.order.referencedordernumber": "Referenced Order Number",
		"entity.task.taskmethod": "Task Method",
		"entity.postalcode": "Postal Code",
		"entity.promotionreward.promotionperiod": "Promotion Period",
		"permission.warehouse.deletestockadjustment": "Stock Adjustment - Delete",
		"entity.shippingmethodoption.shiptopostalcode": "Ship To Postal Code",
		"define.qmin.full": "Minimum",
		"defaultmessage_required_dependentproperty": "{1} is required if you specify a value for {2}{3}.",
		"validate.delete.physical.physicalstatustypesystemcode.inlist": "The physical count cannot be deleted as it has been commited.",
		"validate.save.promotioncode.promotioncode.hasuniquepromotioncode": "The promotion code is not unique.",
		"processobject.order_addorderpayment.savegiftcardtoaccountflag": "Redeem Gift Card To This Account",
		"admin.entity.createpromotionrewardsubscription": "Subscription Product Discount",
		"validate.save.sku.price.minvalue": "The sku price cannot be a negative value.",
		"entity.country.streetaddressrequiredflag": "Require Street Address",
		"admin.entity.ordertabs.orderitems.saleitems": "Sale Items",
		"entity.physicalcount.physical": "Physical",
		"define.qosh.full": "On Stock Hold",
		"setting.integrationmurasuperusersyncflag": "Add Mura Super Users to Slatwall Super User Group",
		"entity.define.attributevalues": "Attribute Values",
		"permission.setting.listtaxcategory": "Tax Category- List",
		"entity.subscriptionusage.initialorderitem": "Initial Order Item",
		"entity.audit_plural": "Audits",
		"permission.setting.createterm": "Term - Create",
		"entity.vendororderitem.vendororderitemtype": "Vendor Order Item Type",
		"entity.attributeset.attributesetname": "Attribute Set Name",
		"admin.entity.integrationtabs.paymenttest": "Payment Test",
		"entity.account.accountid": "accountID",
		"entity.orderpayment_plural": "Order Payments",
		"entity.accountloyalty.account": "Account",
		"admin.entity.stocktabs.inventory": "Inventory",
		"setting.integrationupsusername": "UPS Username ",
		"validate.save.attribute.attributecode.regex": "The value entered for ${propertyName} should be alphanumeric with no spaces or hyphens.",
		"permission.product.detailbrand": "Brand - Detail",
		"entity.producttype.promotionrewards": "Promotion Rewards",
		"admin.entity.processtask.processoption.taskscheduleid": "Schedule",
		"defaultmessage_futuredate_withafter": "{1} must be a date in the future. The date entered must come after {2}.",
		"setting.integrationgigyalegacyuidpropertyidentifier_hint": "This is an an optional setting used for using legacy gigya accounts that were imported into slatwall.  You can store the old UID of the imported user in a remoteID field, or a custom attribute and then define the custom attribute code here.",
		"entity.giftcard.process.updateemailaddress_success": "The Email Has Been Successfully Sent",
		"entity.producttype.promotionrewardexclusions": "Promotion Reward Exclusions",
		"entity.promotionreward.eligiblepricegroups": "Eligible Price Groups",
		"entity.collection.parentcollection": "Base Collection",
		"validate.setupinitialadmin.account_setupinitialadmin.password.regex": "Admin passwords should include at least 1 letter, 1 number, and be 7 or more characters long.",
		"setting.globalallowcustombranchupdates": "allow custom branch updates (use at your own risk)",
		"setting.shippingmethodrateadjustmentamount": "Rate Adjustment Amount",
		"validate.account.loginblocked": "Your login has been blocked due to too many invalid attempts please contact the site adminstrator to unlock it.",
		"validate.delete.paymenttransaction.paymenttransactionid.maxlength": "Deletion of payment transactions is not permitted.",
		"admin.orderdetail.orderitems.customization": "Customization",
		"define.monday": "Monday",
		"entity.paymenttransaction.authorizationcodeused": "Auth. Code Used",
		"entity.vendorskustock.sku": "sku",
		"admin.entity.fulfillmentmethodtabs.shippingmethods": "Shipping Methods",
		"entity.workflowtaskaction": "Workflow Task Action",
		"entity.task.taskmethod.customurl": "Custom URL",
		"entity.orderpayment.process.authorizeandcharge": "Authorize & Charge",
		"setting.integrationsagepaysimulatormode": "Simulator Mode",
		"validate.processphysical_addphysicalcount.invalidfile": "The file you uploaded is not a valid file type. Please upload a valid text file ( with a .txt or .csv extension ).",
		"entity.entityqueuehistory.entityqueuehistoryid": "Entity Queue History ID",
		"setting.contentrequiresubscriptionflag_hint": "If this option is selected, then the only way a person will have access to this page is if they have purchased acess via subscription product.",
		"entity.country.countrycode3digit": "Country Code 3 Digit",
		"admin.entity.fulfillmentmethodtypes.shippingtabs.shippingmethods": "Shipping Methods",
		"entity.accountpaymentmethod.nameoncreditcard": "Name On Card",
		"entity.subscriptionusagebenefitaccount_plural": "Subscription Usage Benefit Accounts",
		"permission.order.listorder": "Order - List",
		"validate.processorder_addorderitem.orderfulfillmentid.novalidfulfillmentmethod": "There was no valid fulfillment method to add this item to the order with",
		"entity.define.giftcardnumber": "Gift Card Number",
		"entity.promotionreward.delete_validateisassigned": "This promotion code cannot be deleted because it is in use.",
		"setting.integrationendiciasyncftpsite": "FTP Sync Server Address",
		"entity.order.process.placeorder.returnrequirementerror": "The order could not be placed because it was missing valid return infomation",
		"report.productperformancereport.returnafterdiscount": "Returned",
		"report.orderitemreport.itemdiscount": "Item Discounts",
		"entity.address_plural": "Addresses",
		"entity.producttype.parentproducttype": "Parent Product Type",
		"entity.product.event.productname": "Event Name",
		"setting.integrationfedexpassword": "FedEx Password",
		"entity.sku.skuname": "Sku Name",
		"entity.accountpayment.providertoken": "Provider Token",
		"define.every": "every",
		"setting.integrationpayflowpropassword": "Password",
		"entity.orderfulfillment.taxamount": "Fulfillment Items Tax Amount",
		"define.create": "Create",
		"admin.order.ordertabs.orderpayments.charges": "Order Payment Charges",
		"processobject.sku_changeeventdates.scheduleendtype": "Ends on",
		"entity.productreview.rating": "Rating",
		"email.orderdeliveryconfirmation": "Order Delivery Confirmation",
		"define.welcometoslatwall": "Welcome To Slatwall",
		"entity.accountloyaltytransaction.loyaltyredemption": "Loyalty Redemption",
		"entity.sku.delete_validateisdefault": "The SKU cannot be deleted because it is the default SKU for this product.",
		"entity.shippingmethod.shippingmethodname": "Shipping Method Name",
		"entity.term.loyaltyterms": "Loyalty Terms",
		"permission.main.default": "Dashboard",
		"admin.entity.settingstabs.fulfillmentmethod": "Fulfillment Method Settings",
		"entity.skucurrency": "Sku Currency",
		"validate.delete.orderitemgiftrecipient.giftcards.caneditordelete": "You cannot delete a gift recipient while it's gift cards are active.",
		"entity.sku.webqexp": "webQEXP",
		"entity.product.webqexp": "webQEXP",
		"entity.orderreturn_plural": "Order Returns",
		"setting.integrationmuralegacymyaccount": "Legacy My Account Filename",
		"entity.schedule.frequencyinterval_hint": "Between the Start Time & End Time of any given day, this schedule will run every interval of minutes defined.",
		"entity.accountrelationshiprole_plural": "Account Relationship Roles",
		"entity.paymentmethod.placeordercredittransactiontype": "Checkout Credit Trans.",
		"entity.order.referencedordertype.return": "Return",
		"entity.shippingmethodrate.sortorder": "Sort Order",
		"setting.emailsubject": "Email Subject",
		"entity.waitlistqueueterm": "Waitlist Queue Term",
		"entity.orderpayment.process.credit": "Credit",
		"define.qmax": "QMAX",
		"admin.entity.createreturnorder": "Create Return Order",
		"entity.paymentmethod.saveorderpaymentencryptflag_hint": "Selecting this option will store the secure payment info in an encrypted format when saving an Order Payment.  It is not recommended, as other options like generating tokens are typically better.",
		"entity.entityqueuehistory.baseid": "Base ID",
		"entity.loyaltyaccruement.accruementtype": "Accruement Type",
		"define.shipping": "Shipping",
		"event.onapplicationsetup": "On Application Setup",
		"entity.promotion.promotionperiods": "Promotion Periods",
		"entity.taxcategoryrate.appliedtaxes": "Applied Taxes",
		"admin.entity.skutabs.currencies": "Currencies",
		"entity.permission.subsystem": "Sub System",
		"entity.stockreceiveritem.stockreceiveritemid": "Stock Receiver Item ID",
		"entity.integration.paymentreadyflag": "Payment Ready Flag",
		"admin.entity.loyaltyaccruementtabs.skus": "Skus",
		"processobject.subscriptionusage_addusagebenefit.benefittermtype": "Add to Initial vs Renewal",
		"permission.product.detailproduct": "Product - Detail",
		"validate.changeeventdates.sku_changeeventdates.eventenddatetime.gtnow": "The event end date cannot be before now.",
		"entity.account.process.changepassword": "Change Password",
		"admin.entity.accounttabs.paymentmethods": "Payment Methods",
		"entity.promotionqualifier.promotionperiod": "Promotion Period",
		"entity.shortreference.shortreferenceid": "Short Reference ID",
		"entity.comment": "Comment",
		"entity.physicalcount_plural": "Physical Counts",
		"entity.product.nextskucodecount": "Next sku count",
		"entity.promotionqualifier.excludedskus": "SKU Exclusions",
		"entity.email.emailid": "Email ID",
		"entity.pricegrouprate.products": "Include Products",
		"entity.report.dynamicdaterangeendtype.thisweekendsaturday": "Current Week ( Ending Saturday )",
		"define.renewalsku": "Renewal Sku",
		"entity.pricegrouprate.appliesto": "Rate Applies To",
		"entity.schedule.frequencystarttime": "Start Time",
		"entity.account.murauser": "Mura User",
		"validate.addoption.product_addoption.options.required": "Please select a unique combination to create a new sku.",
		"entity.order.taxtotal": "Tax Total",
		"permission.setting.detailtype": "Type - Detail",
		"define.remove": "Remove",
		"permission.product.detailsubscriptionterm": "Subscription Term - Detail",
		"entity.product.alternateimage": "Alternate Image",
		"entity.serverinstance.serverinstanceipaddress": "IP Address",
		"entity.product.listprice": "List Price",
		"entity.subscriptionterm.billedondayofmonth": "Bill On Day of Month",
		"entity.accountloyaltyaccruement.accruementtype.enrollment": "Program Enrollment",
		"setting.integrationmuralegacyinjectflag": "Inject Legacy Views",
		"permission.product.deletebrand": "Brand - Delete",
		"define.qndosa": "QNDOSA",
		"entity.contentaccess.contentaccessid": "Content Access ID",
		"entity.promotionqualifier.rewardmatchingtype.brand": "Brand",
		"permission.setting.listcategory": "Category - List",
		"entity.address.lastname": "Last Name",
		"admin.main.dashboard.timeline": "Timeline",
		"entity.setting.product": "Product",
		"entity.attributeoption.attributeoptionvalue": "Value",
		"define.event": "Event",
		"define.first": "first",
		"setting.globalassetsimagefolderpath": "Image Assets Folder Path",
		"entity.subscriptionorderitem": "Subscription Order Item",
		"define.price": "Price",
		"entity.commentrelationship.orderitem": "Order Item",
		"entity.promotionqualifier.qualifiertype.order": "Order",
		"entity.vendorphone.vendor": "vendor",
		"entity.shortreference_plural": "Short References",
		"admin.main.log_permission": "View Slatwall Log",
		"validate.account.emailaddress": "Invalid email address",
		"admin.entity.processsku.editcapacity_success": "Capacity values\tchanged successfully.",
		"setting.integrationuspsuserid": "USPS Web Tools UserID ",
		"permission.order.detailorderfullfillment": "Order Fulfillment - Detail",
		"permission.product.listsubscriptionbenefit": "Subscription Benefit - List",
		"entity.producttype.producttypename": "Product Type Name",
		"entity.product.purchasestartdatetime": "Purchase Start Date",
		"admin.entity.processsku.changeeventdates_success": "Event dates successfully updated.",
		"permission.warehouse.liststockreceiver": "Stock Receiver - List",
		"setting.skugiftcardautogeneratecode": "Autogenerate Gift Card Codes",
		"validate.save.accountpayment.amount.minvalue": "Account payment amount cannot be a negative value.",
		"entity.email.emailto": "To",
		"permission.setting.editaddresszone": "Address Zone - Edit",
		"frontend.checkout.saveaccount": "Save & Continue",
		"admin.entity.settingstabs.global": "Global Settings",
		"entity.promotionreward.rewards": "Rewards",
		"validate.account.authorizeaccount.invalidemail": "There is no account with the Email address that was provided.",
		"entity.audit.changedetails.propertychanged.rollback": "Changed",
		"define.charge": "Charge",
		"entity.country.statecodeshowflag": "Show State Code",
		"entity.orderpayment.process.createtransaction": "Create Transaction",
		"setting.integrationfedexcontactcompany": "Contact Company",
		"validate.delete.product.transactionexistsflag.eq": "This product can not be deleted because one or more of it's skus has been used on transactions.",
		"entity.accountphonenumber.phonenumber": "Phone Number",
		"define.qiats.full": "Immediately Available To Sell",
		"setting.tasksuccessemailtemplate": "Task Success Email Template",
		"admin.entity.orderitemtabs.promotions": "Promotions",
		"entity.profile.account": "account",
		"entity.loyaltyaccruement.brands": "Brands",
		"entity.product.loyaltyredemptions": "Loyalty Redemptions",
		"entity.promotionapplied.appliedtype": "Applied Type",
		"entity.sku.skuid": "skuID",
		"entity.attributevalue.vendor": "Vendor",
		"define.february": "February",
		"entity.attributevalue.accountpayment": "Account Payment",
		"entity.loyaltyredemption.loyaltyterm": "Loyalty Term",
		"entity.paymentmethod.allowsaveflag": "Allow Accounts to Save",
		"entity.vendoraddress": "Vendor Address",
		"setting.producttypehtmltitlestring": "Product Type HTML Title String",
		"entity.loyaltyredemption.minimumpointquantity": "Minimum Point Quantity",
		"entity.emailtemplate.emailtemplatefile": "Email Template File",
		"setting.accountauthenticationautologouttimespan_hint": "This should be a comman seperated list of numbers that specifies: days, hours, minutes, seconds.  For example if you want to auto-logout after two hours the value should be: 0,2,0,0",
		"entity.paymenttransaction": "Payment Transaction",
		"admin.entity.listcartandquote_title": "View A List of Carts & Quotes",
		"setting.integrationendiciasyncftpsiteusername": "FTP Sync Username",
		"entity.paymenttransaction.accountpayment": "Account Payment",
		"entity.product.alternateimages": "Alternate Images",
		"entity.address.phone": "Phone",
		"admin.entity.attributetabs.description": "Description",
		"entity.vendor.numberbrands": "Brands Offered",
		"define.weekly": "Weekly",
		"entity.attributeset.producttypes": "Product Types",
		"setting.paymentmethodmaximumordertotalpercentageamount": "Maximum Order Total Percentage Amount",
		"entity.emailtemplate.emails": "Emails",
		"entity.account.process.unlock": "Unlock",
		"entity.locationconfiguration.locationconfigurationcapacity": "Configuration Capacity",
		"entity.order.process.placeorder.accountrequirementerror": "The order could not be placed because it was missing valid account information",
		"entity.product.shippingweight": "Shipping Weight",
		"entity.account.primaryaddress": "Primary Address",
		"entity.promotionqualifier.maximumordersubtotal": "Maximum Order Subtotal",
		"setting.integrationipaymentapplicationpassword": "Application Password",
		"setting.integrationvertexwebservicesusername_hint": "Used with Vertx Password when no Trusted ID is defined",
		"defaultmessage_custom": "{1} custom validation failed.",
		"setting.productshowdetailwhennotpublishedflag_hint": "This setting allows you to basically override the default behavior of slatwall by allowing for old product pages to still render after they have been removed from 'published'.",
		"permission.product.listsubscriptionterm": "Subscription Term - List",
		"entity.integration.integrationtypelist": "Integration Type List",
		"entity.eventregistration.process.exire": "Expire",
		"entity.emailtemplate.emailbodytext": "Body Text",
		"entity.orderdeliveryshipping.trackingnumber": "Tracking Number",
		"setting.globalusagestats_hint": "Selecting this option will send your application usage information to the Slatwall development team to help better inform the product.",
		"entity.promotionqualifier.minimumitemquantity": "Minimum Item Qty.",
		"process.vendororder_addvendororderitem.delivertolocationid": "Deliver To Location",
		"entity.productbundlegroup.fixed": "Fixed",
		"entity.account.failedloginattemptcount": "Failed Login Attempts",
		"entity.account.accountpayments": "Account Payments",
		"entity.accountloyaltytransaction.orderitem": "Order Item",
		"entity.email_plural": "Emails",
		"admin.entity.detailcountry.addressrequirements": "Address Requirements",
		"admin.entity.tasktabs.taskhistory": "Task History",
		"entity.country.localityrequiredflag": "Require Locality",
		"entity.session.lastplacedorderid": "Last Placed Order ID",
		"entity.stockadjustmentitem": "Stock Adjustment Items",
		"entity.entityqueue_plural": "Entity Queues",
		"admin.entity.promotionqualifiertabs.shippingaddresszones": "Shipping Address Zones",
		"entity.optiongroup.optiongroupname": "Option Group Name",
		"entity.account.process.updatepassword": "Update Password",
		"entity.product.process.addsku": "Add Sku",
		"define.securitycode": "Security Code",
		"entity.productbundlegroupitem_plural": "Product Bundle Group Items",
		"admin.entity.accounttabs.productreviews": "Product Reviews",
		"entity.loyaltyredemption.redemptiontype.vouchercreation": "voucher Creation",
		"entity.orderorigin": "Order Origin",
		"validate.save.sku.redemptionamount.minvalue": "The Redemption amount must be greater than 0.",
		"entity.productbundlebuild": "Product Bundle Build",
		"entity.orderitem.status": "Status",
		"permission.vendor.listvendororder": "Vendor Order - List",
		"admin.entity.pricegroupratetabs.skus": "Skus",
		"entity.pricegrouprate.excludedproducts": "Exclude Products",
		"entity.accountcollection": "Account Collection",
		"admin.entity.processaccount.addaccountloyalty_success": "The loyalty program has been successfully added to the account.",
		"admin.main.unlockaccount_permission": "Unlock Account Permission",
		"define.notplaced": "Not Placed",
		"setting.integrationauthorizenettestmodeflag": "Test Mode",
		"entity.category.site": "Site",
		"admin.entity.createmanualinadjustment_nav": "Manual In Adjustment",
		"entity.promotionqualifier.minimumfulfillmentweight": "Minimum Fulfillment Weight",
		"entity.stockhold.stockholdexpirationdatetime": "Stock Hold Expiration Date Time",
		"define.march": "March",
		"entity.accountcontentaccess.orderitem": "Order Item",
		"entity.optiongroup.optiongroupid": "Option Group ID",
		"admin.entity.createproduct.selectsubscriptionbenifits": "Select the Subscription Benefit(s) that you would like to sell as this product.",
		"entity.productbundlebuilditem_plural": "Product Bundle Build Items",
		"entity.accountpayment.termoffsetreceived": "Order Payment Received",
		"entity.stock_plural": "Stocks",
		"entity.subscriptionusage.subscriptionorderitemtype": "Subscription Stage",
		"entity.product.productname": "Product Name",
		"admin.entity.producttabs.images.defaultimages": "Default Images",
		"entity.content.displayinnavigation": "Display in Navigation",
		"entity.type.parenttype.eventregistrationstatustype": "Registratiion Status",
		"entity.alternateskucode": "Alternate Sku Code",
		"entity.order.orderstatustype": "Order Status",
		"entity.eventregistration.process.confrm": "Confirm",
		"admin.entity.producttypetabs.productsettings": "Product Settings",
		"entity.file.mimetype": "MIME Type",
		"entity.accountphonenumber": "Account Phone Number",
		"setting.integrationsagepaycurrency": "Login ID ",
		"entity.orderpayment.process.offlinetransaction": "Enter Offline Transaction",
		"setting.skushippingweightunitcode": "Shipping Weight Unit of Measurement",
		"admin.entity.orderitemtabs.taxes": "Taxes",
		"admin.entity.promotionrewardtabs.skus": "Skus",
		"entity.define.enddatetime": "End",
		"entity.account.generateapiaccesskey.nonvalidaccount": "You are not able to create an Access Key for this account.",
		"entity.baseentity.searchscore": "searchScore",
		"admin.entity.processsubscriptionusage.sendrenewalreminder_success": "Renewal reminder email sent.",
		"entity.paymenttransaction.statuscode": "Status Code",
		"entity.orderfulfillment.tax": "Tax",
		"setting.contentincludechildcontentproductsflag": "Include Products from Child Listing Pages",
		"entity.country.localitylabel": "Locality Label",
		"entity.locationaddress": "Location Address",
		"entity.collection": "Collection",
		"entity.sku.orderitems": "Order Items",
		"setting.integrationorbitalterminalid_hint": "Terminal ID to use for processing payments",
		"validate.create.product_create.eventstartdatetime.datatype.date": "Event Start Date must be a valid date",
		"setting.skuqatsincludesqnrosaflag": "QATS Includes QNROSA",
		"entity.report.dynamicdaterangetype.yeartodate": "Year to Date",
		"define.system": "System",
		"entity.product.productyear_title": "Year",
		"admin.entity.addskuprice.invalid": "The Sku Price you've tried to add has an invalid quantity definition please define a min and a max quantity or neither.",
		"permission.setting.editcontent": "Content - Edit",
		"entity.country.countrycode": "Country Code",
		"entity.attribute.attributeinputtype.atcheckbox": "Check Box",
		"entity.subscriptionusage.accountpaymentmethod": "Account Payment Method",
		"admin.entity.processgiftcard.toggleactive_success": "You have successfully changed the gift card's active state.",
		"admin.define.saveandnew": "Save & New",
		"processobject.order_createreturn.receiveitemsflag": "Auto Receive Items",
		"setting.integrationipaymentcurrency": "Currency (ISO 4217)",
		"admin.entity.accounttabs.parentaccounts": "Parent Accounts",
		"entity.stockreceiver.stockreceiverid": "Stock Receiver ID",
		"setting.integrationcanadapostcpcid": "CPC Shipping Integration ID ",
		"entity.shippingmethodrate.shipmentitempricerange": "Item Price Range",
		"processobject.product_create.selectproducttype": "Select Product Type",
		"processobject.product_addsku.locationconfigurations": "Location Configuration",
		"setting.integrationpaypalexpresspaypalheaderimage": "PayPal Header Image",
		"entity.form.process.addformresponse": "Add Form Response",
		"validate.create.product_create.eventenddatetime.datatype.date": "Event End Date must be a valid date",
		"entity.attribute.attributetype.attextbox": "Text Box",
		"define.logout": "Logout",
		"processobject.order_create.newaccountflag": "New Account",
		"entity.pricegroup.parentpricegroup": "Inherited Group Rates",
		"entity.loyaltyredemption.redemptionpointtype.lifetime": "Lifetime Point Balance",
		"entity.paymentmethod.providergateway": "Payment Provider Gateway",
		"entity.promotioncode.enddatetime": "End Date/Time",
		"entity.subscriptionterm_plural": "Subscription Terms",
		"entity.copyfromtype": "Copy From",
		"entity.loyaltyaccruement.products": "Products",
		"setting.integrationmerchantesolutionstestmodeflag": "Test Mode",
		"entity.session.sessionid": "sessionID",
		"entity.setting.paymentmethod": "Payment Method",
		"setting.integrationelavonlivegatewayurl": "Live API Gateway URL",
		"entity.account.generateapiaccesskey.accesskeyinfo": "The following keys have been generated to access the Slatwall API. Please copy them to a secure location, you will NOT be able to retrieve these values once the page is refreshed.<br /><br /> <strong>Access-Key:</strong> ${accessKey} <br> <strong>Access-Key-Secret:</strong> ${accessKeySecret}",
		"processobject.product_create.subscriptionterms": "Subscription Term",
		"setting.integrationupsshipfromstreet": "Shipping From Street Address",
		"setting.integrationorbitalmerchantidbycurrencycodelist": "Merchant ID By Currency Code List",
		"define.rate": "Rate",
		"define.locationtransfer": "Location Transfer",
		"entity.promotionqualifier.qualifiertype.subscription": "Subscription",
		"admin.entity.promotionrewardtabs.shippingaddresszones": "Shipping Address Zones",
		"admin.entity.workflowtabs.history": "Trigger History",
		"entity.accountcollection.accountcollectionname": "Account Collection Name",
		"admin.entity.processeventregistration.confirm_success": "Registration has been Confirmed.",
		"define.qosh": "QOSH",
		"admin.entity.tasktabs.taskschedule": "Task Schedule",
		"admin.entity.processvendororder.receive_success": "Vendor Order Received",
		"entity.product.relatedproducts": "Related Products",
		"entity.vendororder.process.receive": "Receive Vendor Order",
		"entity.country.statecodelabel": "State Code Label",
		"admin.entity.createpromotionrewardcontentaccess": "Content Access Product Discount",
		"entity.orderpayment.paymentterm": "Payment Term",
		"permission.setting.deletetaxcategory": "Tax Category - Delete",
		"entity.session.cart": "cart",
		"entity.promotionaccount.account": "Account",
		"entity.locationaddress.locationaddressid": "Location Address ID",
		"admin.entity.createaddresszonelocation_nav": "Add Location to Zone",
		"entity.attributeset.accountsaveflag": "Enable Account Saving",
		"admin.entity.createreport": "Create Saved Report",
		"entity.pricegroup.inheritsfromnothing": "No (Do not inherit)",
		"setting.globalurlkeyproducttype": "Product Type URL Key",
		"entity.promotion.promotionname": "Promotion Name",
		"admin.entity.fulfillmentmethodtabs.fulfillmentsettings": "Fulfillment Method Settings",
		"admin.entity.ordertabs.orderreturns": "Order Returns",
		"validate.create.product_create.renewalsubscriptionbenefits.required": "You must define a Renewal Benefit.",
		"entity.define.effectivedatetime": "Effective Date Time",
		"entity.product.subscriptiontermsrequired": "Subscription Terms are Required",
		"entity.orderfulfillment.total": "Fulfillment Total",
		"setting.integrationupscustomerclassificationcode": "Customer Classification Code (advanced optional) ",
		"permission.product.editsubscriptionbenefit": "Subscription Benefit - Edit",
		"entity.pricegroup.pricegroupname": "Price Group Name",
		"entity.order.process.create": "Create Order",
		"permission.setting.deleteterm": "Term - Delete",
		"entity.vendoraddress.vendor": "vendor",
		"entity.define.amountcharged": "Amount Charged",
		"define.never": "Never",
		"entity.attribute.attributeinputtype.atrichtexteditor": "Rich Text Editor",
		"defaultmessage_notinlist": "{1} was found in the list: {2}.",
		"permission.setting.deletelocation_missing": "Location - Delete",
		"entity.commentrelationship.referencedexpressionvalue": "Referenced Expression Value",
		"entity.orderpayment.orderpaymentstatustype": "Order Payment Status Type",
		"entity.order.accountloyaltytransactions": "Account Loyalty Transactions",
		"entity.vendoremail.vendor": "vendor",
		"entity.integration.customreadyflag": "Custom Ready Flag",
		"admin.entity.orderpaymenttabs.appliedaccountpayments": "Applied Account Payments",
		"entity.currency_plural": "Currencies",
		"event.onevent": "On Event",
		"entity.paymenttransaction.securitycodematchflag": "Security Code Match",
		"entity.attributeset": "Attribute Set",
		"entity.promotionreward.excludedbrands": "Brand Exclusions",
		"entity.attribute.process.addformquestion": "Add Form Question",
		"entity.paymentmethod.saveaccountpaymentmethodencryptflag_hint": "Selecting this option will store the secure payment info in an encrypted format when saving an Account Payment Method.  It is not recommended, as other options like generating tokens are typically better.",
		"entity.sku.skudefinition": "Sku Definition",
		"entity.paymentterm": "Payment Term",
		"define.qvomin": "QVOMIN",
		"entity.term.termmonths": "Term Months",
		"admin.main.encryption.batchsizelimit": "Batch Size Limit",
		"define.exportlist": "Export List",
		"admin": "Admin",
		"entity.setting": "Setting",
		"entity.attributeset.requiredflag": "Required Flag",
		"permission.order": "Order",
		"admin.entity.listemail": "Logged Emails",
		"setting.globalencryptionalgorithm": "Encryption Algorithm",
		"entity.brand.vendors": "Vendors",
		"entity.stockadjustment.process.addstockadjustmentitem": "Add",
		"entity.shippingmethodrate.shipmentquantityrange": "Quantity Range",
		"entity.subscriptionusage.currentstatustype": "Current Status",
		"entity.address.streetaddress_validaterequired": "Please enter a vaild Street Address",
		"entity.product.allowpreorderflag": "Preorder OK",
		"admin.main.about": "About",
		"admin.processorder_addorderitem.quantity.invalid": "You're order item quantity must not be less than the gift cards you have assigned and no more than 1000.",
		"define.qnroro.full": "Not Received On Return Order",
		"admin.entity.skutabs.locationconfigurations": "Location Configurations",
		"entity.shippingmethodoption.shippingmethodoptionsplitshipments": "Shipping Method Option Split Shipments",
		"entity.pricegrouprate_plural": "Price Group Rates",
		"define.phonenumber": "Phone Number",
		"entity.product.loyaltyaccruements": "Loyalty Accruements",
		"entity.shippingmethod.eligibleaddresszone_hint": "Limits a shipping method to only be used for a given address Zone.  Leave blank to allow for all address",
		"entity.category.categoryidpath": "Category ID Path",
		"entity.physical.process.addphysicalcount": "Add Physical Count",
		"entity.promotionapplied_plural": "Applied Promotions",
		"setting.contentincludechildcontentproductsflag_hint": "By selecting this option, and products that are assinged to child listing pages of this listing page will be included in the product list.",
		"validate.createtransaction.orderpayment.orderstatuscode.inlist": "You cannot process a payment transaction because the order is not in acceptable status",
		"processobject.product_addsubscriptionterm.listprice": "List Price",
		"permission.setting.editschedule": "Schedule - Edit",
		"entity.paymentterm_plural": "Payment Terms",
		"report.appliedpromotionreport.promotionapplieddatetime": "Discount Applied Date Time",
		"entity.product.process.addlocation": "Add location",
		"entity.loyaltyterm.loyaltytermname": "Loyalty Term Name",
		"entity.sku.calculatedskudefinition": "Sku Definition",
		"setting.emailsmtpport": "SMTP Port",
		"entity.orderfulfillment.fulfillmentmethod.shipping": "Shipping",
		"entity.accountcollection_plural": "Account Collections",
		"entity.brand.brandvendors": "brandVendors",
		"define.sunday": "Sunday",
		"setting.integrationsofortassumeuntraceableassuccess": "Assume untraceable payments are successfull",
		"permission.setting.editorderorigin": "Order Origin - Edit",
		"entity.optiongroup.sortorder": "Sort Order",
		"setting.accountpaymentterm": "Default Account Payment Term",
		"entity.stockreceiver.receivertype.vendororder": "Vendor Order",
		"entity.collection.collectionid": "Collection ID",
		"entity.term.initialsubscriptionusageterms": "Initial Subscription Usage Terms",
		"entity.task.taskmethod.updatecalculatedproperties": "Update Calculated Properties",
		"entity.productreview.account": "Account",
		"define.password": "Password",
		"entity.stockadjustmentitem.stockadjustmentdeliveryitems": "Stock Adjustment Delivery Items",
		"entity.account.accountemailaddresses": "Account Email Addresses",
		"define.image": "Image",
		"entity.audit.auditdatetime": "Date",
		"processobject.sku_changeeventdates.scheduleenddate": "Schedule end date",
		"entity.product.datelastreceived": "dateLastReceived",
		"entity.content.productlistingpageflag_hint": "By selecting 'Yes' here, this page will show up in the Slatwall admin for a product under the Product Pages so that individual products can be added to this page to build out a list or grid.",
		"entity.sku.alloweventwaitlistingflag": "Allow Waitlisting",
		"entity.stockadjustment.fromlocation": "From Location",
		"setting.integrationpayflowproaccountpaymentcommentonetemplate": "Account Payment Comment One Template",
		"entity.session.sessionexpirationdatetime": "Session Expiration Time",
		"entity.subscriptionterm.autorenewflag_hint": "If this is set to 'Yes' then a renewal order will be automatically created at the end of the subscription term",
		"setting.productimageoptioncodedelimiter": "Product Image Option Code Delimiter",
		"permission.setting.createtaxcategory": "Tax Category - Create",
		"setting.integrationsofortapikey": "API Key",
		"entity.content.urltitle": "URL Title",
		"setting.globalapidirtyread": "API Read Uncomitted Data",
		"entity.setting.shippingmethodrate": "Shipping Method Rate",
		"admin.entity.orderpaymenttabs.paymenttransactions": "Payment Transactions",
		"entity.orderdelivery.deliveryopendatetime": "Delivery Open Date",
		"entity.task.taskconfig": "Task Config",
		"entity.define.expirationyear": "Expiration Year",
		"entity.producttype.producttypedescription": "Product Type Description",
		"validate.processproduct_create.scheduleenddate_defined": "Schedule end date must be defined for recurring schedules.",
		"entity.define.companypaymentmethodflag_hint": "This should be set to 'No' if the payment being use is a personal card, or 'Yes' if the card is a company card.",
		"admin.entity.ordertabs.orderdeliveries": "Order Deliveries",
		"entity.orderdelivery.shippingaddress": "Shipping Address",
		"entity.account.process.create": "Create Account",
		"report.orderitemreport": "Order Item Sales Report",
		"setting.integrationendiciapassphrase": "Pass Phrase",
		"entity.define.bankaccountnumber": "Bank Account Number",
		"processobject.sku_move.product": "Destination Product",
		"entity.order.orderitems": "Order Items",
		"entity.promotionqualifier.fulfillmentmethods": "Fulfillment Methods",
		"setting.integrationendiciaaccountid": "Account ID",
		"entity.account.termaccountorderpayments": "Term Account Order Payments",
		"entity.stockreceiver.packingslipnumber": "Packing Slip Number",
		"admin.entity.createpromotionqualifierfulfillment": "Fulfillment Qualifier",
		"entity.accountcollection.entityname": "Entity Name ",
		"entity.orderdelivery.containerlabel": "Shipping Label",
		"validate.edit.email.emailid.maxlength": "Logged Email is not editable.",
		"processobject.product_updateskus.updatepriceflag": "Update Price",
		"entity.sku.redemptionamount": "Redemption Amount",
		"entity.orderpayment.process.chargepreauthorization": "Charge Pre-Authorization",
		"entity.accountauthentication.integrationaccesstoken": "Integration Access Token",
		"setting.accountlockminutes_hint": "This is should be how many minutes that you want accounts to be locked for whenever they get locked. Min value of 30.",
		"api.define.delete_error": "There was an error trying to delete the ${EntityName}.",
		"setting.siterecaptchaprotectedevents": "Recaptcha Protected Events",
		"admin.entity.processaccount.changepassword_success": "Account password has been changed successfully.",
		"admin.entity.promotionqualifiertabs.producttypes": "Product Types",
		"permission.warehouse": "Warehouse",
		"entity.define.fulfillmentmethod": "Fulfillment Method",
		"entity.postalcode.latitude": "latitude",
		"entity.shippingmethodrate.splitshipmentweight": "Split Shipment Weight",
		"admin.entity.loyaltytabs.loyaltyredemption": "Loyalty Program Redemption Criteria",
		"entity.paymentmethod.saveorderpaymentencryptflag": "Encrypted & Save (OP)",
		"entity.orderpayment.dynamicamountflag": "Dynamic Amount",
		"entity.giftcard": "Gift Card",
		"entity.orderdelivery.deliveryclosedatetime": "Delivery Close Date",
		"entity.promotion.enddatetime": "End Date/Time",
		"entity.physical.physicalcounts": "Physical Counts",
		"entity.orderdeliveryitem.orderitem": "Order Item",
		"setting.integrationendiciasyncftpsitepassword": "FTP Sync Password",
		"admin.entity.preprocesssite": "Create Site",
		"entity.attributevalue.file": "File",
		"admin.entity.detailaccount.authenticationdetails": "Authentication Details",
		"entity.orderfulfillment.emailaddress": "Email Address",
		"validate.edit.comment.comment.canedit": "User not allowed to edit this comment",
		"entity.shippingmethodrate.ratemultiplieramount": "Rate Multiplier Amount",
		"setting.globalfiletypewhitelist": "Allowed File Types",
		"entity.physical.physicalname": "Physical Name",
		"entity.integration.shippingactiveflag": "Shipping Integration Active",
		"validate.save.orderpayment.giftcardnumberencrypted.giftcardnotappliedtoorder": "This Gift Card has already been applied to the order.",
		"processobject.orderdelivery_create.capturableamount": "Amount to be Captured",
		"entity.addresszone.norecords": "No Address Zones Defined",
		"validate.changeeventdates.sku_changeeventdates.eventstartdatetime.ltdatetimeproperty": "The event end date must occur after start date.",
		"entity.option.skus": "Skus",
		"admin.report.exportcsv": "Export CSV",
		"setting.paymentmethodmaximumordertotalpercentageamount_hint": "This setting allows you to define if you would like this particular payment method to only be a portion of the order total amount.  For example on a Term Payment method you may only want 50% of the order total to be used",
		"entity.promotionaccount.promotionaccountid": "Promotion Account ID",
		"entity.content.process.createsku": "Create Sku",
		"permission.setting.savemeasurementunit": "Measurement Unit - Save",
		"entity.entityqueuehistory.successflag": "Success",
		"permission.product.savebrand": "Brand - Save",
		"entity.workflowtaskaction.processmethod": "Process Method",
		"define.inherit": "Inherit",
		"entity.databasecache": "Database Cache",
		"admin.entity.promotionreward.editdisabled": "This promotion reward cannot be edited because its promotion period has expired.",
		"entity.emailbounce.relatedobject": "Related Object",
		"setting.integrationmuraaccountsynctype_hint": "This setting will define how accounts are synced back and forth between Mura and Slatwall.  The default is 'Mura System Users Only' which means that any new accounts in Slatwall will not create site members in Mura, but existing/new Mura system accounts will automatically have a linked account created in Slatwall.",
		"entity.inventory.orderdeliveryitem": "Order Delivery Item",
		"setting.accounthtmltitlestring": "Account HTML Title String",
		"entity.product.shippingweightunitcode": "Shipping Weight Unit of Measurement",
		"entity.order.billingaddress": "Billing Address",
		"entity.promotionqualifier.maximumitemquantity": "Maximum Item Quantity",
		"email.email.emailbodytext": "Text Body",
		"entity.order.referencedorder": "Original Order",
		"entity.filerelationship.baseobject": "Base Object",
		"setting.integrationelavonpintemplate_hint": "This template will be string replaced based on the order, and then passed as PIN to Elavon.  An Example would be: ${myCustomOrderAttributeCode}.  Plain text works as well",
		"entity.brand.promotionqualifiers": "Promotion Qualifiers",
		"entity.order.ordernumber": "Order Number",
		"define.filter": "Filter",
		"admin.entity.orderitemgiftrecipienttabs.giftcards": "Gift Cards",
		"admin.entity.skutabs.accesscontents": "Access Content",
		"entity.account.passwordconfirm": "Confirm Password",
		"entity.subscriptionorderitem.orderitem": "Order Item",
		"entity.product.qea": "QEA",
		"entity.producttype.producttypeidpath": "Product Type ID Path",
		"entity.collection.dirtyreadflag": "Dirty Read Enabled",
		"entity.vendororder.type": "Type",
		"define.datetime": "Date Time",
		"validate.processorder_placeorder.duplicate": "The order could not be placed, because this order has already been placed.  This could be the result of double clicking the 'Submit' button which would indicate that the order has in fact been placed.",
		"admin.entity.editphysicalcountitem_disabled": "The physical count Item cannot be edited as the physical count has been committed.",
		"admin.entity.processaccount.redeemgiftcard_failure": "The gift card you have entered cannot be redeemed.",
		"validation.account_authorizeaccount.failure": "The username or password that you entered is invalid.",
		"admin.entity.processaccount.redeemgiftcard_success": "The gift card has been attached to the account.",
		"entity.subscriptionusagebenefitaccount.account": "Account",
		"entity.order.calculatedtotal": "Total",
		"permission.setting.editterm": "Term - Edit",
		"admin.main.encryption.updatepassword_title": "Update Password",
		"setting.productautoapprovereviewsflag": "Auto approve product reviews",
		"entity.promotionreward.maximumuseperorder": "Max. Use Per Order",
		"entity.brand.promotionrewardexclusions": "Promotion Reward Exclusions",
		"permission.setting.savetask": "Task - Save",
		"define.sortorder": "Sort Order",
		"admin.entity.processaccount.createpassword_success": "Account password created successfully.",
		"admin.pricing.createpromotionqualifierorder": "Create Promotion Qualifier Order",
		"setting.integrationvertexwebservicespassword_hint": "Used with Vertx Username when no Trusted ID is defined",
		"entity.orderfulfillment.itemdiscountamounttotal": "Item Discounts",
		"admin.define.detail_permission": "${itemEntityName} - View Details",
		"entity.product.allowshippingflag": "Shipping OK",
		"admin.entity.deleteaddresszonelocation_success": "The location has successfully been removed from this Address Zone.",
		"entity.workflow.modifiedby": "Modified By",
		"admin.entity.vendortabs.vendororders": "Orders",
		"validate.save.orderfulfillment.fulfillmentmethod.allorderfulfillmentitemsareeligibleforfulfillmentmethod": "All Order Fulfillment Items must be eligible for the given Fulfillment Method",
		"entity.shippingmethod.delete_validateisdeletable": "This shipping method cannot be deleted because it has been used in an order.",
		"entity.skuprice.pricegroup": "Price Group",
		"entity.product.qia": "QIA",
		"entity.audit.audittype.login": "Login",
		"validate.define.maxlength": "${propertyName} must be no more than ${constraintValue} characters long",
		"admin.main.about_title": "About",
		"entity.account.guestaccountflag": "Guest",
		"entity.order.refundshippingamount": "Refund Shipping Amount",
		"define.sameasprice": "Same As Price",
		"entity.giftcard.balanceamount": "Balance Amount",
		"entity.shippingmethodrate.defaultamount": "Default Amount",
		"entity.order.orderopenipaddress": "Order Open IP Address",
		"setting.integrationmerchantesolutionstestprofilekey": "Test Merchant Key",
		"admin.entity.processgiftcard.redeemtoaccount_success": "The account has been successfully associated with the gift card.",
		"admin.entity.settingdefinedin": "Setting Defined In",
		"entity.email.emailfrom": "From",
		"entity.orderorigin.orderoriginid": "Order Origin ID",
		"admin.entity.formtabs.formresponses": "Form Responses",
		"entity.paymentmethod.creditcard": "Credit Card",
		"define.renewalterm": "Renewal Term",
		"admin.main.dashboard.recentproductreviews": "Recent Product Reviews",
		"entity.subscriptionusage.renewalsubscriptionusagebenefits": "Renewal Subscription Usage Benefits",
		"entity.subscriptionstatus.subscriptionstatuschangereasontype": "Subscription Status Change Reason Type",
		"entity.form.process.create": "Create Form",
		"entity.account.primaryemailaddress": "Account Primary Email Address",
		"entity.workflowtrigger": "Workflow Trigger",
		"admin.entity.detailorderitem.skupricewhenordered": "Sku Price When Ordered",
		"entity.subscriptionbenefit.pricegroups": "Price Groups",
		"api.define.delete_success": "The ${EntityName} was deleted successfully.",
		"entity.workflowtrigger.triggereventtitle": "Trigger Event Title",
		"admin.report.default.integrationreports": "Integration Reports",
		"permission.setting.saveaddresszone": "Address Zone - Save",
		"entity.orderreturn": "Order Return",
		"define.authorizeandcharge": "Authorize & Charge",
		"entity.order.paymentamountreceivedtotal": "Received Amount",
		"define.integration": "Integration",
		"entity.shippingmethodoptionsplitshipment_plural": "Shipping Method Option Split Shipments",
		"entity.accountpaymentmethod.paymenttransactions": "Payment Transactions",
		"admin.entity.createproduct.bundlecontentaccess_hint": "Would you like to bundle all pages selected into a single sku?",
		"admin.main.default": "Dashboard",
		"email.email.emailbodyhtml": "HTML Body",
		"admin.main.dashboard.recentvendorupdates": "Recent Vendor Updates",
		"entity.integration.authenticationreadyflag": "Authentication Ready Flag",
		"entity.shippingmethodrate.shippingrateid": "Shipping Rate ID",
		"entity.orderitem.calculatedtaxamount": "Tax Amount",
		"entity.accountloyaltyredemption.redemptiontype.productpurchase": "Product Purchase",
		"entity.product.productcode_hint": "A unique string (alphanumeric, no spaces) to identify the product.",
		"setting.subscriptionusageautoretrypaymentdays_hint": "This is a comma seperated list that will try to automatically re-charge the payment on a renewal order every x,y,z days.",
		"entity.paymentmethod.process.processcheckpayment": "Process Check Payment",
		"entity.giftcardtransaction.debitamount": "Debit Amount",
		"processobject.product_create.renewalmethod": "Renewal Method",
		"entity.address.statecode": "State",
		"validate.addorderitem.order_addorderitem.quantity.minvalue": "You must enter 1 or greater for the order quantity.",
		"admin.entity.processorderdelivery.create_success": "Order Item Fulfillment was Successful",
		"entity.brand.brandwebsite_hint": "If the brand has an external website, insert it here. It should begin with http:// or https://",
		"entity.vendororder.vendororderstatustype": "Vendor Order Status Type",
		"admin.entity.processproduct.addeventschedule_success": "The Event Schedule has been successfully added.",
		"entity.addresszone.addresszonelocations": "Address Zone Locations",
		"define.delete": "Delete",
		"admin.entity.promotionrewardtabs.options": "Options",
		"entity.content.process.create": "Create Content",
		"admin.entity.updateskucache": "Update Sku Cache",
		"admin.entity.processphysical.addphysicalcount_success": "The file you uploaded was imported successfully.",
		"entity.stockadjustmentitem.stockadjustment": "Stock Adjustment",
		"entity.task.startdatetime": "Task Start Date",
		"admin.entity.updateskucache_success": "Sku Cache Update Started",
		"entity.shippingmethodoption.shiptocountrycode": "Ship To Country Code",
		"entity.vendoraddress.vendoraddresstype": "vendorAddressType",
		"entity.shippingmethodrate.shippingmethodoptions": "Shipping Method Options",
		"entity.vendorskustock.vendor": "vendor",
		"setting.productimageoptioncodedelimiter_hint": "Allows for you to define how default product images will be formatted.  Default Product Images start with the productCode, and then any option codes that have been defined as Image Option Groups.  This value is the delimiter that seperates the option codes.",
		"permission.setting.createroundingrule": "Rounding Rule - Create",
		"entity.product.originalprice": "originalPrice",
		"validate.processorderdelivery_create.captureamount": "There was an issue trying to capture the payments necessary to fulfill this order.  Please review order payments and try again.",
		"entity.email.emailbcc": "BCC",
		"entity.subscriptionbenefit.maxusecount": "Maximum Use Per Access Code",
		"setting.integrationfullcirclelocaltransferdirctory": "Local Transfer Directory",
		"entity.eventregistration.pendingclaimdatetime": "Pending Claim Date Time",
		"entity.subscriptionterm.subscriptiontermid": "SubscriptionTermID",
		"entity.define.quantityin": "Quantity In",
		"entity.stockadjustmentdelivery.stockadjustment": "Stock Adjustment",
		"entity.category": "Category",
		"entity.promotion.promotioncodes": "Promotion Codes",
		"entity.order.isguestaccount": "Guest Account",
		"validation.define.regex": "This input is invalid.",
		"entity.product.allowdropshipflag": "Dropship OK",
		"entity.orderitem.skuprice": "Sku Price",
		"admin.main.ckfinder_permission": "File Manager Access",
		"entity.loyaltyredemption.autoredemptiontype.none": "None",
		"permission.setting.deletecountrycountry": "- Delete",
		"defaultmessage_daterange": "{1} must be a valid date between {2} and {3}.",
		"entity.promotionqualifier.minimumorderquantity": "Minimum Order Qty.",
		"entity.taxcategory.taxcategorycode": "Tax Category Code",
		"entity.productbundlegroup.maximumquantity": "Max Quantity",
		"entity.form.formname": "Form Name",
		"defaultmessage_range": "{1} must be between {2} and {3}.",
		"setting.integrationstripeapiurl": "API Url",
		"setting.accounteligiblepaymentmethods": "Eligible Payment Methods",
		"entity.pricegroup.name": "Price Group Name",
		"entity.producttype.loyaltyredemptions": "Loyalty Redemptions",
		"permission.warehouse.createstockadjustment": "Stock Adjustment - Create",
		"entity.eventtrigger.emailtemplate": "Email Template",
		"entity.giftcard.process.redeemtoaccount": "Select Owner Account",
		"validate.createtransaction.orderpayment_createtransaction.amount.lteproperty": "The amount entered is outside the amount possible this type of transaction based on the Order Payment amount.",
		"setting.integrationpaypalexpressexternalpaymentreturnurl": "Payment Return URL",
		"entity.productschedule.productscheduleid": "Product Schedule ID",
		"entity.loyaltyredemption.loyaltyredemptionid": "Loyalty Program Redemption ID",
		"admin.main.update_success": "Slatwall updated successfully",
		"permission.setting.editpaymentmethod": "Payment Method - Edit",
		"entity.sku.renewalsubscriptionbenefits_required": "Please specify a Renewal Sku or a Renewal Subscription Benefit and Price.",
		"processobject.subscriptionusage_renew.renewalstarttype": "Renewal Start Type",
		"validate.account.phonenumber": "Invalid phone number",
		"entity.skualternate.skualternateid": "skuAlternateID",
		"define.none": "None",
		"entity.commentrelationship.comment": "Comment",
		"entity.product.promotionqualifiers": "Promotion Qualifiers",
		"permission.account.editpermissiongroup": "Permission Group - Edit",
		"entity.subscriptionstatus.subscriptionusage": "Subscription Usage",
		"entity.vendororderitem_plural": "Vendor Order Items",
		"entity.paymenttransaction.message": "Message",
		"admin.entity.selectpricegrouprate_nav": "Select Price Group",
		"entity.define.excludeflag": "Exclude",
		"admin.entity.listform": "Form Builder",
		"entity.paymenttransaction.transactionstarttickcount": "Transaction Start Tick Count",
		"entity.vendororderitem.quantityreceived": "Qty. Received",
		"entity.content.urltitlepath": "URL Title Path",
		"validate.define.maxvalue": "${propertyName} must be no more than ${constraintValue}",
		"entity.taxcategoryrate.taxliabilityappliedtoitemflag": "Taxes Added to Order Item",
		"admin.entity.createproductimage": "Upload New Product Image",
		"entity.product.event.productcode": "Event Code",
		"define.merchandise": "Merchandise",
		"entity.order.process.cancelorder": "Cancel Order",
		"entity.stockreceiver.receivertype.stockadjustment": "Stock Adjustment",
		"entity.accountloyaltytransaction.pointsout": "Points Out",
		"entity.account.process.addaccountpayment": "Add Account Payment",
		"define.fourth": "fourth",
		"entity.taxcategory_plural": "Tax Categories",
		"entity.subscriptionterm.allowprorateflag_hint": "Selecting this options will allow for subscriptions to be pro-rated based on a schedule",
		"validate.create.processorderdelivery_create.orderdeliveryitems.hasquantityononeorderdeliveryitem": "At a minimum you must enter 1 quantity to fulfill.",
		"define.november": "November",
		"entity.promotionreward_plural": "Promotion Rewards",
		"entity.product.promotionrewards": "Promotion Rewards",
		"entity.order.process.placeorder.hassubscriptionwithautopayflagwithoutorderpaymentwithaccountpaymentmethod_info": "You have a Subscription Term with 'Auto-Pay' Set to yes, but no Payment Methods that allow for accounts to save\"",
		"define.url": "URL",
		"entity.app.appname": "Application Name",
		"entity.content.contenttemplatetype": "Template Type",
		"setting.contenthtmltitlestring": "Content HTML Title String",
		"entity.content.contentid": "Content ID",
		"define.may": "May",
		"admin.entity.processgiftcard.updateemailaddress_success": "You have successfully updated the email address for this gift card an email has been sent to the new address.",
		"permission.setting.createpaymentmethod": "Payment Method - Create",
		"admin.entity.skutabs.currencies.converted": "Converted",
		"admin.metaexists_error": "<strong>IMPORTANT:</strong> This version of Slatwall still has the /meta directory deployed which is used for development purposes only.  It should be removed from your install prior to being deployed in production.<br /><a href='?slatAction=main.removemeta' target='_self'>Remove /meta directory now</a>.",
		"validate.create.product_create.scheduleenddate.gtdatetimeproperty": "The Schedule End Date must be a date after the first Event End Date",
		"permission.setting.listmeasurementunit": "Measurement Unit - List",
		"define.premissions": "Permissions",
		"admin.entity.pricegrouptabs.assignedaccounts": "Assigned Accounts",
		"define.general": "General",
		"entity.productbundlegroup.productbundlegroupid": "Product Bundle Group ID",
		"admin.entity.subscriptionusagetabs.subscriptionusageaccess": "Access Codes",
		"entity.audit.frontendandadmin": "Audit history available, but only starts at point of first admin update",
		"entity.orderitem.orderfulfillment": "Order Fulfillment",
		"entity.fulfillmentbatch.fulfillmentbatchnumber": "Fulfillment Batch Number",
		"entity.order.process.addpromotioncode_success": "Promotion Code added Successfully",
		"entity.orderpayment.bankaccountnumberencrypted": "Bank account Number  Encrypted",
		"entity.audit.data": "Data",
		"validate.delete.order.statuscode.inlist": "Orders that have been placed can not be deleted.",
		"setting.producttypedisplaytemplate_hint": "The content object that you would like to use as the template for displaying product on the front-end.  Typically this is a page in your CMS or Custom Application",
		"setting.skueventattendancetype": "Attendance type",
		"setting.skuorderitemgiftrecipientemailtemplate": "sku order item gift recipient email template",
		"processobject.subscriptionusage_renew.saveaccountpaymentmethodname": "Nickname",
		"entity.subscriptionusage.renewalprice": "Renewal Price",
		"entity.formresponse.formresponseid": "Form Response ID",
		"entity.accountemailaddress.account": "Account",
		"admin.default.products_nav": "Products",
		"entity.stockreceiveritem.stock": "Stock",
		"entity.stock.qc": "qc",
		"entity.paymenttransaction.authorizationcodeinvalidflag": "Authorization Code Invalid Flag",
		"admin.entity.updatefrontendviews_confirm": "ARE YOU 100% SURE YOU WANT TO UPDATE ALL OF YOUR CUSTOM VIEWS? YOU MAY LOSE YOUR CUSTOMIZATIONS",
		"entity.taskschedule.successemaillist": "Success Emails",
		"frontend.account.edit": "Edit Account",
		"entity.taxcategoryrate.taxrate": "Tax Rate",
		"validate.eventscheduleconflict": "Another event is already schedule at that location during the specified time frame.",
		"entity.taxapplied": "Tax Applied",
		"entity.product.qoh": "QOH",
		"entity.stockreceiveritem_plural": "Stock Receiver Items",
		"admin.main.forgotpassword": "Forgot Password",
		"entity.product.qoo": "QOO",
		"entity.emailtemplate.emailbodyhtml": "Body HTML",
		"entity.eventregistration.process.notplaced": "Change to Not Placed",
		"admin.entity.promotionrewardtabs.brands": "Brands",
		"entity.define.countpostdatetime": "Count Post Date Time",
		"entity.promotion": "Promotion",
		"admin.entity.promotionreward.discounttype.amount": "Fixed Amount",
		"entity.emailverification_plural": "Email Verifications",
		"entity.eventregistration.emailaddress": "Email",
		"validate.delete.define.maxcollection": "This ${className} can not be deleted because it has ${propertyName} assigned to it.",
		"setting.imagemissingimagepath": "Missing Image Path",
		"frontend.checkout.saveshippingaddress": "Save & Continue",
		"entity.audit.auditid": "Audit ID",
		"entity.task.runningflag": "Running",
		"processobject.accountloyalty_manualtransaction.points": "Points",
		"entity.sku.delete_validateonesku": "The SKU cannot be deleted because each product must have at least one SKU.",
		"entity.orderfulfillment.process.fulfillitems": "Fulfill Items",
		"admin.entity.taxcategorytabs.rates": "Tax Rates",
		"entity.schedule.recuringinterval": "Recurring  Interval",
		"entity.sku.salepriceexpirationdatetime": "Sale Price Ends",
		"entity.subscriptionbenefit.subscriptionbenefitid": "Subscription Benefit ID",
		"entity.vendor.vendorid": "Vendor ID",
		"entity.physicalcountitem.physicalcountitemid": "Physical Count Item ID",
		"admin.entity.processeventregistration.register_success": "Status successfully changed to Registered.",
		"admin.entity.processorder.placeorder_success": "Order Placed Successfully.",
		"entity.file.download.filedownloaderror": "There was an error while trying to download the file",
		"setting.producttypemetadescriptionstring": "Product Type Meta Description String",
		"entity.vendoraccount.vendor": "Vendor",
		"processobject.product_addeventschedule.bundlelocationconfigurationflag_hint": "When selecting 'Yes' all of the confirguations selected will be joined into a single sku that one can register for.  If you would like people to select which location configuration they are registering for select 'No'.",
		"admin.entity.createshippingmethodrate_nav": "Manual Rate",
		"admin.entity.createpromotionrewardmerchandise": "Merchandise Product Discount",
		"define.through": "through",
		"setting.skuordermaximumquantity_hint": "Maximum per SKU Qty. allowed on order",
		"entity.vendoraccount": "Vendor Account",
		"admin.entity.processorderpayment.createtransaction_success": "Payment transaction successfully processed.",
		"setting.globalpagemyaccount": "My Account Page",
		"api.define.save_success": "The ${EntityName} was saved successfully",
		"entity.product.gender": "gender",
		"entity.skuprice.maxquantity": "Max Quantity",
		"validate.save.orderitem.quantity.hasquantitywithinmaxorderquantity": "The quantity that you have entered exceeds the maximum order quantity.",
		"entity.sku.process.addlocation": "Add Location",
		"entity.paymenttransaction.orderpayment": "Order Payment",
		"entity.emailbounce.rejectedemailfrom": "Rejected Email From",
		"setting.globalsmartlistgetallrecordslimit": "Smart List Get All Records Limit (0=unlimited)",
		"entity.loyalty.accountloyalties": "Account Loyalties",
		"entity.define.creditcardlastfour": "Last Four",
		"validate.define.filtersrequired": "Filter(s) are required",
		"entity.giftcard.activeflag": "Active Flag",
		"setting.integrationuspspackagewidth": "Package Width ",
		"define.edit": "Edit",
		"define.manualin": "Manual In",
		"entity.promotioncode.delete_success": "Promotion Code Deleted",
		"entity.eventregistration": "Event Registration",
		"processobject.giftcard_toggleactive.activeflag": "Active",
		"entity.paymentmethod.saveaccountpaymentmethodtransactiontype_hint": "Typically used to generate 'tokens' from the processor, which are then stored with the 'Account Payment Method' to avoid encrypting & storing data.",
		"entity.pricegrouprate": "Price Group Rate",
		"entity.emailtemplate.emailtemplatefile_hint": "The template file is optional but if found it will be used to generate the actual email contents.  You can find these templates and add more in: {custom}/templates/email/{object}",
		"entity.order.assignedaccount": "Assigned Account",
		"error.unexpected.checklog": "There was an unexpected error processing your request.  Check the Slatwall Log for details.",
		"admin.entity.pricegroupratetabs.producttypes": "Product Types",
		"report.orderitemreport.returnafterdiscount": "Returned",
		"entity.location.parentlocation": "Parent Location",
		"entity.accountpaymentmethod.expirationyear": "Expiration Year",
		"entity.vendororderitem.quantity": "Qty.",
		"entity.orderpayment.process.runplaceordertransaction": "Run Place Order Transaction",
		"entity.accountpaymentmethod.account": "Account",
		"entity.audit.baseid": "Base ID",
		"processobject.subscriptionusage_renew.extendexpirationdate": "New Expiration Date",
		"define.actions": "Actions",
		"entity.orderitemgiftrecipient.orderitemgiftrecipientid": "Order Item Gift Recipient ID",
		"admin.entity.skutabs.skusettings": "Sku Settings",
		"entity.workflow.workflowname": "Workflow Name",
		"admin.entity.processorder.addorderitem_success": "Order Item successfully added",
		"entity.taxcategoryrate_plural": "Tax Category Rates",
		"entity.setting.sku": "Sku",
		"setting.skugiftcardenforceexpirationterm": "Enforce Gift Card Expiration Terms",
		"entity.email.process.addtoqueue": "Send Email",
		"setting.integrationavataxcompanycode": "Company Code",
		"entity.attribute.attributeinputtype.relatedobjectselect": "Related Object Select",
		"define.chargepreauthorization": "Charge Pre-Authorization",
		"define.noaccess": "You do not have access",
		"admin.entity.listapp": "Applications",
		"entity.brand.loyaltyredemptions": "Loyalty Redemptions",
		"entity.promotionqualifier.rewardmatchingtype.producttype": "Product Type",
		"entity.promotionperiod.promotion": "Promotion",
		"admin.entity.createlocationtransferadjustment_nav": "Location Transfer Adjustment",
		"entity.inventory_plural": "Inventory Transactions",
		"permission.setting.listroundingrule": "Rounding Rule - List",
		"setting.skuallowwaitlistingflag": "Allow waitlisting",
		"processobject.product_updateskus.updatelistpriceflag": "Update List Price",
		"entity.sku.subscriptionterm": "Subscription Term",
		"entity.product.process.updatedefaultimagefilenames_confirm": "Are you sure that you want to override the default image filename?  Doing this may remove your existing default images.",
		"permission.order.detailorder": "Order - Detail",
		"entity.email.relatedobjectprimaryidfield": "Related Object Primary ID Field",
		"entity.type.typename": "Name",
		"entity.updatescript.scriptpath": "Script Path",
		"entity.sku.stocks": "stocks",
		"processobject.product_uploaddefaultimage.uploadfile": "Select Image File",
		"entity.vendoraccount_plural": "Vendor Accounts",
		"validate.create.orderdelivery_create.orderdeliveryitems.hasrecipientsforallgiftcarddeliveryitems": "You do not have enough gift recipients to fulfill these items.",
		"entity.producttype.promotionqualifiers": "Promotion Qualifiers",
		"validate.audit.rollback.rollbackpointdoesnotexist": "Rollback point does not exist.",
		"setting.integrationusaepaypin": "Pin Number ",
		"permission.setting.deletecontent": "Content - Delete",
		"entity.account.process.resetpassword": "Reset Password",
		"entity.define.currencycode": "Currency Code",
		"setting.integrationorbitallivemodeflag": "Live Mode",
		"admin.entity.physicaltabs.discrepancies.qoh": "Quantity On Hand",
		"setting.integrationipaymentaccountid": "Account ID",
		"permission.pricing.deletepromotion": "Promotion - Delete",
		"setting.value": "Value",
		"entity.content.contentbody": "Content Body",
		"paypalexpress.main.main_permission": "PayPal Express Integration",
		"entity.define.shippingaccountaddress": "Shipping Account Address",
		"admin.entity.loyaltyredemptiontabs.producttypes": "Product Types",
		"validate.promotioncode.overmaximumusecount": "The promotion code that you have entered has exceeded the maximum number of usages.",
		"entity.report.reportname": "Report Name",
		"admin.entity.processcontent.duplicatecontent_failure": "The content could not be duplicated.",
		"admin.entity.settingstabs.locationconfiguration": "Location Configuration Settings",
		"entity.file.filedescription": "File Description",
		"entity.subscriptionterm.renewalterm_hint": "This defines the duration of all the subsequent auto-renew terms after the initial term.",
		"setting.skushippingweight": "Shipping Weight",
		"define.qvomax": "QVOMAX",
		"setting.integrationavataxcustomerusagetypepropertyidentifier_hint": "This is the property at the Account level where the user's tax exemption type is stored. Frequently, it is used to mark a customer as fully or partially tax exempt.",
		"entity.promotionreward.maximumuseperitem_hint": "This defines the maximum quantity of any single item that will have a discount applied.  If set to 10, and the item on the cart has a quantity of 15 the discount will only apply to the first 10 quantity.",
		"entity.subscriptionterm.skus": "SKUS",
		"setting.accountpaymentterm_hint": "This is the default term that will be applied to an accounts order when it is placed",
		"define.unknown": "Unknown",
		"define.gift-card": "Gift Card",
		"admin.entity.skutabs.saleshistory": "Sales History",
		"validate.accountpayment.offlineprocessingerror": "There was an unknown error trying to add an offline transaction for this order payment.",
		"entity.orderfulfillment.orderfulfillmentitems": "Order Fulfillment Items",
		"entity.attributeset.skus": "Skus",
		"validate.save.subscriptionterm.renewalreminderdays.regex": "The value entered for ${propertyName} should be numeric and optionally can be comma seperated.",
		"permission.product.editproducttype": "Product Type - Edit",
		"admin.entity.processproduct.uploaddefaultimage_success": "Product Image was Uploaded Successfully",
		"validate.order.orderitemoutofstock": "The product item can not be added to your order because of inventory constraints.",
		"validate.delete.promotion.promotioncodes.getpromotioncodesdeletableflag": "Promotion contains a Promotion Code that is not deletable",
		"entity.vendoremail.vendoremailtype": "vendorEmailType",
		"entity.remoteentity_plural": "Remote Entities",
		"entity.attribute.attributetype.atselectbox": "Select Box",
		"entity.country.localityshowflag": "Show Locality",
		"entity.currency.currencycode": "Currency Code",
		"permission.warehouse.detailstockadjustment": "Stock Adjustment - Detail",
		"setting.integrationpayflowprousername": "User Name",
		"entity.location.locationname": "Location Name",
		"setting.skuqatsincludesqnroroflag_hint": "By setting this to 'yes' any quantity not yet received on 'Open Return Orders' will be included in the Quantity Available To Sell",
		"validate.save.currencyrate.effectivestartdatetime.gtnow": "Start date must be greater than now.",
		"entity.eventtrigger_plural": "Event Triggers",
		"entity.promotionqualifier.skus": "Skus",
		"setting.integrationendiciasyncftpsitedropoffdirectory": "FTP Sync Dropoff Directory",
		"setting.integrationfullcirclelocaltransferurlpassword": "Local Transfer URL Password",
		"entity.address.street2address": "Street Address 2",
		"validate.create.account_create.emailaddress.getemailaddressnotinuseflag": "The email address that you have entered is already in use.  If you have forgotten you password, you can use the 'forgot password' tool to reset your password via email.",
		"entity.orderitem.estimatedfulfillmentdatetime": "Estimated Fulfillment Date Time",
		"entity.filerelationship.file": "File",
		"print.packingslip": "Packing Slip",
		"entity.schedule.schedulename": "Schedule Name",
		"entity.promotionreward.amounttype": "Discount Type",
		"entity.promotion_plural": "Promotions",
		"entity.serverinstance.serverinstanceid": "Server Instance ID",
		"mura.main.updateviews": "Update Views",
		"admin.entity.subscriptionbenefittabs.categories": "Categories",
		"entity.product.productcode_validateunique": "The product code is already in use for another product.",
		"defaultmessage_isvalidobjectemptyarray": "validation failed because a valid array cannot be empty.",
		"admin.entity.processstockadjustment.additems": "Add Items",
		"admin.entity.skutabs.alternateskucodes": "Alternate Sku Codes",
		"validate.delete.sku.orderitems": "The sku cannot be delete because it has orders.",
		"setting.integrationpayleaplivemodeflag": "Live Mode",
		"entity.product.trackinventoryflag": "Track Inventory",
		"validate.define.minvalue": "${propertyName} must be ${constraintValue} or more",
		"entity.sku.process.changeeventdates": "Edit Event Dates",
		"setting.globalurlkeyaddress": "Address URL Key",
		"entity.app_plural": "Applications",
		"entity.category_plural": "Categories",
		"validate.delete.accountemailaddress.primaryflag.eq": "You cannot delete this email address because it is the accounts primary email address",
		"entity.printtemplate.printtemplateid": "Print Template ID",
		"validate.createpassword.account_createpassword.password.regex": "Admin passwords should include at least 1 letter, 1 number, and be 7 or more characters long.",
		"entity.product.allowbackorderflag": "Backorder OK",
		"processobject.sku_addlocation.editscope": "Edit scope",
		"entity.audit.audittype.update": "Updated",
		"setting.integrationvertexdivision": "Division",
		"entity.promotionqualifier.qualifiertype.contentaccess": "Content Access",
		"admin.entity.detailorderitem.currentskurenewalprice": "Current Sku Renewal Price",
		"setting.globalpublicautologoutminutes": "Log Out Public Accounts After X Minutes of Inactivity",
		"permission.setting.editattributeset": "Attribute Set - Edit",
		"define.credit": "Credit",
		"entity.workflowtaskaction.update": "Update",
		"entity.addresszone.addresszonename": "Address Zone Name",
		"entity.producttype_plural": "Product Types",
		"validate.changeeventdates.sku_changeeventdates.eventenddatetime.gtdatetimeproperty": "",
		"validate.define.bundlegrouprequired": "A Bundle Group is Required",
		"admin.entity.vendorordertabs.orderitems": "Order Items",
		"frontend.cart.detail": "Shopping Cart",
		"setting.paymentmethodstorecreditcardnumberwithorder": "Auto Store Credit Card Number With Order",
		"setting.integrationvertexsendinvoiceflag": "Send All Order Invoices To Vertex",
		"setting.emailsmtpserver": "SMTP Server",
		"entity.collection.collectionname": "Collection Name",
		"setting.integrationupsshipfromname": "Shipping Name",
		"admin.entity.emailtabs.textbody": "Text Body",
		"setting.globalassetsfilefolderpath": "File Assets Folder Path",
		"entity.measurementunit.measurementtype": "Measurement Type",
		"entity.commentrelationship.referencedexpressionproperty": "Referenced Expression Property",
		"entity.orderpayment.referencingorderpayments": "Referencing Order Payments",
		"setting.iintegrationauthorizenettestmodeflag": "Test Mode ",
		"admin.entity.processeventregistration.cancel_success": "Registration has been Cancelled.",
		"validate.account.forgotnotfound": "No account found with the email you provided",
		"entity.vendoraddress.vendoraddressid": "vendorAddressID",
		"frontend.account.detail.header": "Account Details",
		"entity.order.orderreturns": "Order Returns",
		"entity.audit.changedetails.propertychanged.create": "Set",
		"entity.orderpayment.providertoken": "Provider Token",
		"entity.vendorskustock.cost": "cost",
		"permission.setting.deleteschedule": "Schedule - Delete",
		"entity.sku.delete_validateordered": "This SKU cannot be deleted because it has been ordered.",
		"entity.productbundlegroup.skucollectionconfig": "Sku Collection Config",
		"entity.productschedule.recurringtimeunit": "Recurs",
		"validate.delete.type.systemcode.haspeertypewithmatchingsystemcode": "The Type System Code must have a peer Type with a matching System Code",
		"setting.integrationorbitalbin": "BIN",
		"admin.entity.settingstabs.image": "Image Settings",
		"entity.orderitem.price": "Price",
		"permission.account.editaccount": "Account - Edit",
		"admin.main.update_nav": "Update Slatwall",
		"admin.entity.accountloyaltytabs.accountloyaltytransactions": "Account Loyalty Transactions",
		"define.september": "September",
		"admin.entity.updatefrontendviews_nav": "Update All Frontend Views",
		"entity.attributevalue.brand": "Brand",
		"entity.addresszonelocation.addresszone": "Address Zone",
		"processobject.order_addorderitem.saveshippingaccountaddressname": "Nickname",
		"entity.producttype.promotionqualifierexclusions": "Promotion Qualifier Exclusions",
		"entity.email.emailname": "Email Name",
		"validate.define.uniqueornull": "${propertyName} must be unique or empty",
		"entity.workflowtask.norecordsfound": "No tasks have been created",
		"entity.type.typeidpath": "Type ID Path",
		"entity.order.referencedorderid": "Referenced Order ID",
		"entity.shippingmethod.delete_success": "Shipping Method was saved successfully",
		"entity.taskhistory.response": "Response",
		"entity.accountpayment.bankroutingnumberencrypted": "Bank Routing Number Encrypted",
		"entity.eventregistration.process.pendingconfirmation": "Change to Pending Confirmation",
		"entity.physicalcountitem.sku": "Sku",
		"entity.workflowtrigger.triggerevent": "Trigger Event",
		"entity.accountpaymentmethod.accountpaymentmethodid": "Account Payment Method ID",
		"entity.stockadjustment.type": "Type",
		"entity.attribute.attributetype.relatedobjectmultiselect": "Related Object Multiselect",
		"admin.entity.addorderitemgiftrecipient.createrecipient": "Create Recipient",
		"entity.productimage.imagedescription": "Image Description",
		"entity.term.termname": "Term Name",
		"admin.account.processsubscriptionusage.cancel_success": "This subscription usage has been successfully canceled.",
		"entity.product.webqc": "webQC",
		"entity.vendororder.estimatedreceivaldatetime": "Estimated Receival",
		"entity.subscriptionusagebenefit.renewalsubscriptionusage": "Renewel Subscription Usage",
		"entity.loyaltyredemption.excludedbrands": "Excluded Brands",
		"setting.globalencryptionservice": "Encryption Service",
		"entity.accountpaymentapplied.accountpayment": "Account Payment",
		"entity.country.street2addresslabel": "Street2 Address Label",
		"setting.integrationuspstestingflag": "Test Mode ",
		"entity.email.relatedobjectid": "Related Object ID",
		"setting.integrationpayflowprolivemodeflag": "Live Mode",
		"entity.loyaltyredemption.redemptionpointtype.monthly": "Monthly Point Balance",
		"permission.product.deleteproductreview": "Product Review - Delete",
		"entity.product.webqoh": "webQOH",
		"entity.order.shippingaccountaddress": "Shipping Account Address",
		"entity.paymentmethod": "Payment Method",
		"entity.alternateskucode.alternateskucodeid": "Alternate Sku Code ID",
		"admin.define.detail_nav": "View ${itemEntityName}",
		"report.orderitemreport.returnprediscount": "Pre Discount Return",
		"entity.session.lastrequestipaddress": "Last Request IP Address",
		"setting.integrationpayflowpropartnerid": "Partner ID",
		"admin.productbundle.bundlegrouptype": "Bundle Group Type",
		"setting.integrationfullcirclefcftpusesecure": "Use Secure FTP (SFTP)",
		"entity.emailbounce.rejectedemailsubject": "Rejected Email Subject",
		"setting.integrationvertexdepartment": "Department",
		"entity.commentrelationship.referencedexpressionentity": "Referenced Expression Entity",
		"define.discount": "Discount",
		"setting.skubundleautobreakupinventoryonreturnflag": "Bundle Auto Breakup Inventory On Return",
		"entity.brand.loyaltyredemptionexclusions": "Loyalty Redemption Exclusions",
		"define.order": "Order",
		"processobject.sku_editcapacity.editscope": "Edit scope",
		"entity.orderpayment.order": "Order",
		"entity.addresszone.taxcategoryrates": "Tax Category Rates",
		"entity.taxapplied.taxlocality": "Tax Locality",
		"entity.email": "Email",
		"entity.accountpayment": "Account Payment",
		"entity.loyalty.loyaltyredemptions": "Loyalty Redemptions",
		"admin.entity.createmanualoutadjustment_nav": "Manual Out Adjustment",
		"setting.globalextendedsessionautologoutindays": "Log out public users after x days of inactivity when using extended sessions.",
		"entity.accountpaymentmethod.creditcardnumber": "Credit Card Number",
		"entity.accountloyalty.process.manualtransaction": "Manual Transaction",
		"admin.define.list_permission": "${itemEntityName} - View List",
		"entity.subscriptionterm.graceperiodterm": "Grace Period Term",
		"setting.skudefaultimagenamingconvention": "Default Image Naming Convention",
		"define.firstname": "First Name",
		"setting.skuqatsincludesqnrovoflag_hint": "By setting this to 'yes' any quantity not yet received on 'Open Vendor Orders' will be included in the Quantity Available To Sell",
		"entity.integration.fw1readyflag": "FW1 Ready Flag",
		"entity.loyaltyredemption.producttypes": "Product Types",
		"entity.stockadjustmentdeliveryitem.stockadjustmentitem": "Stock Adjustment",
		"setting.siterecaptchasecretkey": "Recaptcha Secret Key",
		"entity.stock.vendororderitems": "Vendor Order Items",
		"entity.order.stockreceivers": "Stock Receivers",
		"entity.taxapplied.appliedtype": "Applied Type",
		"entity.locationconfiguration_plural": "Location Configurations",
		"entity.commentrelationship_plural": "Comment Relationships",
		"entity.stockadjustment.purchaseorder": "purchaseOrder",
		"entity.stockreceiver.stockadjustment": "Stock Adjustment",
		"entity.user.firstname": "firstName",
		"entity.accountemailaddress.emailaddressconfirm": "Confirm Email Address",
		"entity.stockadjustmentdeliveryitem.stock": "Stock",
		"setting.integrationclickandbuyprojectid": "Project ID",
		"entity.vendoraddress_plural": "Addresses",
		"entity.option.optionimage_hint": "Select Associated Option Image to Upload (optional)",
		"setting.globalnosessionpersistdefault_hint": "If this is set to yes then sessions will only be persisted when they need to for login & carts",
		"admin.entity.promotionqualifiertabs.fulfillmentmethods": "Fulfillment Methods",
		"admin.warehouse.detailstockadjustment.fromlocationname": "From Location Name",
		"admin.export.listfiltered": "Export Filtered List",
		"entity.content.contenttemplatefile": "Template",
		"permission.setting.createtype": "Type - Create",
		"entity.productbundlegroup.maximumquantity_hint": "This defines the maximum quantity of items that can be selected for this group on a per bundle build up basis.  Leave blank for unlimited",
		"setting.integrationfedexshipperstatecode": "Shipping From State Code ",
		"entity.loyaltyaccruement.excludedbrands": "Excluded Brands",
		"admin.entity.settingstabs.task": "Task Settings",
		"entity.shippingmethodoption.totalcharge": "Total Charge",
		"entity.task.taskhistories": "Task History",
		"admin.pricing.createpromotionqualifierfulfillment": "Create Promotion Qualifier Fulfillment",
		"entity.taskschedule.startdatetime": "Start Date",
		"admin.pricing.createpromotionrewardfulfillment": "Create Promotion Reward Fulfillment",
		"entity.accountpaymentmethod.bankroutingnumber": "Bank Routing Number",
		"entity.shippingmethodrate.shippingmethodratename": "Rate Name",
		"entity.sku.qc": "QC",
		"setting.integrationorbitalmerchantidbycurrencycodelist_hint": "This should be a comma seperated list of currencyCode=merchantID.  If this setting is defined the Merchant ID setting will only be used if the currency code for the transaction isn't defined in this list.  For example: USD=192001,CAD=192002 ",
		"entity.currency.currencyisonumber": "ISO Number",
		"entity.orderfulfillment.fulfillmentshippingmethodoptions": "Fulfillment Shipping Method Options",
		"entity.orderitem.quantityunreceived": "Qty. Unreceived",
		"admin.entity.accountpaymenttabs.paymenttransactions": "Payment Transactions",
		"entity.account.cmsaccountid": "CMS Account ID",
		"entity.accountpayment.termoffsetunreceived": "Amount Unreceived",
		"admin.entity.detailpromotion.initialperiod": "Initial Period",
		"admin.entity.ordertabs.promotions": "Promotions",
		"admin.entity.settingstabs.paymentmethod": "Payment Method Settings",
		"setting.integrationmuralookuplistingcontentobjects": "Lookup Listing Page Content Objects",
		"setting.integrationorbitalmerchantid": "Merchant ID",
		"setting.integrationupspassword": "UPS Password ",
		"entity.workflowtrigger.triggertype": "Trigger Type",
		"define.amount": "Amount",
		"entity.taxcategoryrate.addresszone": "Address Zone",
		"setting.integrationfullcirclelocaltransferurlpassword_hint": "If the transfer URL sits behind a Username or Password then please specify it here.",
		"api.define.create_error": "There was an error trying to create the ${EntityName}.",
		"setting.integrationipaymentinvoicetext": "Invoice Text (max. 25)",
		"endicia.main.syncall_permission": "FTP Sync Both",
		"entity.shippingmethodoptionsplitshipment.shipmentcharge": "Shipment Charge",
		"entity.term.loyaltyaccruementexpirationterms": "Loyalty Accruement Expiration Terms",
		"admin.entity.loyaltyredemptiontabs.brands": "Brands",
		"entity.commentrelationship.referencedrelationshipflag": "Referenced Relationship Flag",
		"frontend.checkout.saveshippingmethod": "Save & Continue",
		"define.year": "year",
		"entity.contentaccess_plural": "Content Accesses",
		"entity.promotionaccount": "Promotion Account",
		"entity.subscriptionbenefit.skus": "SKUS",
		"entity.session.loggedindatetime": "Logged In Datetime",
		"admin.entity.subscriptionusagetabs.orderitems": "Order Items",
		"entity.fulfillmentmethod.fulfillmentmethodid": "Fulfillment Method ID",
		"setting.integrationvirtualmerchanttestmerchantid": "Test VirtualMerchant ID (6 Digit)",
		"entity.subscriptionusage.initialorder": "Initial Order",
		"entity.option.optioncode_hint": "A unique string (alphanumerc, no spaces) to identify the option.",
		"setting.skuregistrationapprovalrequiredflag": "Registration Approval Required",
		"entity.paymentmethod.paymentmethodname": "Payment Method Name",
		"entity.producttype.attributevalues": "Attribute Values",
		"entity.integration_plural": "Integrations",
		"entity.loyalty.loyaltyterms": "Loyalty Terms",
		"validate.create.product_create.purchasestartdatetime.gtnow": "Purchase Start Date must occur in the future",
		"admin.entity.processorder.addorderitem_error": "There was an error adding the Order Item to this Order",
		"entity.state.country": "country",
		"validate.save.accountcollection.collection.hasvalidconfiguration": "Account Collection cannot be based on both a persisted Collection and an Account Collection Config at the same time",
		"admin.entity.detailorderfulfillment.item_totals": "Item Totals",
		"entity.accountpayment.accountpaymentmethod": "Account Payment Method",
		"entity.productreview": "Product Review",
		"entity.orderfulfillment.quantityundelivered": "Quantity Undelivered",
		"validate.newpassword.duplicatepassword": "Your new password cannot be same as the previous 4 passwords.",
		"entity.product.onclearancesale": "onClearanceSale",
		"entity.stockadjustment": "Stock Adjustment",
		"entity.orderitem.ordershipment": "Order Shipment",
		"admin.entity.processsubscriptionusage.addusagebenefit_success": "Subscription Benefit Added",
		"processobject.product_addsubscriptionsku.renewalmethod": "Renewal Method",
		"entity.producttype.pricegrouprateexclusions": "Price Group Rate Exclusions",
		"entity.product.madeincountry": "madeInCountry",
		"admin.entity.orderdeliverytabs.orderdeliveryitems": "Order Delivery Items",
		"entity.loyaltyredemption.excludedproducttypes": "Excluded Product Types",
		"entity.collection.baseentityname": "Object Type",
		"entity.currencyrate.conversionrate": "Conversion Rate",
		"entity.orderitem": "Order Item",
		"entity.physical.products": "Physical Products",
		"admin.entity.preprocessorder_addorderitem.wrongcurrency_info": "The item that you have attempted to add, can not be sold in the same currency as this order.",
		"entity.report.dynamicdaterangetype.weektodatemonday": "Week to Date ( Starting Monday )",
		"entity.product.loyaltyaccruementexclusions": "Loyalty Accruement Exclusions",
		"define.categories": "Categories",
		"entity.sku.promotionqualifiers": "Promotion Qualifiers",
		"entity.orderpayment.giftcardtransactions": "Gift Card Transactions",
		"entity.productschedule.eventstarttime": "Event start time",
		"setting.accountlockminutes": "Lock Accounts For x Minutes",
		"setting.integrationstripetestmode": "Test Mode",
		"entity.content.site": "Site",
		"validate.addeventschedule.product_addeventschedule.eventendtime.gtdatetimeproperty": "Event end date must occur after start date.",
		"entity.shippingmethodoption.totalshippingitemprice": "Total Shipping Item Price",
		"entity.brand": "Brand",
		"admin.entity.processgiftcard.redeemtoaccount_failure": "The account could not be associated with this gift card.",
		"setting.skuqatsincludesqnrosaflag_hint": "By setting this to 'yes' any quantity not yet received on 'Open Stock Adjustments' will be included in the Quantity Available To Sell",
		"define.permissions": "Permissions",
		"validate.delete.accountpaymentmethod.paymenttransactions.hasonlygeneratetokentransactions": "Account Paymnet Method requires Generate Token Transactions Exclusively",
		"entity.taxapplied.taximpositiontype": "Tax Imposition Type",
		"entity.audit.sessionaccountemailaddress": "Email",
		"permission.pricing.detailpromotion": "Promotion - Delete",
		"define.thursday": "Thursday",
		"admin.entity.settings": "Settings",
		"setting.integrationfullcirclefcftpusername_hint": "Username to connect to FC Server via FTP",
		"admin.entity.pricegroupratetabs.currencies": "Currencies",
		"setting.subscriptionusageautoretrypaymentdays": "Auto Retry After Day(s)",
		"admin.entity.settingstabs.brand": "Brand Settings",
		"define.email": "Email",
		"setting.skuorderminimumquantity": "Min Order Qty.",
		"validate.delete.locationaddress.locationaddressid.hasnoassociatedorders": "This location address cannot be deleted. It is associated to an order.",
		"permission.setting.editlocation": "Location - Edit",
		"entity.app.approotpath": "Application Root Path",
		"entity.comment.commentrelationships": "Comment Relationships",
		"entity.taxcategoryrate.taxintegration": "Tax Integration",
		"setting.integrationmuralegacycreateaccount": "Legacy Create Account Filename",
		"setting.skueventenforceconflicts": "Enforce conflicts for event products",
		"entity.orderreturn.fulfillmentrefundamount": "Fulfillment Refund Amount",
		"validate.delete.orderitem.orderstatuscode.inlist": "Cannot delete an orderitem which is part of a processed order.",
		"entity.productlistingpage_plural": "Product Listing Pages",
		"permission.setting.listorderorigin": "Order Origin - List",
		"entity.order.testorderflag": "Test Order",
		"setting.skuregistrationautoapprovalaccountcollection": "Registration Auto Approval Accounts",
		"setting.globalcurrencytype": "Currency Type",
		"entity.shippingmethodrate.shippingintegrationmethod": "Service Provider Method",
		"admin.setting_nav": "View A List of Settings",
		"entity.shippingmethodoptionsplitshipment.shippingmethodoption": "Shipping Method Option",
		"validate.order.account.populate": "Customer Account is required.",
		"setting.integrationgigyalegacyuidpropertyidentifier": "Legcacy Gigya UID Property Identifier (advanced)",
		"entity.define.productreviews": "Product Reviews",
		"admin.entity.settingstabs.email": "Email Settings",
		"defaultmessage_pastdate": "{1} must be a date in the past.",
		"entity.location_plural": "Locations",
		"entity.promotionqualifier.producttypes": "Product Types",
		"entity.sku.loyaltyaccruements": "Loyalty Accruments",
		"define.graceperiod": "Grace Period",
		"permission.integration": "Integration",
		"paypalexpress_permission": "PayPal Express Integration",
		"define.language.de_de": "German",
		"entity.measurementunit.conversionratio": "Conversion Ratio",
		"permission.product": "Product",
		"setting.integrationfullcirclefcftppassword": "Full Circle FTP Password",
		"entity.taxapplied_plural": "Applied Taxes",
		"entity.task.taskmethod.updateeventwaitlists": "Update Event Waitlists",
		"entity.integration.customactiveflag": "Custom Integration Active",
		"entity.orderdeliveryitem.orderdelivery": "Order Delivery",
		"entity.email.relatedobject": "Related Object",
		"entity.app.appid": "App ID",
		"permission.product.listproductreview": "Product Review - List",
		"setting.integrationfullcirclelocaltransferurlpath_hint": "This needs to be a URL that points to the Transfer Directory so that transfer files can be imported over HTTP. Example: http://202.202.202.202/fctransfer",
		"setting.contentmetakeywordsstring": "Content Meta Keywords String",
		"setting.integrationmuracreatedefaultpages": "Create Default Pages and Templates",
		"entity.order.process.updatestatus": "Force Status Update",
		"validate.create.product_create.eventstartdatetime.gtnow": "Event Start Date must occur in the future",
		"entity.define.modifiedbyaccount": "Modified By",
		"entity.paymentterm.paymenttermid": "Payment Term ID",
		"entity.postalcode_plural": "Postal Codes",
		"entity.vendorphonenumber": "Vendor Phone Number",
		"entity.attribute.decryptvalueinadminflag": "Decrypt Value In Admin",
		"admin.main.encryption.reencryptdata_now": "Re-encrypt Now",
		"entity.country_plural": "Countries",
		"entity.report.dynamicdaterangeendtype": "Date Range As Of",
		"entity.attributevalue.vendororder": "Vendor Order",
		"entity.workflowtaskaction.export": "Export",
		"entity.productbundlebuild_plural": "Product Bundle Builds",
		"setting.contentrequirepurchaseflag": "Require Purchase for Access",
		"admin.entity.processorder.placeonhold_success": "This order has been placed 'On Hold'.",
		"entity.user.company": "company",
		"define.giftmessage": "Gift Message",
		"entity.promotioncode_plural": "Promotion Codes",
		"entity.eventregistration.process.attend": "Change to Attended",
		"setting.integrationavataxsourcecity": "Source City",
		"setting.skugiftcardcodelength": "Length of Autogenerated Gift Card Code",
		"permission.main": "Main",
		"entity.productbundlegroup_plural": "Product Bundle Groups",
		"setting.integrationsofortcustomerid": "Customer ID",
		"entity.databasecache.databasecachevalue": "Database Cache Value",
		"admin.entity.createproduct.bundlecontentaccess": "Bundle Content",
		"permission.setting.detailcategory": "Category - Detail",
		"entity.giftcard.giftcardpin": "Gift Card Pin",
		"validate.save.country.countrycode3digit.maxlength": "Country Code 3 Digit must be 3 characters",
		"entity.product.datefirstreceived": "dateFirstReceived",
		"entity.accountemailaddress_plural": "Account Email Addresses",
		"define.qc.full": "Committed",
		"mura.muraevent.oncontentedit.createskuheader": "Create SKU to Sell Content",
		"entity.emailverification.accountemailaddress": "Account Email Address",
		"entity.define.expirationdate": "Expiration Date",
		"setting.integrationgigyasecretkey": "Secret Key",
		"define.authorize": "Authorize",
		"entity.taxapplied.taxrate": "Tax Rate",
		"entity.loyaltyaccruement.startdatetime": "Start Date/Time",
		"permission.pricing.editpromotion": "Promotion - Edit",
		"entity.skubundle_plural": "Sku Bundles",
		"entity.define.createdbyaccount": "Created By",
		"setting.emailimapserver": "Bounced Email Server (IMAP)",
		"entity.vendororder.vendorordernumber": "Order Number",
		"entity.giftcardtransaction.giftcardtransactionid": "Gift Card Transaction ID",
		"entity.paymentmethod.subscriptionrenewaltransactiontype": "Subscription Renewal Trans.",
		"entity.giftcard.calculatedbalanceamount": "Balance Amount",
		"entity.loyaltyaccruement.accruementtype.fulfillmentmethodused": "Fulfillment Method Used",
		"setting.productautoapprovereviewsflag_hint": "Selecting this option will automatically setup product reviews to be able to be approved automatically and show up on the front end of the site.",
		"admin.define.delete": "Delete ${itemEntityName}",
		"permission.integration.editintegration": "Integration - Edit",
		"define.length": "Length",
		"entity.postalcode.state": "state",
		"entity.loyaltyterm.loyalty": "Loyalty",
		"setting.accounteligiblepaymentmethods_hint": "This should be a list of all the available payment methods an account can utilize on their orders.",
		"setting.integrationfedextestingflag": "Test Mode ",
		"entity.product.process.addeventinstance": "Add Event Instance",
		"validate.addorderitem.order_addorderitem.sku.activeflag.eq": "You cannot add an inactive sku.",
		"admin.entity.ordertabs.orderpayments.nonactive": "Invalid & Removed",
		"entity.audit.audittype": "Type",
		"entity.attributevalue.attributevalueencrypteddatetime": "Attribute Value Encrypted Date Time",
		"validate.createpassword.account.slatwallauthenticationexistsflag.eq": "There is already a password defined for this account.  You may want to use the 'change password' tool or you can remove the password under the 'Authentication Details' section.",
		"define.new": "New",
		"entity.vendor_plural": "Vendors",
		"entity.emailtemplate_plural": "Email Templates",
		"entity.vendor.vendoremailaddresses": "Vendor Email Addresses",
		"setting.integrationsofortprojectid": "Project ID",
		"entity.workflowtriggerhistory": "Trigger History",
		"validate.addrecipientstoorderitem.orderitem_addrecipientstoorderitem.assignedgiftrecipientquantity.gt": "You must select or create a gift recipient.",
		"admin.main.encryption.reencryptdata_success": "Encrypted data stored in the database was re-encrypted with most recent encryption password.",
		"define.searchandassignproducts": "Search & assign products...",
		"entity.paymentmethod.process.processcreditcardpayment": "Process Credit Card Payment",
		"define.status": "Status",
		"entity.workflowtrigger.runningflag": "Running Flag",
		"processobject.orderfulfillment_fulfillitems.verifycreditcardcaptureflag": "Verify Credit Card Capture",
		"entity.address.postalcode_validaterequired": "Please enter a valid Postal Code",
		"validate.cancelorder.order.orderitems.cancancel": "This order cannot be cancelled",
		"validate.processsku_changeeventdates.editscope": "You must select a Scheduling Type",
		"processobject.account_addaccountpayment.saveaccountpaymentmethodflag": "Save as Account Payment",
		"entity.type.systemcode": "System Code",
		"setting.integrationuspsshipfrompostalcode": "Shipping From Postal Code ",
		"entity.fulfillment": "Fulfillment",
		"validate.save.sku.options.hasuniqueoptions": "The sku option is not unique.",
		"entity.account.termaccountbalance": "Term Account Balance",
		"entity.skucurrency.sku": "SKU",
		"permission.setting.editroundingrule": "Rounding Rule - Edit",
		"admin.entity.orderitemgiftrecipient.firstname": "First Name",
		"setting.globaluseextendedsession": "Turns on extended sessions for frontend users.",
		"admin.entity.processsubscriptionusage.updatestatus_success": "Subscription Status Updated Successfully",
		"entity.orderdelivery.orderdeliveryid": "Order Delivery ID",
		"entity.account.subscriptionusagebenefitaccounts": "Subscription Usage Benefit Accounts",
		"setting.productimagesmallwidth": "Small Image Width",
		"admin.entity.processorderreturn.receive_success": "Order return has been received",
		"admin.entity.createfile": "Add File",
		"validate.save.promotionrewardcurrency.currencycode.neqproperty": "Currency Code cannot be equal to Promotion Reward Currency Code",
		"entity.accountpaymentmethod.accountpaymentmethodname": "Nickname",
		"entity.audit.changedetails.propertychanged.archive": "Changed",
		"entity.optiongroup.delete_success": "The Option Group was successfully deleted.",
		"api.main.getformresponses": "API GET Form Responses",
		"entity.promotionperiod.maximumusecount": "Max. Use Count",
		"entity.shippingmethodrate.minimumshipmentweight": "Min Fulfillment Weight",
		"endicia.main.default_permission": "Endicia Integration Tools",
		"setting.siteverifyaccountemailaddressemailtemplate_hint": "This setting defines the site based e-mail template that is going to be sent for account email addresses getting validated",
		"entity.promotionreward.excludedproducts": "Product Exclusions",
		"setting.integrationpayleappassword": "Password",
		"define.april": "April",
		"dashboard.tracksessionissue_error": "There is an know issue with you current configuration of Mura & Slatwall that will cause the frontend to lock up.  You can either open up your mura /config/settings.ini and set trackSessionInNewThread=0 or you can update you mura core to the latest version.",
		"admin.entity.preprocessphysical_title": "Add Physical Count",
		"validation.define.lte": "This value is invalid",
		"admin.entity.detailorderpayment.dynamiccredit": "Dynamic Credit Amount",
		"entity.attributeset.attributesetid": "Attribute Set ID",
		"admin.entity.ordertabs.referencingorders": "Referencing Orders",
		"entity.postalcode.city": "city",
		"entity.product.process.addsubscriptionsku": "Add Subscription Sku",
		"admin.entity.processaccount.create_success": "Account Created",
		"admin.define.edit_nav": "Edit ${itemEntityName}",
		"admin.main.encryptionupdatepassword": "Update Database Encryption Password",
		"entity.attributevalue.productreview": "Product Review",
		"entity.optiongroup.imagegroupflag_hint": "If this is selected, then any product with options from this group will have different images",
		"entity.accountpayment.checknumber": "Check Number",
		"setting.skushippingcostexempt": "Shipping Cost Exempt",
		"entity.product.promotionrewardexclusions": "Promotion Reward Exclusions",
		"entity.access_plural": "Accesses",
		"entity.stock.qoh": "qoh",
		"admin.entity.processsite.create_success": "Site saved successfully",
		"entity.order.cancel_validatestatus": "Order cannot be deleted due to order status ({statusValue})",
		"entity.formresponse_plural": "Form Responses",
		"entity.audit.process.rollback": "Rollback",
		"entity.shippingmethodrate.addresszone": "Address Zone",
		"permission.pricing.listpromotion": "Promotion - List",
		"admin.entity.ordertabs.orderpayments.credits": "Credits",
		"setting.integrationorbitalpassword_hint": "Orbital Gateway Password",
		"admin.entity.permissiongrouptabs.actionpermissions": "Action Permissions",
		"entity.loyaltyaccruement.accruementtype.orderclosed": "Order Closed",
		"processobject.sku_changeeventdates.schedulestartdate": "Schedule Starts On",
		"entity.file": "File",
		"entity.report.dynamicdaterangeendtype.thisweekendsunday": "Current Week ( Ending Sunday )",
		"setting.integrationpayflowproaccountpaymentcommentonetemplate_hint": "This template will be string replaced based on the order payment, and then passed as custom comment 1 to PayFlow Pro.  An Example would be: ${accountPaymentID} or ${myCustomAccountPaymentAttributeCode}.  Plain text works as well",
		"admin.entity.accounttabs.accountpaymentmethods.adddisabled": "You cannot add any account payment methods because there are no payment methods configured that have 'Allow Save' set to yes.  Please update one of your payment methods under Config > Payment Methods to have 'Allow Save' set to yes.",
		"entity.accountauthentication.accesskey": "Access Key",
		"entity.shippingmethodrate.shippingrate": "Shipping Charge",
		"entity.account.process.createpassword": "Create Password",
		"admin.main.update_permission": "Update Slatwall",
		"setting.integrationpayflowproorderpaymentcommenttwotemplate_hint": "This template will be string replaced based on the order payment, and then passed as custom comment 2 to PayFlow Pro.  An Example would be: ${orderPaymentID} or ${myCustomOrderPaymentAttributeCode}.  Plain text works as well\"",
		"setting.paymentmethodstorecreditcardnumberwithaccount": "Auto Store Credit Card Number With Account",
		"entity.task": "Task",
		"entity.promotionapplied": "Promotion Applied",
		"admin.editfilteritem.saveandfinish": "Save And Finish",
		"entity.account.accountname": "Account Name",
		"entity.subscriptionterm.renewalterm": "Renewal Term",
		"entity.product.price": "Price",
		"validate.promotioncode.invaliddatetime": "The promotion code that you have entered is valid, but it is not currently available.  Verify the date / time that the promotion was running.",
		"entity.define.urltitle_hint": "This field is used to create the front-end URL for SEO purposes.  The value must contain only alpha-numeric charecters as well as - or _.  Best practice is to leave this value as all lower case",
		"admin.entity.orderitemgiftrecipient.email": "Email Address",
		"validate.processsubscriptionusage_renew.order.newflag": "The Subscription Usage could not be renewed because there was already an open renewal order. Please complete this order before attempting to renew.",
		"entity.file.fileupload": "File",
		"admin.entity.editskucurrency_disabled": "This default sku currency cannot be edited, if you would like to change the amount in this currency then just update the price values on the sku itself.",
		"setting.skuallowbackorderflag_hint": "Indicate whether this product can be backordered",
		"entity.stockhold.stockholdid": "Stock Hold ID",
		"admin.define.process_permission": "${itemEntityName} - Process",
		"entity.subscriptionusage.process.renew": "Renew",
		"entity.type.childrequiressystemcodeflag": "Child Requires System Code Flag",
		"permission.setting.listaddresszone": "Address Zone - List",
		"admin.entity.processorder.removepromotioncode_success": "Promotion code removed.",
		"entity.eventregistration.process_confrm": "Confirm",
		"entity.order.process.updateorderfulfillments": "Update Order Fulfillments",
		"defaultmessage_boolean": "{1} must be a valid boolean.",
		"entity.updateprice": "Price",
		"entity.shippingmethodrate.haspricegroups": "Price Groups",
		"define.confirm": "Confirm",
		"entity.roundingrule_plural": "Rounding Rules",
		"admin.entity.detailorderpayment.changeamount": "Change Amount",
		"entity.shippingmethodoptionsplitshipment.shipmentweight": "Shipment Weight",
		"define.totals": "Totals",
		"entity.subscriptionusage": "Subscription Usage",
		"entity.currencyrate.effectivestartdatetime_hint": "Set this as the datetime that you would like for the conversion rate to start applying.  The value can not be edited, and it needs to be something in the future.  If you leave it blank it will set the value as 'Now'.",
		"entity.vendor.brands": "Brands Offered",
		"defaultmessage_isvalidobjectemptystruct": "validation failed because a valid structure cannot be empty.",
		"entity.productbundlegroup.none": "None",
		"entity.vendor.emailaddress": "Email Address",
		"admin.entity.ordertabs.saleorderitems": "Sale Order Items",
		"entity.emailtemplate.emailtemplateid": "Email Template ID",
		"entity.subscriptionusage.mostrecentorder": "Most Recent Order",
		"admin.entity.ordertabs.orderpayments": "Order Payments",
		"entity.skualternate.skutype": "skuType",
		"validate.addorderpayment.order_addorderpayment.giftcardid.canpurchasewithgiftcard": "The gift card you're are trying to use either doesn't exists, isn't active, or is expired.",
		"processobject.physical_addphysicalcount.locationid": "Location ID",
		"admin.entity.createpromotionqualifiersubscription": "Subscription Item Qualifier",
		"entity.vendororder.taxtotal": "Tax",
		"entity.print_plural": "Prints",
		"define.global": "Global",
		"entity.location.locationconfigurations": "Location Configurations",
		"validate.account.emailaddress.exists": "This Email Address is already in use with another Account",
		"admin.entity.processorder.takeoffhold_success": "This order has been taken off 'On Hold' status.",
		"setting.brandmetadescriptionstring": "Brand Meta Description String",
		"entity.order.paymentauthorizedtotal": "Authorized Amount",
		"permission.order.editorderfullfillment": "Order Fulfillment - Edit",
		"entity.form.emailto": "Email To",
		"entity.sku.defaultflag": "Is Default",
		"processobject.subscriptionusage_cancel.effectivedatetime": "Effective Date Time",
		"entity.fulfillmentbatchitem.quantityonbatch": "Quantity On Batch",
		"entity.stockreceivervendororder.boxcount": "Box Count",
		"entity.stockadjustmentitem.quantity": "Qty.",
		"entity.integration.integrationpackage": "Integration Package",
		"entity.skuprice.price": "Price",
		"entity.order.orderid": "Order ID",
		"validate.createpassword.account_createpassword.password.minlength": "Account Password should be at least 8 characters long.",
		"entity.taxapplied.taxamount": "Tax Amount",
		"entity.product.promotionqualifierexclusions": "Promotion Qualifier Exclusions",
		"entity.sku.purchasestartdatetime": "Purchase Start Date",
		"entity.accountpayment.paymentmethod": "Payment Method",
		"setting.integrationvirtualmerchanttestaccountflag": "Test Mode",
		"define.friday": "Friday",
		"entity.taskschedule": "Task Schedule",
		"permission.vendor.deletevendor": "Vendor - Delete",
		"admin.main.log": "Slatwall Log",
		"setting.integrationstripelivesecretkey": "Live Secret Key",
		"entity.accountpayment.termoffsetunassigned": "(Additional Unassigned Amount)",
		"entity.skualternate.sku": "sku",
		"define.developerdocs": "Developer Docs",
		"setting.integrationvertexwebservicesurl_hint": "This is the URL of where the web services application is setup.  For example: http://127.0.0.1/vertex-ws/services",
		"validation.define.unique": "This value must be unique.",
		"entity.shippingmethodrate.maximumshipmentitemprice": "Max Fulfillment Subtotal",
		"entity.subscriptionusagebenefit.subscriptionbenefit": "Subscription Benefit",
		"admin.entity.createpromotionqualifierorder": "Order Qualifier",
		"mura.main_permission": "Dashboard",
		"processobject.subscriptionusage_renew.saveaccountpaymentmethodflag": "Save as Account Payment",
		"setting.integrationupsshipfromcity": "Shipping From City ",
		"entity.eventregistration.process.register": "Change to Registered",
		"entity.skualternate.skuvalue": "skuValue",
		"entity.accountpayment.termoffsetamount": "Amount",
		"setting.integrationipaymenttransactionsecuritykey": "Transaction Security Key",
		"setting.integrationuspspackagegirth": "Package Girth",
		"validate.save.accountcollection.collectionconfig.hasvalidconfiguration": "Account Collection cannot be based on both a persisted Collection and an Account Collection Config at the same time",
		"entity.collection.filter.norecordsfound": "No filters have been created",
		"entity.shippingmethodrate.maximumshipmentweight": "Max Fulfillment Weight",
		"entity.pricegroup.subscriptionbenefits": "Subscription Benefits",
		"entity.paymentmethod.paymentmethodcode": "Payment Method Code",
		"entity.eventtrigger.eventtriggertype": "Event Trigger Type",
		"entity.task_plural": "Tasks",
		"entity.addresszone.shippingmethods": "Shipping Methods",
		"define.title": "Title",
		"validate.account_setupinitialadmin.password.minlength": "Your password must be at least 8 characters long",
		"entity.stockadjustmentdelivery.deliveryopendatetime": "Delivery Open Date Time",
		"entity.setting.account": "Account",
		"setting.productimagemediumheight": "Medium Image Height",
		"entity.attribute.attributecode_hint": "A unique string (alphanumeric, no spaces) to identify the attribute.",
		"setting.integrationsagepayvendorid": "Vendor ID",
		"admin.entity.sku.renewalsubscriptionbenefits": "Renewal Subscription Benefits",
		"entity.fulfillmentmethod.shippingmethods": "Shipping Methods",
		"setting.emailimapserverusername": "Bounced Email Server Username",
		"entity.task.taskname": "Task Name",
		"define.now": "Now",
		"entity.audit.sessionipaddress": "IP",
		"entity.accountauthentication.accesskeypassword": "Access Key Password",
		"entity.form": "Form",
		"setting.skueligiblepaymentmethods": "Eligible Payment Methods",
		"entity.loyaltyaccruement.accruementtype.enrollment": "Program Enrollment",
		"setting.fulfillmentmethodautominreceivedpercentage": "Min. Amount Received Percentage",
		"validate.save.orderitemgiftrecipient.giftmessage.hascorrectgiftmessagelength": "Gift Card Message cannot be greater than global Gift Card Message Length setting ",
		"entity.sku.listprice": "List Price",
		"entity.measurementunit.unitname": "Unit Name",
		"entity.account.primarypaymentmethod": "Account Primary Payment Method",
		"entity.orderdelivery.process.create.cannotfulfillitem": "This item will not be fulfilled at this time.",
		"define.yesno": "Yes / No",
		"entity.category.categoryname": "Category Name",
		"entity.loyaltyredemption.pricegroup": "Price Group",
		"entity.email.eventname": "Event Name",
		"define.disabled": "Disabled",
		"define.qmax.full": "Maximum",
		"admin.entity.listproduct.createnocontent": "You cannot create a 'Content Access' product until you have content records defined.  This is typically done by integrating with a CMS, and adding content in that CMS.",
		"entity.task.taskid": "Task ID",
		"entity.attributevalue.attributevalueid": "attributeValueID",
		"admin.entity.settingstabs.advanced": "Advanced Settings",
		"admin.main.unlockaccount_info": "You have successfully unlocked this account.",
		"setting.skuallowpreorderflag": "Preorder OK",
		"entity.accountpaymentmethod.creditcardnumberencrypted": "Credit Card Number  Encrypted",
		"admin.entity.stockreceivertabs.stockreceiveritems": "Items Received",
		"permission.setting.detailorderorigin": "Order Origin - Detail",
		"setting.globalnosessionipregex": "Ignore Session Tracking IP Regex",
		"entity.permission.processcontext": "Process Context",
		"entity.locationconfiguration.locationtree": "Location",
		"entity.commentrelationship.product": "Product",
		"define.autoincrement": "Auto Increment",
		"entity.workflowtrigger.norecordsfound": "No triggers have been created",
		"admin.entity.sitetabs.sitesettings": "Site Settings",
		"permission.vendor.createvendor": "Vendor - Create",
		"admin.entity.apptabs.sitesettings": "Site Settings",
		"entity.productschedule.weeklyrepeatdays": "Days of the Week",
		"admin.entity.settingstabs.globaladvanced": "Global Advanced Settings",
		"entity.integration.integrationid": "Integration ID",
		"entity.order": "Order",
		"admin.entity.preprocessorder_addorderitem.fulfillmentdetails": "Fulfillment Details",
		"entity.account.promotioncodes": "Promotion Codes",
		"entity.accountpayment.termoffsettotal": "Total",
		"entity.paymentmethod.accountpaymentmethods": "Account Payment Methods",
		"api.define.save_error": "There was an error trying to save the ${EntityName}.",
		"entity.vendor.vendorwebsite": "Vendor Website",
		"validate.rollback.audit.audittype.inlist": "The audit type does not allow for rollback.",
		"entity.order.process.removeorderpayment": "Remove Order Payment",
		"setting.integrationelavonpintemplate": "Pin Template",
		"entity.session.sessioncookiepsid": "Persistent Session ID",
		"entity.vendor": "Vendor",
		"entity.define.shortreferenceid": "Short Reference ID",
		"setting.integrationfullcirclefcftpusesecure_hint": "Should files be pushed and pulled via secure FTP",
		"entity.taxapplied.taxjurisdictionname": "Tax Jurisdiction Name",
		"entity.subscriptionusage.subscriptionstatus": "Status",
		"entity.attribute.attributeinputtype.file": "File",
		"entity.product.productdisplaytemplate": "Product Display Template",
		"report.orderitemreport.quantityreturned": "Quantity Returned",
		"setting.integrationupsapikey": "API Key ",
		"entity.orderorigin_plural": "Order Origins",
		"entity.attribute.attributedescription": "Attribute Description",
		"entity.product.process.deletedefaultimage": "Delete Default Image",
		"validate.addorderitem.order_addorderitem.price.minvalue": "Price needs to be a positive number",
		"entity.option.productimages": "Product Images",
		"frontend.account.detail": "My Account",
		"validate.addorderpayment.order.statuscode.inlist": "You're not able to add an order payment with the order's current status.",
		"entity.orderitemgiftrecipient.orderitem": "Order Item",
		"admin.entity.promotionqualifiertabs.brands": "Brands",
		"entity.productrelationship.product": "Product",
		"admin.entity.settingstabs.globalpage": "Global Page Settings",
		"admin.entity.processorder.createreturn_success": "Return order created successfully",
		"defaultmessage_equalto": "{1} must be the same as {2}{3}.",
		"setting.skuqatsincludesqnrovoflag": "QATS Includes QNROVO",
		"permission.product.editproduct": "Product - Edit",
		"admin.pricing.promotionperiod.editdisabled_info": "This promotion period cannot be edited because it has expired.",
		"entity.subscriptionusagebenefitaccount.subsusagebenefitaccountid": "Subscription Usage Benefit Account ID",
		"permission.setting.listlocation": "Location - List",
		"entity.fulfillmentmethod.fulfillmentmethodname": "Fulfillment Method Name",
		"admin.entity.detailorderitem.currentskuprice": "Current Sku Price",
		"admin.entity.locationtabs.locationconfigurationsettings": "Location Configuration Settings",
		"entity.subscriptionusage.totalnumberofsubscriptionorderitems": "Total Subscription Order Items",
		"entity.orderitem.orderitemstatustype": "Order Item Status",
		"entity.orderpayment.purchaseordernumber": "Purchase Order Number",
		"setting.integrationauthorizenetduplicatewindow": "Duplicate Transaction Time Window",
		"entity.account.accountpaymentmethods": "Payment Methods",
		"define.average": "Average",
		"admin.default.accounts_nav": "Accounts",
		"admin.entity.detailpermissiongroup.superuser_info": "This is the super user permission group that can not be deleted or modified.  There is no need to set permissions for this group because any accounts assigned to this group has access to the entire application.",
		"entity.attribute.defaultvalue": "Default Value",
		"entity.order.referencedordertype.duplicate": "Duplicate",
		"admin.entity.promotionperiodtabs.promotionqualifiers": "Promotion Qualifiers",
		"entity.promotionreward.maximumuseperqualification_hint": "This setting is mostly used in defining things like buy one get one free where you would qualify by having a quantity of 2 of an item, and then this would be set to 1 with 100% discount.  If there are no qualifiers than this setting is never used.",
		"entity.productschedule_plural": "Product Schedules",
		"entity.pricegroup.pricegroupcode_hint": "A unique string (alphanumerc, no spaces) to identify the price group.",
		"setting.emailreplytoaddress": "Email Reply To Address",
		"entity.product.qc": "QC",
		"entity.promotionreward.maximumuseperqualification": "Max. Use Per Qualification",
		"mura.main.default_permission": "Mura Integration",
		"entity.eventregistration_plural": "Event Registrations",
		"entity.address.name": "Name",
		"admin.entity.processaudit.rollback_success": "Rollback was successful",
		"entity.paymentterm.orderpayments": "Order Payments",
		"entity.producttype.producttypeid": "productTypeID",
		"entity.sku.process.makeupbundledskus": "Makeup Sku Bundle",
		"setting.integrationmuralegacycheckout": "Legacy Checkout Filename",
		"admin.pricing.detailpromotion.norewards_info": "Currently there are no rewards assigned to this promotion. You have created the promotion and setup an initial period, but you need to open that promotion period below and define what this promotion will be for.",
		"permission.vendor.detailvendor": "Vendor - Detail",
		"entity.session.sessioncookieextendedpsid": "Session Cookie Extended PSID",
		"entity.integration.authenticationactiveflag": "Auth Active",
		"admin.entityas.pricegrouptabs.pricegrouprates": "Price Group Rates",
		"entity.vendorphone.phone": "phone",
		"admin.entity.createloyaltyterm": "Add Loyalty Term",
		"entity.workflowtask.taskname": "Task Name",
		"entity.sku.options": "Options",
		"define.true": true,
		"entity.promotionreward.amount": "Amount",
		"processobject.product_addoptiongroup.optiongroup": "Option Group",
		"entity.accountemailaddress.accountemailaddressid": "accountEmailAddressID",
		"admin.entity.settingstabs.shippingmethod": "Shipping Method Settings",
		"define.annually": "Annually",
		"setting.fulfillmentmethodemailsubjectstring": "Email Subject Template",
		"entity.subscriptionusage.subscriptionusageid": "Subscription Usage ID",
		"admin.entity.settingstabs.product": "Product Settings",
		"define.sort": "Sort",
		"entity.fulfillmentmethod.sortorder": "Sort Order",
		"setting.integrationvirtualmerchantpin": "Virtual Merchant PIN",
		"entity.roundingrule.roundingruleexpression": "Rounding Rule Expression",
		"entity.sku.process.move.placeholder": "Select Destination Product",
		"entity.attribute.attributeinputtype.atselectbox": "Select Box",
		"validate.processproduct_create.scheduleenddate_valid": "Schedule end date must occur after schedule start date.",
		"processobject.account_generateapiaccesskey.authenticationdescription": "Access Key Description",
		"entity.account.remoteemployeeid": "Remote Employee ID",
		"entity.accountpaymentmethod": "Account Payment Method",
		"entity.profile.profiletemplate": "profileTemplate",
		"permission.product.deleteoptiongroup": "Option Group - Delete",
		"admin.entity.listcontent": "Content",
		"validate.save.collection.collectioncode.uniqueornull": "CollectionCode entered is not unique",
		"setting.integrationupsshipfromcountrycode": "Shipping From Country Code ",
		"entity.fulfillmentbatchitem.quantitypicked": "Quantity Picked",
		"admin.entity.locationtabs.locationstocks": "Location Stocks",
		"entity.loyaltyaccruement": "Loyalty Program Accruement Criteria",
		"defaultmessage_collectionsize_gte": "{1} size is not equal to or greater than {2}.",
		"entity.shippingmethodrate": "Shipping Method Rate",
		"entity.audit.baseobject": "Base Object",
		"entity.content.contentidpath": "Content ID Path",
		"entity.accountcontentaccess": "Account Content Access",
		"entity.entityqueuehistory_plural": "Entity Queue History",
		"entity.sku.exclusive": "Image is exclusive for this sku",
		"admin.entity.brandtabs.brandsettings": "Brand Settings",
		"entity.accountpayment.termoffsettotals": "Totals",
		"entity.commentrelationship.stockadjustment": "Stock Adjustment",
		"entity.giftcardtransaction_plural": "Gift Card Transactions",
		"entity.attributevalue.producttype": "Product Type",
		"admin.entity.processaccount.addaccountpayment_success": "Account payment created successfully",
		"entity.productbundlegroupitem.productbundlegroupitemid": "Product Bundle Group Item ID",
		"admin.entity.downloadfile_permission": "Download Files",
		"admin.entity.promotionperiodtabs.promotionrewards": "Promotion Rewards",
		"entity.product.sortorder": "Sort Order",
		"entity.type.typedescription": "Type Description",
		"permission.setting.deletelocation": "Location - Delete",
		"entity.sku.imagepath": "Image Path",
		"entity.form_plural": "Forms",
		"entity.accountaddress.accountaddressid": "accountAddressID",
		"entity.workflowtaskaction.delete": "Delete",
		"admin.define.process_error": "There was an error trying to process the ${entityName}",
		"admin.entity.createaddresszonelocation": "Add Location to Zone",
		"define.selectall": "Select All",
		"entity.stockreceiveritem.stockadjustmentitem": "Stock Adjustment Item",
		"entity.permissiongroup": "Permission Group",
		"entity.orderitemgiftrecipient.emailaddress": "Email Address",
		"setting.integrationupspickuptypecode": "Pickup Type Code (advanced optional)",
		"permission.order.editorder": "Order - Edit",
		"admin.editfilteritem.criteria": "Criteria",
		"entity.orderitem.stock": "stock",
		"setting.globalnosessionpersistdefault": "Ignore Session Tracking until Logged In or Cart Created",
		"entity.sku.eventattendancecode": "Attendance Code",
		"entity.order.totaldepositamount": "Total Deposit Amount Required For Deposit Elegible Items",
		"entity.printtemplate_plural": "Print Templates",
		"permission.product.editproductreview": "Product review - Edit",
		"api.define.create_success": "The ${EntityName} was created successfully",
		"entity.currency.currencyname": "Currency Name",
		"entity.permissiongroup.permissiongroupname": "Permission Group Name",
		"entity.orderfulfillment.appliedpromotions": "Applied Promotions",
		"validate.save.subscriptionterm.autopayflag.gethaspaymentmethodthatallowsaccountstosave": "When auto pay is selected, at least one payment method needs to be setup with the option 'allow account to save' turned on.",
		"admin.report.default.customreports": "Custom Reports",
		"admin.entity.detailshippingmethod.norates_info": "Currently there are no rates defined for this shipping method.  You need to define at least one rate for this shipping method to be able to be used on the frontend.  When creating a new rate, you will be able to define which of the active shipping provider integrations you would like to use for the rate, or just define a static amount",
		"entity.sku.imagefilename": "Image File Name",
		"entity.account.productreviews": "Product Reviews",
		"entity.setting.cmscontentid": "CMS Content ID",
		"setting.producttitlestring": "Product Title Format",
		"report.orderitemreport.saleprediscount": "Pre Discount Sale",
		"entity.physical_plural": "Physicals",
		"admin.define.create": "Create ${itemEntityName}",
		"entity.orderfulfillment.registrants": "Registrants",
		"defaultmessage_regex": "{1} must match the specified pattern.",
		"entity.accountpayment.termoffsetordernum": "Order Number",
		"entity.comment.childcomment": "Related Children Comment",
		"entity.country.cityshowflag": "Show City",
		"define.july": "July",
		"entity.promotionqualifier.brands": "Brands",
		"setting.accountmetakeywordsstring": "Account Meta Keywords String",
		"entity.attributeset.sortorder": "Sort Order",
		"entity.serverinstance.settingsexpired": "Setting is Expired",
		"entity.serverinstance_plural": "Server Instances",
		"admin.entity.processphysical.commit_success": "The physical count has been successfully committed and the stock has been updated.",
		"setting.globalclientsecret": "Client Secret",
		"entity.accountauthentication.accountauthenticationid": "Account Authentication ID",
		"setting.integrationauthorizenetgatewayurl": "API Gateway URL",
		"entity.audit.changedetails.propertychanged.old": "Changed From",
		"validation.define.neq": "The value entered is not correct",
		"setting.integrationvertexwebservicesusername": "Vertex Username",
		"define.qndorvo.full": "Not Delivered On Return Vendor Order",
		"entity.pricegroupratecurrency.pricegroupratecurrencyid": "Price Group Currency Rate ID",
		"permission.setting.deleteroundingrule": "Rounding Rule - Delete",
		"admin.entity.orderdeliveryitemtabs.giftcards": "Gift Cards",
		"define.june": "June",
		"entity.email.emailbodyhtml": "Email Body HTML",
		"admin.entity.subscriptiontermtabs.subscriptionusagesettings": "Subscription Usage Settings",
		"entity.productlistingpage": "Product Listing Page",
		"entity.promotionqualifier.rewardmatchingtype.sku": "Sku",
		"entity.updatescript.maxexecutioncount": "Max Execution Count",
		"entity.permission_plural": "Permissions",
		"entity.orderfulfillment.accountemailaddress": "Account Email Address",
		"entity.report.reportdatetime": "Report Date Time",
		"entity.paymentmethod.placeorderchargetransactiontype": "Checkout Charge Trans.",
		"setting.integrationfullcirclefcftpdirecotry": "Full Circle FTP Directory",
		"validate.save.sku.options.hasoneoptionperoptiongroup": "Sku requires one option per option group",
		"entity.accountrelationship.relatedaccount": "relatedAccount",
		"admin.entity.settings_permission": "Global Setting Access",
		"entity.accountaddress_plural": "Account Addresses",
		"entity.printtemplate.printtemplateobject": "Print Template Object",
		"admin.pricing.createpromotionrewardorder": "Create Promotion Reward Order",
		"setting.globalorderplacedemailcc": "New Order Placed Email CC",
		"setting.integrationclickandbuysandboxisactive": "Sandbox active",
		"entity.accountpayment.account": "Account",
		"entity.skuprice.listprice": "List Price",
		"entity.promotionperiod": "Promotion Period",
		"permission.warehouse.detailstockreceiver": "Stock Receiver - Detail",
		"admin.entity.locationconfigurationtabs.locationconfigurationsettings": "Location Configuration Settings",
		"validate.create.product_create.purchasestartdatetime.ltdatetimeproperty": "Purchase Start Date must occur before the event.",
		"entity.sku.pricegrouprates": "Price Group Rates",
		"entity.promotionreward.shippingamount": "Shipping Rate Fixed Amount",
		"permission.warehouse.createstockreceiver": "Stock Receiver - Create",
		"validate.save.accountemailaddress.emailaddress.getemailaddressnotinuseflag": "The email address that you have entered is already in use by another authenticated account.",
		"entity.setting.settingname": "Setting Name",
		"admin.entity.listloyaltyterm": "Loyalty Terms",
		"setting.subscriptionusagerenewalreminderemailtemplate": "Subscription Renewal Reminder Email Template",
		"define.adjustment": "Adjustment",
		"setting.integrationstripetestsecretkey": "Test Secret Key",
		"entity.orderfulfillment.chargeafterdiscount": "Total Fulfillment Charge",
		"entity.orderreturn.returnlocation": "Return Location",
		"entity.task.taskmethod.subscriptionusagerenewalreminder": "Subscription Usage - Renewal Reminder",
		"setting.integrationpayflowprovendorid": "Vendor ID",
		"entity.setting_plural": "Settings",
		"entity.currencyrate_plural": "Currency Rates",
		"setting.integrationvertexorigincity": "Origin City",
		"admin.account.processsubscriptionusage.cancelsubscription_nav": "Cancel Subscription",
		"admin.entity.createreturnorder_nav": "Create Return Order",
		"entity.attributeoption": "Attribute Option",
		"entity.task.schedule": "Task Schedule",
		"entity.skuoption.sku": "sku",
		"entity.updatescript": "Update Script",
		"entity.subscriptionbenefit_plural": "Subscription Benefits",
		"entity.currencyrate": "Currency Rate",
		"entity.setting.shippingmethod": "Shipping Method",
		"define.definedin": "Defined In",
		"validate.order.orderitems.toomanyeventregistrations": "There are more event registrations defined than the specified quantity allows.",
		"setting.accounteligiblepaymentterms_hint": "This should be a list of all the available payment terms an account can utilize on a given order.",
		"entity.app": "Application",
		"setting.integrationfedexcontactpersonname": "Contact Full Name",
		"entity.databasecache.databasecacheid": "Database Cache ID",
		"entity.emailbounce.relatedobjectid": "Related Object ID",
		"entity.email.emailtemplate": "Email Template",
		"entity.paymentmethod.saveorderpaymenttransactiontype_hint": "Typically used to generate 'tokens' from the processor, which are then stored with the 'Order Payment' to avoid encrypting & storing data.",
		"admin.entity.detailorder.overview": "Overview",
		"entity.productrelationship.relationshiptype": "Relationship Type",
		"entity.account.superuserflag": "Super User",
		"entity.subscriptionusage.process.cancel": "Cancel Subscription",
		"setting.contentrestrictaccessflag_hint": "By selecting this option the only way this page will be viewed is if the current account has purchased it, or has a subscription to the content.",
		"admin.entity.promotionrewardtabs.producttypes": "Product Types",
		"entity.report.dynamicdaterangeendtype.lastweekendsunday": "Previous Week ( Ending Sunday )",
		"admin.entity.updateproductcache": "Update Product Cache",
		"define.qnrosa.full": "Not Received On Stock Adjustment",
		"entity.stockadjustment.process.additems": "Process Stock Adjustment",
		"setting.contentdefaultproductsperpage_hint": "Default number of products per page",
		"setting.integrationupsshipfromemailaddress": "Shipping Email Address ",
		"entity.product.option.select": "Please select an option...",
		"entity.physicalcountitem": "Physical Count Item",
		"entity.accountpayment.process.createtransaction": "Create Transaction",
		"admin.entity.processproduct.create.renewalskumethod": "Renewal Sku Method",
		"setting.skutaxcategory": "Tax Category",
		"validate.delete.accountloyalty.accountloyaltyid.maxlength": "The account loyalty program cannot be deleted.",
		"defaultmessage_nohtml": "{1} cannot contain HTML tags.",
		"entity.loyaltyredemption.accountloyaltytransactions": "Account Loyalty Transactions",
		"entity.currency.currencylocal": "Currency Local",
		"entity.country": "Country",
		"validate.account_forgotpassword.loginblocked": "You may not reset your password while your account is locked, please contact your adminstrator.",
		"processobject.accountloyalty_manualtransaction.expirationdatetime": "Expiration Date/Time",
		"entity.giftcard.process.updateemailaddress": "Update Email Address & Resend",
		"entity.shippingmethod.useratetableflag": "Use Rate Table",
		"admin.entity.loyaltyaccruementtabs.products": "Products",
		"entity.accountpayment.termoffsetunappliedwarning2": "that will not be assigned to any orders",
		"entity.accountpayment.termoffsetunappliedwarning1": "Warning: There is",
		"entity.vendorphone.vendorphoneid": "vendorPhoneID",
		"permission.setting.editfulfillmentmethod": "Fulfillment Method - Edit",
		"validate.addsku.sku.redemptionamount.minvalue": "Please select an amount greater than zero.",
		"permission.warehouse.editstockreceiver": "Stock Receiver - Edit",
		"admin.define.detail_title": "View ${itemEntityName}",
		"setting.integrationmerchantesolutionsprofileid": "Profile ID",
		"setting.globalweightunitcode": "Weight Measurement Unit",
		"entity.skuprice.sku": "Sku",
		"entity.attributeset.attributes": "Attributes",
		"entity.stockreceiver.receivertype.order": "Return / Exchange Order",
		"entity.accountpaymentmethod_plural": "Account Payment Methods",
		"paypalexpress.main_permission": "PayPal Express Integration",
		"entity.product.calltoorderflag": "Phone Order Only",
		"permission.vendor.editvendor": "Vendor - Edit",
		"admin.define.configuration": "Configuration",
		"setting.integrationstripelogenabled": "Enable Logging",
		"setting.integrationavataxsourceregion": "Source State (Region)",
		"entity.shippingmethod.shippingmethodtype": "Shipping Method Type",
		"processobject.order_addorderpayment.saveaccountpaymentmethodflag_hint": "Selecting yes will save this payment method against the account for future orders.",
		"entity.productschedule.schedulesummary": "Summary",
		"setting.globalallowedoutsideredirectsites_hint": "A comma delimited list of all outside sites that you want to allow Slatwall to be able to redirect to. Example site: http://www.example.com/",
		"define.to": "to",
		"setting.globalimageextension": "Image Extension",
		"entity.orderitemgiftrecipient.lastname": "Last Name",
		"entity.stockadjustmentitem_plural": "Stock Adjustment Items",
		"entity.physicalcountitem.physicalcount": "Physical Count",
		"admin.entity.createpromotionrewardorder": "Order Discount",
		"setting.producthtmltitlestring": "Product HTML Title String",
		"entity.location": "Location",
		"setting.integrationparcel2goshippercountrycode": "Shipping From Country Code",
		"entity.audit.changedetails.propertychanged.update": "Changed",
		"entity.orderitem.quantityreceived": "Qty. Received",
		"entity.vendor.primaryaddress": "Primary Address",
		"validate.delete.giftcard.giftcardcode.caneditordelete": "Gift Cards that have been issued can not be deleted.",
		"entity.promotionreward.itemdiscounttype": "Discount Type",
		"defaultmessage_pastdate_withbefore": "{1} must be a date in the past. The date entered must come before {2}.",
		"report.orderitemreport.quantitysold": "Quantity Sold",
		"admin.entity.processsku.logattendance_success": "Attendance has been logged successfully.",
		"entity.attribute.attributeinputtype.email": "Email",
		"entity.loyaltyaccruement.pointtype": "Point Type",
		"setting.sitemissingimagepath": "Site Missing Image Path",
		"admin.define.save": "Save ${itemEntityName}",
		"entity.attributevalue.attribute": "attribute",
		"entity.account.process.updatepassword_success": "You have successfully updated your password.",
		"setting.integrationfedexshipperpostalcode": "Shipping From Postal Code ",
		"entity.vendororderitem.stocklocation": "Location",
		"admin.entity.subscriptionbenefittabs.contents": "Content",
		"entity.pricegrouprate.roundingrule": "Rounding Rule",
		"entity.option.sortorder": "Sort Order",
		"entity.accountpayment.giftcardnumberencrypted": "Gift Card Number",
		"define.export": "Export",
		"entity.taxcategory.taxcategoryid": "Tax Category ID",
		"entity.vendoraccount.vendoraccountid": "Vendor Account ID",
		"setting.integrationupstestingflag": "Test Mode ",
		"entity.inventory.quantityout": "Quantity Out",
		"entity.promotionqualifier.shippingaddresszones": "Address Zones",
		"entity.country.postalcodeshowflag": "Show Postal Code",
		"entity.subscriptionusage.subscriptionorderitemname": "Subscription Item",
		"entity.comment_plural": "Comments",
		"entity.workflowtrigger.collectionfetchsize": "Fetch Size",
		"admin.entity.physicaltabs.discrepancies.norows": "There aren't any Physical Count Items.",
		"define.checkboxgroup": "Checkbox Group",
		"entity.productbundlebuilditem": "Product Bundle Build Item",
		"entity.address.entity.address.addressname": "Address Name",
		"entity.stockadjustment.stockreceivers": "Stock Receivers",
		"entity.sku.redemptionamounttype.select": "Please select a Redemption Amount Type.",
		"entity.stockreceiver.stockreceiveritems": "Stock Receiver Items",
		"entity.audit.changedetails": "Change Details",
		"entity.skucurrency.currency": "Currency",
		"setting.integrationmuralegacyorderconfirmation_hint": "If you have upgraded from a previous version of Slatwall that used the filename hooks, and the 'frontend' subsystem, then the filename of that page should be in this field",
		"admin.define.save_title": "Save ${itemEntityName}",
		"entity.filerelationship_plural": "Files",
		"entity.vendororder_plural": "Vendor Orders",
		"define.local": "Local",
		"entity.accountphonenumber_plural": "Account Phone Numbers",
		"entity.pricegroup": "Price Group",
		"entity.promotionperiod.promotionperiodid": "Promotion Period ID",
		"entity.permission.entityname": "Entity Name",
		"entity.order.orderpayments": "Order Payments",
		"permission.setting.createattributeset": "Attribute Set - Create",
		"validate.addeventschedule.product_addeventschedule.eventstartdatetime.gtnow": "Event start date must occur in the future.",
		"admin.entity.vendorordertabs.stockreceivers": "Stock Receivers",
		"entity.skuprice.skupriceid": "Sku Price ID",
		"entity.orderpayment.appliedaccountpayments": "Applied Account Payments",
		"validate.define.eq": "${propertyName} must be equal to ${constraintValue}",
		"admin.main.update.currentversion": "Current Version",
		"entity.session.account": "account",
		"setting.integrationendiciasyncftpsitesecure": "FTP Sync Secure?",
		"entity.report_plural": "Reports",
		"admin.define.bundledsku": "Bundled Sku",
		"entity.subscriptionbenefit.categories": "Categories",
		"entity.vendororder.total": "Total",
		"entity.accountpaymentapplied.accountpaymentappliedid": "Account Payment Applied ID",
		"entity.workflow.activeflag": "Active",
		"defaultmessage_rangelength": "{1} must be between {2} and {3} characters long.",
		"entity.product.producttype": "Product Type",
		"admin.define.list_title": "View A List of ${itemEntityNamePlural}",
		"entity.sku.optionsdisplay": "Options",
		"define.emailrequired": "Email address format is incorrect",
		"admin.entity.createformquestion": "Create Form Question",
		"entity.define.renewalprice": "Renewal Price",
		"admin.entity.settingstabs.sku": "Sku Settings",
		"entity.skuoption.skuoptionid": "skuOptionID",
		"entity.sku.physicals": "Physicals",
		"entity.sku.eventconflictexistsflag": "Event Conflict",
		"define.qe": "QE",
		"entity.content.cmscontentid": "CMS Content ID",
		"entity.sku.process.editcapacity": "Edit capacity",
		"permission.warehouse.liststockadjustment": "Stock Adjustment - List",
		"define.qc": "QC",
		"entity.audit.audittype.create": "Created",
		"setting.emailfromaddress": "Email From Address",
		"entity.remoteentity": "Remote Entity",
		"setting.fulfillmentmethodautolocation_hint": "This location will be used for an 'auto' fulfillment methods.  It can be overridden in each 'auto' fulfillment method if you create multiple of that type.",
		"validation.define.eq": "The value entered is not correct.",
		"define.lastname": "Last Name",
		"entity.productbundlegroup.skupricepercentageincrease": "Sku Price Percentage Increase",
		"define.from": "from",
		"define.qs": "QS",
		"define.qr": "QR",
		"entity.inventory.quantityin": "Quantity In",
		"validate.save.skuprice.maxquantity.hasvalidquantityconfiguration": "The sku price cannot be saved becasue the quantity range is invalid.",
		"entity.accountpaymentmethod.bankaccountnumber": "Bank Account Number",
		"entity.pricegroup.appliedorderitems": "Applied Order Items",
		"setting.integrationendiciafrompostalcode": "From Postal Code",
		"entity.account.phonenumber": "Phone Number",
		"permission.product.saveproducttype": "Product Type - Save",
		"permission.order.saveorder": "Order - Save",
		"define.third": "Third",
		"entity.image.product": "Product",
		"entity.user.lastname": "lastName",
		"entity.account.subscriptionusages": "Subscriptions",
		"permission.vendor.savevendor": "Vendor - Save",
		"entity.term.termyears": "Term Years",
		"entity.taxapplied.taxliabilityamount": "Entity Tax Liability Amount",
		"gigya.main_permission": "Main Setup",
		"define.na": "N/A",
		"entity.vendor.vendorordertype": "Order Type",
		"validate.account.loginfailed": "The login you provided is invalid",
		"entity.collection.accountcollections": "Account Collections",
		"entity.accountauthentication.expirationdatetime": "Authentication Expiration",
		"processobject.sku_removelocation.editscope": "Edit scope",
		"define.no": false,
		"entity.schedule.daysofweektorun": "Days of Week",
		"entity.subscriptionusagebenefitaccount": "Subscription Usage Benefit Account",
		"define.ok": "Ok",
		"entity.subscriptionusagebenefit.excludedcontents": "Excluded Contents",
		"defaultmessage_minpatternsmatch_server": "{1} patterns were matched but {2} were required.",
		"entity.order.paymentamountdue": "Payment Amount Due",
		"define.showing": "Showing",
		"entity.product": "Product",
		"entity.subscriptionusage.mostrecentsubscriptionorderitem": "Most Recent Subscription Order Item",
		"define.of": "Of",
		"entity.setting.site": "Site",
		"entity.country.street2addressrequiredflag": "Require Street2 Address",
		"entity.taskhistory.endtime": "Task End Time",
		"admin.entity.processproduct.updatedefaultimagefilenames_success": "All default images have been reset.",
		"entity.vendorphonenumber.vendorphonenumberid": "Vendor Phone Number ID",
		"define.cancel": "Cancel",
		"setting.productimagedefaultextension": "Default Image Extension",
		"validate.save.roundingrule.roundingruleexpression.hasexpressionwithlistofnumericvaluesonly": "Rounding Rule must have an expression with a list of numeric values only",
		"setting.integrationendiciasyncftpsitedropofffilename": "FTP Sync Dropoff Filename",
		"admin.define.process_success": "The ${itemEntityName} was processed successfully",
		"admin.entity.settingstabs.content": "Content Settings",
		"define.or": "Or",
		"admin.entity.producttabs.saleshistory": "Sales History",
		"entity.attribute.attributeinputtype.typeselect": "Type Select",
		"validate.save.stock.location.getlocationisleafnode": "Location needs to be a leaf node with no child locations",
		"define.test_not_implemented": "Test has not been implemented",
		"entity.pricegrouprate.excludedproducttypes": "Exclude Product Types",
		"permission.vendor.detailvendororder": "Vendor Order - Detail",
		"entity.shippingmethodoption": "Shipping Method Option",
		"entity.attributeset.brands": "Brands",
		"entity.orderpayment": "Order Payment",
		"entity.order.promotioncodes": "Promotion Codes",
		"define.fulfillment": "Fulfillment",
		"setting.integrationauthorizenetloginid": "Login ID ",
		"entity.country.cityrequiredflag": "Require City",
		"entity.attribute.attributehint": "Attribute Hint",
		"defaultmessage_date": "{1} must be a valid date.",
		"admin.entity.pricegroupratetabs.products": "Products",
		"admin.entity.createmerchandiseproduct_nav": "New Merchandise Product",
		"entity.session.rblocale": "RB Locale",
		"entity.address.addressdisplaytemplate": "Display Template",
		"define.august": "August",
		"entity.option.optiondescription": "Option Description",
		"setting.integrationupsshipfromphonenumber": "Shipping Phone Number",
		"entity.shippingmethod.promotionqualifiers": "Promotion Qualifiers",
		"entity.subscriptionusagebenefit.promotions": "Promotions",
		"setting.globaldefaultsite": "Default Site",
		"entity.product.productcode": "Product Code",
		"permission.vendor.listvendor": "Vendor - List",
		"validate.delete.orderitem.quantitydelivered.eq": "You cannot delete an order item which has been fulfilled.",
		"entity.giftcard_plural": "Gift Cards",
		"admin.entity.producttabs.productpages": "Product Pages",
		"entity.product.redemptionamounttype.select": "Please select a Redemption Amount Type...",
		"define.daily": "Daily",
		"permission.account.listaccount": "Account - List",
		"entity.attributevalue.attributevalueencrypted": "Attribute Value Encrypted",
		"entity.productschedule.eventendtime": "Event end time",
		"setting.accountauthenticationautologouttimespan": "Authentication Auto Logout Timespan",
		"entity.skuprice_plural": "Sku Prices",
		"entity.stockadjustmentdelivery.deliveryclosedatetime": "Delivery Close Date Time",
		"setting.integrationmuralegacyorderstatus": "Legacy Order Status Filename",
		"entity.shippingmethod.shippingprovidermethod": "Shipping Provider Method",
		"entity.entityqueuehistory": "Entity Queue History",
		"entity.giftcardtransaction.creditamount": "Credit Amount",
		"entity.define.creditcardnumberencryptedgenerator": "Credit Card Number Encryption Generator",
		"admin.entity.producttypetabs.products": "Products",
		"define.payment": "Payment",
		"setting.globalorderplacedemailsubjectstring": "New Order Placed Email Subject",
		"entity.file.fileid": "File ID",
		"entity.attributeoption_plural": "Attribute Options",
		"admin.entity.detailpromotion.norewards_info": "Currently there are no rewards assigned to this promotion.  You have created the promotion and setup an initial period, but you need to open that promotion period below and define what this promotion will be for.",
		"defaultmessage_numeric": "{1} must be a number.",
		"entity.orderpayment.checknumberencrypted": "Check Number  Encrypted",
		"entity.taxapplied.taxappliedid": "Tax Applied ID",
		"entity.shippingmethod.shippingmethodrates": "Shipping Method Rates",
		"entity.promotioncode.promotioncode_validateunique": "This promotion code is already in use.",
		"validate.product.accesscontentsrequired": "You must select a content node to be used for this Content Access product.  If none are available then you need to go into the admin of your site, and specify a page as restricted",
		"entity.promotionreward.promotionrewards": "Promotion Reward",
		"entity.updatescript.lastexecuteddatetime": "Last Execution Date Time",
		"admin.main.ckfinder_nav": "File Manager",
		"validate.addeventschedule.product_addeventschedule.purchasestartdatetime.gtnow": "Purchase Start Date must occur in the future",
		"setting.orderfulfillmentemailtemplate": "order fulfillment email template",
		"entity.image.directory": "Directory",
		"entity.report.dynamicdaterangeendtype.thisyearend": "Current Year End",
		"entity.accountloyaltytransaction.accountloyaltytransactionid": "Account Loyalty Transaction ID",
		"setting.paymentmethodstorecreditcardnumberwithorder_hint": "If this is set to yes, then when orders get placed it will automatically encrypyt the value of the credit card number and store in the order payment",
		"entity.currencyrate.conversioncurrency": "Conversion Currency",
		"admin.entity.processaccountloyalty.manualtransaction_success": "The account loyalty program transaction has been created successfully.",
		"validate.processproduct_create.schedulestartdate": "Event start date and schedule start date must match",
		"permission.product.deleteproducttype": "Product Type - Delete",
		"permission.setting.listtask": "Task - List",
		"entity.loyaltyredemption.autoredemptiontype.loyaltytermend": "Loyalty Term End",
		"entity.accountpaymentmethod.bankaccountnumberencrypted": "Bank Account Number  Encrypted",
		"entity.inventory.inventoryid": "Inventory ID",
		"mura.muraevent.oncontentedit.contentskus.norecords": "There are currently no products defined to sell this content.",
		"setting.skueligiblefulfillmentmethods": "Eligible Fulfillment Methods",
		"admin.entity.settings_title": "Settings",
		"admin.entity.deletepromotionperiod_disabled": "This promotion period cannot be deleted because it has been used in a transaction and/or it has expired.",
		"validate.addsubscriptionsku.product_addsubscriptionsku.renewalsubscriptionbenefits.required": "You must define either a Renewal Sku or a Renewal Benefit and Price.",
		"entity.image": "Image",
		"entity.subscriptionusage.fulfillmentcharge": "Shipping Charge",
		"admin.entity.preprocessorder_include.changestatuscomment": "Add Comment (optional)",
		"entity.productbundlegroup.amounttype": "Base Price Adjustment Type",
		"validate.updatepassword.account_updatepassword.password.regex": "Admin passwords should include at least 1 letter, 1 number, and be 7 or more characters long.",
		"validate.delete.account.owneraccount.candeletebyowner": "You are not permitted to delete this Account",
		"admin.define.create_title": "Create New ${itemEntityName}",
		"entity.country.streetaddressshowflag": "Show Street Address",
		"setting.integrationuspsliveapiendpointurl": "USPS Live API Endpoint URL",
		"permission.setting.listsetting": "Setting - List",
		"entity.product.eventregistrations": "Event Registrations",
		"entity.access.subscriptionusagebenefit": "Subscription Usage Benefit",
		"setting.siterecaptchasitekey": "Recaptcha Site Key",
		"define.qoh.full": "On Hand",
		"entity.productreview.sku": "Sku",
		"setting.integrationsofortlanguage": "Language (ISO 639-1)",
		"define.initial": "Initial",
		"entity.fulfillmentbatchitem_plural": "Fullfillment Batch Items",
		"entity.paymentmethod.process.processcashpayment": "Process Cash Payment",
		"entity.option.optionid": "Option ID",
		"validate.save.access.accessid.hasusageorusagebenefitorusagebenefitaccount": "Access Requires either a Subscription Usage, a Subscription Benefit or a Subscription Benefit Account",
		"entity.paymenttransaction.paymenttransactionid": "Payment Transaction ID",
		"permission.setting.detailterm": "Term - Detail",
		"defaultmessage_minpatternsmatch": "{1} did not match the required number of patterns.",
		"defaultmessage_email": "{1} must be a valid email address.",
		"admin.main.update.backup": "IMPORTANT: Be sure to backup your files and database before performing an update.",
		"entity.loyaltyaccruement.activeflag": "Active Flag",
		"entity.category.allowproductassignmentflag": "Allow Product Assignment",
		"define.qndoo": "QNDOO",
		"entity.vendorskustock.availabledatetime": "availableDateTime",
		"admin.entity.processapp.create_success": "Application saved successfully",
		"entity.productschedule.scheduleendoccurrences": "Occurrences",
		"admin.entity.ordertabs.orderitems.returnitems": "Return Items",
		"entity.skuprice.minquantity.null": "any",
		"admin.entity.createorderpayment.processoption.transactiontype": "Transaction Type",
		"entity.pricegrouprate.excludedskus": "Exclude SKUs",
		"setting.integrationmuralegacyorderconfirmation": "Legacy Order Confirmation Filename",
		"entity.alternateskucode_plural": "Alternate Sku Codes",
		"entity.order.totaldepositandnondepositamounts": "Total Amount for Deposit and Non-deposit Eligible Items",
		"validate.processphysical_addphysicalcount.skucodeerrorwarning": "The file you uploaded had ${skuCodeError} sku code(s) that could not be found in the system.  Please verify these code(s) can map to the correct skus.",
		"entity.site.cmssiteid": "CMS Site ID",
		"admin.entity.deletepromotionreward_disabled": "This promotion reward cannot be deleted because it has been used in a transaction and/or its promotion period has expired.",
		"entity.skuoption.option": "option",
		"entity.sku.skucode": "SKU Code",
		"entity.giftcardtransaction": "Gift Card Transaction",
		"entity.accountcontentaccess.accesscontents": "Access Contents",
		"admin.entity.loyaltyaccruementtabs.producttypes": "Product Types",
		"entity.subscriptionusage.graceperiodterm": "Grace Period",
		"entity.loyaltyredemption.autoredemptiontype.pointsadjusted": "Points Adjusted",
		"setting.integrationmuralegacyorderstatus_hint": "If you have upgraded from a previous version of Slatwall that used the filename hooks, and the 'frontend' subsystem, then the filename of that page should be in this field",
		"entity.address.norecords": "No Addresses Defined",
		"define.contentaccess": "Content Access",
		"setting.integrationelavonuserid": "User ID",
		"entity.productbundlebuilditem.productbundlebuilditemid": "Product Bundle Build Item ID",
		"permission.setting.detailcountry": "Country - Detail",
		"entity.attributeoption.attributeoptionlabel": "Label",
		"entity.stockadjustmentdelivery.stockadjustmentdeliveryid": "Stock Adjustment Delivery ID",
		"admin.entity.processproduct.create.selectrenewalsku": "Select a Sku to be used upon renewal.",
		"entity.accountloyaltytransaction.accountloyalty": "Account Loyalty",
		"admin.entity.producttabs.skusettings": "Sku Settings",
		"define.primary": "Primary",
		"admin.entity.accounttabs.carts": "Carts",
		"entity.session_plural": "Sessions",
		"setting.addressmetakeywordsstring": "Address Meta Keywords String",
		"entity.loyaltyterm": "Loyalty Term",
		"api.main.get": "API GET Method",
		"defaultmessage_doesnotcontainotherproperties": "{1} must not contain the values of properties named: {2}.",
		"entity.promotionqualifier.minimumprice": "Minimum Order Total",
		"entity.content.title": "Content Title",
		"entity.order.orderplacedsite": "Order Placed Site",
		"entity.account.accountaddresses": "Addresses",
		"setting.integrationmerchantesolutionsapiurl": "API URL",
		"setting.accountmetadescriptionstring": "Account Meta Description String",
		"entity.accountaddress.accountaddressname": "Nickname",
		"entity.promotionreward.shippingmethods": "Shipping Methods",
		"entity.workflowtaskaction.import": "Import",
		"admin.entity.processcontent.create_success": "Content saved successfully",
		"admin.main.lockaccount.toomanyattempts_error": "<strong>IMPORTANT:</strong> This account has been locked because there were too many failed login attempts made. <a href='?slatAction=main.unlockAccount&accountid=${accountID}' target='_self' >Unlock this account.</a>",
		"report.paymenttransactionreport": "Payment Transaction",
		"report.productperformancereport.returnprediscount": "Pre Discount Return",
		"entity.orderitem.referencedorderitem": "Referenced Order Item",
		"entity.promotioncode.promotion": "Promotion",
		"admin.entity.createproduct.selectrenewalsubscriptionbenefits": "Select Renewal Subscription Benefit(s)",
		"admin.setting.settings_nav": "Settings",
		"entity.fulfillmentbatch": "Batch",
		"entity.integration.integrationname": "Integration Name",
		"entity.sku.userdefinedpriceflag": "User Defined Price",
		"entity.sku.renewalsubscriptionbenefits": "Renewal Subscription Benefits",
		"setting.skuordermaximumquantity": "Max Order Qty.",
		"setting.integrationvertexwebservicestimeout": "Vertext Request Timeout",
		"entity.orderitem.quantityundelivered": "Qty. Undelivered",
		"define.fifth": "fifth",
		"report.promotionusagereport.promotionapplieddatetime": "Discount Applied Date Time",
		"entity.previousorderpayment": "Previous Order Payment",
		"admin.entity.addresszonetabs.locations": "Locations",
		"entity.vendoremailaddress_plural": "Vendor Email Addresses",
		"validation.define.uniqueornull": "This value must be unique or empty",
		"entity.stockadjustment.createdatetime": "Created Date",
		"processobject.order_addorderitem.fulfillmentmethodid": "Fulfillment Method",
		"validate.define.numeric": "The value entered for ${propertyName} is not a number.",
		"permission.help.about": "About",
		"entity.product.process.addsubscriptionterm": "Add Subscription Term",
		"entity.paymentmethod.process.processpayment": "Process Payment",
		"admin.define.edit_title": "Edit ${itemEntityName}",
		"processobject.subscriptionusage_renew.renewalpaymenttype": "Pay For Renewal Via",
		"entity.address.addressid": "Address ID",
		"entity.vendoremail.vendoremailid": "vendorEmailID",
		"entity.promotionqualifier.shippingmethods": "Shipping Methods",
		"admin.define.notfound": "Not Found",
		"entity.attributevalue.attributevalue": "Attribute Value",
		"admin.main.processbouncedemails": "Process Bounced Emails",
		"entity.orderitemgiftrecipient": "Order Item Gift Recipient",
		"entity.sku.process.move": "Move To Another Product",
		"entity.remoteentity.remoteentityid": "Remote Entity ID",
		"entity.form.formid": "Form ID",
		"admin.entity.editreport_nav": "Update Config & Defaults",
		"admin.entity.producttypetabs.skusettings": "Sku Settings",
		"setting.brandhtmltitlestring": "Brand HTML Title String",
		"entity.loyaltyredemption.redemptiontype": "Loyalty Reward",
		"admin.entity.processprint.addtoqueue_success": "Print Successfully Queued",
		"permission.account.detailaccount": "Account - Detail",
		"define.metrics": "Metrics",
		"entity.workflowtaskaction.printtemplate": "Print Template",
		"entity.attribute.validationtype": "Validate",
		"entity.sku.qexp": "QEXP",
		"processobject.product_create.giftcardexpirationterm": "Expiration Term",
		"entity.taxapplied.taxstreet2address": "Tax Street 2 Address",
		"entity.promotionqualifier.rewardmatchingtype.any": "Any",
		"entity.brand.publishedflag": "Published Flag",
		"admin.define.save_nav": "Save ${itemEntityName}",
		"admin.entity.detailaccount.authenticationdetails_hint": "This section lists out all of the different forms of authentication this account can use to login.  If nothing is listed below you can create an authentication by going to 'Actions > Create Password'.  You can also remove authentications below including any temporary passwords might have been previously created using the forgot password tool.",
		"permission.product.editsubscriptionterm": "Subscription Term - Edit",
		"entity.content.childcontents": "Child Contents",
		"entity.stockadjustment.process.processadjustment": "Process Adjustment",
		"validate.addeventschedule.product_addeventschedule.purchaseenddatetime.gtdatetimeproperty": "Purchase End Date must occur after Purchase Start Date.",
		"admin.entity.stockadjustments.stockreceivers": "Stock Receivers",
		"entity.sku.options_validateunique": "This option combination already exists.",
		"define.qe.full": "Expected",
		"entity.subscriptionterm.graceperiodterm_hint": "If an auto-renewed subscription is unpaid for some reason, then this grace period will provide the duration that someone can continue to use services until their account is suspended",
		"setting.skuqatsincludesqnroroflag": "QATS Includes QNRORO",
		"entity.stockadjustment.stockadjustmenttype": "Type",
		"entity.product.brand": "Brand",
		"define.after": "After",
		"entity.sku.skucode_validateunique": "This SKU code is already in use.",
		"admin.main.about_nav": "About Slatwall",
		"entity.eventregistration.process.waitlist": "Add to Wait List",
		"setting.integrationupsshipfrompostalcode": "Shipping From Postal Code ",
		"permission.setting.saveattributeset": "Attribute Set - Save",
		"processobject.product_addeventschedule.bundlelocationconfigurationflag": "Single Registration",
		"entity.accountloyaltytransaction": "Account Loyalty Transaction",
		"entity.attributevalue.orderdelivery": "Order Delivery",
		"entity.option.images": "Images",
		"entity.promotionqualifier.maximumorderquantity": "Maximum Order Quantity",
		"define.bundle": "Bundle",
		"admin.entity.paymentmethodtabs.settings": "Payment Method Settings",
		"setting.siteverifyaccountemailaddressemailtemplate": "Verify Account Email Address Email Template",
		"admin.entity.loyaltyredemptiontabs.products": "Products",
		"define.weeks": "Weeks",
		"admin.define.process": "Process ${itemEntityName}",
		"frontend.cart.detail.noitems": "There are currently no items in your cart.",
		"entity.sku.purchaseenddatetime": "Purchase End Date",
		"entity.accountrelationship_plural": "Account Relationships",
		"entity.producttype.loyaltyaccruements": "Loyalty Accruements",
		"entity.taxapplied.taxstreetaddress": "Tax Street Address",
		"setting.integrationavataxtestingflag": "Test Mode ",
		"admin.pricing.promotionperiod.productortypeorskunotdefined_info": "There must be at least one sku, product, or product type selected for this reward to work.",
		"permission.product.saveproduct": "Product - Save",
		"entity.permission.permissionid": "Permission ID",
		"define.second": "second",
		"entity.shippingmethod.shippingprovider": "Shipping Provider",
		"entity.promotionqualifier.excludedproducts": "Product Exclusions",
		"entity.accountloyalty.manualadjustmenttype.manualout": "Manual Out",
		"admin.entity.detailstockadjustment.fromlocationname": "From Location",
		"entity.producttype.producttypenamepath": "Product Type Name Path",
		"setting.integrationauthorizenettestserverflag": "Use Test Server ",
		"admin.entity.fulfillmentmethodtypes.pickuptabs.settings": "Settings",
		"permission.product.saveoptiongroup": "Option Group - Save",
		"permission.setting.detailaddresszone": "Address Zone - Detail",
		"api.main.define.delete_success": "The ${EntityName} was deleted successfully",
		"entity.order.previouslyrefundedfulfillment": "Previously Refunded Fulfillment",
		"entity.addresszone.addresszoneid": "Address Zone ID",
		"entity.orderpayment.giftcardpaymentprocessedflag": "Gift Card Payment Processed Flag",
		"entity.loyaltyaccruement.loyalty": "Loyalty",
		"admin.main.dashboard.recentvendororderupdates": "Recently Updated Vendor Orders",
		"entity.order.defaultstocklocation": "Default Stock Location",
		"validate.promotioncode.overmaximumaccountusecount": "The promotion code that you have entered can not be used any more by this account.",
		"admin.entity.processproduct.addskubundle_success": "A sku bundle has been created successfully.",
		"entity.report.metrics": "Metrics",
		"admin.entity.processorder.addorderpayment_success": "Order payment added successfully",
		"entity.eventregistration.registrantattendancecode": "Registrant Attendance Code",
		"entity.loyaltyterm.loyaltytermstartdatetime": "Loyalty Term Start Date Time",
		"entity.accountloyalty.accountloyaltyid": "Account Loyalty ID",
		"admin.define.delete_permission": "${itemEntityName} - Delete",
		"setting.shippingmethodqualifiedrateselection": "Qualifying Shipping Rate Selection Method",
		"entity.stockadjustmentdelivery": "Stock Adjustment Delivery",
		"entity.promotioncode.promotioncode": "Promotion Code",
		"entity.option.optiongroup": "Option Group",
		"entity.workflowtriggerhistory.response": "Response",
		"defaultmessage_futuredate": "{1} must be a date in the future.",
		"entity.vendororder": "Vendor Order",
		"report.appliedtaxreport": "Applied Sales Tax",
		"endicia.main.syncpush_permission": "FTP Sync Push",
		"entity.task.taskmethod.subscriptionusagerenew": "Subscription Usage - Renew Subscriptions",
		"entity.integration.fw1activeflag": "FW1 Subsystem Active",
		"admin.entity.processorder.duplicateorder_success": "The duplicate order was created successfully.",
		"define.passwordconfirm": "Confirm Password",
		"admin.define.saveandfinish": "Save & Finish",
		"defaultmessage_inlist": "{1} was not found in the list: {2}.",
		"entity.define.countpostdatetime_hint": "This value defines the exact date/time when the discrepancy against this count should be calculated",
		"entity.sku.liveprice": "Live Price",
		"entity.loyaltyredemption.autoredemptionterm": "Auto Redemption Term",
		"entity.brand.brandid": "brandID",
		"admin.entity.accounttabs.childaccounts": "Child Accounts",
		"entity.promotion.appliedpromotions": "Applied Promotions",
		"entity.eventregistration.skudefinition": "Location Configuration",
		"entity.product.publishedflag_hint": "Item is available and visible on the front-end (both 'Active' and 'Published' must be selected to display on the front-end)",
		"entity.promotionreward.maximumorderrewardquantity": "Max. Qty. per Order",
		"entity.physical.producttypes": "Product Types",
		"entity.content.allowpurchaseflag_hint": "By setting this value to 'yes' then this page will be available to be sold as a content access product.",
		"entity.physicalcount.location": "Physical Count Location",
		"entity.taxcategoryrate.taxcategory": "Tax Category",
		"entity.workflowtrigger.savetriggerhistoryflag": "Save trigger History",
		"entity.shippingmethodrate.shipmentweightrange": "Weight Range",
		"validate.setupinitialadmin.account_setupinitialadmin.password.minlength": "Password must be at least 8 characters long",
		"processobject.account_setupinitialadmin.sitetitle": "Site Title",
		"entity.stockreceiveritem": "Stock Receiver Item",
		"entity.session.accountauthentication": "Account Authentication",
		"entity.option.optionname": "Option Name",
		"define.date": "Date",
		"entity.accountloyaltytransaction.pointsin": "Points In",
		"define.amountoff": "Amount Off",
		"entity.orderdelivery": "Order Delivery",
		"setting.skueligiblecurrencies_hint": "This defines the active currencies that a sku is avalable for sale in.",
		"entity.comment.commentid": "Comment ID",
		"entity.shippingmethod.shippingmethodcode": "Shipping Method Code",
		"frontend.checkout.detail.guestcheckout": "Guest Checkout",
		"entity.sku.skudescription": "Sku Description",
		"entity.account.accountemails": "Account Emails",
		"entity.promotioncode.promotioncodeid": "Promotion Code ID",
		"admin.entity.createpromotionrewardfulfillment": "Fulfillment Discount",
		"define.renewal": "Renewal",
		"validate.create.account_create.password.regex": "Admin passwords should include at least 1 letter, 1 number, and be 7 or more characters long.",
		"entity.fulfillmentmethod.promotionqualifiers": "Promotion Qualifiers",
		"setting.globalurlkeyproduct": "Product URL Key",
		"admin.entity.ordertabs.depositorderitems": "Deposit Order Items",
		"admin.entity.settings_nav": "Settings",
		"entity.productschedule.eventstartdatetime": "Event End",
		"define.cost": "Cost",
		"entity.taxapplied.taximpositionid": "Tax Imposition ID",
		"entity.sku.startreservationdatetime": "Reservation Start Date",
		"entity.accountpayment.termoffsettotalamount": "Order Payment Amount",
		"admin.entity.producttabs.basic": "Basic",
		"entity.accountloyaltyaccruement.accruementtype.itemfulfilled": "Item Fulfilled",
		"entity.attributevalue.orderitem": "Order Item",
		"validate.delete.orderdeliveryitem.orderdeliveryitemid.maxlength": "You cannot delete and order delivery item.",
		"entity.setting.subscriptionusage": "Subscription Usage",
		"entity.sku.renewalmethod": "Renewal Method",
		"processobject.sku_changeeventdates.reservationendtime": "New reservation end time",
		"admin.define.cashdetails": "Cash Details",
		"admin.entity.physicaltabs.discrepancies": "Discrepancies",
		"entity.paymentterm.term": "Term",
		"entity.paymenttransaction.avsdescription": "AVS Description",
		"entity.orderfulfillment.subtotalafterdiscountswithtax": "Fulfillment Items Total After Discounts & Tax",
		"validate.changeeventdates.sku_changeeventdates.startreservationdatetime.ltdatetimeproperty": "The event reservation end date must occur after start date.",
		"entity.workflowtriggerhistory.workflowtriggerhistoryid": "Workflow Trigger History ID",
		"define.line": "Line",
		"define.here": "Here",
		"admin.entity.producttabs.productcategories": "Product Categories",
		"define.directory": "Directory",
		"entity.promotionqualifier.rewardmatchingtype": "Reward Matching Type",
		"entity.pickwave_plural": "Pick Waves",
		"entity.postalcode.postalcode": "Postal Code",
		"defaultmessage_integer": "{1} must be an integer.",
		"setting.skueligiblecurrencies": "Eligible Currencies",
		"entity.vendororderitem.estimatedreceivaldatetime": "Estimated Receival",
		"entity.sku.loyaltyredemptions": "Loyalty Redemptions",
		"entity.attribute.attributeinputtype": "Input Type",
		"entity.type.typeid": "typeID",
		"validate.save.content.urltitlepath.isuniqueurltitlepathbysite": "The URL Title Path is not unique.",
		"define.years": "years",
		"validate.account.accesscode": "The access code you provided is invalid.",
		"entity.report.dynamicdaterangetype": "Date Range Type",
		"report.orderitemreport.itemdiscountgiven": "Discount",
		"validate.save.orderitem.quantity.hasquantitywithinminorderquantity": "The quantity that you have entered is less than the minimum order quantity.",
		"entity.collection.collectionconfig": "Collection Config",
		"entity.address.company": "Company",
		"admin.entity.exporttask_title": "Export Task List",
		"setting.integrationelavonmerchantid": "Merchant ID",
		"entity.paymentmethod.saveaccountpaymentmethodtransactiontype": "Save APM Trans.",
		"entity.subscriptionusage.userenewalsku": "Use Renewal Sku?",
		"entity.productreview.reviewtitle": "Review Title",
		"entity.accountloyaltytransaction.loyaltyaccruement": "Loyalty Accruement",
		"entity.subscriptionusagebenefit": "Subscription Usage Benefit",
		"setting.integrationvertexoriginpostalcode": "Origin Postal Code",
		"entity.product.eventconflict": "There are event time and location conflicts with one of this product's events. Review the Skus tab for details.",
		"define.monthly": "Monthly",
		"entity.waitlistqueueterm_plural": "Waitlist Queue Terms",
		"processobject.sku_changeeventdates.editscope": "Edit schedule for",
		"admin.define.basic": "Basic",
		"setting.productimagelargewidth": "Large Image Width",
		"admin.entity.producttabs.skus": "Skus",
		"admin.entity.ordertabs.orderitemgiftrecipients": "Gift Card Recipients",
		"setting.locationconfigurationcapacity": "Location Configuration Capacity",
		"entity.taskschedule.failureemaillist": "Failure Emails",
		"entity.permission.allowcreateflag": "Allow Create Flag",
		"entity.content.skus": "Skus",
		"entity.sku.webwholesaleqoh": "webWholesaleQOH",
		"admin.main.update.availablestableversion": "Available Stable Version",
		"entity.currency": "Currency",
		"define.pricegroups": "Price Groups",
		"entity.workflow.createdby": "Created By",
		"entity.product.calculatedproductrating": "Product Rating",
		"define.search": "Search",
		"entity.subscriptionusage.autorenewflag": "Auto Renew",
		"entity.accountaddress.address": "Address",
		"processobject.sku_changeeventdates.reservationstarttime": "New reservation start time",
		"entity.orderitem.appliedtaxes": "Applied Taxes",
		"entity.permission.allowreadflag": "Allow Read Flag",
		"setting.globalencryptionkeysize": "Encryption Key Size",
		"validate.addeventschedule.product_addeventschedule.purchasestartdatetime.ltdatetimeproperty": "Purchase Start Date must occur before the event.",
		"admin.define.nosearchresults": "No Results Found",
		"validate.save.promotionperiod.enddatetime.gtproperty": "The end date should be greater than the start date.",
		"define.weekofthemonth": "Week of the Month",
		"setting.globalauditautoarchiveversionlimit": "Audit Auto-Archive After X Versions",
		"entity.type": "Type",
		"entity.attributevalue.account": "account",
		"setting.integrationvertexorigincountry": "Origin Country",
		"entity.pricegroup.subscriptionusagebenefits": "Subscription Usage Benefits",
		"entity.commentrelationship.vendororder": "Vender Order",
		"entity.profiletemplate.profiletemplateid": "profileTemplateID",
		"entity.taxcategoryrate": "Tax Category Rate",
		"entity.site_plural": "Sites",
		"entity.workflowtriggerhistory.starttime": "Start Time",
		"admin.entity.createpromotionqualifiercontentaccess": "Content Access Item Qualifier",
		"entity.loyaltyterm_plural": "Loyalty Terms",
		"entity.promotionapplied.orderitem": "Order Item",
		"admin.entity.processemail.addtoqueue_success": "Email Sent",
		"entity.commentrelationship.referencedexpressionend": "Referenced Expression End",
		"setting.accountfailedadminloginattemptcount": "Max Admin Failed Login Attempts",
		"define.qndorvo": "QNDORVO",
		"permission.setting.listtype": "Type - List",
		"setting.integrationvirtualmerchantmerchantid": "VirtualMerchant ID (6 Digit)",
		"admin.entity.skutabs.orderitems": "Order Items",
		"entity.location.primaryaddress": "Primary Address",
		"entity.define.calculatedqats": "QATS",
		"define.qs.full": "Sold",
		"permission.setting.savelocation": "Location - Save",
		"admin.entity.detailorderpayment.entireordertotal": "Entire Order Total",
		"entity.shippingmethod.promotionrewards": "Promotion Rewards",
		"entity.giftcard.process.toggleactive": "Toggle Active",
		"admin.main": "Dashboard",
		"admin.entity.define.addaccountpayment_error": "There was an error adding the Account Payment",
		"entity.promotionperiod.maximumaccountusecount": "Max. Account Use Count",
		"entity.brand.promotionqualifierexclusions": "Promotion Qualifier Exclusions",
		"entity.product.productyear": "Product Year",
		"entity.subscriptionusage.process.updatestatus": "Update Subscription Status",
		"entity.option.promotionqualifiers": "Promotion Qualifiers",
		"setting.subscriptionusagerenewalreminderdays_hint": "Comma seperated list of when you would like emails to go-out before a subscription expires",
		"admin.entity.producttabs.customattributes": "Custom Attributes",
		"entity.attributeoption.delete_success": "Attribute option deleted.",
		"entity.audit.sessionaccountfullname": "Account Name",
		"entity.audit.changedetails.propertychanged.new": "Changed To",
		"entity.report.reportcompareflag": "Report Compare Flag",
		"entity.vendoremailaddress": "Vendor Email Address",
		"entity.subscriptionterm.subscriptiontermname": "Subscription Term Name",
		"gigya_permission": "Gigya Integration",
		"entity.orderfulfillment.manualfulfillmentchargeflag": "Manual Fulfillment Charge Flag",
		"permission.pricing.listpricegroup": "Price Group - List",
		"permission.product.saveproductreview": "Product Review - Save",
		"entity.productrelationship.relatedproduct": "Related Product",
		"entity.addresszonelocation.addresszonelocationid": "Address Zone Location ID",
		"entity.waitlistqueueterm.waitlistqueuetermname": "Term Name",
		"entity.accountrelationship.accountrelationshipid": "accountRelationshipID",
		"entity.audit.sessionaccountid": "Session Account ID",
		"permission.product.listbrand": "Brand - List",
		"entity.promotioncode": "Promotion Code",
		"setting.skuallowbackorderflag": "Backorder OK",
		"entity.workflowtrigger.nextrundatetime": "Next Run Date Time",
		"admin.entity.ordertabs.stockreceivers": "Stock Receivers",
		"permission.order.saveorderfullfillment": "Order Fulfillment - Save",
		"define.time": "Time",
		"entity.promotionreward.promotionrewardcurrencies": "Promotion Reward Currencies",
		"entity.type_plural": "Types",
		"entity.collection_plural": "Collections",
		"api.main.getformresponses_permission": "API GET Method for Form Responses",
		"entity.updatescript.executioncount": "Execution Count",
		"entity.paymentmethod.process.processtermaccountpayment": "Process Term Account Payment",
		"entity.orderitem.profile": "profile",
		"permission.product.savesubscriptionterm": "Subscription Term - Save",
		"entity.term.renewalsubscriptionterms": "Renewal Subscription Terms",
		"entity.workflowtask_plural": "Tasks",
		"entity.product.categories": "Categories",
		"entity.category.categorydescription": "Category Description",
		"entity.accountpaymentmethod.creditcardlastfour": "Credit Card",
		"entity.attributeset.globalflag": "Global Attribute Set",
		"entity.loyaltyredemption.amounttype.dollarperpoint": "Dollar Per Point",
		"entity.orderitem.calculatedextendedprice": "Extended Price",
		"entity.accountpayment.termoffsetaccountbalance": "Account Balance After",
		"entity.site.sitename": "Site Name",
		"entity.postalcode.longitude": "longitude",
		"setting.integrationclickandbuysecretkey": "Secret Key",
		"entity.promotionreward.excludedskus": "Sku Exclusions",
		"validate.orderitem.quantity.toomanyeventregistrations": "There are too many assigned event registration.",
		"validate.account_setupinitialadmin.password.regex": "Admin passwords should include at least 1 letter, 1 number, and be 7 or more characters long.",
		"permission.product.editbrand": "Brand - Edit",
		"entity.order.orderfulfillments": "Order Fulfillments",
		"entity.orderdelivery.totalquantitydelivered": "Total Qty. Delivered",
		"validate.offlinetransaction.giftcard_offlinetransaction.amount.lteproperty.giftcardbalanceamount": "You've entered an amount to charge greater than the balance of the gift card.",
		"entity.productschedule.scheduleendtype": "End Type",
		"setting.integrationavataxsourcepostalcode": "Source Postal Code",
		"entity.attributevalue_plural": "Attribute Values",
		"admin.entity.promotionqualifiertabs.skus": "Skus",
		"admin.physical.listphysical.status": "Status",
		"entity.accountpaymentmethod.bankroutingnumberencrypted": "Bank Routing Number  Encrypted",
		"entity.skucurrency.price": "Price",
		"entity.taxcategoryrate.taxaddresslookup": "Tax Address",
		"admin.pricing.createpromotionqualifiersubscription": "Create Promotion Qualifier Subscription",
		"entity.orderdeliveryitem": "Order Delivery Item",
		"entity.stockadjustmentitem.adjustmentquantity": "Adjustment Qty.",
		"entity.stockadjustment.stockadjustmentitems": "Stock Adjustment Items",
		"entity.postalcode.country": "country",
		"entity.define.remoteid": "Remote ID",
		"setting.globalapipageshowlimit": "API Page Show Limit ",
		"admin.entity.processeventregistration.pendingapproval_success": "Registration has been changed to Pending Approval.",
		"admin.entity.preprocessorder": "Create Order",
		"entity.locationconfiguration.locationconfigurationid": "Location Configuration ID",
		"setting.integrationupsshipfromaddressline": "Shipping Street Name",
		"entity.define.bundleflag": "SKU Bundle",
		"admin.entity.subscriptionusagetabs.subscriptionusagesettings": "Subscription Usage Settings",
		"admin.entity.processproduct.deletedefaultimage_success": "Imaged Deleted",
		"define.pie": "Pie",
		"setting.integrationfullcirclelocaltransferurlusername": "Local Transfer URL Username",
		"entity.orderitem.taxliabilityamount": "Tax Liability Amount",
		"entity.subscriptionusagebenefit.excludedcategories": "Excluded Categories",
		"entity.accountpaymentapplied.orderpayment": "Order Payment",
		"validate.create.product_create.renewalprice.required": "You must define a Renewal Price and it must be greater than zero.",
		"setting.header.sitesettings": "Site Settings",
		"entity.term.sortorder": "Sort Order",
		"entity.account.emailaddressconfirm": "Confirm Email Address",
		"permission.setting.saveterm": "Term - Save",
		"entity.site.domainnames": "Domain Names",
		"admin.main.encryptionreencryptdata": "Re-encrypt Database",
		"setting.accountfailedpublicloginattemptcount_hint": "This is the max number of login attempts than a public user gets before their account is locked.",
		"admin.entity.accounttabs.accountsettings": "Account Settings",
		"entity.accountloyalty.manualadjustmenttype.manualin": "Manual In",
		"entity.permissiongroup_plural": "Permission Groups",
		"entity.loyaltyterm.term": "Term",
		"entity.fulfillmentbatch.fulfillmentbatchid": "Fulfillment Batch ID",
		"entity.taxcategoryrate.taxaddresslookup.billing": "Billing Only",
		"setting.skuholdbackquantity_hint": "Qty. To Hold Back From ATS (Available To Sell) Calculations",
		"entity.report.dynamicdaterangetype.weektodatesunday": "Week to Date ( Starting Sunday )",
		"validate.giftcard.isexpired": "The gift card you are trying to use is expired.",
		"entity.producttype.pricegrouprates": "Price Group Rates",
		"admin.entity.processproduct.create.selectcustomrenewal": "Select a benefit and price to be used upon renewal.",
		"define.language.fr_fr": "French",
		"define.subscriptionbenefits": "Subscription Benefits",
		"setting.globaltimeformat": "Time Format",
		"entity.producttype": "Product Type",
		"entity.emailtemplate.logemailflag": "Log Email",
		"setting.integrationpaypalexpresspaypalaccountsandboxflag": "PayPal Account Sandbox",
		"admin.entity.accounttabs.giftcards": "Gift Cards",
		"entity.producttype.loyaltyredemptionexclusions": "Loyalty Redemption Exclusions",
		"entity.pricegrouprate.amount": "Amount",
		"define.multiselect": "Multiselect",
		"validate.changepassword.account_changepassword.password.minlength": "The password that you enter must be at least 8 characters long.",
		"entity.sku.locationconfigurations": "Location Configuration",
		"entity.sku_plural": "Skus",
		"validate.define.inlist": "${propertyName} must be in list ${constraintValue}",
		"entity.vendoraddress.vendoraddressname": "Nickname",
		"entity.promotionperiod.enddatetime": "End Date/Time",
		"entity.order.process.removepersonalinfo": "Remove Personal Info",
		"admin.entity.editorderitemgiftrecipient_disabled": "You cannot edit a gift recipient while it's gift cards are active.",
		"event.onapplicationfullupdate": "On Application Full Update",
		"entity.order.discounttotal": "Discount",
		"admin.metadismissed_info": "The /meta directory warning has been dismissed make sure you delete the /meta directory manually before deploying in production use.",
		"entity.vendororder.vendororderitems": "Vendor Order Items",
		"entity.ordertiem": "Order Item",
		"setting.productdisplaytemplate": "Product Display Template",
		"setting.fulfillmentmethodemailbcc": "fulfillment method email bcc",
		"entity.physical.process.commit": "Commit Physical Count",
		"entity.paymentmethod.paymentmethodtype": "Payment Method Type",
		"validate.delete.sku.transactionexistsflag.eq": "This sku can not be deleted it has been used on transactions.",
		"permission.setting.editcountry": "Country - Edit",
		"entity.country.statecoderequiredflag": "Require State Code",
		"entity.loyaltyredemption.brands": "Brands",
		"admin.entity.promotionqualifiertabs.shippingmethods": "Shipping Methods",
		"mura.main.default": "Mura Integration",
		"admin.entity.createphysicalcountitem": "Add Items",
		"admin.entity.processeventregistration.notplaced_success": "Registration status changed to Not Placed.",
		"entity.shippingmethodrate.shippingmethod": "Shipping Method",
		"api.main.exportformresponses_permission": "API Export Method for Form Responses",
		"entity.productschedule.scheduleenddate": "Schedule End Date",
		"entity.product.define.productname": "Product Name",
		"entity.taskhistory.taskhistoryid": "Task History ID",
		"admin.entity.listworkflow": "Workflows",
		"admin.entity.createproduct.selectrenewalsubscriptionbenifits": "Select the Renewal Subscription Benefit(s) that you would like to sell as this product.",
		"entity.taxcategory.taxcategoryname": "Tax Category Name",
		"admin.entity.preprocessphysical.addphysicalcount": "Add Physical Count",
		"entity.stockreceiver": "Stock Receiver",
		"admin.main.dashboard.neworders": "New Orders",
		"entity.loyaltyaccruement.enddatetime": "End Date/Time",
		"entity.paymentterm.accountpaymentmethods": "Account Payment Methods",
		"admin.entity.listproduct.createnoevent": "You cannot create an 'Event' product until you have defined at least one 'Location Configuration' inside of a 'Location'.",
		"entity.physicalcountitem.skucode": "Sku Code",
		"entity.print.printid": "Print ID",
		"processobject.content_create.urltitle": "URL Title",
		"setting.locationconfigurationadditionalprereservationtime_hint": "This setting will allow for events using this configuration to add these minutes onto the begining of the location reservation for extra breakdown time for example",
		"entity.report.dynamicdaterangetype.quartertodate": "Quarter To Date",
		"entity.account.delete_success": "Account Deleted Successfully",
		"admin.entity.settingstabs.shippingmethodrate": "Shipping Rate Settings",
		"entity.loyaltyredemption.redemptionpointtype.current": "Current Point Balance",
		"define.address": "Address",
		"permission.superuser": "Super User",
		"validate.delete.orderfulfillment.orderfulfillmentid.maxvalue": "The order fulfillment cannot be deleted as the order has been placed.",
		"admin.main.dashboad": "Dashboad",
		"setting.globalordernumbergeneration": "Order Number Generation",
		"define.accesscode": "Access Code",
		"admin.define.list_nav": "${itemEntityNamePlural}",
		"entity.accountloyalty.lifetimebalance": "Lifetime Point Balance",
		"validate.processsubscriptionusage_renew.order.notplaced": "A renewal order was created, however it couldn't be placed which is most likely because of payment issues.  Please navigate to this order to finalize and place:",
		"entity.loyaltyredemption.skus": "Skus",
		"entity.giftcard.ownerfirstname": "First Name",
		"entity.order.process.closeorder": "Close Order",
		"admin.define.delete_error": "There was an error when trying to delete the ${itemEntityName}",
		"admin.entity.createphysicalcount": "Create New Physical Count",
		"setting.locationconfigurationadditionalpostreservationtime": "Post Event Reservation Minutes",
		"admin.pricing.detailpromotion.initialperiod": "Initial Period",
		"entity.vendoraccount.roletype": "Role Type",
		"define.reporttype": "Report Type",
		"email.deliveryconfirmation": "Delivery Confirmation",
		"entity.state_plural": "States",
		"validate.save.workflowtaskaction.actiontype.checkpermission": "User does not have permission to run Workflow Task Action",
		"permission.setting.createtask": "Task - Create",
		"entity.address.city": "City",
		"admin.entity.processproduct.addsubscriptionsku_success": "Subscription Sku Added",
		"entity.baseentity.updatekeys": "updateKeys",
		"entity.addresszone.shippingmethodrates": "Shipping Method Rates",
		"entity.attribute.attributeoptions": "Attribute Options",
		"entity.subscriptionorderitem.subscriptionorderitemid": "Subscription Order Item ID",
		"entity.accountpayment.checknumberencrypted": "Check Number Encrypted",
		"entity.account.accountcontentaccesses": "Account Content Accesses",
		"admin.entity.settingstabs.site": "Site Settings",
		"entity.stockadjustmentitem.tostock": "To Stock",
		"entity.subscriptionbenefit": "Subscription Benefit",
		"entity.stockadjustmentitem.stock": "Stock",
		"entity.define.billingaccountaddress": "Billing Account Address",
		"entity.file.filename": "File Name",
		"report.productperformancereport.saleprediscount": "Pre Discount Sale",
		"admin.pricing.createpromotionqualifiermerchandise": "Create Promotion Qualifier Merchandise",
		"entity.orderfulfillment.pickuplocation": "Pickup Location",
		"entity.stockadjustment.adjustmenttype": "adjustmentType",
		"entity.orderfulfillment.process.manualfulfillmentcharge": "Override Fulfillment Charge",
		"setting.taskfailureemailtemplate_hint": "This email template will be used to send out failure notifications in the event that a task does not run successfully",
		"admin.entity.promotionreward.discounttype.amountoff": "Amount Off",
		"entity.orderfulfillment.discountamount": "Discounts",
		"setting.productimagesmallheight": "Small Image Height",
		"entity.content.contenttemplatetype_hint": "There are special pages defined by Slatwall as 'Template' pages that get used as the template for a given product, brand, etc.  For example if you select 'Product' here, this page will then be available in the settings tab of the products in Slatwall to be used as a template.",
		"admin.entity.processapp.create_error": "There was a problem saving application",
		"entity.promotionqualifier.qualifiertype.merchandise": "Merchandise",
		"define.creditoffline": "Credit Offline",
		"entity.product_plural": "Products",
		"admin.entity.promotiontabs.promotionperiods": "Promotion Periods",
		"entity.product.process.create": "Create Product",
		"permission.setting.detailcontent": "Content - Detail",
		"processobject.sku_changeeventdates.eventendtime": "New end time",
		"entity.subscriptionstatus.subscriptionstatustype": "Subscription Status Type",
		"entity.pickwave.pickwaveid": "Pick Wave ID",
		"admin.pricing.createpromotionrewardmerchandise": "Create Promotion Reward Merchandise",
		"entity.loyaltyredemption.nextredemptiondatetime": "Next Redemption Date/Time",
		"validate.delete.sku.defaultflag.eq": "This sku can not be deleted because it is the default sku for this product.",
		"entity.productbundlegroup": "Product Bundle Group",
		"define.modifiedbyaccount": "Modified By",
		"entity.taxapplied.taxjurisdictionid": "Tax Jurisdiction ID",
		"entity.address.middleinitial": "Middle Initial",
		"entity.promotionreward.products": "Products",
		"entity.promotionqualifier.qualifiertype": "Qualifier Type",
		"entity.promotionreward.itemrewardquantity": "Qty. per Qualification",
		"entity.define.companypaymentmethodflag": "Company Payment Method",
		"admin.entity.producttypetabs.producttypesettings": "Product Type Settings",
		"admin.define.externaldetails": "External Details",
		"entity.accountemailaddress.accountemailtype": "Email Type",
		"entity.paymentmethod.allowsaveflag_hint": "If this is set to yes, then people will be able to save payment methods of this type to their account.",
		"setting.emailimapserverpassword": "Bounced Email Server Password",
		"permission.product.listproducttype": "Product Type - List",
		"admin.entity.optiongrouptabs.description": "Description",
		"entity.sku.eventcapacity": "Event capacity",
		"entity.accountemailaddress.emailaddress": "Email Address",
		"entity.orderitem.quantity": "Qty.",
		"processobject.account_create.createauthenticationflag_hint": "Selecting yes will allow you to save a password for this account so that it can be accessed later",
		"setting.globaldateformat": "Date Format",
		"entity.stockadjustment.tolocation": "To Location",
		"admin.entity.attributesettabs.attributes": "Attributes",
		"define.qualified": "Qualified",
		"define.month": "Month",
		"admin.entity.optiongrouptabs.options": "Options",
		"entity.sku.redemptionamounttype": "Redemption Amount Type",
		"admin.entity.promotionrewardtabs.currencies": "Currencies",
		"setting.paymentmethodstorecreditcardnumberwithaccount_hint": "If this is set to yes, then when orders get placed it will automatically create an account payment method, that is setup with the credit card number encrypted and saved",
		"admin.entity.processorder.closeorder_success": "The order has successfully been closed.",
		"admin.entity.emailtemplatetabs.htmlbody": "HTML Body",
		"entity.promotionqualifier.maximumitemprice": "Maximum Item Price",
		"admin.entity.orderitemtabs.orderitemgiftrecipients": "Gift Recipients",
		"api.main.define.save_success": "The ${EntityName} was saved successfully",
		"entity.collection.collectiontabletitle": "Collection Results",
		"entity.currencyrate.effectivestartdatetime": "Effective Start DateTime",
		"entity.term_plural": "Terms",
		"entity.orderitem.bundleitemquantity": "Package Quantity",
		"admin.main.update.bleedingedge": "Bleeding Edge",
		"entity.product.loyaltyredemptionexclusions": "Loyalty Redemption Exclusions",
		"entity.audit.frontendonly": "There is no audit history available, only front end updates have been performed",
		"entity.paymenttransaction.transactiontype": "Transaction Type",
		"entity.stockadjustment.adjustmentdatetime": "adjustmentDateTime",
		"entity.attribute.attributetype.atcheckbox": "Check Box",
		"entity.brand.loyaltyaccruements": "Loyalty Accruements",
		"admin.entity.createsubscriptionproduct_nav": "New Subscription Product",
		"entity.promotion.promotionsummary": "Promotion Summary",
		"entity.orderpayment.process.authorize": "Authroize",
		"entity.paymenttransaction.transactiondatetime": "Transaction Date Time",
		"validate.create.account_create.emailaddress.getprimaryemailaddressnotinuseflag": "The email address that you have entered is already in use as the primary email address for another account.  If this is your email address, you can use forgot password tool to reset your password via email.",
		"entity.promotionreward.fulfillmentmethods": "Fulfillment Methods",
		"entity.permissiongroup.accounts": "Accounts",
		"setting.integrationorbitalbin_hint": "Your 'BIN' setting is the orbital platform your merchant account is running on.  Contact your Technical Analyst or Relationship Manager if you are unsure which Platform your merchant account resides on.",
		"entity.orderitem.discountamount": "Discounts",
		"entity.promotionqualifier.maximumfulfillmentweight": "Maximum Weight",
		"admin.entity.emailtabs.htmlbody": "HTML Body",
		"entity.sku.eventenddatetime": "Event End",
		"entity.account.accountphonenumbers": "Phone Numbers",
		"admin.define.create_nav": "Add ${itemEntityName}",
		"entity.attributevalue.attributevalueencryptedgenerator": "Attribute Value Encryption Generator",
		"entity.sku.skucode_hint": "A unique string (alphanumerc, no spaces) to identify the sku.",
		"entity.product.process.uploaddefaultimage": "Upload Image",
		"entity.product.process.addoption": "Add Option",
		"admin.entity.createproduct.searchproductbundletype": "Search or Add Bundle Group Type...",
		"entity.workflowtaskaction.process": "Process",
		"entity.product.process.addoptiongroup": "Add Option Group",
		"entity.promotionreward.rewardcanapplytoqualifierflag": "Include Qualifier in Reward",
		"permission.setting.listcountry": "Country - List",
		"validate.changeeventdates.sku_changeeventdates.startreservationdatetime.gtnow": "The start reservation date cannot be before now.",
		"entity.promotionreward.roundingrule": "Rounding Rule",
		"entity.permission": "Permission",
		"entity.pricegrouprate.pricegrouprateappliesto": "Applies To",
		"validate.account.passwordconfirmmismatch": "The passwords that you entered do not match",
		"permission.setting.detailschedule": "Schedule - Detail",
		"entity.taskhistory.starttime": "Task Start Time",
		"entity.schedule.frequencyinterval": "Frequency Repeat Minutes",
		"setting.integrationvertexoriginmaindivision": "Origin Main Division (State)",
		"admin.entity.processcontent.create_error": "There was a problem saving content",
		"entity.subscriptionusage.process.sendrenewalreminder": "Send Renewal Reminder",
		"entity.accountemailaddress.verifiedflag": "Verified",
		"entity.sku.formattedredemptionamount": "Redemption Amount",
		"entity.app.appcode": "Application  Code",
		"entity.accountloyaltyaccruement.accruementtype.orderclosed": "Order Closed",
		"entity.schedule.recuringtype": "Recurring Type",
		"entity.optiongroup.globalflag": "Global Object Group",
		"entity.order.referencingpaymentamountcreditedtotal": "Credited on Referencing",
		"setting.globalremoteidshowflag": "View RemoteID Fields in Administrator",
		"admin.entity.stockadjustments.products": "Products",
		"entity.state": "State",
		"define.emailaddress": "Email Address",
		"admin.editfilteritem.saveandaddanotherfilter": "Save And Add Another Filter",
		"define.quantitymustbegreaterthanzero": "Quantity Must Be Numeric and Greater Than Zero",
		"setting.integrationfullcirclefcftpdirecotry_hint": "Full Circle FTP Directory",
		"setting.skuminimumpercentageamountrecievedrequiredtoplaceorder": "Minimum Percentage Amount Recieved Required To Place Order",
		"admin.main.update_title": "Update Slatwall",
		"validate.save.country.countrycode.maxlength": "Country Code cannot have more than 3 characters",
		"validation.define.gte": "This value is invalid",
		"define.international": "International",
		"entity.accountloyalty.accountloyaltynumber": "Account Loyalty Program Number",
		"entity.address.statecode_validaterequired": "Please enter a valid State",
		"setting.integrationavataxsourcestreetaddress": "Source Street Address",
		"entity.vendororder.vendorordercreateddatetime": "Date Created",
		"permission.order.deleteorder": "Order - Delete",
		"entity.sku.endreservationdatetime": "Reservation End Date",
		"entity.subscriptionterm.autopayflag": "Auto Pay",
		"admin.define.giftcarddetails": "Gift Card Details",
		"processobject.orderdelivery_create.trackingnumber": "Tracking Number",
		"entity.audit.audittype.logout": "Logout",
		"processobject.subscriptionusage_renew.updatesubscriptionusageaccountpaymentmethodflag": "Use For Future Renewals",
		"entity.paymentmethod.saveaccountpaymentmethodencryptflag": "Encrypted & Save (APM)",
		"validate.account.password": "Invalid password",
		"validate.save.paymenttransaction.orderpayment.hasorderpaymentoraccountpayment": "Payment Transaction requires an Order Payment or Account Payment",
		"event.onapplicationbootstraprequeststart": "On Application Bootstrap Request Start",
		"report.productperformancereport.itemdiscount": "Discount",
		"entity.vendororderitem": "Vendor Order Item",
		"setting.skuallowpreorderflag_hint": "Indicate whether this product can be preordered",
		"admin.entity.attributesettabs.producttypes": "Product Types",
		"setting.integrationvertextaxcategoriestoinvoice": "Tax Categories to Invoice",
		"define.occurs": "Occurs",
		"admin.entity.listaudit": "Audit Log",
		"entity.loyaltyredemption.products": "Products",
		"entity.accountpayment.termoffsetterm": "Term",
		"setting.integrationvertexwebservicespassword": "Vertex Password",
		"validate.define.typeidrequired": "Type ID is Required",
		"entity.shippingmethodrate.maximumshipmentquantity": "Max Fulfillment Quantity",
		"validate.save.promotion.promotioncodes.hasuniquepromotioncodes": "There are duplicate promotion codes defined for this promotion.",
		"entity.promotionperiod.startdatetime": "Start Date/Time",
		"entity.productreview.review": "Review",
		"entity.optiongroup.optiongroupcode_hint": "A unique string (alphanumerc, no spaces) to identify the option group.",
		"entity.sku.skucurrencies": "SKU Currencies",
		"entity.optiongroup.optiongroupcode": "Option Group Code",
		"processobject.order_addorderitem.orderfulfillmentid": "Order Fulfillment",
		"entity.accountloyaltyaccruement.accruementtype.fulfillmentmethodused": "Fulfillment Method Used",
		"define.yes": true,
		"admin.entity.promotionrewardtabs.fulfillmentmethods": "Fulfillment Methods",
		"entity.loyaltyaccruement_plural": "Loyalty Program Accruements",
		"entity.attributeoption.attributeoptionid": "attributeOptionID",
		"entity.audit.audittype.logininvalid": "Login Invalid",
		"admin.entity.categorytabs.childcategories": "Child Categories",
		"define.backtolist": "Back To List",
		"admin.entity.permissiongrouptabs.entitypermissions": "Data Permissions",
		"setting.contentrestrictaccessflag": "Restrict Access",
		"admin.define.no_items_selected": "No items selected",
		"entity.subscriptionusage.initialsubscriptionorderitem": "Initial Subscription Order Item",
		"admin.entity.createreturnorder.processoption.quantity": "Return Qty.",
		"define.qomax": "QOMAX",
		"report.productperformancereport.saleafterdiscount": "Purchased",
		"validate.addrecipientstoorderitem.orderitem.orderitemgiftrecipients.hasunassignedgiftcards": "OrderItem has unassigned gift cards",
		"entity.sku.image.exists": "Image Exists",
		"entity.term": "Term",
		"entity.loyaltyredemption.excludedproducts": "Excluded Products",
		"entity.content.createdby": "Created By",
		"entity.shortreference.referenceobjectid": "Reference Object ID",
		"admin.entity.contenttabs.products": "Products",
		"setting.integrationipaymentapplicationid": "Application ID",
		"setting.integrationpayflowproorderpaymentcommentonetemplate_hint": "This template will be string replaced based on the order payment, and then passed as custom comment 1 to PayFlow Pro.  An Example would be: ${orderPaymentID} or ${myCustomOrderPaymentAttributeCode}.  Plain text works as well\"",
		"entity.orderdelivery.createddatetime": "Delivered On",
		"entity.vendor.vendororders": "Vendor Orders",
		"entity.producttype.delete_validateisassigned": "This product type cannot be deleted because it has been assigned to a product and/or it has subtypes which must be moved or deleted first.",
		"entity.vendor.products": "Products",
		"entity.producttype.loyaltyaccruementexclusions": "Loyalty Accruement Exclusions",
		"define.qndosa.full": "Not Delivered On Stock Adjustment",
		"entity.orderdelivery.orderdeliveryitems_validatehasorderdeliveryitems": "No quantities from the orderfulfillment were indicated for delivery.",
		"permission.setting.createlocation": "Location - Create",
		"entity.shippingmethod.eligibleaddresszone": "Eligible Address Zone",
		"entity.product.loyaltyredemptionexclusion": "Loyalty Redemption Exclusions",
		"entity.accountauthentication.updatepasswordonnextloginflag": "Password Update Required",
		"validate.create.product_create.purchaseenddatetime.datatype.date": "Purchase End Date must be a valid date",
		"entity.contentaccess.subscriptionusagebenefit": "Subscription Usage Benefit",
		"validate.define.required": "The ${propertyName} is required.",
		"entity.emailbounce.rejectedemailto": "Rejected Email To",
		"permission.account.detailpermissiongroup": "Permission Group - Detail",
		"admin.main.encryption.iterationcount": "Iteration Count",
		"entity.report.dynamicdaterangeendtype.now": "Date Run",
		"permission.setting.detailpaymentmethod": "Payment Method - Detail",
		"validate.save.setting.settingvalue.minvalue": "The value that you have entered is below the minimum value allowed.",
		"entity.subscriptionterm.initialterm": "Initial Term",
		"admin.entity.fulfillmentmethodtypes.shippingtabs.settings": "Settings",
		"entity.product.process.updatedefaultimagefilenames": "Reset Default Image Filenames",
		"validate.create.product_create.purchaseenddatetime.gtdatetimeproperty": "Purchase End Date must occur after Purchase Start Date",
		"define.false": false,
		"entity.access.subscriptionusage": "Subscription Usage",
		"setting.globalpagecheckout": "Checkout Page",
		"entity.accountaddress.accountaddresstype": "Address Type",
		"entity.image.imageid": "Image ID",
		"validate.addeventschedule.product_addeventschedule.scheduleenddate.gtdatetimeproperty": "Schedule end date must occur after schedule start date.",
		"admin.entity.accounttabs.orders": "Orders",
		"entity.updatescript.updatescriptid": "Update Script ID",
		"setting.integrationupsshipfromstatecode": "Shipping From State Code ",
		"entity.orderorigin.orderorigintype": "Order Origin Type",
		"entity.entityqueuehistory.entityqueuedata": "Entity Queue Data",
		"entity.integration.paymentactiveflag": "Payment Integration Active",
		"entity.site.siteid": "Site ID",
		"validate.save.file.fileupload.isfiletypewhitelisted": "The File Type you are trying to upload is not approved, this can be modified in advanced settings.",
		"frontend.checkout.detail.checkoutasguest": "Checkout As Guest",
		"entity.country.street2addressshowflag": "Show Street2 Address",
		"entity.shippingmethod.shippingrateincreasedollar": "Shipping Rate Increase Dollar",
		"entity.promotionreward": "Promotion Reward",
		"define.yearly": "Yearly",
		"permission.setting.createfulfillmentmethod": "Fullfillment Method - Create",
		"entity.paymentmethod_plural": "Payment Methods",
		"setting.emailsmtpusessl": "SMTP Use SSL",
		"entity.giftcard.issueddate": "Issued Date",
		"report.orderitemreport.saleafterdiscount": "Purchased",
		"validate.processphysical_addphysicalcount.countfile": "The file you uploaded had no valid rows to be imported.",
		"entity.vendorphonenumber_plural": "Vendor Phone Numbers",
		"validate.delete.subscriptionusage.subscriptionusageid.maxlength": "Subscription Usages cannot be deleted.",
		"entity.formresponse.createddatetime": "Date Submitted",
		"entity.option.promotionrewardexclusions": "Promotion Reward Exclusions",
		"setting.integrationavataxsourcestreetaddress2": "Source Street Address 2",
		"entity.content.modifiedby": "Modified By",
		"admin.main.encryption.password": "Password",
		"permission.warehouse.editstockadjustment": "Stock Adjustment - Edit",
		"entity.contentaccess.account": "Account",
		"entity.loyaltyredemption.amounttype.fixed": "Fixed",
		"define.qvomax.full": "Max Per Order",
		"admin.entity.emailtemplatetabs.textbody": "Text Body",
		"entity.product.listprice_hint": "Optional field to specify an MSRP or a price that this product is usually listed as.  Typically this is to show that you offer the product at a lower rate",
		"entity.define.creditcardnumberencrypteddatetime": "Credit Card Encrypted Date Time",
		"entity.fulfillmentbatchitem.fulfillmentbatchitemid": "FulfillmentBatchItemID",
		"entity.emailverification": "Email Verification",
		"entity.product.publishedweight": "Published Weight",
		"entity.productlistingpage.productlistingpageid": "Product Listing Page ID",
		"setting.globalgiftcardmessagelength": "Gift Card Message Length",
		"entity.session.sessioncookienpsid": "Non-Persistent Session ID",
		"define.detail": "Detail",
		"entity.shippingmethod.shippingmethodid": "Shipping Method ID",
		"entity.sku.alternateskucodes": "Alternate SKU Codes",
		"entity.producttype.publishedflag": "Published Flag",
		"entity.subscriptionusage.subscriptionorderitems": "Subscription Order Items",
		"processobject.orderdelivery_create.captureauthorizedpaymentsflag": "Capture pre-authorized CC",
		"permission.help": "Help",
		"validate.save.content.contentid.required": "You are attempting to add content to a site that is not a Slatwall CMS, this cannot be done.",
		"admin.entity.processproduct.addoption_success": "The option has been successfully added to the sku.",
		"entity.promotioncode.delete_validateisassigned": "This promotion code cannot be deleted because it is in use.",
		"entity.report.dynamicdaterangeendtype.lastquarterend": "Previous Quarter End",
		"entity.content.disableproductassignmentflag": "Disable product assignment",
		"validate.addorderitem.order_addorderitem.sku.required": "Please select the option(s) for this product.",
		"entity.accountphonenumber.accountphonetype": "Account Phone Type",
		"entity.skuprice.expiresdatetime": "Expires Date Time",
		"validate.save.promotioncode.enddatetime.gtproperty": "Promotion code end date / time should be greater than start date / time.",
		"entity.subscriptionstatus_plural": "Subscription Statuses",
		"entity.comment.comment": "Comment",
		"entity.brand.products": "Products",
		"entity.optiongroup.optiongroupdescription": "Option Group Description",
		"entity.account.taxexemptflag": "Tax Exempt",
		"entity.shippingmethodoption.shiptocity": "Ship To City",
		"entity.define.modifieddatetime": "Modified Date Time",
		"entity.product.productschedules": "Product Schedules",
		"entity.entityqueuehistory.entityqueuetype": "Entity Queue Type",
		"entity.shippingmethodoption.shippingmethodrate": "Shipping Method Rate",
		"setting.globaladmindomainnames": "Admin Domain Names",
		"report.appliedpromotionreport": "Applied Promotion",
		"entity.stockreceiveritem.stockreceiver": "Stock Receiver",
		"entity.loyaltyredemption_plural": "Loyalty Program Redemptions",
		"entity.promotioncode.maximumaccountusecount": "Max. Account Use Count",
		"entity.term.termhours": "Term Hours",
		"entity.account.accountauthentications": "Account Authentications",
		"entity.stockadjustment.physical": "Physical",
		"admin.entity.preprocessorder_addorderitem.itemdetails": "Item Details",
		"setting.integrationavataxtaxexemptpropertyidentifier_hint": "This is optional and can be pointed to a boolean propertyIdentifier based on the order that will exempt the order for being taxed.",
		"entity.loyalty.loyaltyid": "Loyalty Program ID",
		"admin.entity.createeventtrigger_disabled": "all event triggers have been disabled and migrated as workflows",
		"permission.setting.deleteattributeset": "Attribute Set - Delete",
		"entity.accountauthentication_plural": "Account Authentications",
		"entity.order.process.updateorderamounts": "Update Order Amounts",
		"entity.product.productdescription": "Product Description",
		"entity.order.process.placeorder.paymentprocessedmessage": "There were errors processing one or more of your order payments, however because some payment transactions were placed the order was forced through.  Please review payment transactions for futher detials",
		"define.language.en_us": "English (US)",
		"setting.integrationorbitalindustrytype": "Industry Type",
		"entity.account.process.forgotpassword_success": "A password reset email has been sent to the primary email address on your account.",
		"entity.account.primaryaccountpaymentmethod": "Primary Payment Method",
		"entity.type.type": "Type",
		"entity.audit.auditarchivestartdatetime": "Start Date",
		"entity.workflow.workflowid": "Workflow ID",
		"define.qomin": "QOMIN",
		"entity.databasecache_plural": "Database Cache",
		"validate.define.eqproperty": "The values you have entered do not match.",
		"admin.entity.subscriptionbenefittabs.pricegroups": "Price Groups",
		"processobject.physical_addphysicalcount.countpostdatetime": "Count Post Date Time",
		"define.limitresults": "Limit Results",
		"entity.product.manufacturediscontinuedflag_hint": "Has this product been discontinued by the manufacturer?",
		"entity.sku.process.removelocation": "Remove location",
		"entity.eventtrigger.printtemplate": "Print Template",
		"entity.shippingmethod": "Shipping Method",
		"entity.print.printcontent": "Print Content",
		"define.manual": "Manual",
		"entity.product.subscriptionbenifitsrequired": "Subscription Benefits are Required",
		"define.total": "Total",
		"admin.entity.createproduct.selectsubscriptionbenefits": "Select Subscription Benefit(s)",
		"entity.attribute.attributeset": "Attribute Set",
		"entity.order.ordernumbertooriginal": "Original Order Number",
		"admin.entity.skutabs.eventregistrations": "Event Registrations",
		"entity.promotionperiod_plural": "Promotion Periods",
		"validate.account_forgotpassword.emailaddress.notfound": "No account could be found with the supplied email address.",
		"entity.emailbounce.rejectedemailsendtime": "Rejected Email Send Time",
		"validate.create.product_create.redemptionamount.regex": "The value entered for Redemption Amount should be numeric.",
		"admin.entity.processorder.cancelorder_success": "The order has successfully been canceled",
		"setting.skutrackinventoryflag": "Track Inventory",
		"validation.define.required": "This value is required.",
		"entity.pricegrouprate.pricegroup": "Price Group",
		"setting.addressmetadescriptionstring": "Address Meta Description String",
		"entity.pickwave": "Pick Wave",
		"entity.content.productlistingpageflag": "Product Listing Page",
		"frontend.cart.clearitems": "Clear All Cart Items",
		"entity.loyaltyredemption": "Loyalty Program Redemption Criteria",
		"entity.shippingmethodrate.defaultamount_hint": "When using a 'manual' rate this is the amount that will be charged.  If you are using a shipping provider, then this value is the fallback amount if for some reason the shipping provider is inaccessible.",
		"admin.entity.workflowtabs.triggers.norecordsfound": "No trigger results found",
		"entity.accountloyalty.loyalty": "Loyalty",
		"define.createandlogin": "Create & Login",
		"entity.taxcategoryrate.taxaddresslookup.shipping_billing": "Shipping -> Billing",
		"define.forever": "Forever",
		"setting.globalusagestats": "Send Anonymous Usage Stats",
		"admin.entity.deletesetting_nav": "Remove Setting Override",
		"entity.report.dynamicdaterangeendtype.thismonthend": "Current Month End",
		"admin.entity.producttabs.productreviews": "Product Reviews",
		"entity.accountauthentication.integrationrefreshtoken": "Integration Refresh Token",
		"validate.define.mincollection": "Atleast one ${propertyName} has to be selected.",
		"entity.session.lastrequestdatetime": "Last Request Date/Time",
		"define.pickup": "Pickup",
		"entity.order.ordertype": "Order Type",
		"validate.define.ltdatetimeproperty": "${propertyName} must occur before ${constraintValue}.",
		"entity.promotionreward.skus": "Sku",
		"entity.skuprice": "Sku Price",
		"entity.promotionreward.rewardtype.order": "Order",
		"entity.skuprice.maxquantity.null": "any",
		"entity.loyaltyredemption.excludedskus": "Excluded Skus",
		"validate.delete.sku.stocksdeletableflag.eq": "This sku cannot be deleted because it has stocks assigned to it.",
		"entity.order.process.removeorderitem.parentfailsvalidationerror": "The order item can not be removed because it is required by the product bundle.",
		"define.comments": "Comments",
		"entity.setting.brand": "Brand",
		"entity.account.password": "Password",
		"admin.entity.ordertabs.orderitems.noresults": "No Order Items Have Been Added To This Order",
		"permission.account.deletepermissiongroup": "Permission Group - Delete",
		"entity.order.ordershipments": "Order Shipments",
		"entity.account.orders": "Orders",
		"entity.form.formcode": "Form Code",
		"entity.sku.listprice_hint": "Optional field to specify an MSRP or a price that this product is usually listed as.  Typically this is to show that you offer the product at a lower rate",
		"setting.globaluseproductcacheflag": "User Product Cache",
		"entity.loyaltyaccruement.accruementtype.itemfulfilled": "Item Fulfilled",
		"entity.orderitem.calculateditemtotal": "Item Total",
		"processobject.product_create.generateskusflag": "Generate Sku(s)",
		"validate.define.null": "${propertyname} is null must be ${constraintValue}",
		"entity.emailtemplate": "Email Template",
		"setting.integrationuspstestapiendpointurl": "USPS Test API Endpoint URL",
		"admin.entity.processgiftcard.offlinetransaction_success": "You have sucessfully adjusted the gift card balance.",
		"define.refund": "Refund",
		"entity.order.process.addorderpayment": "Add Order Payment",
		"entity.content.cmscontentidpath": "CMS Content ID Path",
		"entity.stockhold_plural": "Stock Holds",
		"setting.skumarkattendanceasbundle": "sku mark attendance as bundle",
		"entity.loyaltyredemption.redemptiontype.pricegroupassignment": "Price Group Assignment",
		"admin.entity.promotionrewardtabs.shippingmethods": "Shipping Methods",
		"admin.entity.editorderdeliveryitem_disabled": "The order delivery item cannot be edited as the order has been placed.",
		"entity.subscriptionusage.nextbilldate": "Next Bill Date",
		"entity.pricegroup.promotionrewards": "Promotion Rewards",
		"entity.option.promotionrewards": "Promotion Rewards",
		"entity.order.orderopendatetime": "Date Placed",
		"entity.stockadjustmentdeliveryitem.stockadjustmentdelivery": "Stock Adjustment Delivery",
		"permission.setting.deleteaddresszone": "Address Zone - Delete",
		"permission.setting.detailfulfillmentmethod": "Fulfillment Method - Detail",
		"entity.promotionapplied.promotionappliedid": "Promotion Applied ID",
		"entity.taxapplied.taxcity": "Tax City",
		"entity.brand.brandname": "Brand Name",
		"setting.integrationsofortcurrency": "Currency (ISO4217)",
		"validate.giftcardcode.invalid": "The gift card you have entered is invalid.",
		"setting.integrationpaypalexpresspaypalaccountsignature": "PayPal Classic API  Signature",
		"admin.entity.emailtabs.emailsettings": "Email Settings",
		"setting.integrationfullcirclefcftppassword_hint": "Password to connect to FC Server via FTP",
		"entity.sku.promotionqualifierexclusions": "Promotion Qualifier Exclusions",
		"entity.loyaltyredemption.loyalty": "Loyalty",
		"validate.processorder_forceitemquantityupdate.forceditemremoved": "${sku.product.title} - ${sku.skuDefinition} was removed from your order because of availability constraints.",
		"admin.entity.detailorderfulfillment.fulfillment_totals": "Fulfillment Totals",
		"entity.entityqueue.entityqueuetype": "Entity Queue Type",
		"defaultmessage_required_condition": "{1} is required {2}.",
		"admin.define.checkdetails": "Check Details",
		"entity.orderfulfillment.orderfulfillmentid": "Order Fulfillment ID",
		"entity.promotionreward.shippingdiscounttype": "Shipping Discount Type",
		"setting.integrationfedextransactionkey": "FedEx Transaction Key ",
		"define.january": "January",
		"setting.brandmetakeywordsstring": "Brand Meta Keywords String",
		"entity.content.productsortproperty": "Product Sort Property",
		"validate.offlinetransaction.giftcard_offlinetransaction.amount.gt": "You've entered an invalid amount, please enter a positive number",
		"setting.integrationvertexwebservicesurl": "Vertex Server Location",
		"permission.pricing.deletepricegroup": "Price Group - Delete",
		"validate.order.orderitemwrongcurrency": "The current order is of a different currency than the item you are trying to add.  Please clear your order before trying again, or select the currency that matches your order.",
		"endicia.main_permission": "Dashboard",
		"define.dayofthemonth": "Day of the Month",
		"validate.changepassword.account_changepassword.password.regex": "Admin passwords should include at least 1 letter, 1 number, and be 7 or more characters long.",
		"define.modifieddatetime": "Modified on",
		"processobject.product_addsku.bundlelocationconfigurationflag": "Bundle Locations",
		"define.return": "Return",
		"entity.attribute.attributeclasstype": "attributeClassType",
		"setting.emailimapserverport": "Bounced Email Server Port (IMAP)",
		"admin.entity.workflowtabs.tasks": "Tasks",
		"entity.define.amountauthorized": "Amount Authorized",
		"setting.integrationmuralegacycheckout_hint": "If you have upgraded from a previous version of Slatwall that used the filename hooks, and the 'frontend' subsystem, then the filename of that page should be in this field",
		"entity.shippingmethodrate_plural": "Shipping Method Rates",
		"entity.orderitem.quantitydelivered": "Qty. Delivered",
		"define.youhave": "You Have",
		"validate.save.sku.listprice.minvalue": "The sku list price cannot be a negative value.",
		"processobject.sku_changeeventdates.recurringtimeunit": "Occuring",
		"entity.product.options": "Product Options",
		"admin.entity.addorderitemgiftrecipient.hint": "Use the \"search or add recipient\" field below to assign recipients to gift cards.",
		"setting.productmissingimagepath": "Product Missing Image Path",
		"entity.producttype.attributesets": "Attribute Sets",
		"entity.roundingrule.roundingruledirection": "Rounding Direction",
		"entity.orderpayment.orderpaymentid": "Order Payment ID",
		"processobject.order_addorderpayment.saveaccountpaymentmethodflag": "Save as Account Payment",
		"defaultmessage_min": "{1} must be at least {2}.",
		"validate.save.subscriptionterm.autoretrypaymentdays.regex": "The value entered for ${propertyName} should be numeric and optionally can be comma seperated.",
		"entity.eventtrigger.eventtriggerid": "Event Trigger ID",
		"entity.product.manufacturediscontinuedflag": "Discontinued by Manufacturer",
		"entity.roundingrule.roundingruleid": "Rounding Rule ID",
		"entity.address.streetaddress": "Street Address",
		"setting.integrationfedexcontactphonenumber": "Contact Phone Number",
		"validate.save.setting.settingvalue.maxvalue": "The value that you have entered is above the maximum value allowed.",
		"setting.skuholdbackquantity": "Hold Back Qty.",
		"entity.order.ordertotal": "Order Total",
		"entity.shippingmethodoption_plural": "Shipping Method Options",
		"admin.entity.createproductimage_nav": "Add Product Image",
		"entity.permission.allowdeleteflag": "Allow Delete Flag",
		"entity.attributeset.attributesetcode": "Attribute Set Code",
		"entity.promotion.promotiondescription": "Promotion Description",
		"entity.attribute.delete_success": "The Attribute was successfully deleted.",
		"entity.shippingmethodrate.shippingintegration": "Shipping Integration",
		"entity.order.process.addpromotioncode": "Add Promotion Code",
		"validate.processorder_placeorder.incompletepayment": "The order could not be placed because the current order payments do not have sufficient funds to purchase the whole amount.",
		"define.qhb": "QHB",
		"entity.productbundlebuilditem.selectbundlegroup": "Please add one or more items to this bundle group",
		"admin.entity.skutabs.subscription": "Subscription",
		"entity.orderreturn.orderreturnid": "Order Return ID",
		"entity.promotionreward.maximumuseperitem": "Max. Use Per Item",
		"validate.addpromotioncode.order_addpromotioncode.promotioncode.promotioncodenotalreadyapplied": "This promotion code has already been applied to this order.",
		"permission.vendor.createvendororder": "Vendor Order - Create",
		"admin.entity.listcartandquote_nav": "Carts & Quotes",
		"entity.accountloyaltytransaction_plural": "Account Loyalty Program Transactions",
		"define.option": "Option",
		"setting.integrationpayflowproorderpaymentcommentonetemplate": "Order Payment Comment One Template",
		"entity.currency.currencysymbol": "Currency Symbol",
		"admin.entity.processstockadjustment.processadjustment_success": "The stock adjustment has been processed successfully.",
		"entity.merchandiseproducttype": "Merchandise Product Type",
		"entity.productbundlegroup.skuprice": "Sku Price",
		"entity.eventtrigger.eventtriggerobject": "Trigger Object",
		"permission.setting.createaddresszone": "Address Zone - Create",
		"entity.accountaddress": "Account Address",
		"entity.skubundle.skubundleid": "Sku Bundle ID",
		"entity.content.site.sitename": "Site Name",
		"entity.product.process.image.norecordsfound": "Missing Image",
		"setting.globalmaximumfulfillmentsperorder": "The maximum number of fulfillments allowed on a single order.",
		"entity.eventregistration.firstname": "First Name",
		"admin.entity.accounttabs.pricegroups": "Price Groups",
		"admin.main.log_title": "Slatwall Log Viewer",
		"entity.taskschedule.enddatetime": "End Date",
		"setting.integrationpayflowproorderpaymentcommenttwotemplate": "Order Payment Comment Two Template",
		"entity.vendororder.subtotal": "Subtotal",
		"setting.fulfillmentmethodautominreceivedpercentage_hint": "In order for an auto fulfillment to occur this percentage can be set so that X% of the amount for the items being fulfilled actually be received before fulfillment takes place.  Typically this is set to 0 or 100 saying that you either require or don't require payment to be received before the fulfillment automatically happens",
		"admin.entity.orderitemgiftrecipient.giftmessage": "Gift Message",
		"admin.report": "Reporting Dashboard",
		"admin.define.delete_nav": "Delete ${itemEntityName}",
		"define.wysiwyg": "Wysiwyg (Rich Text)",
		"entity.paymenttransaction.avsdescription.b": "Street address matches, but postal code not verified.",
		"admin.entity.orderitemgiftrecipient.quantity": "Quantity",
		"entity.paymenttransaction.avsdescription.a": "Street address matches, but 5-digit and 9-digit postal code do not match.",
		"entity.paymenttransaction.avsdescription.d": "Street address and postal code match. Code \"M\" is equivalent.",
		"entity.printtemplate": "Print Template",
		"entity.paymenttransaction.avsdescription.c": "Street address and postal code do not match.",
		"entity.loyaltyredemption.amounttype": "Amount Type",
		"permission.setting.savetaxcategory": "Tax Category - Save",
		"entity.account.permissiongroups": "Permission Groups",
		"entity.term.termdays": "Term Days",
		"entity.report.dynamicdaterangeendtype.thisquarterend": "Current Quarter End",
		"entity.promotionqualifier.excludedproducttypes": "Product Type Exclusions",
		"endicia_permission": "Endicia",
		"entity.attributevalue.subscriptionbenefit": "Subscription Benefit",
		"entity.physical.skus": "Physical Skus",
		"admin.entity.processaccount.generateapiaccesskey_success": "The API Access Key has been generated successfully.",
		"setting.integrationfedexshippercity": "Shipping From City ",
		"validate.edit.orderitem.orderstatuscode.inlist": "The order Item cannot be edited as the order has been placed.",
		"entity.subscriptionbenefit.promotions": "Promotions",
		"define.default": "Default",
		"entity.audit.audittype.delete": "Deleted",
		"permission.setting.edittask": "Task - Edit",
		"entity.paymenttransaction.avsdescription.v": "Card member's name, billing address, and billing postal code match.",
		"entity.paymenttransaction.avsdescription.u": "Address information unavailable. Returned if the U.S. bank does not support non-U.S. AVS or if the AVS in a U.S. bank is not functioning properly.",
		"entity.report.reporttitle": "Report Title",
		"admin.entity.createcontentaccessproduct_nav": "New Content Access Product",
		"entity.paymenttransaction.avsdescription.x": "Street address and 9-digit postal code match.",
		"entity.paymenttransaction.avsdescription.w": "Street address does not match, but 9-digit postal code matches.",
		"entity.orderfulfillment_plural": "Order Fulfillments",
		"entity.paymenttransaction.avsdescription.z": "Street address does not match, but 5-digit postal code matches.",
		"entity.paymenttransaction.avsdescription.y": "Street address and 5-digit postal code match.",
		"entity.fulfillmentmethod.orderfulfillments": "Order Fulfillments",
		"entity.physicalcount": "Physical Count",
		"entity.paymenttransaction.avsdescription.n": "Street address and postal code do not match.",
		"processobject.sku_changeeventdates.scheduleendoccurrences": "Occurrences",
		"entity.paymenttransaction.avsdescription.m": "Street address and postal code match. Code \"D\" is equivalent.",
		"entity.paymenttransaction.avsdescription.p": "Postal code matches, but street address not verified.",
		"entity.paymenttransaction.avsdescription.o": "Card member's name and billing address match, but billing postal code does not match.",
		"entity.loyaltyaccruement.pointtype.fixed": "Fixed",
		"entity.paymenttransaction.avsdescription.r": "System unavailable.",
		"processobject.product_addeventschedule.createbundleflag": "Create a bundle?",
		"entity.workflowtaskaction.updatedata": "Update Data",
		"entity.paymenttransaction.avsdescription.q": "Card member's name, billing address, and postal code match.",
		"admin.entity.promotionqualifiertabs.products": "Products",
		"entity.paymenttransaction.avsdescription.t": "Card member's name does not match, but street address matches.",
		"entity.schedule.frequencyendtime_hint": "Defining this will allow for the schedule to run multiple times in a given day.",
		"permission.account": "Account",
		"entity.paymenttransaction.avsdescription.s": "Bank does not support AVS.",
		"entity.paymenttransaction.avsdescription.f": "Card member's name does not match, but billing postal code matches.",
		"entity.workflowtask.taskconditionsconfig": "Task Condidtion Config",
		"entity.paymenttransaction.avsdescription.e": "AVS data is invalid or AVS is not allowed for this card type.",
		"entity.order.paymentamounttotal": "Total Payments",
		"entity.report.dynamicdaterangeendtype.lastmonthend": "Previous Month End",
		"entity.paymenttransaction.avsdescription.h": "Card member's name does not match. Street address and postal code match.",
		"setting.integrationorbitalmerchantid_hint": "This is the 6 digit ID that defines your Merchant ID, also sometimes refured to as you Transaction Division Number.",
		"entity.attribute.formemailconfirmationflag": "Form Confirmation Email",
		"define.qomax.full": "Max Per Order",
		"setting.locationconfigurationadditionalprereservationtime": "Pre Event Reservation Minutes",
		"entity.paymenttransaction.avsdescription.g": "Non-U.S. issuing bank does not support AVS.",
		"entity.paymenttransaction.avsdescription.j": "Card member's name, billing address, and postal code match.",
		"entity.task.enddatetime": "Task End Date",
		"entity.define.activeflag_hint": "Item is available for utilization in the back-end",
		"entity.paymenttransaction.avsdescription.i": "Address not verified.",
		"entity.paymenttransaction.avsdescription.l": "Card member's name and billing postal code match, but billing address does not match.",
		"entity.account.accountcode": "Account Code",
		"entity.paymenttransaction.avsdescription.k": "Card member's name matches but billing address and billing postal code do not match.",
		"entity.category.products": "Products",
		"entity.orderitem.taxamount": "Tax Amount",
		"entity.orderpayment.orderpaymenttype": "Order Payment Type",
		"admin.entity.processpromotionperiod.duplicatepromotionperiod_success": "The promotion period has been duplicated successfully.",
		"setting.skuminimumpaymentpercentagetowaitlist": "sku minimum payment percentage to waitlist",
		"entity.vendoremailaddress.vendoremailaddressid": "Vendor Email Address ID",
		"entity.accountphonenumber.account": "Account",
		"entity.productcustomizationattributeset": "Product Customization Attribute Set",
		"entity.order.appliedpromotions": "Applied Promotions",
		"entity.vendororder.stockreceivers": "Stock Receivers",
		"admin.entity.createcontentaccessproducttype_nav": "New Content Access Product Type",
		"entity.paymentmethod.saveorderpaymenttransactiontype": "Save OP Trans.",
		"entity.schedule_plural": "Schedules",
		"entity.loyalty_plural": "Loyalty Programs",
		"admin.define.delete_disabled": "The ${itemEntityName} can not be deleted because it is in use, or has been involved in a previous transaction.  You can however make the ${itemEntityName} inactive",
		"entity.shippingmethod.shippingrateincreasepercentage": "Shipping Rate Increase Percentage",
		"validate.create.product_create.eventenddatetime.gtdatetimeproperty": "Event End Date must occur after Event Start Date",
		"admin.entity.processphysical_addphysicalcount.additems": "Add Physical Count Items",
		"entity.define.createdbyaccountid": "Created By AccountID",
		"setting.integrationstripeapiversion": "API Version",
		"report.orderitemreport.itemtax": "Tax",
		"define.auto": "Auto",
		"permission.setting.savecountry": "Country - Save",
		"entity.remoteentity.deletedflag": "Deleted",
		"entity.session.deviceid": "Device ID",
		"define.reset": "Reset",
		"admin.entity.processform.addformquestion_success": "You have successfully added a question to this form.",
		"entity.accountloyalty": "Account Loyalty Program",
		"permission.product.deletesubscriptionbenefit": "Subscription Benefit - Delete",
		"entity.define.amountcredited": "Amount Credited",
		"entity.sku.publishedflag": "Published",
		"entity.entityqueue": "Entity Queue",
		"entity.fulfillmentmethod.fulfillmentmethodtype": "Fulfillment Method Type",
		"permission.pricing": "Pricing",
		"entity.sku.webwholesaleqc": "webWholesaleQC",
		"setting.fulfillmentmethodautolocation": "Automatic Fulfillment Location",
		"entity.subscriptionusagebenefit.maxusecount": "Max Use Count",
		"define.qoh": "QOH",
		"entity.filerelationship.filerelationshipid": "File Relationship ID",
		"admin.export.list": "Export Entire List",
		"entity.accountpayment.accountpaymenttype": "Account Payment Tyoe",
		"define.textarea": "Text Area",
		"entity.addresszone.delete_validateisdeletable": "This Address Zone cannot be deleted because it is in use.",
		"entity.taskschedule.taskscheduleid": "Task Schedule ID",
		"setting.integrationavataxsourcecountry": "Source Country",
		"entity.accountpaymentapplied_plural": "Account Payments Applied",
		"entity.accountrelationshiprole.accountrelationshiprolename": "Name",
		"entity.address.firstname": "First Name",
		"entity.sku.eventstartdatetime": "Event Start",
		"entity.locationconfiguration.locationpathname": "Location",
		"validate.create.product_create.purchasestartdatetime.datatype.date": "Purchase Start Date must be a valid date",
		"entity.taxcategoryrate.taxaddresslookup.billing_shipping": "Billing -> Shipping",
		"define.qnc": "QNC",
		"entity.report.dimensions": "Dimensions",
		"entity.databasecache.databasecachekey": "Database Cache Key",
		"entity.stockhold.stock": "Stock",
		"entity.permission.allowupdateflag": "Allow Update Flag",
		"setting.skushippingweight_hint": "Shipping weight of a single Qty. of a SKU",
		"entity.vendoremailaddress.vendor": "Vendor",
		"entity.content.disableproductassignmentflag_hint": "Disable product assignment",
		"admin.entity.orderfulfillmenttabs.orderfulfillmentitems": "Order Fulfillment Items",
		"setting.integrationauthorizenettranskey": "Transaction Key ",
		"admin.main.noaccess": "Access Denied",
		"entity.accountcollection.accountcollectionid": "Account Collection ID",
		"permission.setting.deletetask": "Task - Delete",
		"entity.taxapplied.taxpostalcode": "Tax Postal Code",
		"entity.session.shippingaddresspostalcode": "Shipping Address Postal Code",
		"entity.attribute.attributetype.attextarea": "Text Area",
		"entity.stockadjustmentitem.stockreceiveritems": "Stock Receiver Items",
		"admin.entity.promotionperiodtabs.promotionperiodcodes": "Promotion Codes",
		"entity.task.taskurl": "Task URL",
		"defaultmessage_url": "{1} must be a valid URL.",
		"entity.commentrelationship.commentrelationshipid": "Comment Relationship ID",
		"admin.entity.emailtemplatetabs.body": "Email Body",
		"processobject.subscriptionusage_renew.renewalpaymenttype.accountpaymentmethod": "Saved Account Payment Method",
		"entity.workflowtask": "Workflow Task",
		"setting.integrationfullcirclefcftpaddress": "Full Circle FTP Address",
		"entity.vendororderitem.vendororderitemid": "Vendor Order Item ID",
		"setting.integrationmuralookuplistingcontentobjects_hint": "Selecting this option will add additional overhead to the request of product details but it will also inherit content objects from the listing page the use came from.",
		"entity.site.resetsettingcache": "Reset Setting Cache",
		"entity.country.postalcodelabel": "Postal Code Label",
		"admin.entity.stocktabs.inventoryhistory": "Inventory History",
		"entity.entityqueue.entityqueuedata": "Entity Queue Data",
		"entity.loyaltyredemption.redemptionpointtype": "Redemption Point Type",
		"permission.setting.savetaskhistory": "Task History - Save",
		"entity.product.physicals": "Physicals",
		"entity.entityqueue.baseid": "Base ID",
		"entity.pricegrouprate.pricegroupratecurrencies": "Price Group Rate Currencies",
		"defaultmessage_max": "{1} must be no more than {2}.",
		"setting.integrationfullcirclefcftpport": "Full Circle FTP Port",
		"entity.subscriptionusage.allowprorateflag": "Allow Prorate",
		"entity.vendor.phonenumbers": "Phone Numbers",
		"admin.entity.brandtabs.vendors": "Vendors",
		"entity.accountpayment.termoffsetduedate": "Due Date",
		"validate.create.product_create.renewalsku.required": "You must define a renewal sku.",
		"admin.report.exportxls": "Export XLS",
		"setting.productmetadescriptionstring": "Product Meta Description String",
		"admin.pricing.createpromotionrewardsubscription": "Create Promotion Reward Subscription",
		"admin.entity.editemail_disabled": "You cannot edit a logged email.",
		"entity.orderpayment.paymentduedate": "Payment Due Date",
		"setting.globalencryptionkeylocation": "Encryption Key Location",
		"entity.cartandquote": "Cart and Quote",
		"entity.accountauthentication.integrationaccountid": "Integration AccountID",
		"processobject.order_addorderitem.shippingaccountaddressid": "Shipping Account Address",
		"entity.option.optionimage": "Option Image",
		"admin.entity.processtask.runtask_success": "Task Successfully Run",
		"entity.promotion.defaultimage": "Default Image",
		"entity.pricegroup.pricegroupidpath": "Price Group ID Path",
		"entity.attributeoption.attribute": "Attribute",
		"entity.accountrelationship.relationshiptype": "relationshipType",
		"entity.promotionapplied.discountamount": "Discount Amount",
		"admin.entity.processeventregistration.pendingconfirmation_success": "Registration has been changed to Pending Confirmation.",
		"entity.orderpayment.giftcardnumberencrypted": "Gift Card Number",
		"validate.save.paymentmethod.allowsaveflag.getsubscriptiontermhasautopayflagset": "This option can't be turned off until all subscription terms with auto pay turned on, have auto pay turned off.",
		"validate.define.creditcard": "The value entered  is not a valid ${propertyName}.",
		"validate.fileupload": "There was an error trying to upload your file, please verify that you are uploading the correct file type.",
		"entity.stockadjustmentdelivery.stockadjustmentdeliveryitems": "Stock Adjustment Delivery Items",
		"processobject.order_addorderpayment.amount.usetotal": "Use Order Total",
		"processobject.product_addsubscriptionsku.subscriptiontermid": "Subscription Term",
		"entity.workflowtaskaction.workflowtaskactionid": "Workflow Task Action ID",
		"entity.define.urltitle": "URL Title",
		"entity.orderdelivery.location": "Location",
		"processobject.physical_addphysicalcount.countfile": "Count File",
		"entity.producttype.subproducttypes": "subProductTypes",
		"define.qr.full": "Received",
		"entity.sku.giftcardexpirationterm": "Expiration Term",
		"entity.accountphonenumber.accountphonenumberid": "accountPhoneNumberID",
		"email.orderconfirmation": "Order Confirmation",
		"define.showreport": "Show Report",
		"entity.measurementunit": "Measurement Unit",
		"entity.paymentmethod.orderpayments": "Order Payments",
		"entity.attributevalue.orderpayment": "Order Payment",
		"define.wednesday": "Wednesday",
		"admin.main.ckfinder_title": "File Manager",
		"entity.order.process.createreturn": "Create Return Order",
		"permission.warehouse.savestockreceiver": "Stock Receiver - Save",
		"entity.formresponse": "Form Response",
		"define.qty": "Qty.",
		"entity.term.graceperiodsubscriptionterms": "Grace Period Subscription Terms",
		"admin.entity.detailpromotion.currentperiodwithnocurrentpromocode_info": "There is a current promotion period & this promotion also requires a promotion code, however all of the existing promotion codes have expired.",
		"entity.accountpayment.creditcardnumberencrypted": "Credit Card Number Encrypted",
		"entity.printtemplate.printtemplatename": "Print Template Name",
		"entity.attribute.attributeinputtype.relatedobjectmultiselect": "Related Object Multiselect",
		"entity.image.imagefile": "Image",
		"permission.setting.deletefulfillmentmethod": "Fulfillment Method - Delete",
		"entity.account.emailaddress": "Email Address",
		"permission.vendor.deletevendororder": "Vendor Order - Delete",
		"entity.taskhistory.task": "Task",
		"define.once": "Once",
		"entity.vendororder.vendorordertype": "Order Type",
		"define.userguide": "User Guide",
		"permission.vendor.savevendororder": "Vendor Order - Save",
		"processobject.account_redeemgiftcard.giftcardcode": "Gift Card Number",
		"entity.attributevalue.sku": "Sku",
		"validate.create.order_create.password.minlength": "Password Must be at least 6 charecters long.",
		"entity.filerelationship": "File Relationship",
		"entity.workflowtrigger.workflowtriggerid": "Workflow Trigger ID",
		"entity.audit.norecords": "There is no audit history available",
		"entity.shippingmethodoption.totalshippingweight": "Total Shipping Weight",
		"validate.processproduct_create.productbundlegroup.invalid": "Your product bundle configuration is invalid. Please make sure your bundle has all required fields, a type and bundle items.",
		"entity.subscriptionterm": "Subscription Term",
		"admin.entity.accounttabs.cartsandquotes": "Carts & Quotes",
		"entity.order.totalamounttoberefunded": "Total Amount To Be Refunded",
		"admin.entity.subscriptionusagetabs.usagebenefits.renewalbenefits": "Renewal Benefits",
		"entity.order.process.addorderitem": "Add",
		"entity.report": "Report",
		"entity.order.process.removepromotioncode": "Remove Promotion Code",
		"entity.fulfillmentmethod_plural": "Fulfillment Methods",
		"define.required": "required",
		"entity.pricegroupratecurrency_plural": "Price Group Currency Rates",
		"entity.producttype.products": "Products",
		"setting.integrationavataxcommittaxdocumentflag": "Commit Tax Document Flag",
		"permission.account.savepermissiongroup": "Permission Group - Save",
		"entity.stockreceivervendororder.packingslipnumber": "Packing Slip Number",
		"entity.optiongroup.optiongroupimage_hint": "Associate an image for this option Group. Supported Formats. JPG,PNG,GIF.",
		"permission.product.listoptiongroup": "Option Group - List",
		"entity.productschedule": "Product Schedule",
		"entity.eventregistration.process.cancel": "Cancel Registration",
		"entity.option_plural": "Options",
		"entity.schedule": "Schedule",
		"admin.editfilteritem.selectfrom": "Select From",
		"entity.sku.accesscontents": "Access Contents",
		"entity.profiletemplate.profiletemplatedescription": "profileTemplateDescription",
		"entity.locationaddress_plural": "Location Addresses",
		"entity.email.emailbodytext": "Email Body Text",
		"setting.addressdisplaytemplate_hint": "The content object that you would like to use as the template for displaying address on the front-end.  Typically this is a page in your CMS or Custom Application",
		"entity.type.typecode": "Type Code",
		"api.main.exportformresponses": "API GET Export Form Responses",
		"setting.globalurlkeyaccount": "Account URL Key",
		"defaultmessage_maxlength": "{1} must be no more than {2} characters long.",
		"entity.workflowtriggerhistory.successflag": "Success",
		"define.action": "Action",
		"admin.entity.listproduct.createnosubscriptionbenefitorterm": "You cannot create a 'Subscription' product until you have defined at least one 'Subscription Benefit' and at least one 'Subscription Term'.",
		"entity.order.orderorigin": "Order Origin",
		"entity.subscriptionusagebenefit.subscriptionusagebenefitid": "Subscription Usage Benefit ID",
		"entity.pricegroup_plural": "Price Groups",
		"admin.entity.orderreturntabs.orderreturnitems": "Order Return Items",
		"admin.entity.processproduct.addsku_success": "Sku has been added successfully",
		"entity.shippingmethodoptionsplitshipment.shipmentorderitems": "Shipment Order Items",
		"admin.entity.subscriptionusagetabs.renewalusagebenefits": "Renewal Usage Benefits",
		"permission.setting.deleteorderorigin": "Order Origin - Delete",
		"permission.comment": "Comment",
		"entity.skubundle": "Sku Bundle",
		"entity.promotioncode.orders": "Orders",
		"permission.setting.detailtaxcategory": "Tax Category - Detail",
		"admin.main.update.availablebleedingedgeversion": "Available Bleeding Edge Version",
		"setting.paymentmethodcheckouttransactiontype": "Checkout Transaction Type",
		"admin.entity.skutabs.productschedules": "Event Schedule",
		"entity.file.filetype": "File Type",
		"setting.siteforgotpasswordemailtemplate_hint": "This setting defines the account based e-mail template that is going to be sent for 'forgot password' emails",
		"entity.promotionapplied.orderfulfillment": "Order Fulfillment",
		"admin.entity.stockreceivers.missingproducts": "You must enter order items before processing",
		"setting.fulfillmentmethodemailfrom": "Email From",
		"validate.save.loyaltyaccruement.pointtype.inlist": "Point per dollar is not a allowed point type for accruement type program enrollment",
		"entity.define.sortorder": "Sort Order",
		"admin.entity.processsku.addlocation_success": "Location configuration added successfully.",
		"entity.define.billingaddress": "Billing Address",
		"entity.define.expirationdatetime": "Expiration Date Time",
		"validate.edit.orderitemgiftrecipient.giftcards.caneditordelete": "You cannot edit a gift recipient once it's gift cards are active.",
		"validate.processphysical_addphysicalcount.rowerrorwarning": "The file you uploaded had ${rowError} invalid row(s) that could not be imported.",
		"define.eventname": "Event Name",
		"entity.promotionreward.applicableterm": "Applicable Subscription Term",
		"entity.promotionreward.excludedproducttypes": "Product Type Exclusions",
		"entity.shortreference.referenceobject": "Reference Object",
		"entity.product.defaultsku": "Default Sku",
		"entity.account.accountdisplaytemplate": "Display Template",
		"admin.entity.updateslatwall_title": "Update Slatwall",
		"entity.productbundlebuild.productbundlebuildid": "Product Bundle Build ID",
		"entity.define.nextestimatedfulfillmentdatetime": "Next Estimated Order Fulfillment Date Time",
		"setting.skutrackinventoryflag_hint": "Select this if you would like the system to track inventory at this level.",
		"processobject.product_create.bundlecontentaccessflag": "Bundle Content Access Flag",
		"entity.order.process.placeonhold": "Place Order On Hold",
		"entity.pricegroup.delete_success": "PriceGroup Deleted",
		"admin.entity.workflowtabs.basic": "Basic",
		"entity.product.process.addproductreview": "Add Product Review",
		"admin.entity.accounttabs.contactdetails": "Contact Details",
		"setting.accountadminforcepasswordresetafterdays": "Force Admin Password Reset Every x Days",
		"validate.delete.accountpaymentmethod.orderpayments.hasnosubscriptionusage": "You cannot delete an Account Payment Method that is associated with a subscription usage.",
		"entity.audit.audittype.archive": "Archived",
		"entity.define.norecords": "There aren't any ${entityNamePlural}.",
		"entity.subscriptionusagebenefit.accesstype": "Access Type",
		"admin.default.configure_nav": "Config",
		"permission.product.listproduct": "Product - List",
		"entity.subscriptionusage_plural": "Subscription Usages",
		"entity.orderitem.process.addrecipientstoorderitem": "Add Recipients to This Order Item",
		"entity.fulfillmentbatch.fulfillmentbatchname": "Fulfillment Batch Name",
		"define.success": "Success",
		"permission.vendor": "Vendor",
		"define.saturday": "Saturday",
		"validate.save.orderfulfillment.orderfulfillmentid.hasquantityoforderfulfillmentswithinmaxorderquantity": "The maximum number of fulfillments allowed for a single order has been exceeded. Either remove fulfillments or create a new order.",
		"entity.attributevalue": "Attribute Value",
		"entity.taskschedule.task": "Task",
		"permission.setting.edittype": "Type - Edit",
		"entity.subscriptionusagebenefitaccount.subscriptionusagebenefit": "Subscription Usage Benefit",
		"entity.access": "Access",
		"entity.attributevalue.product": "product",
		"entity.content.titlepath": "Content Title Path",
		"entity.account.remotecustomerid": "Remote Customer ID",
		"define.inheritance": "Inheritance",
		"define.remainingcharacters": "Remaining Characters",
		"entity.define.calculatedqnc": "QNC",
		"entity.country.countryname": "Country Name",
		"entity.product.pricegrouprates": "Price Group Rates",
		"entity.stockadjustmentdeliveryitem_plural": "Stock Adjustment Delivery Items",
		"admin.entity.loyaltytabs.loyaltyaccruement": "Loyalty Program Accruement Criteria",
		"entity.eventregistration.registrationstatustitle": "Registration Status",
		"entity.orderdelivery.orderdeliveryitems": "Order Delivery Items",
		"processobject.content_duplicatecontent.urltitle": "URL Title",
		"validate.save.option.optioncode.uniqueornull": "The Option Code is required and must be unique.",
		"entity.report.dynamicdaterangetype.days": "Days(s)",
		"entity.account.process.addaccountloyalty": "Add Account Loyalty Program",
		"entity.product.vendors": "Vendors",
		"setting.locationconfigurationadditionalpostreservationtime_hint": "This setting will allow for events using this configuration to add these minutes onto the end of the location reservation for extra breakdown time for example",
		"define.before": "Before",
		"entity.define.calculatedqoh": "QOH",
		"entity.comment.publicflag": "Public",
		"setting.skucurrency": "Default Currency",
		"admin.entity.listorderfulfillment": "Order Fulfillments",
		"entity.orderfulfillment.orderfulfillmentstatustype": "Order Fulfillment Status",
		"admin.entity.deletepromotionqualifier_disabled": "This promotion qualifier cannot be deleted because it has been used in a transaction and/or its promotion period has expired.",
		"entity.account.primaryphonenumber": "Account Primary Phone Number",
		"entity.accountauthentication": "Account Authentication",
		"validate.account.forgotsuccess": "Login information was sent to the email you provided",
		"entity.report.dynamicdaterangetype.years": "Year(s)",
		"entity.workflowtaskaction_plural": "Workflow Task Actions",
		"entity.locationconfiguration.locationconfigurationname": "Location Configuration",
		"entity.file.filerelationships": "File Relationships",
		"entity.report.dynamicdaterangeendtype.lastweekendsaturday": "Previous Week ( Ending Saturday )",
		"entity.task.timeouttime": "Task Timeout",
		"entity.accountrelationship": "Account Relationship",
		"permission.warehouse.deletestockreceiver": "Stock Receiver - Delete",
		"validate.processsku_editcapacity.eventcapacityinvalid.notenoughseats": "The submitted event capacity would result in an overbooked event.",
		"entity.define.activeflag": "Active",
		"admin.entity.producttabs.images": "Images",
		"validate.save.paymenttransaction.accountpayment.hasorderpaymentoraccountpayment": "Payment Transaction requires an Order Payment or Account Payment",
		"admin.entity.detailpaymenttransaction_permission": "View Payment Transaction Details",
		"setting.integrationvertexwebservicestrustedid": "Vertex Trusted ID",
		"setting.integrationclickandbuymerchantid": "Merchant ID",
		"entity.sku": "SKU",
		"define.orderby": "Order By",
		"entity.printtemplate.printtemplatefile": "Print Template File",
		"admin.order.accountdetails.termaccountcreditdetails.info": "Term Account Credit Details",
		"validate.processorder_forceitemquantityupdate": "The quantities on your order exceeded the maximum allowed for purchase and were adjusted to reflect what is available.",
		"admin.entity.workflowtabs.triggers": "Triggers",
		"report.promotionusagereport": "Promotion Usage",
		"validate.create.product_create.redemptionamount.minvalue": "Tbe value entered for Redemption Amount must be greater than zero.",
		"processobject.account_addaccountloyalty.loyalty": "Loyalty Program",
		"define.october": "October",
		"entity.orderitemgiftrecipient.firstname": "First Name",
		"admin.entity.giftcard": "Gift Card",
		"entity.inventory": "Inventory",
		"define.initialsku": "Initial Sku",
		"entity.contentaccess.content": "Content",
		"entity.address.countrycode": "Country",
		"entity.product.productimages": "Product Images",
		"permission.setting.detailroundingrule": "Rounding Rule - Detail",
		"entity.loyaltyaccruement.pointtype.pointperdollar": "Point Per Dollar",
		"define.fixedamount": "Fixed Amount",
		"entity.attribute.requiredflag": "Required",
		"admin.entity.promotiontabs.promotioncodes": "Promotion Codes",
		"setting.globaladminautologoutminutes": "Log Out Admin Accounts After X Minutes of Inactivity",
		"frontend.checkout.detail.saveaccount": "Save Account",
		"admin.define.detail": "${itemEntityName} Detail",
		"entity.orderfulfillment.shippingcharge": "Shipping Charge",
		"entity.define.changedatetime": "Change Date Time",
		"admin.entity.processsku.changeeventdates_error": "There was a problem saving event date changes.",
		"api.main_permission": "API Access Permission",
		"setting.shippingmethodrateadjustmenttype": "Rate Adjustment Type",
		"entity.stockhold.sku": "Sku",
		"setting.integrationavataxaccesskey": "Avatax License Key",
		"entity.entityqueuehistory.entityqueuehistorydatetime": "Entity Queue History Date Time",
		"defaultmessage_required_dependentpropertyvalue": "{1} is required based on what you entered for {2}{3}.",
		"entity.define.bankroutingnumber": "Bank Routing Number",
		"entity.promotionaccount_plural": "Promotion Accounts",
		"entity.emailtemplate.emailtemplateobject": "Email Template Object",
		"entity.accountpaymentmethod.paymentterm": "Payment Term",
		"setting.integrationavataxcustomerusagetypepropertyidentifier": "Customer Usage Type Property Identifier",
		"entity.updatescript_plural": "Update Scripts",
		"admin.default.orders_nav": "Orders",
		"entity.productschedule.schedulestartdate": "Schedule Start Date",
		"entity.promotionrewardcurrency_plural": "Promotion Reward Currencies",
		"admin.define.save_success": "The ${itemEntityName} was saved successfully.",
		"admin.entity.loyaltyredemptiontabs.skus": "Skus",
		"entity.product.calculatedtitle": "Title",
		"entity.accountloyalty_plural": "Account Loyalty Programs",
		"api.main.define.save_error": "There was an error trying to save the ${EntityName}",
		"entity.shippingmethodoption.shippingmethodoptionid": "Shipping Method Option ID",
		"entity.order.paymentamountcreditedtotal": "Credited Amount",
		"entity.order.orderdeliveries": "Order Deliveries",
		"permission.setting.createmeasurementunit": "Measurement Unit - Create",
		"entity.workflowtaskaction.actiontype": "Action Type",
		"admin.entity.formtabs.formquestions": "Form Questions",
		"entity.physical.stockadjustments": "Stock Adjustments",
		"entity.serverinstance.serverinstanceexpired": "Is Cache Expired",
		"entity.orderpayment.creditcardnumberencrypted": "Credit Card Number Encrypted",
		"entity.optiongroup": "Option Group",
		"entity.orderpayment.securitycode": "CVV Code",
		"entity.orderfulfillment.quantitydelivered": "Quantity Delivered",
		"validate.create.product_create.eventenddatetime.gtnow": "Event End Date must occur in the future",
		"entity.define.startdatetime": "Start",
		"validate.save.schedule.frequencyendtime.gtproperty": "The End Time needs to be greater than the Start Time",
		"admin.entity.skutabs.options": "Options",
		"validate.delete.collection.collectionid.hasnoassociatedcollection": "This collection cannot be deleted. It is associated to other collection.",
		"entity.paymenttransaction.amountreceived": "Amount Received",
		"processobject.product_addeventschedule.schedulingtype": "Occuring",
		"entity.loyaltyaccruement.producttypes": "Product Types",
		"entity.account.loginlockexpiresdatetime": "Account Locked",
		"entity.orderfulfillment.accountaddress": "Account Address",
		"setting.contentdefaultproductsperpage": "Products per page",
		"validate.create.account_create.password.minlength": "The account password should be at least 8 characters long.",
		"entity.inventory.stock": "Stock",
		"entity.loyaltyaccruement.excludedproducts": "Excluded Products",
		"entity.paymenttransaction.providertransactionid": "Provider Transaction ID",
		"entity.physical.locations": "Locations",
		"entity.accountpayment.appliedaccountpayments": "Applied Account Payments",
		"entity.workflowtaskaction.print": "Print",
		"permission.setting.createorderorigin": "Order Origin - Create",
		"entity.accountcontentaccess_plural": "Account Content Accesses",
		"entity.brand.physicals": "Physicals",
		"defaultmessage_true": "{1} must be true.",
		"entity.define.estimateddeliverydatetime": "Estimated Order Delivery Date time",
		"define.workflow": "Workflow",
		"admin.entity.orderitemtabs.deliveryitems": "Delivery Items",
		"entity.setting.emailtemplate": "Email Template",
		"entity.productbundlegroup.minimumquantity": "Min Quantity",
		"entity.stockadjustmentitem.newquantity": "New Qty.",
		"permission.setting.deletetype": "Type - Delete",
		"admin.entity.editorderpayment_disabled": "The order payment cannot be edited as the order has been placed.",
		"define.salutationmrs": "Mrs.",
		"entity.brand_plural": "Brands",
		"permission.setting.savefulfillmentmethod": "Fulfillment Method - Save",
		"entity.product.process.addeventschedule": "Add Event Schedule",
		"entity.address.postalcode": "Postal Code",
		"admin.default.warehouse_nav": "Warehouse",
		"entity.session.loggedoutdatetime": "Logged Out Date Time",
		"entity.collection.collectiondescription": "Description",
		"entity.vendor.emailaddresses": "Email Addresses",
		"entity.commentrelationship": "Comment Relationship",
		"entity.promotionqualifier.qualifiertype.fulfillment": "Fulfillment",
		"setting.integrationelavonlivemodeflag": "Live Mode",
		"entity.comment.publicflag_hint": "This flag is used to determine if the comment should be shown publicly, if set to NO it will only appear in the admin.",
		"permission.setting.detailattributeset": "Attribute Set - Detail",
		"permission.setting.saveschedule": "Schedule - Save",
		"admin.entity.orderitemgiftrecipient.lastname": "Last Name",
		"setting.globalorderplacedemailfrom": "New Order Placed Email From",
		"entity.orderfulfillment.totalshippingweight": "Total Shipping Weight",
		"entity.audit": "Audit",
		"entity.permission.entityclassname": "Entity Class Name",
		"entity.promotionreward.shippingpercentageoff": "Shipping Rate % Off",
		"validate.addorderpayment.order_addorderpayment.giftcardid.canredeemgiftcardtoaccount": "This gift card can not be redeemed to this account, because it already has an account attached to it.",
		"entity.app.integration": "integration",
		"entity.paymenttransaction.accountpaymentmethod": "Account Payment Method",
		"entity.productattributeset": "Product Attribute Set",
		"setting.integrationavataxtaxexemptrequirescompanypaymentmethodflag": "Tax Exempt Requires Company Payment Method",
		"entity.accountpaymentmethod.giftcardnumber": "Gift Card Number",
		"entity.paymentterm.sortorder": "Sort Order",
		"entity.vendoremailaddress.emailaddress": "Email Address",
		"entity.paymentmethod.paymentmethodid": "Payment Method ID",
		"entity.vendorskustock.quantity": "Qty.",
		"setting.emailsmtpusetls": "SMTP Use TLS",
		"entity.define.estimatedfulfillmentdatetime": "Estimated Order Fulfillment Date Time",
		"entity.audit.nosummary": "No summary available",
		"processobject.product_create.listprice": "List Price",
		"entity.orderfulfillmentshipping.discountamount": "Shipping Discount",
		"entity.loyaltyaccruement.accountloyaltytransactions": "Account Loyalty Transactions",
		"admin.entity.contenttabs.content": "Content",
		"entity.permission.permissiongroup": "Permission Group",
		"entity.accountemailaddress.verificationcode": "Verification Code",
		"setting.siteforgotpasswordemailtemplate": "Forgot Password Email Template",
		"entity.optiongroup.delete_validatehasoptions": "This option group cannot be deleted because it contains options.",
		"entity.loyaltyredemption.redemptionpointtype.loyaltytermbalance": "Loyalty Term Balance",
		"entity.pricegroup.pricegrouprates": "Price Group Rates",
		"setting.integrationorbitalusername_hint": "Orbital Gateway Username",
		"entity.stockreceiver.vendororder": "Vendor Order",
		"entity.eventtrigger.eventtriggername": "Event Trigger Name",
		"entity.account.process.redeemgiftcard": "Redeem Gift Card To Account",
		"entity.measurementunit_plural": "Measurement Units",
		"define.add": "Add",
		"entity.pricegroup.enabledonaccount": "Enabled",
		"setting.integrationpayflowproaccountpaymentcommenttwotemplate": "Account Payment Comment Two Template",
		"define.qats": "QATS",
		"entity.paymentmethod.paymentmethodtype.cash": "Cash",
		"entity.attribute.attributecode_validateunique": "The attribute code {attributeCode} is already in use by another attribute.",
		"validate.processphysical_addphysicalcount.validinfo": "The file you uploaded had ${valid} row(s) that imported sucessfully.",
		"admin.entity.physicaltabs.discrepancies.discrepancy": "Discrepancy",
		"setting.skuemailfulfillmenttemplate": "Sku Email Fulfillment Template",
		"entity.physical.physicalid": "Physical ID",
		"entity.productimage.imagetype": "Image Type",
		"setting.productimagemediumwidth": "Medium Image Width",
		"event.onsessionaccountlogin": "On Account Login",
		"api": "Api",
		"entity.accountpayment.accountpaymentid": "accountPaymentID",
		"entity.skuprice.minquantity": "Min Quantity",
		"entity.vendorskustock.vendorskustockid": "vendorSkuStockID",
		"admin.entity.processsubscriptionusage.cancel_success": "Subscription Canceled",
		"define.checkbox": "Checkbox",
		"setting.integrationauthorizenettestgatewayurl": "Test API Gateway URL",
		"entity.schedule.frequencyendtime.runonce": "Run Once",
		"entity.orderpayment.bankroutingnumberencrypted": "Bank Routing number  Encrypted",
		"entity.promotionqualifier.promotionqualifierid": "Promotion Qualifier ID",
		"entity.stock.qexp": "qexp",
		"entity.orderdelivery.paymenttransaction": "Payment Transaction",
		"entity.promotionqualifier.rewardmatchingtype_hint": "This allows you to specify how the item rewards are matched with this qualifier.  Such as 'only apply rewards to items that match the same x as this qualifier'",
		"entity.locationaddress.locationaddressname": "Nickname",
		"entity.promotionrewardcurrency": "Promotion Reward Currency",
		"entity.attributeset.attributesetdescription": "Attribute Set Description",
		"entity.subscriptionusage.expirationdate": "Expiration Date",
		"entity.loyaltyredemption.amount": "Amount",
		"entity.setting.global": "Global Setting",
		"permission.vendor.editvendororder": "Vendor Order - Edit",
		"entity.product.lastupdateddatetime": "Date Last Updated",
		"admin.main.encryption.batchsizelimit_placeholder": "All encrypted records",
		"entity.orderitemgiftrecipient.quantity": "Quantity",
		"entity.integration": "Integration",
		"admin.entity.shippingmethodratetabs.shippingmethodratepricegroups": "Price Groups",
		"entity.account.calculatedfullname": "Full Name",
		"entity.profile.profileid": "profileID",
		"entity.account.testaccountflag": "Test Account",
		"validate.addoption.product.unusedproductoptions.hasunusedproductoptioncombinations": "Product Option combinations already exist for this option",
		"processobject.sku_create.skucode": "SKU Code",
		"setting.accountadminforcepasswordresetafterdays_hint": "This should be the amount of days that you want your admins to be able to use their new password. Once they go over this amount they will be forced to reset their password upon their next log in. Max value of 90.",
		"validate.create.product_create.renewalprice.minvalue": "The Renewal Price must be greater than zero.",
		"admin.main.default_title": "Dashboard",
		"admin.entity.promotionqualifiertabs.options": "Options",
		"defaultmessage_time": "{1} must be a valid time, between 00:00 and 23:59.",
		"admin.processbouncedemails_success": "Successfully Processed Bounced Emails: A report email has been sent to your default \"Email To:\" address.",
		"admin.define.createskubundle": "Add Bundled Sku",
		"entity.stockreceiver.receivertype": "Receiver Type",
		"entity.subscriptionbenefit.subscriptionbenefitname": "Subscription Benefit Name",
		"admin.entity.orderitemtabs.stockreceiveritems": "Stock Receiver Items",
		"admin.define.save_error": "There was an error trying to save the ${itemEntityName}.",
		"entity.accountpaymentmethod.creditcardtype": "Card Type",
		"entity.accountloyaltytransaction.accruementtype": "Accruement Type",
		"entity.task.taskschedules": "Task Schedules",
		"admin.entity.tasktabs.tasksettings": "Task Settings",
		"entity.paymentmethod.paymentmethodtype.external": "External",
		"entity.shippingmethodoptionsplitshipment.shipmethodoptsplitshipmentid": "Shipping Method Option Split Shipment ID",
		"define.show": "Show",
		"define.duration": "Duration",
		"entity.accountcollection.collectionconfig": "Collection Config",
		"entity.setting.producttype": "Product Type",
		"permission.setting.listtaskhistory": "Task History - List",
		"admin.entity.createtaxcategoryrate_nav": "Manual Rate",
		"entity.attribute.attributeid": "attributeID",
		"entity.paymenttransaction.avscode": "AVS Code",
		"entity.brand.branddisplaytemplate": "Display Template",
		"entity.report.dynamicdaterangeendtype.lastyearend": "Previous Year End",
		"admin.entity.integrationtabs.settings": "Integration Settings",
		"entity.promotionrewardcurrency.promotionrewardcurrencyid": "Promotion Reward Currency ID",
		"entity.orderitem.extendedprice": "Extended Price",
		"entity.roundingrule.roundingrulename": "Rounding Rule Name",
		"entity.orderitem.sku": "Sku",
		"define.cart": "Order",
		"entity.orderfulfillment.shippingmethod": "Shipping Method",
		"entity.productreview.product": "Product",
		"entity.account.company": "Company",
		"entity.promotionperiod.process.duplicatepromotionperiod": "Duplicate Promotion Period",
		"define.termpayment": "Term Payment",
		"permission.setting.createschedule": "Schedule - Create",
		"entity.product.liveprice": "Price",
		"admin.entity.producttabs.images.alternateimages": "Alternate Images",
		"admin.pricing.createpromotionqualifiercontentaccess": "Create Promotion Qualifier Content Access",
		"entity.promotionaccount.promotion": "Promotion",
		"entity.skuprice.promotionreward": "Promotion Reward",
		"entity.order.process.updateorderfulfillment": "Update Order Fulfillment",
		"entity.sku.loyaltyredemptionexclusions": "Loyalty Redemption Exclusions",
		"processobject.subscriptionusage_renew.renewalpaymenttype.new": "New Payment",
		"entity.accountpaymentapplied": "Account Payment Applied",
		"validate.addeventschedule.product_addeventschedule.purchaseenddatetime.gtnow": "Purchase End Date must occur in the future.",
		"define.username": "Username",
		"entity.define.currentflag": "Is Current",
		"admin.entity.skutabs.eventconflicts": "Event Conflicts",
		"define.existingpassword": "Old Password",
		"entity.order.referencingorders": "Referencing Orders",
		"entity.fulfillmentmethod": "Fulfillment Method",
		"entity.stockadjustment.stockadjustmentid": "Stock Adjustment ID",
		"entity.attributeset.attributesetcode_hint": "A unique string (alphanumerc, no spaces) to identify the attribute set.",
		"validate.delete.sku.stocksdeletableflag": "This sku cannot be deleted because it has stocks assigned to it.",
		"entity.address.country": "Country",
		"admin.entity.orderitemgiftrecipient.emailaddress": "Email Address",
		"admin.entity.skutabs.inventory": "Inventory",
		"entity.define.quantityout": "Quantity Out",
		"entity.sku.subscriptionbenefits": "Subscription Benefits",
		"entity.sku.product": "Product",
		"admin.entity.skutabs.pricegroups": "Price Groups",
		"entity.image.imagename": "Image Name",
		"entity.report.dynamicdaterangetype.months": "Month(s)",
		"admin.entity.createmanualoutadjustment": "Manual Out Adjustment",
		"setting.globalpagecreateaccount": "Create Account Page",
		"entity.emailbounce_plural": "Email Bounces",
		"setting.emailbccaddress": "Email BCC Address",
		"entity.orderdelivery.shippingmethod": "Shipping Method",
		"entity.email.emailsubject": "Email Subject",
		"define.manualout": "Manual Out",
		"entity.product.title": "Product Title",
		"admin.entity.producttabs.relatedproducts": "Related Products",
		"admin.entity.processorder.updatestatus_success": "Status Updated",
		"entity.pricegrouprate.delete_success": "Price Group Rate Deleted",
		"admin.entity.ordertabs.orderpayments.charges": "Charges",
		"validate.resetpassword.account_resetpassword.password.minlength": "Please select a password that is 8 characters or greater.",
		"entity.shippingmethod.orderfulfillments": "Order Fulfillments",
		"admin.entity.listcartandquote_permission": "Carts & Quote - View List",
		"entity.promotionreward.producttypes": "Product Types",
		"entity.workflowtriggerhistory_plural": "Trigger Histories",
		"validate.save.collection.collectionid.cansavecollectionbycollectionobject": "You do not have read access to Collection Type",
		"define.contents": "Content",
		"setting.integrationupsshipfromcompany": "ShippingCompany",
		"entity.orderitemgiftrecipient.account": "Account",
		"entity.entityqueue.entityqueuedatetime": "Entity Queue Date Time",
		"define.both": "Both",
		"entity.contentaccess.accountcontentaccess": "Account Content Access",
		"processobject.product_create.renewalprice": "Renewal Price",
		"admin.entity.processorder.removepromotioncode_confirm": "Are you sure you want to remove this Promotion code from the order?",
		"entity.orderfulfillment.subtotalafterdiscounts": "Fulfillment Items Subtotal",
		"entity.paymenttransaction.transactionendtickcount": "Transaction End Tick Count",
		"setting.integrationvertexcompany": "Company",
		"setting.integrationvertextestingflag": "Test Mode ",
		"setting.integrationfullcirclecompanycode": "Full Circle Company Code",
		"validate.delete.orderdelivery.orderdeliveryid.maxlength": "You cannot delete and order delivery.",
		"setting.integrationgigyaenabledproviders": "Enabled Providers",
		"entity.access.accessid": "Access ID",
		"enity.orderfulfillment.orderfulfillmenttype.attend": "Order Fulfillment Type",
		"admin.entity.producttabs.vendors": "Vendors",
		"entity.promotionapplied.promotion": "Promotion",
		"admin.define.process_nav": "Process ${itemEntityName}",
		"define.all": "All",
		"entity.location.sellstockonweb": "Sell Stock On Web",
		"entity.addresszone.promotionqualifiers": "Promotion Qualifiers",
		"define.external": "External",
		"validate.save.shippingmethod.shippingmethodcode.uniqueornull": "Shipping Method Code Must Be Unique",
		"define.qomin.full": "Min Per Order",
		"entity.skuprice.currencycode": "Currency Code",
		"entity.subscriptionusage.process.addusagebenefit": "Add Subscription Benefit",
		"entity.orderpayment.checknumber": "Check Number",
		"setting.integrationparcel2goshipperpostalcode": "Shipping From Postal Code ",
		"entity.stockadjustmentdelivery_plural": "Stock Adjustment Deliveries",
		"setting.contentmetadescriptionstring": "Content Meta Description String",
		"setting.integrationavataxtaxexemptnumberpropertyidentifier_hint": "This is the property at the Account level where the user's Tax Exemption number is stored. Sending any value in this field will flag the transaction as exempt. ",
		"setting.globalforcecreditcardoverssl": "Force Credit Card Over SSL",
		"entity.promotionperiod.promotionqualifiers": "Promotion Qualifiers",
		"entity.fulfillmentbatchitem": "Fulfillment Batch Item",
		"defaultmessage_required": "{1} is required.",
		"entity.accountpayment_plural": "Account Payments",
		"define.quantity": "Quantity",
		"entity.skuprice.renewalprice": "Renewal Price",
		"setting.skugiftcardemailfulfillmenttemplate": "Gift Card Email Fulfillment Template",
		"entity.state.statecode": "State Code",
		"processobject.product_create.redemptionamounttype": "Redemption Amount Type",
		"define.percentageoff": "Percentage Off",
		"entity.brand.delete_validateisassigned": "Brand cannot be deleted because it has been assigned to products",
		"entity.taxcategoryrate.taxcategoryratecode": "Tax Category Rate Code",
		"validate.account.authorizeaccount.invalidpassword": "The password that was provided was invalid.",
		"report.productperformancereport.revenue": "Revenue",
		"entity.inventory.stockadjustmentdeliveryitem": "Stock Adjustment Delivery Item",
		"setting.integrationusaepaytestingflag": "Test Mode ",
		"entity.orderitem.appliedpricegroup": "Applied Price Group",
		"admin.main.update.unexpected_error": "An unexpected error was encountered trying to update Slatwall.  Please try again, and if the problem persists you can check the Slatwall Log for more details about the error.",
		"setting.integrationorbitalusername": "User Name",
		"admin.entity.shippingmethodratetabs.shippingmethodratesettings": "Shipping Rate Settings",
		"entity.subscriptionstatus": "Subscription Status",
		"entity.orderitem.parentorderitem": "Parent Order Item",
		"admin.entity.producttabs.productsettings": "Product Settings",
		"entity.subscriptionbenefit.accesstype": "Access Code Generation Type",
		"entity.content.cmssiteid": "CMS Site ID",
		"entity.promotion.delete_validateisdeletable": "This promotion cannot be deleted because it is in use.",
		"define.range": "Range",
		"entity.attribute.displayonorderdetailflag": "Display On Order Detail Page",
		"entity.vendororder.process.receivestock": "Receive Stock",
		"validate.addsubscriptionsku.product_addsubscriptionsku.renewalprice.required": "You must define either a Renewal Sku or a Renewal Benefit and Price.",
		"entity.orderitem.towaitlist": "There are not enough seats available. Entering account information here will cause this registrant to be placed on a waitlist.",
		"entity.promotionqualifier_plural": "Promotion Qualifiers",
		"entity.subscriptionstatus.subscriptionstatusid": "Subscription Status ID",
		"permission.setting.createcountry": "Country - Create",
		"permission.setting.detaillocation": "Location - Detail",
		"validate.save.sku.eventconflictexistsflag": "There is a conflict with an existing event. Please choose a different location or time.",
		"entity.skucurrency_plural": "Sku Currencies",
		"entity.promotionreward.promotionrewardid": "Promotion Reward ID",
		"entity.entityqueue.baseobject": "Base Object",
		"entity.order_plural": "Orders",
		"entity.subscriptionterm.initialterm_hint": "This defines the duration of the first term for a given subscription.",
		"define.and": "and",
		"define.tuesday": "Tuesday",
		"processobject.accountloyalty_manualtransaction.manualadjustmenttype": "Manual Adjustment Type",
		"entity.subscriptionterm.autorenewflag": "Auto Renew",
		"define.any": "Any",
		"define.subscription": "Subscription",
		"admin.processbouncedemails_failure": "There was a problem processing your email, please check your server settings.",
		"entity.shippingmethodrate.minimumshipmentitemprice": "Min Fulfillment Subtotal",
		"define.renewalsubscriptionbenefits": "Renewal Subscription Benefits Name",
		"define.stockloss": "Stock Loss",
		"define.qnc.full": "Not Committed",
		"entity.eventtrigger": "Event Trigger",
		"setting.productimagelargeheight": "Large Image Height",
		"setting.integrationupsshippernumber": "Shipper Number (UPS Account Number)",
		"permission.basecontroller": "Base Controller",
		"validate.edit.orderfulfillment.orderstatuscode.inlist": "The order fulfillment cannot be edited as the order has been placed.",
		"entity.subscriptionusagebenefitaccount.enddatetime": "End Date Time",
		"define.active": "Active",
		"entity.report.dynamicdaterangeinterval": "Date Range Length",
		"entity.accountrelationshiprole.accountrelationshiproleid": "Account Relationship Role ID",
		"permission.setting.listschedule": "Schedule - List",
		"entity.commentrelationship.referencedexpressionstart": "Referenced Expression Start",
		"setting.integrationclickandbuycurrency": "Currency (ISO 4217)",
		"permission.print": "Print",
		"validate.define.regex": "The value entered for ${propertyName} should be alphanumeric with no spaces.",
		"define.inherited": "Inherited",
		"entity.entityqueuehistory.baseobject": "Base Object",
		"entity.attribute.attributename": "Attribute Name",
		"entity.location.sellstockonwebwholesale": "Sell Stock On Web Wholesale",
		"entity.content": "Content",
		"entity.orderitem.accountloyaltytransactions": "Account Loyalty Transactions",
		"entity.audit.auditarchivecreateddatetime": "Created Date",
		"entity.subscriptionusage.account": "Account",
		"permission.setting.listpaymentmethod": "Payment Method - List",
		"entity.image.imagedescription": "Image Description",
		"entity.accountcollection.account": "Account",
		"admin.entity.createmerchandiseproducttype_nav": "New Merchandise Product Type",
		"admin.entity.attributetabs.attributeoptions": "Attribute Options",
		"entity.country.citylabel": "City Label",
		"setting.globalurlkeybrand": "Brand URL Key",
		"entity.workflowtriggerhistory.endtime": "End Time",
		"entity.pricegroup.childpricegroups": "Child Price Groups",
		"permission.integration.detailintegration": "Integration - Detail",
		"setting.integrationusaepaykey": "Source Key ",
		"entity.subscriptionusage.subscriptionusagebenefits": "Subscription Usage Benefits",
		"entity.sku.webqoh": "webQOH",
		"entity.attribute_plural": "Attributes",
		"admin.entity.preprocessphysical_addphysicalcount_title": "Add Physical Count Items",
		"entity.orderdeliveryitem.orderdeliveryitemid": "Order Delivery Item ID",
		"entity.report.dynamicdaterangetype.weeks": "Week(s)",
		"define.admin.orderdetail.title": "Title",
		"entity.optiongroup.imagegroupflag": "Product Image Group",
		"entity.define.changedbyaccount": "Changed By",
		"entity.task.process.runtask": "Run Task Now",
		"validate.save.skuprice.minquantity.hasvalidquantityconfiguration": "The sku price cannot be saved because the quantity range is invalid.",
		"entity.productimage": "Product Image",
		"admin.entity.loyaltyaccruementtabs.brands": "Brands",
		"entity.content.productsortdefaultdirection": "Product Sort Default Direction",
		"entity.accountcontentaccess.account": "Account",
		"entity.attributeset.globalflag_hint": "Setting this to yes will make this attribute set automatically available based on the attribute set type selected. Otherwise you will need to explicitly assign the attribute set to where you want to use it.",
		"mura_permission": "Mura",
		"entity.task.nextrundatetime": "Next Run",
		"setting.contenttemplatefile": "Content Template File",
		"entity.report.reportid": "Report ID",
		"entity.loyaltyaccruement.excludedproducttypes": "Excluded Product Types",
		"permission.setting.edittaxcategory": "Tax Category - Edit",
		"entity.site.allowadminaccessflag": "Allow Admin Access",
		"admin.entity.skutabs.registrants": "Registrants",
		"entity.vendorskustock": "Vendor Sku Stock",
		"entity.orderitem.appliedpromotions": "Applied Promotions",
		"api.main.post": "API POST Method",
		"setting.integrationfullcirclelocaltransferdirctory_hint": "This is the full directory path on this web server to where you would like transfer files to go. Example: C:\\Inetpub\\wwwroot\\fctransfer",
		"entity.accountemailaddress": "Account Email Address",
		"entity.skucurrency.listprice": "List Price",
		"entity.attributeset.products": "Products",
		"admin.entity.vendorordertabs.products": "Products",
		"setting.integrationmerchantesolutionstestprofileid": "Test Profile ID",
		"entity.subscriptionusagebenefit.subscriptionusage": "Subscription Usage",
		"entity.product.calculatedallowbackorderflag": "Calculated Allow Backorder Flag",
		"entity.accountcollection.collectiondisplaycode": "Collection Display Code",
		"entity.define.creditcardnumber": "Credit Card Number",
		"entity.shippingmethodoption.orderfulfillment": "Order Fulfillment",
		"entity.promotion.promotionid": "Promotion ID",
		"setting.globalremoteideditflag": "Edit RemoteID Fields in Administration",
		"permission.main.ckfinder": "File Manager",
		"entity.product.template": "Design Template",
		"validate.define.gtdatetimeproperty": "${propertyName} must occur after ${constraintValue}.",
		"admin.entity.processeventregistration.approve_success": "Registration has been changed to Approved.",
		"entity.eventregistration.process.approve": "Change to Approved",
		"entity.accountrelationship.approvalflag": "Approved",
		"admin.main.encryption.reencryptdata_confirm": "Re-encrypting the database could take some time depending on the batch size limit.",
		"setting.emailsmtpusername": "SMTP Username",
		"admin.entity.preprocessaccount": "Add Account",
		"setting.globalmimetypewhitelist": "Allowed MIME Types",
		"permission.setting.detailsetting": "Setting - Detail",
		"entity.accountcontentaccess.accountcontentaccessid": "Account Content Access ID",
		"define.dayoftheweek": "Day of the Week",
		"validate.save.skucurrency.price.minvalue": "The sku currency price cannot be a negative value.",
		"entity.pricegroup.pricegroupcode": "Price Group Code",
		"admin.entity.detailaudit": "Audit",
		"entity.accountpaymentmethod.billingaccountaddress": "Billing Account Address",
		"entity.accountpaymentmethod.providertoken": "Provider Token",
		"define.name": "Name",
		"admin.entity.preprocessorder_addorderitem.returndetails": "Return Details",
		"define.language.en_gb": "English (UK)",
		"entity.subscriptionterm.allowprorateflag": "Allow Prorate",
		"entity.promotionqualifier.minimumordersubtotal": "Minimum Order Subtotal",
		"permission.setting.editcategory": "Category - Edit",
		"entity.accountpaymentmethod.expirationmonth": "Expiration Month",
		"entity.attribute.attributetype.relatedobjectselect": "Related Object Select",
		"admin.main.encryption.updatepassword_success": "The database encryption password was successfully updated.",
		"entity.orderfulfillment.shippingaddress": "Shipping Address",
		"entity.taxcategory.taxcategoryrates": "Tax Category Rates",
		"entity.define.createddatetime": "Created Date Time",
		"permission.pricing.savepromotion": "Promotion - Save",
		"entity.account.process.setupinitialadmin": "Setup Initial Admin",
		"entity.access.accesscode": "Access Code",
		"setting.contentrequiresubscriptionflag": "Require Subscription for Access",
		"processobject.task_updatecalculatedproperties.updateorderflag": "Update Orders",
		"entity.schedule.frequencystarttime_hint": "Defines the time of day that you would like the schedule to start.  If no end time is defined, then this is just the 1 time during the day where the schedule will run.",
		"entity.productbundlegroupitem": "Product Bundle Group Item",
		"setting.globalencryptionencoding": "Encryption Encoding",
		"setting.integrationvirtualmerchanttestpin": "Test Virtual Merchant PIN",
		"admin.entity.editskucurrency": "Edit Price for ${currencyCode} Currency",
		"admin.define.norecordsfound": "No Records Found.",
		"setting.productshowdetailwhennotpublishedflag": "Display Product Detail When Not Published"
	};

/***/ },
/* 107 */
/***/ function(module, exports) {

	module.exports = {
		"admin.entity.promotionreward.discounttype.percentageoff": "Percentage Off",
		"entity.orderitemgiftrecipient_plural": "Gift Recipients",
		"entity.vendororder.billtolocation": "Bill To Location",
		"validate.create.product_create.purchaseenddatetime.gtnow": "Purchase End Date must occur in the future",
		"define.emailaddressconfirm": "Confirm Email Address",
		"entity.setting.settingid": "settingID",
		"entity.taxcategoryrate.taxcategoryrateid": "Tax Category Rate ID",
		"define.onthe": "on the",
		"entity.permission.allowactionflag": "Allow Action Flag",
		"entity.alternateskucode.alternateskucode": "Sku Code",
		"entity.setting.settingvalue": "Setting Value",
		"admin.report.default.builtinreports": "Built In Reports",
		"entity.report.dynamicdaterangetype.quarters": "Quarter(s)",
		"entity.roundingrule": "Rounding Rule",
		"entity.physicalcount.physicalcountid": "Physical Count ID",
		"entity.orderdelivery.trackingnumber": "Tracking Number",
		"entity.attributevalue.orderfulfillment": "Order Fulfillment",
		"entity.setting.subscriptionterm": "Subscription Term",
		"validate.createreturn.order_createreturn.orderitems.haspositiveorderitemquantity": "You must define at least one order item to return with a quantity greater than 0.",
		"entity.orderitem_plural": "Order Items",
		"entity.report.dynamicdaterangetype.monthtodate": "Month to Date",
		"entity.orderitem.orderitemtype": "Order Item Type",
		"entity.vendor.accountnumber": "Account Number",
		"admin.entity.createreport_nav": "Save As New Report",
		"define.ofthemonth": "of the month",
		"entity.accountloyaltyredemption.redemptiontype.cashcouponcreation": "Cash Coupon Creation",
		"entity.vendoraddress.address": "address",
		"entity.account": "Account",
		"setting.shippingmethodrateminimumamount": "Minimum Rate Amount",
		"define.transactiontype": "Transaction Type",
		"admin.entity.order.addorderpayment_error": "There was an error adding the Order Payment",
		"admin.entity.imagetabs.image": "Image",
		"setting.globallogmessages": "Slatwall Application Logging",
		"entity.vendorskustock.lastupdateddatetime": "lastUpdatedDateTime",
		"entity.attribute.attributecode": "Attribute Code",
		"entity.shippingmethodrate.shippingmethodrateid": "Shipping Method Rate ID",
		"setting.integrationmuralegacyshoppingcart_hint": "If you have upgraded from a previous version of Slatwall that used the filename hooks, and the 'frontend' subsystem, then the filename of that page should be in this field",
		"entity.audit.audittype.rollback": "Rollback",
		"admin.entity.detailorder.payments": "Payments",
		"entity.productschedule.reservationendtime": "Reservation end time",
		"entity.promotionqualifier.excludedbrands": "Excluded Brands",
		"entity.paymentmethod.sortorder": "Sort Order",
		"entity.attribute.attributeinputtype.attextbox": "Text Box",
		"entity.account.process.forgotpassword": "Forgot Password",
		"entity.option.defaultimage": "Default Image",
		"setting.skuallowwaitlistingflag_hint": "Indicate whether waitlisting is allowed on this event",
		"entity.promotionqualifier.options": "Options",
		"setting.siteorderorigin": "Order Origin",
		"entity.taxcategory": "Tax Category",
		"entity.type.childtypes": "Child Types",
		"entity.sku.price": "Price",
		"entity.option.optiongroup.optiongroupname": "Option Group Name",
		"entity.sku.qia": "QIA",
		"entity.physical.brands": "Physical Brands",
		"admin.entity.processsite.create_error": "There was a problem saving site",
		"validate.edit.physical.physicalstatustypesystemcode.inlist": "The physical cannot be edited as the physical count has been commited.",
		"admin.account.processsubscriptionusage.renewsubscription_nav": "Renew Subscription",
		"processobject.account_setupinitialadmin.adminaccessflag": "Admin Access",
		"entity.eventregistration.eventregistrationid": "Event Registration ID",
		"entity.accountloyaltyredemption.redemptiontype.pricegroupassignment": "Price Group Assignment",
		"setting.skubundleinventory": "Bundle Inventory",
		"entity.vendoraccount.account": "Account",
		"entity.orderfulfillment.fulfillmentcharge": "Fulfillment Charge",
		"entity.stock": "Stock",
		"entity.promotionperiod.promotionrewards": "Promotion Rewards",
		"entity.product.process.updateskus": "Update Skus",
		"entity.define.expirationmonth": "Expiration Month",
		"entity.promotionreward.maximumuseperorder_hint": "This defines the maximum number of times that this reward can be applied to an order.",
		"permission.product.detailproductreview": "Product Review - Detail",
		"entity.sku.promotionrewards": "Promotion Rewards",
		"define.text": "Text",
		"define.december": "December",
		"define.giftcard": "Gift Card",
		"entity.paymenttransaction.authorizationcode": "Auth. Code",
		"admin.entity.processproduct.create_success": "The product has been successfully created.",
		"permission.account.saveaccount": "Account - Save",
		"setting.integrationpayleapusername": "User Name",
		"setting.globaldisplayintegrationprocessingerrors": "Display Integration Processing Errors",
		"entity.vendorphone.vendorphonetype": "vendorPhoneType",
		"entity.paymentmethod.process.processgiftcardpayment": "Process Gift Card Payment",
		"admin.entity.shippingmethodtabs.shippingmethodsettings": "Shipping Method Settings",
		"setting.integrationendiciasyncftpsiteport": "FTP Sync Port",
		"entity.shippingmethodrate.minimumshipmentquantity": "Min Fulfillment Quantity",
		"admin.entity.subscriptionusagetabs.usagebenifits": "Subscription Usage Benefits",
		"entity.accountpaymentmethod.giftcardnumberencrypted": "Gift Card Number",
		"entity.account.process.lock": "Lock",
		"validate.account.accessid": "The access ID you provided is invalid.",
		"entity.permission.item": "Item",
		"admin.entity.processsubscriptionusage.renew_success": "The subscription has been renewed successfully.",
		"admin.entity.createpromotionqualifiermerchandise": "Merchandise Item Qualifier",
		"entity.promotionqualifier.products": "Products",
		"define.print": "Print",
		"entity.category.childcategories": "Child Categories",
		"entity.sku.shippingweight": "Shipping Weight",
		"permission.setting.detailtask": "Task - Detail",
		"entity.vendororder.vendororderid": "Vendor Order ID",
		"validate.changeeventdates.sku_changeeventdates.eventendtime.gtdatetimeproperty": "",
		"entity.pricegrouprate.displayname": "Name",
		"entity.sku.qea": "QEA",
		"entity.integration.dataactiveflag": "Data Integration Active",
		"entity.product.activeflag_hint": "Item is available for utilization in the back-end",
		"processobject.subscriptionusage_renew.renewalpaymenttype.none": "No Payment, Just Create Invoice",
		"entity.taxapplied.taxcountrycode": "Tax Country Code",
		"define.dimensions": "Dimensions",
		"entity.giftcard.owneremailaddress": "Email Address",
		"entity.orderdeliveryitem.stock": "Stock",
		"entity.subscriptionusage.initialproduct": "Initial Product",
		"permission.order.listorderfullfillment": "Order Fulfillment - List",
		"entity.attribute.validationregex": "Validation Regex",
		"admin.entity.attributesettabs.description": "Attribute Set Description",
		"admin.entity.updateproductcache_success": "Product Cache Update Started",
		"setting.integrationfullcirclecompanycode_hint": "Full Circle Company Code",
		"processobject.subscriptionusage_renew.prorateexpirationdate": "New Expiration Date",
		"permission.setting.deletemeasurementunit": "Measurement Unit - Delete",
		"entity.promotionqualifier": "Promotion Qualifier",
		"entity.account.termaccountavailablecredit": "Term Account Available Credit",
		"validate.save.promotionrewardcurrency.currencycode.neqproperty.promotionreward.currencycode": "This default promotion reward currency cannot be edited, if you would like to change the amount in this currency then just update the value on the promotion reward itself.",
		"entity.taxcategoryrate.taxaddresslookup.shipping": "Shipping Only",
		"entity.sku.promotionrewardexclusions": "Promotion Reward Exclusions",
		"entity.permissiongroup.permissiongroupid": "Permission Group ID",
		"entity.sku.webwholesaleqexp": "webWholesaleQEXP",
		"entity.country.countryisonumber": "Country ISO Number",
		"permission.setting.savesetting": "Setting - Save",
		"entity.paymentmethod.paymentmethodtype.giftcard": "Gift Card",
		"entity.stockadjustment_plural": "Stock Adjustments",
		"define.quantityshipped": "Shipped",
		"validate.define.pricemustbenumeric": "Price Must Be Numeric",
		"entity.addresszone": "Address Zone",
		"define.benefits": "Benefits",
		"entity.pricegroup.accounts": "Accounts",
		"define.notconfirmed": "The value that was entered does not match the 'confirm' value.",
		"setting.integrationorbitalpassword": "Password",
		"validate.account.accountauthenticationexists": "There is already an admin account authorized.",
		"entity.orderreturn.process.receivereturn": "Receive Order Return",
		"entity.option": "Option",
		"entity.updatescript.loadorder": "Load Order",
		"entity.subscriptionterm.subscriptionbenefits": "Subscription Benefits",
		"entity.paymentmethod.process.processexternalpayment": "Process External Payment",
		"setting.globalpageorderstatus": "Order Status Page",
		"entity.subscriptionbenefit.excludedcategories": "Excluded Categories",
		"admin.entity.processproduct.updateskus_success": "Skus Updated Successfully",
		"validate.edit.giftcard.giftcardcode.caneditordelete": "You cannot edit a gift card once it has been issued.",
		"entity.email.emailfailto": "Email Fail To",
		"entity.loyaltyterm.loyaltytermid": "Loyalty Term ID",
		"permission.schedule": "Schedule",
		"entity.attributeoption.sortorder": "Sort Order",
		"admin.entity.processaudit.rollback_error": "There was an error during the rollback",
		"admin.entity.processeventregistration.attend_success": "Registration has been changed to Attended.",
		"entity.option.promotionqualifierexclusions": "Promotion Qualifier Exclusions",
		"frontend.checkout.detail": "Checkout",
		"entity.entityqueue.entityqueueid": "Entity Queue ID",
		"entity.collection.collectioncode": "Collection Code",
		"entity.integration.process.test": "Test Integration",
		"admin.entity.createlocationtransferadjustment": "Location Transfer Adjustment",
		"entity.collection.collectionobject": "Collection Type",
		"entity.order.process.placeorder.fulfillmentrequirementerror": "The order could not be placed because it was missing valid fulfillment infomation",
		"define.recurring": "Recurring",
		"entity.country.streetaddresslabel": "Street Address Label",
		"admin.main.update": "Slatwall Update Utility",
		"entity.order.process.takeoffhold": "Take Order Off Hold",
		"entity.accountpayment.bankaccountnumberencrypted": "Bank Account Number Encrypted",
		"entity.orderpayment.referencedorderpayment": "Referenced Order Payment",
		"entity.accountloyaltytransaction.expirationdatetime": "Expiration Date Time",
		"entity.physicalcount.physicalcountitems": "Physical Count Items",
		"entity.form.process.addformquestion": "Add Form Question",
		"entity.term.renewalsubscriptionusageterms": "Renewal Subscription Usage Terms",
		"validate.addeventschedule.product_addeventschedule.eventenddatetime.gtnow": "Event end date must occur in the future.",
		"admin.entity.promotionqualifier.edit_disabled": "This promotion period cannot be edited because it has expired.",
		"entity.orderfulfillment.subtotal": "Subtotal",
		"processobject.sku_changeeventdates.eventstarttime": "New start time",
		"setting.integrationvirtualmerchanttestuserid": "Test Virtual Merchant User ID",
		"entity.product.calculatedsaleprice": "Calculated Sale Price",
		"entity.paymentmethod.paymentmethodtype.check": "Check",
		"validate.processorder_forceitemquantityupdate.forceditemquantityadjusted": "${sku.product.title} - ${sku.skuDefinition} on your order had the quantity updated from ${oldQuantity} to ${newQuantity} because of inventory constraints.",
		"entity.permission.allowprocessflag": "Allow Process Flag",
		"setting.integrationmuralegacycreateaccount_hint": "If you have upgraded from a previous version of Slatwall that used the filename hooks, and the 'frontend' subsystem, then the filename of that page should be in this field",
		"validate.save.account.primaryemailaddress.getprimaryemailaddressesnotinuseflag": "You cannot set that email address as the primary email address because it is the primary email address of another account.",
		"entity.sku.saleprice": "Sale Price",
		"entity.productimage.imagename": "Image Name",
		"entity.image.options": "Options",
		"entity.order.paymentamountdueaftergiftcards": "Payment Amount Due After Gift Card Charges",
		"validate.create.orderdelivery_create.giftcardcodes.hasallgiftcardcodes": "You don not have enough gift card numbers to fulfill these items.",
		"define.sec": "Sec.",
		"entity.attributeset_plural": "Attribute Sets",
		"entity.filerelationship.baseid": "Base ID",
		"entity.term.graceperiodsubscriptionusageterms": "Grace Period Subscription Usage Terms",
		"admin.main.sendpasswordreset": "Send Password Reset",
		"entity.promotion.delete_success": "Promotion Deleted",
		"setting.accountfailedadminloginattemptcount_hint": "This is the max number of login attempts than an admin user gets before their account is locked.",
		"define.failure": "Failure",
		"admin.entity.processorder.addpromotioncode_success": "Promotion Code Applied",
		"admin.entity.preprocesseventregistration_include.changestatuscomment": "Add comment (optional)",
		"define.bar": "Bar",
		"validate.addorderitem.order_addorderitem.quantity.lteproperty.sku.qats": "The quantity that you have added to your cart is greater than the amount available.",
		"entity.subscriptionusage.autopayflag": "Auto Pay",
		"admin.entity.accounttabs.subscriptionusage": "Subscription Usage",
		"entity.order.process.removeorderitem": "Remove Order Item",
		"entity.attributevalue.profile": "profile",
		"admin.entity.contenttabs.settings": "Settings",
		"entity.promotionqualifier.excludedoptions": "Excluded Options",
		"entity.orderreturn.orderreturnitems": "Order Return Items",
		"setting.integrationmuralegacymyaccount_hint": "If you have upgraded from a previous version of Slatwall that used the filename hooks, and the 'frontend' subsystem, then the filename of that page should be in this field",
		"entity.inventory.stockreceiveritem": "Stock Receiver Item",
		"entity.currencyrate.currencyrateid": "Currency Rate ID",
		"entity.vendorphonenumber.phonenumber": "Phone Number",
		"processobject.account_create.createauthenticationflag": "Create Account Password",
		"entity.loyaltyaccruement.expirationterm": "Expiration Term",
		"admin.entity.processsku.removelocation_success": "Location removed successfully.",
		"entity.account.remotecontactid": "Remote Contact ID",
		"entity.loyaltyaccruement.loyaltyaccruementid": "Loyalty Program Accruement ID",
		"define.count": "Count",
		"admin.define.or": "OR",
		"setting.globalpageorderconfirmation": "Order Confirmation Page",
		"entity.accountauthentication.account": "Account",
		"setting.integrationavataxtaxexemptpropertyidentifier": "Tax Exempt Property Identifier",
		"define.qmin": "QMIN",
		"entity.productbundlegroup.skupricepercentagedecrease": "Sku Price Percentage Decrease",
		"admin.entity.createpromotionrewardcurrency": "Add Promotion Reward Currency",
		"entity.address.middlename": "Middle Name",
		"define.salutationmiss": "Miss.",
		"entity.locationaddress.location": "Location",
		"entity.skucurrency.skucurrencyid": "Sku Currency ID",
		"setting.productdisplaytemplate_hint": "The content object that you would like to use as the template for displaying product on the front-end.  Typically this is a page in your CMS or Custom Application",
		"admin.orderdetail.orderitems.details": "Details",
		"entity.site.sitecode": "Site Code",
		"entity.location.locationaddresses": "Location Addresses",
		"entity.productrelationship.productrelationshipid": "Product Relationship ID",
		"entity.integration.shippingreadyflag": "Shipping Ready Flag",
		"define.radiogroup": "Radio Group",
		"entity.accountattributeset": "Account Attribute Set",
		"entity.loyaltyredemption.autoredemptiontype": "Auto Redemption Type",
		"entity.promotionqualifier.rewardmatchingtype.product": "Product",
		"entity.product.delete_success": "The Product was successfully deleted.",
		"entity.producttype.physicals": "Physicals",
		"entity.workflowtask.activeflag": "Active",
		"entity.roundingrule.roundingruleexpression_hint": "This sting allows you to define how you would like to round a value.  For example to round to the nearest .49 or .99 this would be your rounding ule expression: .49,.99",
		"entity.content.fulltitle": "Content Title",
		"entity.loyaltyredemption.activeflag": "Active Flag",
		"entity.promotionreward.excludedoptions": "Option Exclusions",
		"entity.promotionreward.rewardtype.product": "Product",
		"entity.subscriptionusage.mostrecentorderitem": "Most Recent Order Item",
		"entity.vendor.vendorphonenumbers": "Vendor Phone Numbers",
		"setting.skucurrency_hint": "Skus can be sold in multiple currencies, however this setting dictates the currency that is stored as the primary price.",
		"define.expired": "Expired",
		"processobject.order_createreturn.fulfillmentrefundamount": "Fulfillment Refund Amount",
		"entity.attribute.attributeinputtype.atradiogroup": "Radio Group",
		"entity.profiletemplate.profiletemplatename": "profileTemplateName",
		"entity.addresszone_plural": "Address Zones",
		"admin.entity.editorderitem_disabled": "Cannot edit an orderitem which is part of a processed order.",
		"entity.subscriptionorderitem.subscriptionorderitemtype": "Subscription Order Item Type",
		"entity.loyaltyaccruement.pointquantity": "Point Ratio",
		"entity.accountloyaltytransaction.orderfulfillment": "Order Fulfillment",
		"entity.type.parenttype": "parentType",
		"entity.commentrelationship.account": "Account",
		"define.expires": "Expires",
		"admin.entity.promotionrewardtabs.products": "Products",
		"entity.vendororderitem.quantityunreceived": "Qty. Unreceived",
		"entity.address.salutation": "Salutation",
		"entity.content_plural": "Content",
		"admin.entity.updatefrontendviews": "Update All Frontend Views",
		"processobject.order_addorderitem.saveshippingaccountaddressflag": "Save as Account Address",
		"entity.order.subtotal": "Subtotal",
		"entity.subscriptionusage.nextreminderemaildate": "Next Reminder Email",
		"processobject.sku_addeventregistration.newaccountflag": "New Account?",
		"entity.taskhistory.successflag": "Task Success",
		"entity.vendororderitem.stock": "Stock",
		"setting.emailtoaddress": "Email To Address",
		"entity.pricegrouprate.pricegrouprateid": "Price Group Rate ID",
		"setting.integrationavataxtaxexemptrequirescompanypaymentmethodflag_hint": "Even if the propertyIdentifier says that this order should be tax exempt this will further require that the company payment method is a corporate payment method",
		"entity.orderitem.extendedpriceafterdiscount": "Total",
		"admin.entity.listeventregistration": "Event Registrations",
		"entity.address.locality": "Locality",
		"setting.subscriptionusagerenewalreminderdays": "Renewal Reminder Day(s)",
		"admin.metaremoved_info": "The /meta directory has been removed!",
		"validate.save.accountemailaddress.emailaddress.getprimaryemailaddressnotinuseflag": "The email address that you have entered is already in use as the primary email address for another account.",
		"entity.define.creditcardtype": "Credit Card Type",
		"admin.entity.settingstabs.producttype": "Product Type Settings",
		"admin.main.update.currentreleasetype": "Current Release Type",
		"setting.skuorderminimumquantity_hint": "Minimum per SKU Qty. allowed on order",
		"entity.image.imagetype": "Image Type",
		"entity.product.delete_validateordered": "This product cannot be deleted because it has been ordered.",
		"entity.pricegroup.pricegroupid": "Price Group ID",
		"entity.orderdeliveryitem.referencingorderitems": "Referencing Order Items",
		"admin.entity_permission": "Additional Misc",
		"processobject.orderdelivery_create.useshippingintegrationfortrackingnumber": "Use Integration to get tracking number?",
		"entity.orderpayment.termpaymentaccount": "Term Payment Account",
		"entity.vendor.vendorwebsite_hint": "The vendor website must begin with http:// or https://",
		"defaultmessage_collectionsize_between": "{1} size is not between {2} and {3}.",
		"entity.workflowtask.workflowtaskid": "Workflow Task ID",
		"event.onapplicationrequestend": "On Application Request End",
		"entity.promotionreward.rewardtype": "Reward Type",
		"entity.promotionaccount.enddatetime": "End Date Time",
		"setting.integrationvertexwebservicestrustedid_hint": "Authentication ID used instead of Username / Password",
		"permission.product.deleteproduct": "Product - Delete",
		"admin.define.termpaymentdetails": "Term Payment Details",
		"validate.save.orderpayment.amount.lteproperty.maximumpaymentmethodpaymentamount": "The order payment amount exceeds the allowable percentage for this payment method",
		"entity.audit.changedetails.property": "Property",
		"entity.vendororder.process.addvendororderitem": "Add Item",
		"permission.pricing.savepricegroup": "Price Group - Save",
		"entity.vendororderitem.stockreceiveritems": "Stock Receiver Items",
		"entity.optiongroup.options": "Options",
		"define.unlimited": "Unlimited",
		"entity.order.account": "Customer Account",
		"entity.emailtemplate.emailtemplatename": "Template Name",
		"entity.loyaltyaccruement.excludedskus": "Excluded Skus",
		"entity.product.price_hint": "The everyday price at which this product will be sold on your site (do not appy sales/promotions here).",
		"entity.paymentmethod.placeordercredittransactiontype_hint": "This type of transaction will be run for all 'credit' order payments when the order is placed.",
		"setting.integrationauthorizenettestserverflag_hint": "This should be set to YES if your authorize.net account is a test account at http://sandbox.authorize.net",
		"entity.pricegrouprate.amounttype": "Rate Type",
		"entity.orderitem.order": "Order",
		"entity.updatescript.successfulexecutioncount": "Successful Execution Count",
		"mura.main.updateviews_permission": "Update Views",
		"processobject.subscriptionusage_renew.renewalpaymenttype.orderpayment": "Previous Subscription Payment",
		"entity.taskhistory_plural": "Task Histories",
		"setting.accountfailedpublicloginattemptcount": "Max Public Failed Login Attempts",
		"entity.stockadjustment.stockadjustmentstatustype": "Status",
		"frontend.cart.update": "Update Cart",
		"permission.report.order": "Orders",
		"entity.image_plural": "Images",
		"entity.define.publicremoteid": "Public Remote ID",
		"define.qnrovo.full": "Not Received On Vendor Order",
		"entity.attributevalue.image": "Image",
		"entity.accountloyalty.accountloyaltytransactions": "Account Loyalty Transactions",
		"permission.setting.createcontent": "Content - Create",
		"entity.sku.process.logattendance": "Log Attendance",
		"entity.subscriptionusage.subscriptionterm": "Subscription Term",
		"entity.vendororderitem.extendedcost": "Extended Cost",
		"setting.globaluseshippingintegrationfortrackingnumberoption": "Use Shipping Integration For Tracking Number Option",
		"entity.stockreceiver_plural": "Stock Receivers",
		"setting.globalpageshoppingcart": "Shopping Cart Page",
		"entity.stockhold": "Stock Hold",
		"entity.orderaccount": "Account",
		"entity.location.locationidpath": "Location ID Path",
		"admin.entity.settingstabs.account": "Account Settings",
		"admin.entity.processsku.breakupbundledskus_success": "Bundled sku breakup was successful.",
		"validate.define.url": "The ${propertyName} is not valid url, be sure to inclide http:// or https:// at the begining of the URL.",
		"entity.emailbounce.emailbounceid": "Email Bounce ID",
		"setting.skueligibleorderorigins": "Eligible Order Origins",
		"entity.product.gendertype": "genderType",
		"entity.eventregistration.process_exire": "Expire",
		"entity.order.fulfillmenttotal": "Delivery Charges",
		"entity.workflowtrigger_plural": "Triggers",
		"entity.vendor.primaryphonenumber": "Primary Phone Number",
		"permission.setting.listterm": "Term - List",
		"setting.contentrestrictedcontentdisplaytemplate_hint": "When a public user does not have access to this page, they will be redirected to the setting defined here.  You can add more pages to this list by creating content and setting the 'Template Type' to 'Barrier Page'",
		"entity.productreview.reviewername": "Reviewer Name",
		"entity.accountaddress.account": "account",
		"entity.vendor.vendorname": "Vendor Name",
		"setting.globalmissingimagepath": "Missing Image Path",
		"entity.producttype.systemcode": "System Code",
		"entity.promotionqualifier.maximumprice": "Maximum Item Price",
		"entity.productschedule.monthlyrepeatbytype": "Repeat Monthly On",
		"entity.account.process.generateapiaccesskey": "Generate API Access Key",
		"admin.frontendexample": "Frontend Example",
		"entity.accountrelationship.account": "account",
		"entity.vendorskustock_plural": "Vendor Sku Stocks",
		"admin.entity.deletereport_nav": "Delete Saved Report",
		"entity.sku.webqc": "webQC",
		"admin.entity.shippingmethodtabs.shippingmethodrates": "Shipping Rates",
		"entity.loyaltyaccruement.skus": "Skus",
		"entity.state.statename": "State Name",
		"admin.entity.listcartandquote": "Carts & Quotes",
		"permission.product.detailproducttype": "Product Type - Detail",
		"entity.workflowtaskaction.emailtemplate": "Email Template",
		"entity.paymentmethod.paymentmethodtype.termpayment": "Term Payment",
		"setting.integrationmuralegacyshoppingcart": "Legacy Shopping Cart Filename",
		"entity.taxapplied.taximpositionname": "Tax Imposition Name",
		"admin.define.delete_confirm": "Are you sure you would like to delete this ${itemEntityName}?",
		"setting.integrationavataxtaxexemptnumberpropertyidentifier": "Tax Exemption Number Property Identifier",
		"entity.pricegrouprate.skus": "Include SKUs",
		"processobject.product_addeventschedule.sellindividualskuflag": "Sell individual sku?",
		"permission.setting.saveorderorigin": "Order Origin - Save",
		"define.receiveoffline": "Receive Offline",
		"entity.order.process.updateorderamount": "Update Order Amounts",
		"define.process": "Process",
		"setting.emailfailtoaddress": "Bounced Email Reply Address",
		"entity.order.process.changecurrencycode": "Change Currency Code",
		"define.login": "Login",
		"entity.promotionreward.options": "Options",
		"admin.entity.producttypetabs.producttypedescription": "Product Type Description",
		"entity.pricegroup.parentpricegroup_hint": "Selecting a Parent Price group to inherit rates from allows you to setup a broad price group and then override / add only the rates that are different.",
		"entity.vendororderitem.cost": "Cost",
		"setting.globalallowedoutsideredirectsites": "Allowed Outside Redirect Sites",
		"entity.schedule.frequencyendtime": "End Time",
		"entity.taxapplied.orderitem": "Order Item",
		"permission.setting.savecategory": "Category - Save",
		"admin.entity.processorderfulfillment.manualfulfillmentcharge_success": "Fulfillment Charge Updated",
		"admin.entity.ordertabs.orderitems": "Order Items",
		"setting.integrationclickandbuyprojectdescription": "Project description",
		"admin.entity.detailpromotion": "Promotion Detail",
		"admin.main.dashboard.recentproductupdates": "Recently Updated Products",
		"entity.orderitem.orderreturn": "Order Return",
		"entity.currency.currencyrates": "Currency Rates",
		"entity.vendoremail.email": "Email",
		"entity.editpromotionrewardcurrency_disabled": "You cannot edit this currency.",
		"entity.giftcard.giftcardtransactions": "Transactions",
		"entity.audit.rollbackpoint": "Rollback Point",
		"entity.product.process.addskubundle": "Add Sku Bundle",
		"entity.taskschedule.schedule": "Schedule",
		"entity.stockhold.orderitem": "Order Item",
		"validate.account.forgotloginmessage": "Enter your email address, and we will send you a link to reset your password.",
		"entity.email.emailreplyto": "Email Reply To",
		"entity.orderdeliveryitem_plural": "Order Delivery Items",
		"entity.workflow.workflowobject": "Object",
		"entity.option.optioncode": "Option Code",
		"validate.promotioncode.invalidaccount": "The promotion code that you have entered is valid, but the account that you are currently using is not a valid account to use this promotion code.  If you are not logged in, then please log in and try again.",
		"entity.productbundlegroup.minimumquantity_hint": "This defines the minimum quantity of items that can be selected for this group on a per bundle build up basis.  Set this to 0 or leave blank if you would like this group to be optional, set this to 1 or greater if an item is required for this group",
		"entity.sku.imagefile": "Image File Name",
		"admin.entity.imagetabs.options": "Options",
		"admin.entity.createsubscriptionproducttype_nav": "New Subscription Product Type",
		"entity.locationconfiguration": "Location Configuration",
		"setting.taskfailureemailtemplate": "Task Failure Email Template",
		"admin.entity.emailtemplatetabs.emailsettings": "Email Settings",
		"define.notapplicable": "N/A",
		"define.receive": "Receive",
		"entity.accountloyaltytransaction.redemptiontype": "Redemption Type",
		"entity.image.promotion": "Promotion",
		"entity.taxapplied.taxstatecode": "Tax State Code",
		"entity.accountpaymentmethod.giftcardbalanceamount": "Gift Card Balance",
		"define.generatetoken": "Generate Token",
		"validation.define.numeric": "This must be a numeric value.",
		"setting.integrationfedexshippercountrycode": "Shipping From Country Code ",
		"entity.orderitem_plura": "Order Items",
		"entity.user.murauserid": "muraUserID",
		"permission.setting.savepaymentmethod": "Payment Method - Save",
		"define.toassign": "to assign",
		"setting.integrationfullcirclefcftpport_hint": "Port to connect to FTP over",
		"entity.sku.loyaltyaccruementexclusions": "Loyalty Accruement Exclusions",
		"entity.physicalcountitem_plural": "Physical Count Items",
		"admin.main.log_nav": "Slatwall Log",
		"entity.vendororder.vendor": "Vendor",
		"entity.productschedule.scheduleenddatewithouttime": "Schedule End",
		"entity.paymenttransaction_plural": "Payment Transactions",
		"entity.account.type": "Type",
		"admin.editfilteritem.definefilter": "Define Filter",
		"processobject.product_addsubscriptionterm.subscriptiontermid": "Subscription Term",
		"entity.collection.missingfilter": "No filter property has been selected",
		"entity.paymentmethod.placeorderchargetransactiontype_hint": "This type of transaction will be run for all 'charge' order payments when the order is placed.",
		"admin.entity.processphysical.addphysicalcount_error": "The file you uploaded had no valid rows to be imported.",
		"admin.entity.processphysical_addphysicalcount.additems_title": "Add Physical Count Items",
		"entity.brand.brandwebsite": "Brand Website",
		"entity.category.cmscategoryid": "CMS Category ID",
		"entity.emailverification.emailverificationid": "Email Verification ID",
		"entity.physical.physicalstatustype": "Physical Status Type",
		"entity.content.allowpurchaseflag": "Sell This Content",
		"setting.integrationpayflowproaccountpaymentcommenttwotemplate_hint": "This template will be string replaced based on the order payment, and then passed as custom comment 2 to PayFlow Pro.  An Example would be: ${accountPaymentID} or ${myCustomAccountPaymentAttributeCode}.  Plain text works as well",
		"permission.setting.detailmeasurementunit": "Measurement Unit - Detail",
		"admin.define.list": "${itemEntityNamePlural}",
		"processobject.task_updatecalculatedproperties.updatestockskuproductflag": "Update Stocks / Skus / Products",
		"entity.sku.delete_success": "The SKU was deleted successfully.",
		"define.sum": "Sum",
		"validate.edit.physicalcountitem.physicalstatustypesystemcode.inlist": "The physical count Item cannot be edited as the physical count has been commited.",
		"defaultmessage_isvalidobjectsimplevalue": "validation failed because a valid object cannot be a simple value.",
		"setting.integrationfedexaccountno": "FedEx Account Number",
		"define.qiats": "QIATS",
		"validate.save.orderpayment.amount.lteproperty.termpaymentaccount.termaccountavailablecredit": "The order payment amount exceeds the available credit for this account",
		"entity.stock.location": "location",
		"validate.save.country.countrycode3digit.minlength": "Country Code 3 Digit must be 3 characters",
		"entity.audit.auditarchiveenddatetime": "End Date",
		"admin.pricing.createpromotionrewardcontentaccess": "Create Promotion Reward Content Access",
		"entity.account_plural": "Accounts",
		"entity.order.total": "Total",
		"entity.promotioncode.accounts": "Accounts",
		"setting.accounteligiblepaymentterms": "Eligible Payment Terms",
		"frontend.checkout.processorder": "Place Order",
		"entity.workflowtaskaction.norecordsfound": "No actions have been created",
		"define.exchange": "Exchange",
		"entity.vendor.primaryemailaddress": "Primary Email Address",
		"entity.productreview_plural": "Product Reviews",
		"define.months": "Months",
		"entity.giftcard.giftcardid": "Gift Card ID",
		"permission.setting.savetype": "Type - Save",
		"define.repcaptchafailed": "Invalid Captcha",
		"setting.imagealtstring": "Missing Image Alt String",
		"admin.entity.createproduct.selectsubscriptionterms": "Select Subscription Terms",
		"entity.pricegroup.inheritsfrom": "Inherits From",
		"processobject.order_createreturn.stocklossflag": "Stock Loss?",
		"entity.brand.loyaltyaccruementexclusions": "Loyalty Accruement Exclusions",
		"entity.pricegrouprate.globalflag": "Global Rate",
		"entity.address.city_validaterequired": "Please enter a valid City",
		"setting.integrationfullcirclelocaltransferurlusername_hint": "If the transfer URL sits behind a Username or Password then please specify it here.",
		"entity.shippingmethod_plural": "Shipping Methods",
		"entity.define.amountreceived": "Amount Received",
		"entity.sku.qoh": "QOH",
		"entity.account.firstname": "First Name",
		"entity.permission.propertyname": "Property Name",
		"entity.loyalty": "Loyalty Program",
		"entity.vendor.vendoraddresses": "Vendor Addresses",
		"admin.entity.producttypetabs.attributesets": "Attribute Sets",
		"entity.product.ontermsale": "onTermSale",
		"entity.account.fullname": "Name",
		"entity.content.excludefromsearch": "Exclude From Search",
		"entity.subscriptionbenefit.excludedcontents": "Excluded Contents",
		"entity.content.process.duplicatecontent": "Duplicate Content",
		"entity.promotionaccount.startdatetime": "Start Date Time",
		"entity.stockreceiveritem.orderitem": "Order Item",
		"entity.attributevalue.attributeid": "Attribute ID",
		"entity.content.templateflag": "Template",
		"define.qndoo.full": "Not Delivered On Order",
		"entity.pricegroupratecurrency": "Price Group Currency Rate",
		"validate.delete.sku.skuid.isnotdefaultsku": "The default sku cannot be deleted.",
		"entity.sku.attendedquantity": "Attended Quantity",
		"setting.accounttermcreditlimit_hint": "This value represents the maximum amount of open unpaid term payments that are allowed for a given account.",
		"entity.printtemplate.printcontent": "Print Content",
		"entity.subscriptionterm.autopayflag_hint": "If this is set to 'Yes' then when a renewal order is created, it will automatically use the payment method on file to renew the order",
		"frontend.account.editpassword": "Edit Password",
		"setting.fulfillmentmethodemailcc": "Email CC",
		"entity.currency.formattedexample": "Formatted Example",
		"entity.physicalcountitem.stock": "Stock",
		"setting.integrationfedexshipperstreet": "Shipping From Street Address",
		"admin.entity.createaccountemailaddress": "Add Email Address",
		"entity.profiletemplateattribute.profiletemplate": "profileTemplate",
		"permission.setting": "Setting",
		"validate.edit.orderpayment.orderstatuscode.inlist": "The order payment cannot be edited as the order has been placed.",
		"admin.entity.promotionperiod.editdisabled_info": "This promotion period cannot be edited because it has expired.",
		"permission.setting.listattributeset": "Attribute Set - List",
		"validate.define.telephone": "The ${propertyName} is not a valid phone number. Valid phone numbers are 10 digits long.",
		"entity.audit.title": "Title",
		"setting.integrationclickandbuyconsumerlanguage": "Consumer language (ISO 639-1)",
		"entity.attribute.attributetype": "Input Type",
		"entity.country.postalcoderequiredflag": "Require Postal Code",
		"entity.content.listingproducts": "Listing Products",
		"entity.accountpayment.paymenttransactions": "Payment Transactions",
		"entity.category.categoryid": "Category ID",
		"entity.product.shippingweight_hint": "Weight (in lbs) to be used to calculate shipping charges.",
		"entity.paymenttransaction.transactionsuccessflag": "Success",
		"entity.define.modifiedbyaccountid": "Modified By AccountID",
		"entity.promotionreward.delete_success": "Promotion Reward Deleted",
		"entity.term.paymentterms": "Payment Terms",
		"admin.default.integrations_nav": "Integrations",
		"entity.account.pricegroups": "Price Groups",
		"entity.orderfulfillment.accountloyaltytransactions": "Account Loyalty Transactions",
		"admin.entity.subscriptionusagetabs.subscriptionusageaccounts": "Accounts",
		"entity.alternateskucode.sku": "Sku",
		"entity.integration.installedflag": "Installed Flag",
		"admin.define.creditcarddetails": "Credit Card Details",
		"entity.define.shippingaddress": "Shipping Address",
		"setting.integrationpaypalexpresspaypalaccountuser": "PayPal Classic API  User",
		"entity.orderpayment.billingaccountaddress": "Billing Account Address",
		"entity.fulfillmentbatch_plural": "Fulfillment Batches",
		"admin.warehouse.detailstockadjustment.tolocationname": "To Location Name",
		"entity.shippingmethodoptionsplitshipment": "Shipping Method Option Split Shipment",
		"processobject.sku_addeventregistration.createorderflag": "Create Order?",
		"entity.task.notificationemails": "Notification Emails",
		"admin.entity.ordertabs.accountdetails": "Account Details",
		"entity.order.orderclosedatetime": "Date Closed",
		"entity.stockreceiver.boxcount": "Box Count",
		"entity.accountpaymentmethod.orderpayments": "Order Payments",
		"entity.promotionqualifier.minimumitemprice": "Minimum Item Price",
		"entity.giftcard.giftcardcode": "Gift Card Code",
		"validate.account.forgotnotvalid": "The email you provided is invalid",
		"entity.workflowtrigger.objectpropertyidentifier": "Object Property Identifier",
		"entity.sku.availableseatcount": "Available Seats",
		"processobject.product_create.redemptionamount": "Redemption Amount",
		"setting.integrationstripelivepublickey": "Live Publishable Key",
		"setting.integrationgigyasitename": "Site Name",
		"processobject.product_addsubscriptionsku.listprice": "List Price",
		"entity.subscriptionorderitem.subscriptionusage": "Subscription Usage",
		"entity.taskhistory.message": "Message",
		"permission.setting.deletepaymentmethod": "Payment Method - Delete",
		"entity.profiletemplateattribute.attribute": "attribute",
		"entity.subscriptionusagebenefit_plural": "Subscription Usage Benefits",
		"entity.loyalty.loyaltyaccruements": "Loyalty Accruements",
		"entity.locationaddress.address": "Address",
		"entity.permission.accesstype": "Access Type",
		"entity.pricegrouprate.producttypes": "Include Product Types",
		"entity.loyaltyredemption.redemptiontype.pointpurchase": "Point Purchase",
		"entity.taxapplied.taxjurisdictiontype": "Tax Jurisdiction Type",
		"entity.product.productid": "Product ID",
		"entity.eventregistration.process.pendingapproval": "Change to Pending Approval",
		"define.select": "Select",
		"entity.optiongroup_plural": "Option Groups",
		"entity.orderitem.itemtotal": "Item Total",
		"entity.account.accountloyalties": "Account Loyalty Programs",
		"entity.taxapplied.taxcategoryrate": "Tax Category Rate",
		"entity.skucurrency.renewalprice": "Renewel Price",
		"setting.contentrequirepurchaseflag_hint": "If this option is selected, then the only way a person will have access to this page is if they have purchased acess via content access product.",
		"entity.workflow_plural": "Workflows",
		"entity.orderitem.stockreceiveritems": "Stock Receiver Items",
		"entity.subscriptionusagebenefit.subscriptionusagebenefitaccounts": "Subscription Usage Benefit Accounts",
		"entity.order.process.placeorder.paymentprocessingerror": "There was an error processing order payment information.",
		"entity.promotionreward.shippingmethod": "Shipping Method",
		"entity.schedule.scheduleid": "Schedule ID",
		"entity.comment.parentcomment": "Related Parent Comment",
		"entity.productimage.imagefile": "Image",
		"admin.entity.producttabs.productdescription": "Product Description",
		"entity.taskschedule_plural": "Task Schedules",
		"entity.stock.sku": "sku",
		"entity.fulfillmentmethod.autofulfillflag": "Auto Fulfill",
		"event.onsessionaccountlogout": "On Account Logout",
		"entity.order.billingaccountaddress": "Billing Account Address",
		"admin.main.update.stable": "Stable",
		"entity.term.termid": "Term ID",
		"entity.permission.section": "Section",
		"admin.define.edit_permission": "${itemEntityName} - Edit Existing",
		"entity.category.restrictaccessflag": "Restrict Access",
		"permission.product.deletesubscriptionterm": "Subscription Term - Delete",
		"entity.stockreceivervendororder_plural": "Stock Receivers",
		"entity.taskhistory": "Task History",
		"entity.order.process.placeorder.paymentrequirementerror": "The order could not be placed because it was missing valid payment infomation",
		"permission.integration.createintegration": "Integration - Create",
		"entity.accountauthentication.integrationaccesstokenexpiration": "Integration Access Token Expiration",
		"entity.physical": "Physical",
		"admin.entity.processorderitem.addrecipientstoorderitem_success": "Added Gift Recipients Successfully",
		"admin.entity.listloyalty": "Loyalty Program",
		"entity.orderdelivery_plural": "Order Deliveries",
		"setting.integrationavataxaccountno": "Avatax Account Number",
		"entity.stockadjustment.status": "Status",
		"entity.promotionreward.brands": "Brands",
		"setting.skubundleautomakeupinventoryonsaleflag": "Bundle Auto Makeup Inventory On Sale",
		"entity.task.timeout": "Timeout",
		"entity.paymentterm.paymenttermname": "Payment Term Name",
		"entity.product.purchaseenddatetime": "Purchase End Date",
		"admin.entity.vendortabs.vendoraddresses": "Vendor Addresses",
		"entity.order.process.clear": "Clear",
		"admin.entity.createaccountphonenumber": "Add Phone Number",
		"validate.account_authorizeaccount.emailaddress.notfound": "There is no account with the Email address that was provided.",
		"entity.productschedule.eventenddatetime": "Event Start",
		"permission.account.deleteaccount": "Account - Delete",
		"entity.attributevalue.attributevaluetype": "Attribute Value Type",
		"setting.contentrestrictedcontentdisplaytemplate": "No Access Template",
		"validate.save.skucurrency.listprice.minvalue": "The sku currency list price cannot be a negative value.",
		"entity.accountemailaddress.isprimary": "isPrimary",
		"entity.orderitem.orderitemid": "Order Item ID",
		"entity.promotionreward.shippingaddresszones": "Shipping Address Zones",
		"admin.entity.sku.subscriptionbenefits": "Subscription Benefits",
		"entity.stockadjustmentdeliveryitem": "Stock Adjustment Delivery Item",
		"admin.entity.detailorderpayment.dynamiccharge": "Dynamic Charge Amount",
		"entity.file_plural": "Files",
		"entity.producttype.childproducttypes": "Child Product Types",
		"validate.addeventschedule.product_addeventschedule.eventenddatetime.gtdatetimeproperty": "Event end date must occur after start date.",
		"admin.define.delete_title": "Delete ${itemEntityName}",
		"entity.schedule.daysofmonthtorun": "Days of Month",
		"entity.taxcategory.taxcategoryrate": "Tax Category Rate",
		"entity.taskhistory.taskschedule": "Task Schedule",
		"setting.integrationfullcirclefcftpusername": "Full Circle FTP Username",
		"entity.attribute.attributetype.atrichtexteditor": "Rich Text Editor",
		"permission.setting.deletecountry": "Country - Delete",
		"entity.measurementunit.unitcode": "Unit Code",
		"entity.promotion.startdatetime": "Start Date/Time",
		"permission.integration.listintegration": "Integration - List",
		"setting.integrationfullcirclefcftpaddress_hint": "Full Circle FTP Address",
		"entity.orderitem.orderdeliveryitems": "Order Delivery Items",
		"admin.entity.skutabs.bundledskus": "Bundled Skus",
		"entity.stockadjustmentitem.fromstock": "From Stock",
		"setting.productmetakeywordsstring": "Product Meta Keywords String",
		"entity.attributeset.attributesetobject": "Attribute Set Object",
		"admin.entity.promotiontabs.promotionsummary": "Summary",
		"entity.session": "Session",
		"entity.stockadjustmentdeliveryitem.stockadjustmentdeliveryitemid": "Stock Adjustment Delivery Item ID",
		"define.salutationmr": "Mr.",
		"define.salutationms": "Ms.",
		"entity.vendororder.process.addorderitems": "Add Order Items",
		"processobject.order_createreturn.refundorderpaymentid": "Refund Payment",
		"report.orderitemreport.revenue": "Revenue",
		"setting.branddisplaytemplate_hint": "The content object that you would like to use as the template for displaying product on the front-end.  Typically this is a page in your CMS or Custom Application",
		"setting.globalcurrencylocale": "Currency Locale",
		"setting.integrationmurasuperusersyncflag_hint": "If set to 'yes' then any S2 Super User accounts in mura will get added to the super user group in Slatwall.  This setting will only apply if the Account Sync Type is set to 'all' or 'systemUserOnly'.",
		"permission.account.listpermissiongroup": "Permission Group - List",
		"setting.integrationorbitalterminalid": "Terminal ID",
		"entity.content.parentcontent": "Parent Content",
		"define.save": "Save",
		"entity.access.subscriptionusagebenefitaccount": "Subscription Usage Benefit Account",
		"entity.profile.profilename": "profileName",
		"admin.entity.accounttabs.accountpayments": "Account Payments",
		"permission.setting.editsetting": "Setting - Edit",
		"setting.integrationfullcirclelocaltransferurlpath": "Local Transfer URL Path",
		"entity.attribute.validationmessage": "Validation Message",
		"entity.vendorphonenumber.vendor": "Vendor",
		"define.bundleproduct": "Bundle Product",
		"entity.accountpaymentmethod.paymentmethod": "Payment Method",
		"entity.productimage_plural": "Product Images",
		"admin.entity.ordertabs.orderfulfillments": "Order Fulfillments",
		"entity.accountauthentication.authenticationdescription": "Description",
		"setting.tasksuccessemailtemplate_hint": "This email template will be used to send out success notifications in the event that a task runs successfully.",
		"define.tax": "Tax",
		"entity.product.qexp": "QEXP",
		"admin.default.tools_nav": "Tools",
		"entity.order.referencedordertype": "Order Reference Type",
		"permission.setting.editmeasurementunit": "Measurement Unit - Edit",
		"define.qvomin.full": "Min Per Order",
		"entity.currencyrate.conversioncurrencycode": "Conversion Currency Code",
		"define.qhb.full": "Held Back",
		"entity.eventregistration.waitlistqueuedatetime": "Waitlist Queue Date Time",
		"entity.accountpayment.process.offlinetransaction": "Offline Transaction",
		"setting.integrationvirtualmerchantuserid": "Virtual Merchant User ID",
		"report.productperformancereport": "Product Performance",
		"entity.orderpayment.paymentmethod": "Payment Method",
		"validate.account_authorizeaccount.password.incorrect": "Account Password Incorrect",
		"admin.account.processsubscriptionusage.updatesubscription_nav": "Update Subscription",
		"entity.profiletemplateattribute.profiletemplateattributeid": "profileTemplateAttributeID",
		"entity.taskschedule.nextrundatetime": "Next Run Time",
		"setting.integrationstripegeneratetokenbehavior": "Generate Token Behavior",
		"define.summary": "Summary",
		"entity.productreview.productreviewid": "Product Review ID",
		"entity.content.templateflag_hint": "Use this as a template for Product/Brand/Product Type",
		"admin.entity.processproduct.addoptiongroup_success": "The option group has been successfully added to the sku.",
		"permission.setting.saveroundingrule": "Rounding Rule - Save",
		"setting.integrationsagepaytestmode": "Test Mode",
		"entity.email.emailcc": "CC",
		"entity.shippingmethod.sortorder": "Sort Order",
		"entity.define.nextestimateddeliverydatetime": "Next Order Estimated Delivery Date time",
		"processobject.account_setupinitialadmin.sitedomains": "Site Domains",
		"entity.attribute": "Attribute",
		"entity.orderpayment.paymenttransactions": "Payment Transactions",
		"validate.define.unique": "The ${propertyName} is not unique.",
		"admin.entity.updateprice_nav": "Update Price",
		"entity.subscriptionorderitem_plural": "Subscription Order Item",
		"admin.entity.vendortabs.vendorbrands": "Brands",
		"admin.entity.promotiontabs.promotiondescription": "Description",
		"define.percentage": "Percentage",
		"admin.entity.addorderitemgiftrecipient.invalid": "Please Specify an email address with a first and last name for this recipient.",
		"admin.main.about_permission": "About Page",
		"processobject.account_setupinitialadmin.slatwallascmsflag": "Use Slatwall as a CMS",
		"permission.product.detailoptiongroup": "Option Group - Detail",
		"validate.createpassword.account.accountemailaddressesnotinuseflag.eq": "You can not create a password for this account because one or more of the email addresses are already associated with another account.",
		"validate.delete.physicalcountitem.physicalstatustypesystemcode.inlist": "The physical count Item cannot be deleted as the physical count has been commited.",
		"permission.setting.listfulfillmentmethod": "Fulfillment Method - list",
		"entity.loyalty.loyaltyname": "Loyalty Program Name",
		"entity.alternateskucode.alternateskucodetype": "Sku Code Type",
		"entity.skubundle.bundledquantity": "Bundled Quantity",
		"entity.stockadjustmentitem.stockadjustmentitemid": "Stock Adjustment Item ID",
		"permission.integration.saveintegration": "Integration - Save",
		"entity.attribute.relatedobject": "Related Object",
		"entity.location.locationid": "Location ID",
		"setting.integrationgigyaapikey": "API Key",
		"entity.productschedule.reservationstarttime": "Reservation start time",
		"setting.integrationpaypalexpresspaypalaccountemail": "PayPal Account Email Address",
		"setting.integrationpaypalexpresspaypalaccountpassword": "PayPal Classic API Password",
		"define.week": "Week",
		"define.basic": "Basic",
		"setting.integrationmuraaccountsynctype": "Account Sync Type",
		"entity.brand.promotionrewards": "Promotion Rewards",
		"entity.emailbounce.rejectedemailbody": "Rejected Email Body",
		"defaultmessage_false": "{1} must be false.",
		"entity.report.reportdatetimegroupby": "Report Date Time Group By",
		"entity.orderfulfillment.fulfillmentmethod": "Fulfillment Method",
		"entity.shippingmethodoption.shiptostatecode": "Ship To State Code",
		"permission.report": "Report",
		"define.qnrovo": "QNROVO",
		"admin.entity.processorder.create_success": "The new order was created successfully.",
		"entity.taxapplied.integrationtaxratetype": "Integration Tax Rate Type",
		"entity.attribute.attributeinputtype.attextarea": "Text Area",
		"entity.stockreceiveritem.vendororderitem": "Vendor Order Item",
		"entity.orderpayment.process.processtransaction": "Process Transaction",
		"setting.integrationvertexorigincurrencycode": "Origin Currency Code",
		"entity.orderorigin.orderoriginname": "Order Origin Name",
		"permission.product.savesubscriptionbenefit": "Subscription Benefit - Save",
		"validate.changeeventdates.sku_changeeventdates.eventstartdatetime.gtnow": "The event start date cannot be before now.",
		"validate.changeeventdates.sku_changeeventdates.endreservationdatetime.gtnow": "The end reservation date cannot be before now.",
		"entity.product.publishedflag": "Published",
		"entity.report.dynamicdaterangeflag": "Dynamic Date Range",
		"permission.setting.createcategory": "Category - Create",
		"entity.file.download.filemissingerror": "The file no longer exists or could not be located in file system",
		"permission.product.editoptiongroup": "Option Group - Edit",
		"entity.shortreference": "Short Reference",
		"admin.entity.shippingmethodtabs.shippingmethodratesettings": "Shipping Rate Settings",
		"entity.order.shippingaddress": "Shipping Address",
		"setting.integrationpaypalexpresscancelurl": "Cancel URL",
		"define.weight": "Weight",
		"setting.integrationparcel2goapikey": "API Key",
		"entity.sku.process.addeventregistration": "Add Event Registration",
		"admin.entity.ordertabs.returnorderitems": "Return Order Items",
		"entity.attributeset.additionalcharge": "Additional Charge",
		"entity.giftcard.process.offlinetransaction": "Adjust Balance",
		"entity.productschedule.schedulestartdatewithouttime": "Schedule Start",
		"entity.promotioncode.startdatetime": "Start Date/Time",
		"entity.workflowtask.workflowtaskactions": "Task Workflow Actions",
		"permission.pricing.detailpricegroup": "Price Group - Delete",
		"permission.setting.deletecategory": "Category - Delete",
		"entity.accountpaymentapplied.accountpaymenttype": "Account Payment Type",
		"entity.state.countrycode": "Country Code",
		"entity.stock.stockid": "stockID",
		"entity.pricegroup.loyaltyredemptions": "Loyalty Redemptions",
		"entity.order.process.duplicateorder": "Duplicate Order",
		"permission.pricing.editpricegroup": "Price Group - Edit",
		"admin.define.create_permission": "${itemEntityName} - Create New",
		"validate.save.orderfulfillment.fulfillmentcharge.minvalue": "You must set the fulfillment charge to a number of 0 or larger.",
		"entity.paymentmethod.paymentintegration": "Payment Service",
		"entity.define.nameoncreditcard": "Name On Credit Card",
		"define.qats.full": "Available To Sell",
		"setting.shippingmethodratemaximumamount": "Maximum Rate Amount",
		"entity.setting.content": "Content",
		"entity.workflowtaskaction.email": "Email",
		"entity.subscriptionusage.renewalterm": "Renewal Term",
		"entity.category.parentcategory": "Parent Category",
		"setting.branddisplaytemplate": "Brand Display Template",
		"entity.fulfillmentbatchitem.quantityfulfilled": "Quantity Fulfilled",
		"entity.product.define.productcode": "Product Code",
		"setting.emailccaddress": "Email CC Address",
		"admin.entity.editphysical_disabled": "The physical count cannot be edited as it has been committed.",
		"entity.subscriptionterm.billedondayofmonth_hint": "This value is used in conjunction with the pro-rate option",
		"permission.order.deleteorderfullfillment": "Order Fulfillment - Delete",
		"frontend.account.listorders": "List Orders",
		"entity.attribute.attributetype.atradiogroup": "Radio Group",
		"entity.orderpayment.accountpaymentmethod": "Account Payment Method",
		"setting.integrationfedexmeterno": "Meter Number",
		"setting.producttypemetakeywordsstring": "Product Type Meta Keywords String",
		"setting.fulfillmentmethodshippingoptionsorttype": "Sort Shipping Options By",
		"entity.site": "Site",
		"entity.location.physicals": "Physicals",
		"admin.entity.processsku.makeupbundledskus_success": "Bundled sku makeup was successful.",
		"entity.paymentmethod.paymentmethodtype.creditcard": "Credit Card",
		"entity.optiongroup.optiongroupimage": "Option Group Image",
		"permission.product.detailsubscriptionbenefit": "Subscription Benefit - Detail",
		"validate.promotioncode.invalid": "The promotion code that you have entered is invalid.",
		"entity.promotionreward.rewardtype.shipping": "Shipping",
		"entity.account.lastname": "Last Name",
		"admin.entity.processsku.addeventregistration_success": "Event Registration add successfully.",
		"validate.define.email": "The ${propertyName} is not a valid email address.  Email addresses should follow an example like john.doe@gmail.com.",
		"define.qnrosa": "QNROSA",
		"define.0": 0,
		"validate.resetpassword.account_resetpassword.password.regex": "Admin passwords should include at least 1 letter, 1 number, and be 7 or more characters long.",
		"admin.entity.processeventregistration.waitlist_success": "Registration has been Wait Listed.",
		"admin.entity.createaddresszone": "Create New Address Zone",
		"entity.accountpaymentmethod.giftcardbalanceamountformatted": "Gift Card Balance",
		"admin.entity.settingstabs.subscriptionusage": "Subscription Usage Settings",
		"define.qnroro": "QNRORO",
		"entity.subscriptionbenefit.contents": "Content",
		"entity.eventregistration.lastname": "Last Name",
		"admin.entity.accounttabs.addresses": "Addresses",
		"setting.globalauditcommitmode": "Audit Commit Mode",
		"entity.term.initialsubscriptionterms": "Initial Subscription Terms",
		"setting.integrationstripetestpublickey": "Test Publishable Key",
		"admin.entity.createmanualinadjustment": "Manual In Adjustment",
		"entity.product.skus": "Skus",
		"event.onapplicationrequeststart": "On Application Request Start",
		"setting.globalorderplacedemailbcc": "New Order Placed Email BCC",
		"entity.promotionreward.shippingamountoff": "Shipping Rate Amount Off",
		"entity.promotioncode.maximumusecount": "Max. Use Count",
		"entity.orderitem.referencingorderitems": "Referencing Order Items",
		"admin.define.edit": "Edit ${itemEntityName}",
		"entity.eventregistration.eventregistrationstatustype": "Registration Status",
		"setting.globalencryptionkeygenerator": "Encryption Key Generator",
		"defaultmessage_minlength": "{1} must be at least {2} characters long.",
		"setting.producttypedisplaytemplate": "Product Type Display Template",
		"entity.addresszonelocation": "Address Zone Location",
		"admin.entity.detailstockadjustment.tolocationname": "To Location",
		"entity.sku.process.breakupbundledskus": "Breakup Sku Bundle",
		"admin.define.delete_success": "The ${itemEntityName} was deleted successfully.",
		"entity.accountpaymentmethod.paymentmethod.select": "Please select a payment method...",
		"setting.accounttermcreditlimit": "Term Account Credit Limit",
		"admin.define.edit_disabled": "This item can not be edited",
		"endicia.main.syncpull_permission": "FTP Sync Pull",
		"entity.emailbounce": "Email Bounce",
		"entity.baseentity.errorbean": "errorBean",
		"entity.vendororderitem.vendororder": "Vendor Order",
		"entity.order.process.placeorder": "Place Order",
		"entity.brand.delete_success": "Brand deleted",
		"entity.giftcard.ownerlastname": "Last Name",
		"entity.setting.task": "Task",
		"define.temporary": "Temporary",
		"admin.entity.editorderfulfillment_disabled": "The order fulfillment cannot be edited as the order has been placed.",
		"entity.commentrelationship.physical": "Physical",
		"entity.product.listingpages": "Listing Pages",
		"entity.orderfulfillment": "Order Fulfillment",
		"entity.roundingrule.pricegrouprates": "Price Group Rates",
		"setting.globalcopycarttonewsessiononlogout": "Copy users cart to new session when the user logs out.",
		"entity.order.referencedordernumber": "Referenced Order Number",
		"entity.task.taskmethod": "Task Method",
		"entity.postalcode": "Postal Code",
		"entity.promotionreward.promotionperiod": "Promotion Period",
		"permission.warehouse.deletestockadjustment": "Stock Adjustment - Delete",
		"entity.shippingmethodoption.shiptopostalcode": "Ship To Postal Code",
		"define.qmin.full": "Minimum",
		"defaultmessage_required_dependentproperty": "{1} is required if you specify a value for {2}{3}.",
		"validate.delete.physical.physicalstatustypesystemcode.inlist": "The physical count cannot be deleted as it has been commited.",
		"validate.save.promotioncode.promotioncode.hasuniquepromotioncode": "The promotion code is not unique.",
		"processobject.order_addorderpayment.savegiftcardtoaccountflag": "Redeem Gift Card To This Account",
		"admin.entity.createpromotionrewardsubscription": "Subscription Product Discount",
		"validate.save.sku.price.minvalue": "The sku price cannot be a negative value.",
		"entity.country.streetaddressrequiredflag": "Require Street Address",
		"admin.entity.ordertabs.orderitems.saleitems": "Sale Items",
		"entity.physicalcount.physical": "Physical",
		"define.qosh.full": "On Stock Hold",
		"setting.integrationmurasuperusersyncflag": "Add Mura Super Users to Slatwall Super User Group",
		"entity.define.attributevalues": "Attribute Values",
		"permission.setting.listtaxcategory": "Tax Category- List",
		"entity.subscriptionusage.initialorderitem": "Initial Order Item",
		"entity.audit_plural": "Audits",
		"permission.setting.createterm": "Term - Create",
		"entity.vendororderitem.vendororderitemtype": "Vendor Order Item Type",
		"entity.attributeset.attributesetname": "Attribute Set Name",
		"admin.entity.integrationtabs.paymenttest": "Payment Test",
		"entity.account.accountid": "accountID",
		"entity.orderpayment_plural": "Order Payments",
		"entity.accountloyalty.account": "Account",
		"admin.entity.stocktabs.inventory": "Inventory",
		"setting.integrationupsusername": "UPS Username ",
		"validate.save.attribute.attributecode.regex": "The value entered for ${propertyName} should be alphanumeric with no spaces or hyphens.",
		"permission.product.detailbrand": "Brand - Detail",
		"entity.producttype.promotionrewards": "Promotion Rewards",
		"admin.entity.processtask.processoption.taskscheduleid": "Schedule",
		"defaultmessage_futuredate_withafter": "{1} must be a date in the future. The date entered must come after {2}.",
		"setting.integrationgigyalegacyuidpropertyidentifier_hint": "This is an an optional setting used for using legacy gigya accounts that were imported into slatwall.  You can store the old UID of the imported user in a remoteID field, or a custom attribute and then define the custom attribute code here.",
		"entity.giftcard.process.updateemailaddress_success": "The Email Has Been Successfully Sent",
		"entity.producttype.promotionrewardexclusions": "Promotion Reward Exclusions",
		"entity.promotionreward.eligiblepricegroups": "Eligible Price Groups",
		"entity.collection.parentcollection": "Base Collection",
		"validate.setupinitialadmin.account_setupinitialadmin.password.regex": "Admin passwords should include at least 1 letter, 1 number, and be 7 or more characters long.",
		"setting.globalallowcustombranchupdates": "allow custom branch updates (use at your own risk)",
		"setting.shippingmethodrateadjustmentamount": "Rate Adjustment Amount",
		"validate.account.loginblocked": "Your login has been blocked due to too many invalid attempts please contact the site adminstrator to unlock it.",
		"validate.delete.paymenttransaction.paymenttransactionid.maxlength": "Deletion of payment transactions is not permitted.",
		"admin.orderdetail.orderitems.customization": "Customization",
		"define.monday": "Monday",
		"entity.paymenttransaction.authorizationcodeused": "Auth. Code Used",
		"entity.vendorskustock.sku": "sku",
		"admin.entity.fulfillmentmethodtabs.shippingmethods": "Shipping Methods",
		"entity.workflowtaskaction": "Workflow Task Action",
		"entity.task.taskmethod.customurl": "Custom URL",
		"entity.orderpayment.process.authorizeandcharge": "Authorize & Charge",
		"setting.integrationsagepaysimulatormode": "Simulator Mode",
		"validate.processphysical_addphysicalcount.invalidfile": "The file you uploaded is not a valid file type. Please upload a valid text file ( with a .txt or .csv extension ).",
		"entity.entityqueuehistory.entityqueuehistoryid": "Entity Queue History ID",
		"setting.contentrequiresubscriptionflag_hint": "If this option is selected, then the only way a person will have access to this page is if they have purchased acess via subscription product.",
		"entity.country.countrycode3digit": "Country Code 3 Digit",
		"admin.entity.fulfillmentmethodtypes.shippingtabs.shippingmethods": "Shipping Methods",
		"entity.accountpaymentmethod.nameoncreditcard": "Name On Card",
		"entity.subscriptionusagebenefitaccount_plural": "Subscription Usage Benefit Accounts",
		"permission.order.listorder": "Order - List",
		"validate.processorder_addorderitem.orderfulfillmentid.novalidfulfillmentmethod": "There was no valid fulfillment method to add this item to the order with",
		"entity.define.giftcardnumber": "Gift Card Number",
		"entity.promotionreward.delete_validateisassigned": "This promotion code cannot be deleted because it is in use.",
		"setting.integrationendiciasyncftpsite": "FTP Sync Server Address",
		"entity.order.process.placeorder.returnrequirementerror": "The order could not be placed because it was missing valid return infomation",
		"report.productperformancereport.returnafterdiscount": "Returned",
		"report.orderitemreport.itemdiscount": "Item Discounts",
		"entity.address_plural": "Addresses",
		"entity.producttype.parentproducttype": "Parent Product Type",
		"entity.product.event.productname": "Event Name",
		"setting.integrationfedexpassword": "FedEx Password",
		"entity.sku.skuname": "Sku Name",
		"entity.accountpayment.providertoken": "Provider Token",
		"define.every": "every",
		"setting.integrationpayflowpropassword": "Password",
		"entity.orderfulfillment.taxamount": "Fulfillment Items Tax Amount",
		"define.create": "Create",
		"admin.order.ordertabs.orderpayments.charges": "Order Payment Charges",
		"processobject.sku_changeeventdates.scheduleendtype": "Ends on",
		"entity.productreview.rating": "Rating",
		"email.orderdeliveryconfirmation": "Order Delivery Confirmation",
		"define.welcometoslatwall": "Welcome To Slatwall",
		"entity.accountloyaltytransaction.loyaltyredemption": "Loyalty Redemption",
		"entity.sku.delete_validateisdefault": "The SKU cannot be deleted because it is the default SKU for this product.",
		"entity.shippingmethod.shippingmethodname": "Shipping Method Name",
		"entity.term.loyaltyterms": "Loyalty Terms",
		"permission.main.default": "Dashboard",
		"admin.entity.settingstabs.fulfillmentmethod": "Fulfillment Method Settings",
		"entity.skucurrency": "Sku Currency",
		"validate.delete.orderitemgiftrecipient.giftcards.caneditordelete": "You cannot delete a gift recipient while it's gift cards are active.",
		"entity.sku.webqexp": "webQEXP",
		"entity.product.webqexp": "webQEXP",
		"entity.orderreturn_plural": "Order Returns",
		"setting.integrationmuralegacymyaccount": "Legacy My Account Filename",
		"entity.schedule.frequencyinterval_hint": "Between the Start Time & End Time of any given day, this schedule will run every interval of minutes defined.",
		"entity.paymentmethod.placeordercredittransactiontype": "Checkout Credit Trans.",
		"entity.order.referencedordertype.return": "Return",
		"entity.shippingmethodrate.sortorder": "Sort Order",
		"setting.emailsubject": "Email Subject",
		"entity.waitlistqueueterm": "Waitlist Queue Term",
		"entity.orderpayment.process.credit": "Credit",
		"define.qmax": "QMAX",
		"admin.entity.createreturnorder": "Create Return Order",
		"entity.paymentmethod.saveorderpaymentencryptflag_hint": "Selecting this option will store the secure payment info in an encrypted format when saving an Order Payment.  It is not recommended, as other options like generating tokens are typically better.",
		"entity.entityqueuehistory.baseid": "Base ID",
		"entity.loyaltyaccruement.accruementtype": "Accruement Type",
		"define.shipping": "Shipping",
		"event.onapplicationsetup": "On Application Setup",
		"entity.promotion.promotionperiods": "Promotion Periods",
		"entity.taxcategoryrate.appliedtaxes": "Applied Taxes",
		"admin.entity.skutabs.currencies": "Currencies",
		"entity.permission.subsystem": "Sub System",
		"entity.stockreceiveritem.stockreceiveritemid": "Stock Receiver Item ID",
		"entity.integration.paymentreadyflag": "Payment Ready Flag",
		"admin.entity.loyaltyaccruementtabs.skus": "Skus",
		"processobject.subscriptionusage_addusagebenefit.benefittermtype": "Add to Initial vs Renewal",
		"permission.product.detailproduct": "Product - Detail",
		"validate.changeeventdates.sku_changeeventdates.eventenddatetime.gtnow": "The event end date cannot be before now.",
		"entity.account.process.changepassword": "Change Password",
		"admin.entity.accounttabs.paymentmethods": "Payment Methods",
		"entity.promotionqualifier.promotionperiod": "Promotion Period",
		"entity.shortreference.shortreferenceid": "Short Reference ID",
		"entity.comment": "Comment",
		"entity.physicalcount_plural": "Physical Counts",
		"entity.product.nextskucodecount": "Next sku count",
		"entity.promotionqualifier.excludedskus": "SKU Exclusions",
		"entity.email.emailid": "Email ID",
		"entity.pricegrouprate.products": "Include Products",
		"entity.report.dynamicdaterangeendtype.thisweekendsaturday": "Current Week ( Ending Saturday )",
		"define.renewalsku": "Renewal Sku",
		"entity.pricegrouprate.appliesto": "Rate Applies To",
		"entity.schedule.frequencystarttime": "Start Time",
		"entity.account.murauser": "Mura User",
		"validate.addoption.product_addoption.options.required": "Please select a unique combination to create a new sku.",
		"entity.order.taxtotal": "Tax Total",
		"permission.setting.detailtype": "Type - Detail",
		"define.remove": "Remove",
		"permission.product.detailsubscriptionterm": "Subscription Term - Detail",
		"entity.product.alternateimage": "Alternate Image",
		"entity.product.listprice": "List Price",
		"entity.subscriptionterm.billedondayofmonth": "Bill On Day of Month",
		"entity.accountloyaltyaccruement.accruementtype.enrollment": "Program Enrollment",
		"setting.integrationmuralegacyinjectflag": "Inject Legacy Views",
		"permission.product.deletebrand": "Brand - Delete",
		"define.qndosa": "QNDOSA",
		"entity.contentaccess.contentaccessid": "Content Access ID",
		"entity.promotionqualifier.rewardmatchingtype.brand": "Brand",
		"permission.setting.listcategory": "Category - List",
		"entity.address.lastname": "Last Name",
		"admin.main.dashboard.timeline": "Timeline",
		"entity.setting.product": "Product",
		"entity.attributeoption.attributeoptionvalue": "Value",
		"define.event": "Event",
		"define.first": "first",
		"setting.globalassetsimagefolderpath": "Image Assets Folder Path",
		"entity.subscriptionorderitem": "Subscription Order Item",
		"define.price": "Price",
		"entity.commentrelationship.orderitem": "Order Item",
		"entity.promotionqualifier.qualifiertype.order": "Order",
		"entity.vendorphone.vendor": "vendor",
		"entity.shortreference_plural": "Short References",
		"admin.main.log_permission": "View Slatwall Log",
		"validate.account.emailaddress": "Invalid email address",
		"admin.entity.processsku.editcapacity_success": "Capacity values\tchanged successfully.",
		"setting.integrationuspsuserid": "USPS Web Tools UserID ",
		"permission.order.detailorderfullfillment": "Order Fulfillment - Detail",
		"permission.product.listsubscriptionbenefit": "Subscription Benefit - List",
		"entity.producttype.producttypename": "Product Type Name",
		"entity.product.purchasestartdatetime": "Purchase Start Date",
		"admin.entity.processsku.changeeventdates_success": "Event dates successfully updated.",
		"permission.warehouse.liststockreceiver": "Stock Receiver - List",
		"setting.skugiftcardautogeneratecode": "Autogenerate Gift Card Codes",
		"validate.save.accountpayment.amount.minvalue": "Account payment amount cannot be a negative value.",
		"entity.email.emailto": "To",
		"permission.setting.editaddresszone": "Address Zone - Edit",
		"frontend.checkout.saveaccount": "Save & Continue",
		"admin.entity.settingstabs.global": "Global Settings",
		"entity.promotionreward.rewards": "Rewards",
		"validate.account.authorizeaccount.invalidemail": "There is no account with the Email address that was provided.",
		"entity.audit.changedetails.propertychanged.rollback": "Changed",
		"define.charge": "Charge",
		"entity.country.statecodeshowflag": "Show State Code",
		"entity.orderpayment.process.createtransaction": "Create Transaction",
		"setting.integrationfedexcontactcompany": "Contact Company",
		"validate.delete.product.transactionexistsflag.eq": "This product can not be deleted because one or more of it's skus has been used on transactions.",
		"entity.accountphonenumber.phonenumber": "Phone Number",
		"define.qiats.full": "Immediately Available To Sell",
		"setting.tasksuccessemailtemplate": "Task Success Email Template",
		"admin.entity.orderitemtabs.promotions": "Promotions",
		"entity.profile.account": "account",
		"entity.loyaltyaccruement.brands": "Brands",
		"entity.product.loyaltyredemptions": "Loyalty Redemptions",
		"entity.promotionapplied.appliedtype": "Applied Type",
		"entity.sku.skuid": "skuID",
		"entity.attributevalue.vendor": "Vendor",
		"define.february": "February",
		"entity.attributevalue.accountpayment": "Account Payment",
		"entity.loyaltyredemption.loyaltyterm": "Loyalty Term",
		"entity.paymentmethod.allowsaveflag": "Allow Accounts to Save",
		"entity.vendoraddress": "Vendor Address",
		"setting.producttypehtmltitlestring": "Product Type HTML Title String",
		"entity.loyaltyredemption.minimumpointquantity": "Minimum Point Quantity",
		"entity.emailtemplate.emailtemplatefile": "Email Template File",
		"setting.accountauthenticationautologouttimespan_hint": "This should be a comman seperated list of numbers that specifies: days, hours, minutes, seconds.  For example if you want to auto-logout after two hours the value should be: 0,2,0,0",
		"entity.paymenttransaction": "Payment Transaction",
		"admin.entity.listcartandquote_title": "View A List of Carts & Quotes",
		"setting.integrationendiciasyncftpsiteusername": "FTP Sync Username",
		"entity.paymenttransaction.accountpayment": "Account Payment",
		"entity.product.alternateimages": "Alternate Images",
		"entity.address.phone": "Phone",
		"admin.entity.attributetabs.description": "Description",
		"entity.vendor.numberbrands": "Brands Offered",
		"define.weekly": "Weekly",
		"entity.attributeset.producttypes": "Product Types",
		"setting.paymentmethodmaximumordertotalpercentageamount": "Maximum Order Total Percentage Amount",
		"entity.emailtemplate.emails": "Emails",
		"entity.account.process.unlock": "Unlock",
		"entity.locationconfiguration.locationconfigurationcapacity": "Configuration Capacity",
		"entity.order.process.placeorder.accountrequirementerror": "The order could not be placed because it was missing valid account information",
		"entity.product.shippingweight": "Shipping Weight",
		"entity.account.primaryaddress": "Primary Address",
		"entity.promotionqualifier.maximumordersubtotal": "Maximum Order Subtotal",
		"setting.integrationipaymentapplicationpassword": "Application Password",
		"setting.integrationvertexwebservicesusername_hint": "Used with Vertx Password when no Trusted ID is defined",
		"defaultmessage_custom": "{1} custom validation failed.",
		"setting.productshowdetailwhennotpublishedflag_hint": "This setting allows you to basically override the default behavior of slatwall by allowing for old product pages to still render after they have been removed from 'published'.",
		"permission.product.listsubscriptionterm": "Subscription Term - List",
		"entity.integration.integrationtypelist": "Integration Type List",
		"entity.eventregistration.process.exire": "Expire",
		"entity.emailtemplate.emailbodytext": "Body Text",
		"entity.orderdeliveryshipping.trackingnumber": "Tracking Number",
		"setting.globalusagestats_hint": "Selecting this option will send your application usage information to the Slatwall development team to help better inform the product.",
		"entity.promotionqualifier.minimumitemquantity": "Minimum Item Qty.",
		"process.vendororder_addvendororderitem.delivertolocationid": "Deliver To Location",
		"entity.productbundlegroup.fixed": "Fixed",
		"entity.account.failedloginattemptcount": "Failed Login Attempts",
		"entity.account.accountpayments": "Account Payments",
		"entity.accountloyaltytransaction.orderitem": "Order Item",
		"entity.email_plural": "Emails",
		"admin.entity.detailcountry.addressrequirements": "Address Requirements",
		"admin.entity.tasktabs.taskhistory": "Task History",
		"entity.country.localityrequiredflag": "Require Locality",
		"entity.session.lastplacedorderid": "Last Placed Order ID",
		"entity.stockadjustmentitem": "Stock Adjustment Items",
		"entity.entityqueue_plural": "Entity Queues",
		"admin.entity.promotionqualifiertabs.shippingaddresszones": "Shipping Address Zones",
		"entity.optiongroup.optiongroupname": "Option Group Name",
		"entity.account.process.updatepassword": "Update Password",
		"entity.product.process.addsku": "Add Sku",
		"define.securitycode": "Security Code",
		"entity.productbundlegroupitem_plural": "Product Bundle Group Items",
		"admin.entity.accounttabs.productreviews": "Product Reviews",
		"entity.loyaltyredemption.redemptiontype.vouchercreation": "voucher Creation",
		"entity.orderorigin": "Order Origin",
		"validate.save.sku.redemptionamount.minvalue": "The Redemption amount must be greater than 0.",
		"entity.productbundlebuild": "Product Bundle Build",
		"entity.orderitem.status": "Status",
		"permission.vendor.listvendororder": "Vendor Order - List",
		"admin.entity.pricegroupratetabs.skus": "Skus",
		"entity.pricegrouprate.excludedproducts": "Exclude Products",
		"admin.entity.processaccount.addaccountloyalty_success": "The loyalty program has been successfully added to the account.",
		"admin.main.unlockaccount_permission": "Unlock Account Permission",
		"define.notplaced": "Not Placed",
		"setting.integrationauthorizenettestmodeflag": "Test Mode",
		"entity.category.site": "Site",
		"admin.entity.createmanualinadjustment_nav": "Manual In Adjustment",
		"entity.promotionqualifier.minimumfulfillmentweight": "Minimum Fulfillment Weight",
		"entity.stockhold.stockholdexpirationdatetime": "Stock Hold Expiration Date Time",
		"define.march": "March",
		"entity.accountcontentaccess.orderitem": "Order Item",
		"entity.optiongroup.optiongroupid": "Option Group ID",
		"admin.entity.createproduct.selectsubscriptionbenifits": "Select the Subscription Benefit(s) that you would like to sell as this product.",
		"entity.productbundlebuilditem_plural": "Product Bundle Build Items",
		"entity.accountpayment.termoffsetreceived": "Order Payment Received",
		"entity.stock_plural": "Stocks",
		"entity.subscriptionusage.subscriptionorderitemtype": "Subscription Stage",
		"entity.product.productname": "Product Name",
		"admin.entity.producttabs.images.defaultimages": "Default Images",
		"entity.content.displayinnavigation": "Display in Navigation",
		"entity.type.parenttype.eventregistrationstatustype": "Registratiion Status",
		"entity.alternateskucode": "Alternate Sku Code",
		"entity.order.orderstatustype": "Order Status",
		"entity.eventregistration.process.confrm": "Confirm",
		"admin.entity.producttypetabs.productsettings": "Product Settings",
		"entity.file.mimetype": "MIME Type",
		"entity.accountphonenumber": "Account Phone Number",
		"setting.integrationsagepaycurrency": "Login ID ",
		"entity.orderpayment.process.offlinetransaction": "Enter Offline Transaction",
		"setting.skushippingweightunitcode": "Shipping Weight Unit of Measurement",
		"admin.entity.orderitemtabs.taxes": "Taxes",
		"admin.entity.promotionrewardtabs.skus": "Skus",
		"entity.define.enddatetime": "End",
		"entity.account.generateapiaccesskey.nonvalidaccount": "You are not able to create an Access Key for this account.",
		"entity.baseentity.searchscore": "searchScore",
		"admin.entity.processsubscriptionusage.sendrenewalreminder_success": "Renewal reminder email sent.",
		"entity.paymenttransaction.statuscode": "Status Code",
		"entity.orderfulfillment.tax": "Tax",
		"setting.contentincludechildcontentproductsflag": "Include Products from Child Listing Pages",
		"entity.country.localitylabel": "Locality Label",
		"entity.locationaddress": "Location Address",
		"entity.collection": "Collection",
		"entity.sku.orderitems": "Order Items",
		"setting.integrationorbitalterminalid_hint": "Terminal ID to use for processing payments",
		"validate.create.product_create.eventstartdatetime.datatype.date": "Event Start Date must be a valid date",
		"setting.skuqatsincludesqnrosaflag": "QATS Includes QNROSA",
		"entity.report.dynamicdaterangetype.yeartodate": "Year to Date",
		"define.system": "System",
		"entity.product.productyear_title": "Year",
		"permission.setting.editcontent": "Content - Edit",
		"entity.country.countrycode": "Country Code",
		"entity.attribute.attributeinputtype.atcheckbox": "Check Box",
		"entity.subscriptionusage.accountpaymentmethod": "Account Payment Method",
		"admin.entity.processgiftcard.toggleactive_success": "You have successfully changed the gift card's active state.",
		"admin.define.saveandnew": "Save & New",
		"processobject.order_createreturn.receiveitemsflag": "Auto Receive Items",
		"setting.integrationipaymentcurrency": "Currency (ISO 4217)",
		"entity.stockreceiver.stockreceiverid": "Stock Receiver ID",
		"setting.integrationcanadapostcpcid": "CPC Shipping Integration ID ",
		"entity.shippingmethodrate.shipmentitempricerange": "Item Price Range",
		"processobject.product_create.selectproducttype": "Select Product Type",
		"processobject.product_addsku.locationconfigurations": "Location Configuration",
		"setting.integrationpaypalexpresspaypalheaderimage": "PayPal Header Image",
		"entity.form.process.addformresponse": "Add Form Response",
		"validate.create.product_create.eventenddatetime.datatype.date": "Event End Date must be a valid date",
		"entity.attribute.attributetype.attextbox": "Text Box",
		"define.logout": "Logout",
		"processobject.order_create.newaccountflag": "New Account",
		"entity.pricegroup.parentpricegroup": "Inherited Group Rates",
		"entity.loyaltyredemption.redemptionpointtype.lifetime": "Lifetime Point Balance",
		"entity.paymentmethod.providergateway": "Payment Provider Gateway",
		"entity.promotioncode.enddatetime": "End Date/Time",
		"entity.subscriptionterm_plural": "Subscription Terms",
		"entity.copyfromtype": "Copy From",
		"entity.loyaltyaccruement.products": "Products",
		"entity.session.sessionid": "sessionID",
		"entity.setting.paymentmethod": "Payment Method",
		"entity.account.generateapiaccesskey.accesskeyinfo": "The following keys have been generated to access the Slatwall API. Please copy them to a secure location, you will NOT be able to retrieve these values once the page is refreshed.<br /><br /> <strong>Access-Key:</strong> ${accessKey} <br> <strong>Access-Key-Secret:</strong> ${accessKeySecret}",
		"processobject.product_create.subscriptionterms": "Subscription Term",
		"setting.integrationupsshipfromstreet": "Shipping From Street Address",
		"setting.integrationorbitalmerchantidbycurrencycodelist": "Merchant ID By Currency Code List",
		"define.rate": "Rate",
		"define.locationtransfer": "Location Transfer",
		"entity.promotionqualifier.qualifiertype.subscription": "Subscription",
		"admin.entity.promotionrewardtabs.shippingaddresszones": "Shipping Address Zones",
		"admin.entity.workflowtabs.history": "Trigger History",
		"admin.entity.processeventregistration.confirm_success": "Registration has been Confirmed.",
		"define.qosh": "QOSH",
		"admin.entity.tasktabs.taskschedule": "Task Schedule",
		"admin.entity.processvendororder.receive_success": "Vendor Order Received",
		"entity.product.relatedproducts": "Related Products",
		"entity.vendororder.process.receive": "Receive Vendor Order",
		"entity.country.statecodelabel": "State Code Label",
		"admin.entity.createpromotionrewardcontentaccess": "Content Access Product Discount",
		"entity.orderpayment.paymentterm": "Payment Term",
		"permission.setting.deletetaxcategory": "Tax Category - Delete",
		"entity.session.cart": "cart",
		"entity.promotionaccount.account": "Account",
		"entity.locationaddress.locationaddressid": "Location Address ID",
		"admin.entity.createaddresszonelocation_nav": "Add Location to Zone",
		"entity.attributeset.accountsaveflag": "Enable Account Saving",
		"admin.entity.createreport": "Create Saved Report",
		"entity.pricegroup.inheritsfromnothing": "No (Do not inherit)",
		"setting.globalurlkeyproducttype": "Product Type URL Key",
		"entity.promotion.promotionname": "Promotion Name",
		"admin.entity.fulfillmentmethodtabs.fulfillmentsettings": "Fulfillment Method Settings",
		"admin.entity.ordertabs.orderreturns": "Order Returns",
		"validate.create.product_create.renewalsubscriptionbenefits.required": "You must define a Renewal Benefit.",
		"entity.define.effectivedatetime": "Effective Date Time",
		"entity.product.subscriptiontermsrequired": "Subscription Terms are Required",
		"entity.orderfulfillment.total": "Fulfillment Total",
		"setting.integrationupscustomerclassificationcode": "Customer Classification Code (advanced optional) ",
		"permission.product.editsubscriptionbenefit": "Subscription Benefit - Edit",
		"entity.pricegroup.pricegroupname": "Price Group Name",
		"entity.order.process.create": "Create Order",
		"permission.setting.deleteterm": "Term - Delete",
		"entity.vendoraddress.vendor": "vendor",
		"entity.define.amountcharged": "Amount Charged",
		"define.never": "Never",
		"entity.attribute.attributeinputtype.atrichtexteditor": "Rich Text Editor",
		"defaultmessage_notinlist": "{1} was found in the list: {2}.",
		"permission.setting.deletelocation_missing": "Location - Delete",
		"entity.commentrelationship.referencedexpressionvalue": "Referenced Expression Value",
		"entity.orderpayment.orderpaymentstatustype": "Order Payment Status Type",
		"entity.order.accountloyaltytransactions": "Account Loyalty Transactions",
		"entity.vendoremail.vendor": "vendor",
		"entity.integration.customreadyflag": "Custom Ready Flag",
		"admin.entity.orderpaymenttabs.appliedaccountpayments": "Applied Account Payments",
		"entity.currency_plural": "Currencies",
		"event.onevent": "On Event",
		"entity.paymenttransaction.securitycodematchflag": "Security Code Match",
		"entity.attributeset": "Attribute Set",
		"entity.promotionreward.excludedbrands": "Brand Exclusions",
		"entity.attribute.process.addformquestion": "Add Form Question",
		"entity.paymentmethod.saveaccountpaymentmethodencryptflag_hint": "Selecting this option will store the secure payment info in an encrypted format when saving an Account Payment Method.  It is not recommended, as other options like generating tokens are typically better.",
		"entity.sku.skudefinition": "Sku Definition",
		"entity.paymentterm": "Payment Term",
		"define.qvomin": "QVOMIN",
		"entity.term.termmonths": "Term Months",
		"admin.main.encryption.batchsizelimit": "Batch Size Limit",
		"define.exportlist": "Export List",
		"admin": "Admin",
		"entity.setting": "Setting",
		"entity.attributeset.requiredflag": "Required Flag",
		"permission.order": "Order",
		"admin.entity.listemail": "Logged Emails",
		"setting.globalencryptionalgorithm": "Encryption Algorithm",
		"entity.brand.vendors": "Vendors",
		"entity.stockadjustment.process.addstockadjustmentitem": "Add",
		"entity.shippingmethodrate.shipmentquantityrange": "Quantity Range",
		"entity.subscriptionusage.currentstatustype": "Current Status",
		"entity.address.streetaddress_validaterequired": "Please enter a vaild Street Address",
		"entity.product.allowpreorderflag": "Preorder OK",
		"admin.main.about": "About",
		"admin.processorder_addorderitem.quantity.invalid": "You're order item quantity must not be less than the gift cards you have assigned and no more than 1000.",
		"define.qnroro.full": "Not Received On Return Order",
		"admin.entity.skutabs.locationconfigurations": "Location Configurations",
		"entity.shippingmethodoption.shippingmethodoptionsplitshipments": "Shipping Method Option Split Shipments",
		"entity.pricegrouprate_plural": "Price Group Rates",
		"define.phonenumber": "Phone Number",
		"entity.product.loyaltyaccruements": "Loyalty Accruements",
		"entity.shippingmethod.eligibleaddresszone_hint": "Limits a shipping method to only be used for a given address Zone.  Leave blank to allow for all address",
		"entity.category.categoryidpath": "Category ID Path",
		"entity.physical.process.addphysicalcount": "Add Physical Count",
		"entity.promotionapplied_plural": "Applied Promotions",
		"setting.contentincludechildcontentproductsflag_hint": "By selecting this option, and products that are assinged to child listing pages of this listing page will be included in the product list.",
		"validate.createtransaction.orderpayment.orderstatuscode.inlist": "You cannot process a payment transaction because the order is not in acceptable status",
		"processobject.product_addsubscriptionterm.listprice": "List Price",
		"permission.setting.editschedule": "Schedule - Edit",
		"entity.paymentterm_plural": "Payment Terms",
		"report.appliedpromotionreport.promotionapplieddatetime": "Discount Applied Date Time",
		"entity.product.process.addlocation": "Add location",
		"entity.loyaltyterm.loyaltytermname": "Loyalty Term Name",
		"entity.sku.calculatedskudefinition": "Sku Definition",
		"entity.orderfulfillment.fulfillmentmethod.shipping": "Shipping",
		"entity.brand.brandvendors": "brandVendors",
		"define.sunday": "Sunday",
		"setting.integrationsofortassumeuntraceableassuccess": "Assume untraceable payments are successfull",
		"permission.setting.editorderorigin": "Order Origin - Edit",
		"entity.optiongroup.sortorder": "Sort Order",
		"setting.accountpaymentterm": "Default Account Payment Term",
		"entity.stockreceiver.receivertype.vendororder": "Vendor Order",
		"entity.collection.collectionid": "Collection ID",
		"entity.term.initialsubscriptionusageterms": "Initial Subscription Usage Terms",
		"entity.task.taskmethod.updatecalculatedproperties": "Update Calculated Properties",
		"entity.productreview.account": "Account",
		"define.password": "Password",
		"entity.stockadjustmentitem.stockadjustmentdeliveryitems": "Stock Adjustment Delivery Items",
		"entity.account.accountemailaddresses": "Account Email Addresses",
		"define.image": "Image",
		"entity.audit.auditdatetime": "Date",
		"processobject.sku_changeeventdates.scheduleenddate": "Schedule end date",
		"entity.product.datelastreceived": "dateLastReceived",
		"entity.content.productlistingpageflag_hint": "By selecting 'Yes' here, this page will show up in the Slatwall admin for a product under the Product Pages so that individual products can be added to this page to build out a list or grid.",
		"entity.sku.alloweventwaitlistingflag": "Allow Waitlisting",
		"entity.stockadjustment.fromlocation": "From Location",
		"setting.integrationpayflowproaccountpaymentcommentonetemplate": "Account Payment Comment One Template",
		"entity.session.sessionexpirationdatetime": "Session Expiration Time",
		"entity.subscriptionterm.autorenewflag_hint": "If this is set to 'Yes' then a renewal order will be automatically created at the end of the subscription term",
		"setting.productimageoptioncodedelimiter": "Product Image Option Code Delimiter",
		"permission.setting.createtaxcategory": "Tax Category - Create",
		"setting.integrationsofortapikey": "API Key",
		"entity.content.urltitle": "URL Title",
		"entity.setting.shippingmethodrate": "Shipping Method Rate",
		"admin.entity.orderpaymenttabs.paymenttransactions": "Payment Transactions",
		"entity.orderdelivery.deliveryopendatetime": "Delivery Open Date",
		"entity.task.taskconfig": "Task Config",
		"entity.define.expirationyear": "Expiration Year",
		"entity.producttype.producttypedescription": "Product Type Description",
		"validate.processproduct_create.scheduleenddate_defined": "Schedule end date must be defined for recurring schedules.",
		"entity.define.companypaymentmethodflag_hint": "This should be set to 'No' if the payment being use is a personal card, or 'Yes' if the card is a company card.",
		"admin.entity.ordertabs.orderdeliveries": "Order Deliveries",
		"entity.orderdelivery.shippingaddress": "Shipping Address",
		"entity.account.process.create": "Create Account",
		"report.orderitemreport": "Order Item Sales Report",
		"setting.integrationendiciapassphrase": "Pass Phrase",
		"entity.define.bankaccountnumber": "Bank Account Number",
		"entity.order.orderitems": "Order Items",
		"entity.promotionqualifier.fulfillmentmethods": "Fulfillment Methods",
		"setting.integrationendiciaaccountid": "Account ID",
		"entity.account.termaccountorderpayments": "Term Account Order Payments",
		"entity.stockreceiver.packingslipnumber": "Packing Slip Number",
		"admin.entity.createpromotionqualifierfulfillment": "Fulfillment Qualifier",
		"entity.orderdelivery.containerlabel": "Shipping Label",
		"validate.edit.email.emailid.maxlength": "Logged Email is not editable.",
		"processobject.product_updateskus.updatepriceflag": "Update Price",
		"entity.sku.redemptionamount": "Redemption Amount",
		"entity.orderpayment.process.chargepreauthorization": "Charge Pre-Authorization",
		"entity.accountauthentication.integrationaccesstoken": "Integration Access Token",
		"setting.accountlockminutes_hint": "This is should be how many minutes that you want accounts to be locked for whenever they get locked. Min value of 30.",
		"api.define.delete_error": "There was an error trying to delete the ${EntityName}.",
		"setting.siterecaptchaprotectedevents": "Recaptcha Protected Events",
		"admin.entity.processaccount.changepassword_success": "Account password has been changed successfully.",
		"admin.entity.promotionqualifiertabs.producttypes": "Product Types",
		"permission.warehouse": "Warehouse",
		"entity.define.fulfillmentmethod": "Fulfillment Method",
		"entity.postalcode.latitude": "latitude",
		"entity.shippingmethodrate.splitshipmentweight": "Split Shipment Weight",
		"admin.entity.loyaltytabs.loyaltyredemption": "Loyalty Program Redemption Criteria",
		"entity.paymentmethod.saveorderpaymentencryptflag": "Encrypted & Save (OP)",
		"entity.orderpayment.dynamicamountflag": "Dynamic Amount",
		"entity.giftcard": "Gift Card",
		"entity.orderdelivery.deliveryclosedatetime": "Delivery Close Date",
		"entity.promotion.enddatetime": "End Date/Time",
		"entity.physical.physicalcounts": "Physical Counts",
		"entity.orderdeliveryitem.orderitem": "Order Item",
		"setting.integrationendiciasyncftpsitepassword": "FTP Sync Password",
		"admin.entity.preprocesssite": "Create Site",
		"entity.attributevalue.file": "File",
		"admin.entity.detailaccount.authenticationdetails": "Authentication Details",
		"entity.orderfulfillment.emailaddress": "Email Address",
		"entity.shippingmethodrate.ratemultiplieramount": "Rate Multiplier Amount",
		"setting.globalfiletypewhitelist": "Allowed File Types",
		"entity.physical.physicalname": "Physical Name",
		"entity.integration.shippingactiveflag": "Shipping Integration Active",
		"validate.save.orderpayment.giftcardnumberencrypted.giftcardnotappliedtoorder": "This Gift Card has already been applied to the order.",
		"processobject.orderdelivery_create.capturableamount": "Amount to be Captured",
		"entity.addresszone.norecords": "No Address Zones Defined",
		"validate.changeeventdates.sku_changeeventdates.eventstartdatetime.ltdatetimeproperty": "The event end date must occur after start date.",
		"entity.option.skus": "Skus",
		"admin.report.exportcsv": "Export CSV",
		"setting.paymentmethodmaximumordertotalpercentageamount_hint": "This setting allows you to define if you would like this particular payment method to only be a portion of the order total amount.  For example on a Term Payment method you may only want 50% of the order total to be used",
		"entity.promotionaccount.promotionaccountid": "Promotion Account ID",
		"entity.content.process.createsku": "Create Sku",
		"permission.setting.savemeasurementunit": "Measurement Unit - Save",
		"entity.entityqueuehistory.successflag": "Success",
		"permission.product.savebrand": "Brand - Save",
		"entity.workflowtaskaction.processmethod": "Process Method",
		"define.inherit": "Inherit",
		"admin.entity.promotionreward.editdisabled": "This promotion reward cannot be edited because its promotion period has expired.",
		"entity.emailbounce.relatedobject": "Related Object",
		"setting.integrationmuraaccountsynctype_hint": "This setting will define how accounts are synced back and forth between Mura and Slatwall.  The default is 'Mura System Users Only' which means that any new accounts in Slatwall will not create site members in Mura, but existing/new Mura system accounts will automatically have a linked account created in Slatwall.",
		"entity.inventory.orderdeliveryitem": "Order Delivery Item",
		"entity.product.shippingweightunitcode": "Shipping Weight Unit of Measurement",
		"entity.order.billingaddress": "Billing Address",
		"entity.promotionqualifier.maximumitemquantity": "Maximum Item Quantity",
		"email.email.emailbodytext": "Text Body",
		"entity.order.referencedorder": "Original Order",
		"entity.filerelationship.baseobject": "Base Object",
		"entity.brand.promotionqualifiers": "Promotion Qualifiers",
		"entity.order.ordernumber": "Order Number",
		"define.filter": "Filter",
		"admin.entity.orderitemgiftrecipienttabs.giftcards": "Gift Cards",
		"admin.entity.skutabs.accesscontents": "Access Content",
		"entity.account.passwordconfirm": "Confirm Password",
		"entity.subscriptionorderitem.orderitem": "Order Item",
		"entity.product.qea": "QEA",
		"entity.producttype.producttypeidpath": "Product Type ID Path",
		"entity.vendororder.type": "Type",
		"define.datetime": "Date Time",
		"validate.processorder_placeorder.duplicate": "The order could not be placed, because this order has already been placed.  This could be the result of double clicking the 'Submit' button which would indicate that the order has in fact been placed.",
		"admin.entity.editphysicalcountitem_disabled": "The physical count Item cannot be edited as the physical count has been committed.",
		"admin.entity.processaccount.redeemgiftcard_failure": "The gift card you have entered cannot be redeemed.",
		"validation.account_authorizeaccount.failure": "The username or password that you entered is invalid.",
		"admin.entity.processaccount.redeemgiftcard_success": "The gift card has been attached to the account.",
		"entity.subscriptionusagebenefitaccount.account": "Account",
		"entity.order.calculatedtotal": "Total",
		"permission.setting.editterm": "Term - Edit",
		"admin.main.encryption.updatepassword_title": "Update Password",
		"setting.productautoapprovereviewsflag": "Auto approve product reviews",
		"entity.promotionreward.maximumuseperorder": "Max. Use Per Order",
		"entity.brand.promotionrewardexclusions": "Promotion Reward Exclusions",
		"permission.setting.savetask": "Task - Save",
		"define.sortorder": "Sort Order",
		"admin.entity.processaccount.createpassword_success": "Account password created successfully.",
		"admin.pricing.createpromotionqualifierorder": "Create Promotion Qualifier Order",
		"setting.integrationvertexwebservicespassword_hint": "Used with Vertx Username when no Trusted ID is defined",
		"entity.orderfulfillment.itemdiscountamounttotal": "Item Discounts",
		"admin.define.detail_permission": "${itemEntityName} - View Details",
		"entity.product.allowshippingflag": "Shipping OK",
		"admin.entity.deleteaddresszonelocation_success": "The location has successfully been removed from this Address Zone.",
		"entity.workflow.modifiedby": "Modified By",
		"admin.entity.vendortabs.vendororders": "Orders",
		"entity.shippingmethod.delete_validateisdeletable": "This shipping method cannot be deleted because it has been used in an order.",
		"entity.skuprice.pricegroup": "Price Group",
		"entity.product.qia": "QIA",
		"entity.audit.audittype.login": "Login",
		"admin.main.about_title": "About",
		"entity.account.guestaccountflag": "Guest",
		"entity.order.refundshippingamount": "Refund Shipping Amount",
		"define.sameasprice": "Same As Price",
		"entity.giftcard.balanceamount": "Balance Amount",
		"entity.shippingmethodrate.defaultamount": "Default Amount",
		"entity.order.orderopenipaddress": "Order Open IP Address",
		"admin.entity.processgiftcard.redeemtoaccount_success": "The account has been successfully associated with the gift card.",
		"admin.entity.settingdefinedin": "Setting Defined In",
		"entity.email.emailfrom": "From",
		"entity.orderorigin.orderoriginid": "Order Origin ID",
		"admin.entity.formtabs.formresponses": "Form Responses",
		"entity.paymentmethod.creditcard": "Credit Card",
		"define.renewalterm": "Renewal Term",
		"admin.main.dashboard.recentproductreviews": "Recent Product Reviews",
		"entity.subscriptionusage.renewalsubscriptionusagebenefits": "Renewal Subscription Usage Benefits",
		"entity.subscriptionstatus.subscriptionstatuschangereasontype": "Subscription Status Change Reason Type",
		"entity.form.process.create": "Create Form",
		"entity.account.primaryemailaddress": "Account Primary Email Address",
		"entity.workflowtrigger": "Workflow Trigger",
		"admin.entity.detailorderitem.skupricewhenordered": "Sku Price When Ordered",
		"entity.subscriptionbenefit.pricegroups": "Price Groups",
		"api.define.delete_success": "The ${EntityName} was deleted successfully.",
		"entity.workflowtrigger.triggereventtitle": "Trigger Event Title",
		"admin.report.default.integrationreports": "Integration Reports",
		"permission.setting.saveaddresszone": "Address Zone - Save",
		"entity.orderreturn": "Order Return",
		"define.authorizeandcharge": "Authorize & Charge",
		"entity.order.paymentamountreceivedtotal": "Received Amount",
		"define.integration": "Integration",
		"entity.shippingmethodoptionsplitshipment_plural": "Shipping Method Option Split Shipments",
		"entity.accountpaymentmethod.paymenttransactions": "Payment Transactions",
		"admin.entity.createproduct.bundlecontentaccess_hint": "Would you like to bundle all pages selected into a single sku?",
		"admin.main.default": "Dashboard",
		"email.email.emailbodyhtml": "HTML Body",
		"admin.main.dashboard.recentvendorupdates": "Recent Vendor Updates",
		"entity.integration.authenticationreadyflag": "Authentication Ready Flag",
		"entity.shippingmethodrate.shippingrateid": "Shipping Rate ID",
		"entity.accountloyaltyredemption.redemptiontype.productpurchase": "Product Purchase",
		"entity.product.productcode_hint": "A unique string (alphanumeric, no spaces) to identify the product.",
		"setting.subscriptionusageautoretrypaymentdays_hint": "This is a comma seperated list that will try to automatically re-charge the payment on a renewal order every x,y,z days.",
		"entity.paymentmethod.process.processcheckpayment": "Process Check Payment",
		"entity.giftcardtransaction.debitamount": "Debit Amount",
		"processobject.product_create.renewalmethod": "Renewal Method",
		"entity.address.statecode": "State",
		"validate.addorderitem.order_addorderitem.quantity.minvalue": "You must enter 1 or greater for the order quantity.",
		"admin.entity.processorderdelivery.create_success": "Order Item Fulfillment was Successful",
		"entity.brand.brandwebsite_hint": "If the brand has an external website, insert it here. It should begin with http:// or https://",
		"entity.vendororder.vendororderstatustype": "Vendor Order Status Type",
		"admin.entity.processproduct.addeventschedule_success": "The Event Schedule has been successfully added.",
		"entity.addresszone.addresszonelocations": "Address Zone Locations",
		"define.delete": "Delete",
		"admin.entity.promotionrewardtabs.options": "Options",
		"entity.content.process.create": "Create Content",
		"admin.entity.updateskucache": "Update Sku Cache",
		"admin.entity.processphysical.addphysicalcount_success": "The file you uploaded was imported successfully.",
		"entity.stockadjustmentitem.stockadjustment": "Stock Adjustment",
		"entity.task.startdatetime": "Task Start Date",
		"admin.entity.updateskucache_success": "Sku Cache Update Started",
		"entity.shippingmethodoption.shiptocountrycode": "Ship To Country Code",
		"entity.vendoraddress.vendoraddresstype": "vendorAddressType",
		"entity.shippingmethodrate.shippingmethodoptions": "Shipping Method Options",
		"entity.vendorskustock.vendor": "vendor",
		"setting.productimageoptioncodedelimiter_hint": "Allows for you to define how default product images will be formatted.  Default Product Images start with the productCode, and then any option codes that have been defined as Image Option Groups.  This value is the delimiter that seperates the option codes.",
		"permission.setting.createroundingrule": "Rounding Rule - Create",
		"entity.product.originalprice": "originalPrice",
		"validate.processorderdelivery_create.captureamount": "There was an issue trying to capture the payments necessary to fulfill this order.  Please review order payments and try again.",
		"entity.email.emailbcc": "BCC",
		"entity.subscriptionbenefit.maxusecount": "Maximum Use Per Access Code",
		"setting.integrationfullcirclelocaltransferdirctory": "Local Transfer Directory",
		"entity.eventregistration.pendingclaimdatetime": "Pending Claim Date Time",
		"entity.subscriptionterm.subscriptiontermid": "SubscriptionTermID",
		"entity.define.quantityin": "Quantity In",
		"entity.stockadjustmentdelivery.stockadjustment": "Stock Adjustment",
		"entity.category": "Category",
		"entity.promotion.promotioncodes": "Promotion Codes",
		"entity.order.isguestaccount": "Guest Account",
		"validation.define.regex": "This input is invalid.",
		"entity.product.allowdropshipflag": "Dropship OK",
		"entity.orderitem.skuprice": "Sku Price",
		"admin.main.ckfinder_permission": "File Manager Access",
		"entity.loyaltyredemption.autoredemptiontype.none": "None",
		"permission.setting.deletecountrycountry": "- Delete",
		"defaultmessage_daterange": "{1} must be a valid date between {2} and {3}.",
		"entity.promotionqualifier.minimumorderquantity": "Minimum Order Qty.",
		"entity.taxcategory.taxcategorycode": "Tax Category Code",
		"entity.productbundlegroup.maximumquantity": "Max Quantity",
		"entity.form.formname": "Form Name",
		"defaultmessage_range": "{1} must be between {2} and {3}.",
		"setting.integrationstripeapiurl": "API Url",
		"setting.accounteligiblepaymentmethods": "Eligible Payment Methods",
		"entity.pricegroup.name": "Price Group Name",
		"entity.producttype.loyaltyredemptions": "Loyalty Redemptions",
		"permission.warehouse.createstockadjustment": "Stock Adjustment - Create",
		"entity.eventtrigger.emailtemplate": "Email Template",
		"entity.giftcard.process.redeemtoaccount": "Select Owner Account",
		"validate.createtransaction.orderpayment_createtransaction.amount.lteproperty": "The amount entered is outside the amount possible this type of transaction based on the Order Payment amount.",
		"setting.integrationpaypalexpressexternalpaymentreturnurl": "Payment Return URL",
		"entity.productschedule.productscheduleid": "Product Schedule ID",
		"entity.loyaltyredemption.loyaltyredemptionid": "Loyalty Program Redemption ID",
		"admin.main.update_success": "Slatwall updated successfully",
		"permission.setting.editpaymentmethod": "Payment Method - Edit",
		"entity.sku.renewalsubscriptionbenefits_required": "Please specify a Renewal Sku or a Renewal Subscription Benefit and Price.",
		"processobject.subscriptionusage_renew.renewalstarttype": "Renewal Start Type",
		"validate.account.phonenumber": "Invalid phone number",
		"entity.skualternate.skualternateid": "skuAlternateID",
		"define.none": "None",
		"entity.commentrelationship.comment": "Comment",
		"entity.product.promotionqualifiers": "Promotion Qualifiers",
		"permission.account.editpermissiongroup": "Permission Group - Edit",
		"entity.subscriptionstatus.subscriptionusage": "Subscription Usage",
		"entity.vendororderitem_plural": "Vendor Order Items",
		"entity.paymenttransaction.message": "Message",
		"admin.entity.selectpricegrouprate_nav": "Select Price Group",
		"entity.define.excludeflag": "Exclude",
		"admin.entity.listform": "Form Builder",
		"entity.paymenttransaction.transactionstarttickcount": "Transaction Start Tick Count",
		"entity.vendororderitem.quantityreceived": "Qty. Received",
		"entity.content.urltitlepath": "URL Title Path",
		"entity.taxcategoryrate.taxliabilityappliedtoitemflag": "Taxes Added to Order Item",
		"admin.entity.createproductimage": "Upload New Product Image",
		"entity.product.event.productcode": "Event Code",
		"define.merchandise": "Merchandise",
		"entity.order.process.cancelorder": "Cancel Order",
		"entity.stockreceiver.receivertype.stockadjustment": "Stock Adjustment",
		"entity.accountloyaltytransaction.pointsout": "Points Out",
		"entity.account.process.addaccountpayment": "Add Account Payment",
		"define.fourth": "fourth",
		"entity.taxcategory_plural": "Tax Categories",
		"entity.subscriptionterm.allowprorateflag_hint": "Selecting this options will allow for subscriptions to be pro-rated based on a schedule",
		"validate.create.processorderdelivery_create.orderdeliveryitems.hasquantityononeorderdeliveryitem": "At a minimum you must enter 1 quantity to fulfill.",
		"define.november": "November",
		"entity.promotionreward_plural": "Promotion Rewards",
		"entity.product.promotionrewards": "Promotion Rewards",
		"entity.order.process.placeorder.hassubscriptionwithautopayflagwithoutorderpaymentwithaccountpaymentmethod_info": "You have a Subscription Term with 'Auto-Pay' Set to yes, but no Payment Methods that allow for accounts to save\"",
		"define.url": "URL",
		"entity.app.appname": "Application Name",
		"entity.content.contenttemplatetype": "Template Type",
		"setting.contenthtmltitlestring": "Content HTML Title String",
		"entity.content.contentid": "Content ID",
		"define.may": "May",
		"admin.entity.processgiftcard.updateemailaddress_success": "You have successfully updated the email address for this gift card an email has been sent to the new address.",
		"permission.setting.createpaymentmethod": "Payment Method - Create",
		"admin.entity.skutabs.currencies.converted": "Converted",
		"admin.metaexists_error": "<strong>IMPORTANT:</strong> This version of Slatwall still has the /meta directory deployed which is used for development purposes only.  It should be removed from your install prior to being deployed in production.<br /><a href='?slatAction=main.removemeta' target='_self'>Remove /meta directory now</a>.",
		"validate.create.product_create.scheduleenddate.gtdatetimeproperty": "The Schedule End Date must be a date after the first Event End Date",
		"permission.setting.listmeasurementunit": "Measurement Unit - List",
		"define.premissions": "Permissions",
		"admin.entity.pricegrouptabs.assignedaccounts": "Assigned Accounts",
		"define.general": "General",
		"entity.productbundlegroup.productbundlegroupid": "Product Bundle Group ID",
		"admin.entity.subscriptionusagetabs.subscriptionusageaccess": "Access Codes",
		"entity.audit.frontendandadmin": "Audit history available, but only starts at point of first admin update",
		"entity.orderitem.orderfulfillment": "Order Fulfillment",
		"entity.fulfillmentbatch.fulfillmentbatchnumber": "Fulfillment Batch Number",
		"entity.order.process.addpromotioncode_success": "Promotion Code added Successfully",
		"entity.orderpayment.bankaccountnumberencrypted": "Bank account Number  Encrypted",
		"entity.audit.data": "Data",
		"validate.delete.order.statuscode.inlist": "Orders that have been placed can not be deleted.",
		"setting.producttypedisplaytemplate_hint": "The content object that you would like to use as the template for displaying product on the front-end.  Typically this is a page in your CMS or Custom Application",
		"setting.skueventattendancetype": "Attendance type",
		"setting.skuorderitemgiftrecipientemailtemplate": "sku order item gift recipient email template",
		"processobject.subscriptionusage_renew.saveaccountpaymentmethodname": "Nickname",
		"entity.subscriptionusage.renewalprice": "Renewal Price",
		"entity.formresponse.formresponseid": "Form Response ID",
		"entity.accountemailaddress.account": "Account",
		"admin.default.products_nav": "Products",
		"entity.stockreceiveritem.stock": "Stock",
		"entity.stock.qc": "qc",
		"entity.paymenttransaction.authorizationcodeinvalidflag": "Authorization Code Invalid Flag",
		"admin.entity.updatefrontendviews_confirm": "ARE YOU 100% SURE YOU WANT TO UPDATE ALL OF YOUR CUSTOM VIEWS? YOU MAY LOSE YOUR CUSTOMIZATIONS",
		"entity.taskschedule.successemaillist": "Success Emails",
		"frontend.account.edit": "Edit Account",
		"entity.taxcategoryrate.taxrate": "Tax Rate",
		"validate.eventscheduleconflict": "Another event is already schedule at that location during the specified time frame.",
		"entity.taxapplied": "Tax Applied",
		"entity.product.qoh": "QOH",
		"entity.stockreceiveritem_plural": "Stock Receiver Items",
		"admin.main.forgotpassword": "Forgot Password",
		"entity.product.qoo": "QOO",
		"entity.emailtemplate.emailbodyhtml": "Body HTML",
		"entity.eventregistration.process.notplaced": "Change to Not Placed",
		"admin.entity.promotionrewardtabs.brands": "Brands",
		"entity.define.countpostdatetime": "Count Post Date Time",
		"entity.promotion": "Promotion",
		"admin.entity.promotionreward.discounttype.amount": "Fixed Amount",
		"entity.emailverification_plural": "Email Verifications",
		"entity.eventregistration.emailaddress": "Email",
		"validate.delete.define.maxcollection": "This ${className} can not be deleted because it has ${propertyName} assigned to it.",
		"setting.imagemissingimagepath": "Missing Image Path",
		"frontend.checkout.saveshippingaddress": "Save & Continue",
		"entity.audit.auditid": "Audit ID",
		"entity.task.runningflag": "Running",
		"processobject.accountloyalty_manualtransaction.points": "Points",
		"entity.sku.delete_validateonesku": "The SKU cannot be deleted because each product must have at least one SKU.",
		"entity.orderfulfillment.process.fulfillitems": "Fulfill Items",
		"admin.entity.taxcategorytabs.rates": "Tax Rates",
		"entity.schedule.recuringinterval": "Recurring  Interval",
		"entity.sku.salepriceexpirationdatetime": "Sale Price Ends",
		"entity.subscriptionbenefit.subscriptionbenefitid": "Subscription Benefit ID",
		"entity.vendor.vendorid": "Vendor ID",
		"entity.physicalcountitem.physicalcountitemid": "Physical Count Item ID",
		"admin.entity.processeventregistration.register_success": "Status successfully changed to Registered.",
		"admin.entity.processorder.placeorder_success": "Order Placed Successfully.",
		"entity.file.download.filedownloaderror": "There was an error while trying to download the file",
		"setting.producttypemetadescriptionstring": "Product Type Meta Description String",
		"entity.vendoraccount.vendor": "Vendor",
		"processobject.product_addeventschedule.bundlelocationconfigurationflag_hint": "When selecting 'Yes' all of the confirguations selected will be joined into a single sku that one can register for.  If you would like people to select which location configuration they are registering for select 'No'.",
		"admin.entity.createshippingmethodrate_nav": "Manual Rate",
		"admin.entity.createpromotionrewardmerchandise": "Merchandise Product Discount",
		"define.through": "through",
		"setting.skuordermaximumquantity_hint": "Maximum per SKU Qty. allowed on order",
		"entity.vendoraccount": "Vendor Account",
		"admin.entity.processorderpayment.createtransaction_success": "Payment transaction successfully processed.",
		"setting.globalpagemyaccount": "My Account Page",
		"api.define.save_success": "The ${EntityName} was saved successfully",
		"entity.product.gender": "gender",
		"entity.skuprice.maxquantity": "Max Quantity",
		"validate.save.orderitem.quantity.hasquantitywithinmaxorderquantity": "The quantity that you have entered exceeds the maximum order quantity.",
		"entity.sku.process.addlocation": "Add Location",
		"entity.paymenttransaction.orderpayment": "Order Payment",
		"entity.emailbounce.rejectedemailfrom": "Rejected Email From",
		"setting.globalsmartlistgetallrecordslimit": "Smart List Get All Records Limit (0=unlimited)",
		"entity.loyalty.accountloyalties": "Account Loyalties",
		"entity.define.creditcardlastfour": "Last Four",
		"validate.define.filtersrequired": "Filter(s) are required",
		"entity.giftcard.activeflag": "Active Flag",
		"define.edit": "Edit",
		"define.manualin": "Manual In",
		"entity.promotioncode.delete_success": "Promotion Code Deleted",
		"entity.eventregistration": "Event Registration",
		"processobject.giftcard_toggleactive.activeflag": "Active",
		"entity.paymentmethod.saveaccountpaymentmethodtransactiontype_hint": "Typically used to generate 'tokens' from the processor, which are then stored with the 'Account Payment Method' to avoid encrypting & storing data.",
		"entity.pricegrouprate": "Price Group Rate",
		"entity.emailtemplate.emailtemplatefile_hint": "The template file is optional but if found it will be used to generate the actual email contents.  You can find these templates and add more in: {custom}/templates/email/{object}",
		"entity.order.assignedaccount": "Assigned Account",
		"error.unexpected.checklog": "There was an unexpected error processing your request.  Check the Slatwall Log for details.",
		"admin.entity.pricegroupratetabs.producttypes": "Product Types",
		"report.orderitemreport.returnafterdiscount": "Returned",
		"entity.location.parentlocation": "Parent Location",
		"entity.accountpaymentmethod.expirationyear": "Expiration Year",
		"entity.vendororderitem.quantity": "Qty.",
		"entity.orderpayment.process.runplaceordertransaction": "Run Place Order Transaction",
		"entity.accountpaymentmethod.account": "Account",
		"entity.audit.baseid": "Base ID",
		"processobject.subscriptionusage_renew.extendexpirationdate": "New Expiration Date",
		"define.actions": "Actions",
		"entity.orderitemgiftrecipient.orderitemgiftrecipientid": "Order Item Gift Recipient ID",
		"admin.entity.skutabs.skusettings": "Sku Settings",
		"entity.workflow.workflowname": "Workflow Name",
		"admin.entity.processorder.addorderitem_success": "Order Item successfully added",
		"entity.taxcategoryrate_plural": "Tax Category Rates",
		"entity.setting.sku": "Sku",
		"setting.skugiftcardenforceexpirationterm": "Enforce Gift Card Expiration Terms",
		"entity.email.process.addtoqueue": "Send Email",
		"setting.integrationavataxcompanycode": "Company Code",
		"entity.attribute.attributeinputtype.relatedobjectselect": "Related Object Select",
		"define.chargepreauthorization": "Charge Pre-Authorization",
		"define.noaccess": "You do not have access",
		"admin.entity.listapp": "Applications",
		"entity.brand.loyaltyredemptions": "Loyalty Redemptions",
		"entity.promotionqualifier.rewardmatchingtype.producttype": "Product Type",
		"entity.promotionperiod.promotion": "Promotion",
		"admin.entity.createlocationtransferadjustment_nav": "Location Transfer Adjustment",
		"entity.inventory_plural": "Inventory Transactions",
		"permission.setting.listroundingrule": "Rounding Rule - List",
		"setting.skuallowwaitlistingflag": "Allow waitlisting",
		"processobject.product_updateskus.updatelistpriceflag": "Update List Price",
		"entity.sku.subscriptionterm": "Subscription Term",
		"entity.product.process.updatedefaultimagefilenames_confirm": "Are you sure that you want to override the default image filename?  Doing this may remove your existing default images.",
		"permission.order.detailorder": "Order - Detail",
		"entity.email.relatedobjectprimaryidfield": "Related Object Primary ID Field",
		"entity.type.typename": "Name",
		"entity.updatescript.scriptpath": "Script Path",
		"entity.sku.stocks": "stocks",
		"processobject.product_uploaddefaultimage.uploadfile": "Select Image File",
		"entity.vendoraccount_plural": "Vendor Accounts",
		"validate.create.orderdelivery_create.orderdeliveryitems.hasrecipientsforallgiftcarddeliveryitems": "You do not have enough gift recipients to fulfill these items.",
		"entity.producttype.promotionqualifiers": "Promotion Qualifiers",
		"validate.audit.rollback.rollbackpointdoesnotexist": "Rollback point does not exist.",
		"setting.integrationusaepaypin": "Pin Number ",
		"permission.setting.deletecontent": "Content - Delete",
		"entity.account.process.resetpassword": "Reset Password",
		"entity.define.currencycode": "Currency Code",
		"setting.integrationorbitallivemodeflag": "Live Mode",
		"admin.entity.physicaltabs.discrepancies.qoh": "Quantity On Hand",
		"setting.integrationipaymentaccountid": "Account ID",
		"permission.pricing.deletepromotion": "Promotion - Delete",
		"setting.value": "Value",
		"entity.content.contentbody": "Content Body",
		"paypalexpress.main.main_permission": "PayPal Express Integration",
		"entity.define.shippingaccountaddress": "Shipping Account Address",
		"admin.entity.loyaltyredemptiontabs.producttypes": "Product Types",
		"validate.promotioncode.overmaximumusecount": "The promotion code that you have entered has exceeded the maximum number of usages.",
		"entity.report.reportname": "Report Name",
		"admin.entity.processcontent.duplicatecontent_failure": "The content could not be duplicated.",
		"admin.entity.settingstabs.locationconfiguration": "Location Configuration Settings",
		"entity.file.filedescription": "File Description",
		"entity.subscriptionterm.renewalterm_hint": "This defines the duration of all the subsequent auto-renew terms after the initial term.",
		"setting.skushippingweight": "Shipping Weight",
		"define.qvomax": "QVOMAX",
		"setting.integrationavataxcustomerusagetypepropertyidentifier_hint": "This is the property at the Account level where the user's tax exemption type is stored. Frequently, it is used to mark a customer as fully or partially tax exempt.",
		"entity.promotionreward.maximumuseperitem_hint": "This defines the maximum quantity of any single item that will have a discount applied.  If set to 10, and the item on the cart has a quantity of 15 the discount will only apply to the first 10 quantity.",
		"entity.subscriptionterm.skus": "SKUS",
		"setting.accountpaymentterm_hint": "This is the default term that will be applied to an accounts order when it is placed",
		"define.unknown": "Unknown",
		"define.gift-card": "Gift Card",
		"admin.entity.skutabs.saleshistory": "Sales History",
		"validate.accountpayment.offlineprocessingerror": "There was an unknown error trying to add an offline transaction for this order payment.",
		"entity.orderfulfillment.orderfulfillmentitems": "Order Fulfillment Items",
		"entity.attributeset.skus": "Skus",
		"validate.save.subscriptionterm.renewalreminderdays.regex": "The value entered for ${propertyName} should be numeric and optionally can be comma seperated.",
		"permission.product.editproducttype": "Product Type - Edit",
		"admin.entity.processproduct.uploaddefaultimage_success": "Product Image was Uploaded Successfully",
		"validate.order.orderitemoutofstock": "The product item can not be added to your order because of inventory constraints.",
		"entity.vendoremail.vendoremailtype": "vendorEmailType",
		"entity.remoteentity_plural": "Remote Entities",
		"entity.attribute.attributetype.atselectbox": "Select Box",
		"entity.country.localityshowflag": "Show Locality",
		"entity.currency.currencycode": "Currency Code",
		"permission.warehouse.detailstockadjustment": "Stock Adjustment - Detail",
		"setting.integrationpayflowprousername": "User Name",
		"entity.location.locationname": "Location Name",
		"setting.skuqatsincludesqnroroflag_hint": "By setting this to 'yes' any quantity not yet received on 'Open Return Orders' will be included in the Quantity Available To Sell",
		"validate.save.currencyrate.effectivestartdatetime.gtnow": "Start date must be greater than now.",
		"entity.eventtrigger_plural": "Event Triggers",
		"entity.promotionqualifier.skus": "Skus",
		"setting.integrationendiciasyncftpsitedropoffdirectory": "FTP Sync Dropoff Directory",
		"setting.integrationfullcirclelocaltransferurlpassword": "Local Transfer URL Password",
		"entity.address.street2address": "Street Address 2",
		"validate.create.account_create.emailaddress.getemailaddressnotinuseflag": "The email address that you have entered is already in use.  If you have forgotten you password, you can use the 'forgot password' tool to reset your password via email.",
		"entity.orderitem.estimatedfulfillmentdatetime": "Estimated Fulfillment Date Time",
		"entity.filerelationship.file": "File",
		"print.packingslip": "Packing Slip",
		"entity.schedule.schedulename": "Schedule Name",
		"entity.promotionreward.amounttype": "Discount Type",
		"entity.promotion_plural": "Promotions",
		"mura.main.updateviews": "Update Views",
		"admin.entity.subscriptionbenefittabs.categories": "Categories",
		"entity.product.productcode_validateunique": "The product code is already in use for another product.",
		"defaultmessage_isvalidobjectemptyarray": "validation failed because a valid array cannot be empty.",
		"admin.entity.processstockadjustment.additems": "Add Items",
		"admin.entity.skutabs.alternateskucodes": "Alternate Sku Codes",
		"validate.delete.sku.orderitems": "The sku cannot be delete because it has orders.",
		"setting.integrationpayleaplivemodeflag": "Live Mode",
		"entity.product.trackinventoryflag": "Track Inventory",
		"entity.sku.process.changeeventdates": "Edit Event Dates",
		"entity.app_plural": "Applications",
		"entity.category_plural": "Categories",
		"validate.delete.accountemailaddress.primaryflag.eq": "You cannot delete this email address because it is the accounts primary email address",
		"entity.printtemplate.printtemplateid": "Print Template ID",
		"validate.createpassword.account_createpassword.password.regex": "Admin passwords should include at least 1 letter, 1 number, and be 7 or more characters long.",
		"entity.product.allowbackorderflag": "Backorder OK",
		"processobject.sku_addlocation.editscope": "Edit scope",
		"entity.audit.audittype.update": "Updated",
		"setting.integrationvertexdivision": "Division",
		"entity.promotionqualifier.qualifiertype.contentaccess": "Content Access",
		"admin.entity.detailorderitem.currentskurenewalprice": "Current Sku Renewal Price",
		"setting.globalpublicautologoutminutes": "Log Out Public Accounts After X Minutes of Inactivity",
		"permission.setting.editattributeset": "Attribute Set - Edit",
		"define.credit": "Credit",
		"entity.workflowtaskaction.update": "Update",
		"entity.addresszone.addresszonename": "Address Zone Name",
		"entity.producttype_plural": "Product Types",
		"validate.changeeventdates.sku_changeeventdates.eventenddatetime.gtdatetimeproperty": "",
		"validate.define.bundlegrouprequired": "A Bundle Group is Required",
		"admin.entity.vendorordertabs.orderitems": "Order Items",
		"frontend.cart.detail": "Shopping Cart",
		"setting.paymentmethodstorecreditcardnumberwithorder": "Auto Store Credit Card Number With Order",
		"setting.integrationvertexsendinvoiceflag": "Send All Order Invoices To Vertex",
		"entity.collection.collectionname": "Collection Name",
		"setting.integrationupsshipfromname": "Shipping Name",
		"admin.entity.emailtabs.textbody": "Text Body",
		"setting.globalassetsfilefolderpath": "File Assets Folder Path",
		"entity.measurementunit.measurementtype": "Measurement Type",
		"entity.commentrelationship.referencedexpressionproperty": "Referenced Expression Property",
		"entity.orderpayment.referencingorderpayments": "Referencing Order Payments",
		"setting.iintegrationauthorizenettestmodeflag": "Test Mode ",
		"admin.entity.processeventregistration.cancel_success": "Registration has been Cancelled.",
		"validate.account.forgotnotfound": "No account found with the email you provided",
		"entity.vendoraddress.vendoraddressid": "vendorAddressID",
		"frontend.account.detail.header": "Account Details",
		"entity.order.orderreturns": "Order Returns",
		"entity.audit.changedetails.propertychanged.create": "Set",
		"entity.orderpayment.providertoken": "Provider Token",
		"entity.vendorskustock.cost": "cost",
		"permission.setting.deleteschedule": "Schedule - Delete",
		"entity.sku.delete_validateordered": "This SKU cannot be deleted because it has been ordered.",
		"entity.productbundlegroup.skucollectionconfig": "Sku Collection Config",
		"entity.productschedule.recurringtimeunit": "Recurs",
		"setting.integrationorbitalbin": "BIN",
		"admin.entity.settingstabs.image": "Image Settings",
		"entity.orderitem.price": "Price",
		"permission.account.editaccount": "Account - Edit",
		"admin.main.update_nav": "Update Slatwall",
		"admin.entity.accountloyaltytabs.accountloyaltytransactions": "Account Loyalty Transactions",
		"define.september": "September",
		"admin.entity.updatefrontendviews_nav": "Update All Frontend Views",
		"entity.attributevalue.brand": "Brand",
		"entity.addresszonelocation.addresszone": "Address Zone",
		"processobject.order_addorderitem.saveshippingaccountaddressname": "Nickname",
		"entity.producttype.promotionqualifierexclusions": "Promotion Qualifier Exclusions",
		"entity.email.emailname": "Email Name",
		"entity.workflowtask.norecordsfound": "No tasks have been created",
		"entity.type.typeidpath": "Type ID Path",
		"entity.order.referencedorderid": "Referenced Order ID",
		"entity.shippingmethod.delete_success": "Shipping Method was saved successfully",
		"entity.taskhistory.response": "Response",
		"entity.accountpayment.bankroutingnumberencrypted": "Bank Routing Number Encrypted",
		"entity.eventregistration.process.pendingconfirmation": "Change to Pending Confirmation",
		"entity.physicalcountitem.sku": "Sku",
		"entity.workflowtrigger.triggerevent": "Trigger Event",
		"entity.accountpaymentmethod.accountpaymentmethodid": "Account Payment Method ID",
		"entity.stockadjustment.type": "Type",
		"entity.attribute.attributetype.relatedobjectmultiselect": "Related Object Multiselect",
		"admin.entity.addorderitemgiftrecipient.createrecipient": "Create Recipient",
		"entity.productimage.imagedescription": "Image Description",
		"entity.term.termname": "Term Name",
		"admin.account.processsubscriptionusage.cancel_success": "This subscription usage has been successfully canceled.",
		"entity.product.webqc": "webQC",
		"entity.vendororder.estimatedreceivaldatetime": "Estimated Receival",
		"entity.subscriptionusagebenefit.renewalsubscriptionusage": "Renewel Subscription Usage",
		"entity.loyaltyredemption.excludedbrands": "Excluded Brands",
		"setting.globalencryptionservice": "Encryption Service",
		"entity.accountpaymentapplied.accountpayment": "Account Payment",
		"entity.country.street2addresslabel": "Street2 Address Label",
		"setting.integrationuspstestingflag": "Test Mode ",
		"entity.email.relatedobjectid": "Related Object ID",
		"setting.integrationpayflowprolivemodeflag": "Live Mode",
		"entity.loyaltyredemption.redemptionpointtype.monthly": "Monthly Point Balance",
		"permission.product.deleteproductreview": "Product Review - Delete",
		"entity.product.webqoh": "webQOH",
		"entity.order.shippingaccountaddress": "Shipping Account Address",
		"entity.paymentmethod": "Payment Method",
		"entity.alternateskucode.alternateskucodeid": "Alternate Sku Code ID",
		"admin.define.detail_nav": "View ${itemEntityName}",
		"report.orderitemreport.returnprediscount": "Pre Discount Return",
		"entity.session.lastrequestipaddress": "Last Request IP Address",
		"setting.integrationpayflowpropartnerid": "Partner ID",
		"admin.productbundle.bundlegrouptype": "Bundle Group Type",
		"setting.integrationfullcirclefcftpusesecure": "Use Secure FTP (SFTP)",
		"entity.emailbounce.rejectedemailsubject": "Rejected Email Subject",
		"setting.integrationvertexdepartment": "Department",
		"entity.commentrelationship.referencedexpressionentity": "Referenced Expression Entity",
		"define.discount": "Discount",
		"setting.skubundleautobreakupinventoryonreturnflag": "Bundle Auto Breakup Inventory On Return",
		"entity.brand.loyaltyredemptionexclusions": "Loyalty Redemption Exclusions",
		"define.order": "Order",
		"processobject.sku_editcapacity.editscope": "Edit scope",
		"entity.orderpayment.order": "Order",
		"entity.addresszone.taxcategoryrates": "Tax Category Rates",
		"entity.taxapplied.taxlocality": "Tax Locality",
		"entity.email": "Email",
		"entity.accountpayment": "Account Payment",
		"entity.loyalty.loyaltyredemptions": "Loyalty Redemptions",
		"admin.entity.createmanualoutadjustment_nav": "Manual Out Adjustment",
		"setting.globalextendedsessionautologoutindays": "Log out public users after x days of inactivity when using extended sessions.",
		"entity.accountpaymentmethod.creditcardnumber": "Credit Card Number",
		"entity.accountloyalty.process.manualtransaction": "Manual Transaction",
		"admin.define.list_permission": "${itemEntityName} - View List",
		"entity.subscriptionterm.graceperiodterm": "Grace Period Term",
		"setting.skudefaultimagenamingconvention": "Default Image Naming Convention",
		"define.firstname": "First Name",
		"setting.skuqatsincludesqnrovoflag_hint": "By setting this to 'yes' any quantity not yet received on 'Open Vendor Orders' will be included in the Quantity Available To Sell",
		"entity.integration.fw1readyflag": "FW1 Ready Flag",
		"entity.loyaltyredemption.producttypes": "Product Types",
		"entity.stockadjustmentdeliveryitem.stockadjustmentitem": "Stock Adjustment",
		"setting.siterecaptchasecretkey": "Recaptcha Secret Key",
		"entity.stock.vendororderitems": "Vendor Order Items",
		"entity.order.stockreceivers": "Stock Receivers",
		"entity.taxapplied.appliedtype": "Applied Type",
		"entity.locationconfiguration_plural": "Location Configurations",
		"entity.commentrelationship_plural": "Comment Relationships",
		"entity.stockadjustment.purchaseorder": "purchaseOrder",
		"entity.stockreceiver.stockadjustment": "Stock Adjustment",
		"entity.user.firstname": "firstName",
		"entity.accountemailaddress.emailaddressconfirm": "Confirm Email Address",
		"entity.stockadjustmentdeliveryitem.stock": "Stock",
		"setting.integrationclickandbuyprojectid": "Project ID",
		"entity.vendoraddress_plural": "Addresses",
		"entity.option.optionimage_hint": "Select Associated Option Image to Upload (optional)",
		"setting.globalnosessionpersistdefault_hint": "If this is set to yes then sessions will only be persisted when they need to for login & carts",
		"admin.entity.promotionqualifiertabs.fulfillmentmethods": "Fulfillment Methods",
		"admin.warehouse.detailstockadjustment.fromlocationname": "From Location Name",
		"admin.export.listfiltered": "Export Filtered List",
		"entity.content.contenttemplatefile": "Template",
		"permission.setting.createtype": "Type - Create",
		"entity.productbundlegroup.maximumquantity_hint": "This defines the maximum quantity of items that can be selected for this group on a per bundle build up basis.  Leave blank for unlimited",
		"setting.integrationfedexshipperstatecode": "Shipping From State Code ",
		"entity.loyaltyaccruement.excludedbrands": "Excluded Brands",
		"admin.entity.settingstabs.task": "Task Settings",
		"entity.shippingmethodoption.totalcharge": "Total Charge",
		"entity.task.taskhistories": "Task History",
		"admin.pricing.createpromotionqualifierfulfillment": "Create Promotion Qualifier Fulfillment",
		"entity.taskschedule.startdatetime": "Start Date",
		"admin.pricing.createpromotionrewardfulfillment": "Create Promotion Reward Fulfillment",
		"entity.accountpaymentmethod.bankroutingnumber": "Bank Routing Number",
		"entity.shippingmethodrate.shippingmethodratename": "Rate Name",
		"entity.sku.qc": "QC",
		"setting.integrationorbitalmerchantidbycurrencycodelist_hint": "This should be a comma seperated list of currencyCode=merchantID.  If this setting is defined the Merchant ID setting will only be used if the currency code for the transaction isn't defined in this list.  For example: USD=192001,CAD=192002 ",
		"entity.currency.currencyisonumber": "ISO Number",
		"entity.orderfulfillment.fulfillmentshippingmethodoptions": "Fulfillment Shipping Method Options",
		"entity.orderitem.quantityunreceived": "Qty. Unreceived",
		"entity.account.cmsaccountid": "CMS Account ID",
		"entity.accountpayment.termoffsetunreceived": "Amount Unreceived",
		"admin.entity.detailpromotion.initialperiod": "Initial Period",
		"admin.entity.ordertabs.promotions": "Promotions",
		"admin.entity.settingstabs.paymentmethod": "Payment Method Settings",
		"setting.integrationmuralookuplistingcontentobjects": "Lookup Listing Page Content Objects",
		"setting.integrationorbitalmerchantid": "Merchant ID",
		"setting.integrationupspassword": "UPS Password ",
		"entity.workflowtrigger.triggertype": "Trigger Type",
		"define.amount": "Amount",
		"entity.taxcategoryrate.addresszone": "Address Zone",
		"setting.integrationfullcirclelocaltransferurlpassword_hint": "If the transfer URL sits behind a Username or Password then please specify it here.",
		"api.define.create_error": "There was an error trying to create the ${EntityName}.",
		"setting.integrationipaymentinvoicetext": "Invoice Text (max. 25)",
		"endicia.main.syncall_permission": "FTP Sync Both",
		"entity.shippingmethodoptionsplitshipment.shipmentcharge": "Shipment Charge",
		"entity.term.loyaltyaccruementexpirationterms": "Loyalty Accruement Expiration Terms",
		"admin.entity.loyaltyredemptiontabs.brands": "Brands",
		"entity.commentrelationship.referencedrelationshipflag": "Referenced Relationship Flag",
		"frontend.checkout.saveshippingmethod": "Save & Continue",
		"define.year": "year",
		"entity.contentaccess_plural": "Content Accesses",
		"entity.promotionaccount": "Promotion Account",
		"entity.subscriptionbenefit.skus": "SKUS",
		"entity.session.loggedindatetime": "Logged In Datetime",
		"admin.entity.subscriptionusagetabs.orderitems": "Order Items",
		"entity.fulfillmentmethod.fulfillmentmethodid": "Fulfillment Method ID",
		"setting.integrationvirtualmerchanttestmerchantid": "Test VirtualMerchant ID (6 Digit)",
		"entity.subscriptionusage.initialorder": "Initial Order",
		"entity.option.optioncode_hint": "A unique string (alphanumerc, no spaces) to identify the option.",
		"setting.skuregistrationapprovalrequiredflag": "Registration Approval Required",
		"entity.paymentmethod.paymentmethodname": "Payment Method Name",
		"entity.producttype.attributevalues": "Attribute Values",
		"entity.integration_plural": "Integrations",
		"entity.loyalty.loyaltyterms": "Loyalty Terms",
		"validate.create.product_create.purchasestartdatetime.gtnow": "Purchase Start Date must occur in the future",
		"admin.entity.processorder.addorderitem_error": "There was an error adding the Order Item to this Order",
		"entity.state.country": "country",
		"admin.entity.detailorderfulfillment.item_totals": "Item Totals",
		"entity.accountpayment.accountpaymentmethod": "Account Payment Method",
		"entity.productreview": "Product Review",
		"entity.orderfulfillment.quantityundelivered": "Quantity Undelivered",
		"validate.newpassword.duplicatepassword": "Your new password cannot be same as the previous 4 passwords.",
		"entity.product.onclearancesale": "onClearanceSale",
		"entity.stockadjustment": "Stock Adjustment",
		"entity.orderitem.ordershipment": "Order Shipment",
		"admin.entity.processsubscriptionusage.addusagebenefit_success": "Subscription Benefit Added",
		"processobject.product_addsubscriptionsku.renewalmethod": "Renewal Method",
		"entity.producttype.pricegrouprateexclusions": "Price Group Rate Exclusions",
		"entity.product.madeincountry": "madeInCountry",
		"admin.entity.orderdeliverytabs.orderdeliveryitems": "Order Delivery Items",
		"entity.loyaltyredemption.excludedproducttypes": "Excluded Product Types",
		"entity.collection.baseentityname": "Object Type",
		"entity.currencyrate.conversionrate": "Conversion Rate",
		"entity.orderitem": "Order Item",
		"entity.physical.products": "Physical Products",
		"admin.entity.preprocessorder_addorderitem.wrongcurrency_info": "The item that you have attempted to add, can not be sold in the same currency as this order.",
		"entity.report.dynamicdaterangetype.weektodatemonday": "Week to Date ( Starting Monday )",
		"entity.product.loyaltyaccruementexclusions": "Loyalty Accruement Exclusions",
		"define.categories": "Categories",
		"entity.sku.promotionqualifiers": "Promotion Qualifiers",
		"entity.orderpayment.giftcardtransactions": "Gift Card Transactions",
		"entity.productschedule.eventstarttime": "Event start time",
		"setting.accountlockminutes": "Lock Accounts For x Minutes",
		"setting.integrationstripetestmode": "Test Mode",
		"entity.content.site": "Site",
		"validate.addeventschedule.product_addeventschedule.eventendtime.gtdatetimeproperty": "Event end date must occur after start date.",
		"entity.shippingmethodoption.totalshippingitemprice": "Total Shipping Item Price",
		"entity.brand": "Brand",
		"admin.entity.processgiftcard.redeemtoaccount_failure": "The account could not be associated with this gift card.",
		"setting.skuqatsincludesqnrosaflag_hint": "By setting this to 'yes' any quantity not yet received on 'Open Stock Adjustments' will be included in the Quantity Available To Sell",
		"define.permissions": "Permissions",
		"entity.taxapplied.taximpositiontype": "Tax Imposition Type",
		"entity.audit.sessionaccountemailaddress": "Email",
		"permission.pricing.detailpromotion": "Promotion - Delete",
		"define.thursday": "Thursday",
		"admin.entity.settings": "Settings",
		"setting.integrationfullcirclefcftpusername_hint": "Username to connect to FC Server via FTP",
		"admin.entity.pricegroupratetabs.currencies": "Currencies",
		"setting.subscriptionusageautoretrypaymentdays": "Auto Retry After Day(s)",
		"admin.entity.settingstabs.brand": "Brand Settings",
		"define.email": "Email",
		"setting.skuorderminimumquantity": "Min Order Qty.",
		"validate.delete.locationaddress.locationaddressid.hasnoassociatedorders": "This location address cannot be deleted. It is associated to an order.",
		"permission.setting.editlocation": "Location - Edit",
		"entity.app.approotpath": "Application Root Path",
		"entity.comment.commentrelationships": "Comment Relationships",
		"entity.taxcategoryrate.taxintegration": "Tax Integration",
		"setting.integrationmuralegacycreateaccount": "Legacy Create Account Filename",
		"entity.orderreturn.fulfillmentrefundamount": "Fulfillment Refund Amount",
		"validate.delete.orderitem.orderstatuscode.inlist": "Cannot delete an orderitem which is part of a processed order.",
		"entity.productlistingpage_plural": "Product Listing Pages",
		"permission.setting.listorderorigin": "Order Origin - List",
		"setting.skuregistrationautoapprovalaccountcollection": "Registration Auto Approval Accounts",
		"setting.globalcurrencytype": "Currency Type",
		"entity.shippingmethodrate.shippingintegrationmethod": "Service Provider Method",
		"admin.setting_nav": "View A List of Settings",
		"entity.shippingmethodoptionsplitshipment.shippingmethodoption": "Shipping Method Option",
		"validate.order.account.populate": "Customer Account is required.",
		"setting.integrationgigyalegacyuidpropertyidentifier": "Legcacy Gigya UID Property Identifier (advanced)",
		"entity.define.productreviews": "Product Reviews",
		"admin.entity.settingstabs.email": "Email Settings",
		"defaultmessage_pastdate": "{1} must be a date in the past.",
		"entity.location_plural": "Locations",
		"entity.promotionqualifier.producttypes": "Product Types",
		"entity.sku.loyaltyaccruements": "Loyalty Accruments",
		"define.graceperiod": "Grace Period",
		"permission.integration": "Integration",
		"paypalexpress_permission": "PayPal Express Integration",
		"define.language.de_de": "German",
		"entity.measurementunit.conversionratio": "Conversion Ratio",
		"permission.product": "Product",
		"setting.integrationfullcirclefcftppassword": "Full Circle FTP Password",
		"entity.taxapplied_plural": "Applied Taxes",
		"entity.task.taskmethod.updateeventwaitlists": "Update Event Waitlists",
		"entity.integration.customactiveflag": "Custom Integration Active",
		"entity.orderdeliveryitem.orderdelivery": "Order Delivery",
		"entity.email.relatedobject": "Related Object",
		"entity.app.appid": "App ID",
		"permission.product.listproductreview": "Product Review - List",
		"setting.integrationfullcirclelocaltransferurlpath_hint": "This needs to be a URL that points to the Transfer Directory so that transfer files can be imported over HTTP. Example: http://202.202.202.202/fctransfer",
		"setting.contentmetakeywordsstring": "Content Meta Keywords String",
		"setting.integrationmuracreatedefaultpages": "Create Default Pages and Templates",
		"entity.order.process.updatestatus": "Force Status Update",
		"validate.create.product_create.eventstartdatetime.gtnow": "Event Start Date must occur in the future",
		"entity.define.modifiedbyaccount": "Modified By",
		"entity.paymentterm.paymenttermid": "Payment Term ID",
		"entity.postalcode_plural": "Postal Codes",
		"entity.vendorphonenumber": "Vendor Phone Number",
		"entity.attribute.decryptvalueinadminflag": "Decrypt Value In Admin",
		"admin.main.encryption.reencryptdata_now": "Re-encrypt Now",
		"entity.country_plural": "Countries",
		"entity.report.dynamicdaterangeendtype": "Date Range As Of",
		"entity.attributevalue.vendororder": "Vendor Order",
		"entity.workflowtaskaction.export": "Export",
		"entity.productbundlebuild_plural": "Product Bundle Builds",
		"setting.contentrequirepurchaseflag": "Require Purchase for Access",
		"admin.entity.processorder.placeonhold_success": "This order has been placed 'On Hold'.",
		"entity.user.company": "company",
		"define.giftmessage": "Gift Message",
		"entity.promotioncode_plural": "Promotion Codes",
		"entity.eventregistration.process.attend": "Change to Attended",
		"setting.integrationavataxsourcecity": "Source City",
		"setting.skugiftcardcodelength": "Length of Autogenerated Gift Card Code",
		"permission.main": "Main",
		"entity.productbundlegroup_plural": "Product Bundle Groups",
		"setting.integrationsofortcustomerid": "Customer ID",
		"admin.entity.createproduct.bundlecontentaccess": "Bundle Content",
		"permission.setting.detailcategory": "Category - Detail",
		"entity.giftcard.giftcardpin": "Gift Card Pin",
		"validate.save.country.countrycode3digit.maxlength": "Country Code 3 Digit must be 3 characters",
		"entity.product.datefirstreceived": "dateFirstReceived",
		"entity.accountemailaddress_plural": "Account Email Addresses",
		"define.qc.full": "Committed",
		"mura.muraevent.oncontentedit.createskuheader": "Create SKU to Sell Content",
		"entity.emailverification.accountemailaddress": "Account Email Address",
		"entity.define.expirationdate": "Expiration Date",
		"setting.integrationgigyasecretkey": "Secret Key",
		"define.authorize": "Authorize",
		"entity.taxapplied.taxrate": "Tax Rate",
		"entity.loyaltyaccruement.startdatetime": "Start Date/Time",
		"permission.pricing.editpromotion": "Promotion - Edit",
		"entity.skubundle_plural": "Sku Bundles",
		"entity.define.createdbyaccount": "Created By",
		"setting.emailimapserver": "Bounced Email Server (IMAP)",
		"entity.vendororder.vendorordernumber": "Order Number",
		"entity.giftcardtransaction.giftcardtransactionid": "Gift Card Transaction ID",
		"entity.paymentmethod.subscriptionrenewaltransactiontype": "Subscription Renewal Trans.",
		"entity.giftcard.calculatedbalanceamount": "Balance Amount",
		"entity.loyaltyaccruement.accruementtype.fulfillmentmethodused": "Fulfillment Method Used",
		"setting.productautoapprovereviewsflag_hint": "Selecting this option will automatically setup product reviews to be able to be approved automatically and show up on the front end of the site.",
		"admin.define.delete": "Delete ${itemEntityName}",
		"permission.integration.editintegration": "Integration - Edit",
		"define.length": "Length",
		"entity.postalcode.state": "state",
		"entity.loyaltyterm.loyalty": "Loyalty",
		"setting.accounteligiblepaymentmethods_hint": "This should be a list of all the available payment methods an account can utilize on their orders.",
		"setting.integrationfedextestingflag": "Test Mode ",
		"entity.product.process.addeventinstance": "Add Event Instance",
		"validate.addorderitem.order_addorderitem.sku.activeflag.eq": "You cannot add an inactive sku.",
		"admin.entity.ordertabs.orderpayments.nonactive": "Invalid & Removed",
		"entity.audit.audittype": "Type",
		"entity.attributevalue.attributevalueencrypteddatetime": "Attribute Value Encrypted Date Time",
		"validate.createpassword.account.slatwallauthenticationexistsflag.eq": "There is already a password defined for this account.  You may want to use the 'change password' tool or you can remove the password under the 'Authentication Details' section.",
		"define.new": "New",
		"entity.vendor_plural": "Vendors",
		"entity.emailtemplate_plural": "Email Templates",
		"entity.vendor.vendoremailaddresses": "Vendor Email Addresses",
		"setting.integrationsofortprojectid": "Project ID",
		"entity.workflowtriggerhistory": "Trigger History",
		"validate.addrecipientstoorderitem.orderitem_addrecipientstoorderitem.assignedgiftrecipientquantity.gt": "You must select or create a gift recipient.",
		"admin.main.encryption.reencryptdata_success": "Encrypted data stored in the database was re-encrypted with most recent encryption password.",
		"define.searchandassignproducts": "Search & assign products...",
		"entity.paymentmethod.process.processcreditcardpayment": "Process Credit Card Payment",
		"define.status": "Status",
		"entity.workflowtrigger.runningflag": "Running Flag",
		"processobject.orderfulfillment_fulfillitems.verifycreditcardcaptureflag": "Verify Credit Card Capture",
		"entity.address.postalcode_validaterequired": "Please enter a valid Postal Code",
		"validate.processsku_changeeventdates.editscope": "You must select a Scheduling Type",
		"processobject.account_addaccountpayment.saveaccountpaymentmethodflag": "Save as Account Payment",
		"entity.type.systemcode": "System Code",
		"setting.integrationuspsshipfrompostalcode": "Shipping From Postal Code ",
		"entity.fulfillment": "Fulfillment",
		"validate.save.sku.options.hasuniqueoptions": "The sku option is not unique.",
		"entity.account.termaccountbalance": "Term Account Balance",
		"entity.skucurrency.sku": "SKU",
		"permission.setting.editroundingrule": "Rounding Rule - Edit",
		"admin.entity.orderitemgiftrecipient.firstname": "First Name",
		"setting.globaluseextendedsession": "Turns on extended sessions for frontend users.",
		"admin.entity.processsubscriptionusage.updatestatus_success": "Subscription Status Updated Successfully",
		"entity.orderdelivery.orderdeliveryid": "Order Delivery ID",
		"entity.account.subscriptionusagebenefitaccounts": "Subscription Usage Benefit Accounts",
		"setting.productimagesmallwidth": "Small Image Width",
		"admin.entity.processorderreturn.receive_success": "Order return has been received",
		"admin.entity.createfile": "Add File",
		"entity.accountpaymentmethod.accountpaymentmethodname": "Nickname",
		"entity.audit.changedetails.propertychanged.archive": "Changed",
		"entity.optiongroup.delete_success": "The Option Group was successfully deleted.",
		"entity.promotionperiod.maximumusecount": "Max. Use Count",
		"entity.shippingmethodrate.minimumshipmentweight": "Min Fulfillment Weight",
		"endicia.main.default_permission": "Endicia Integration Tools",
		"setting.siteverifyaccountemailaddressemailtemplate_hint": "This setting defines the site based e-mail template that is going to be sent for account email addresses getting validated",
		"entity.promotionreward.excludedproducts": "Product Exclusions",
		"setting.integrationpayleappassword": "Password",
		"define.april": "April",
		"dashboard.tracksessionissue_error": "There is an know issue with you current configuration of Mura & Slatwall that will cause the frontend to lock up.  You can either open up your mura /config/settings.ini and set trackSessionInNewThread=0 or you can update you mura core to the latest version.",
		"admin.entity.preprocessphysical_title": "Add Physical Count",
		"validation.define.lte": "This value is invalid",
		"admin.entity.detailorderpayment.dynamiccredit": "Dynamic Credit Amount",
		"entity.attributeset.attributesetid": "Attribute Set ID",
		"admin.entity.ordertabs.referencingorders": "Referencing Orders",
		"entity.postalcode.city": "city",
		"entity.product.process.addsubscriptionsku": "Add Subscription Sku",
		"admin.entity.processaccount.create_success": "Account Created",
		"admin.define.edit_nav": "Edit ${itemEntityName}",
		"admin.main.encryptionupdatepassword": "Update Database Encryption Password",
		"entity.attributevalue.productreview": "Product Review",
		"entity.optiongroup.imagegroupflag_hint": "If this is selected, then any product with options from this group will have different images",
		"entity.accountpayment.checknumber": "Check Number",
		"setting.skushippingcostexempt": "Shipping Cost Exempt",
		"entity.product.promotionrewardexclusions": "Promotion Reward Exclusions",
		"entity.access_plural": "Accesses",
		"entity.stock.qoh": "qoh",
		"admin.entity.processsite.create_success": "Site saved successfully",
		"entity.order.cancel_validatestatus": "Order cannot be deleted due to order status ({statusValue})",
		"entity.formresponse_plural": "Form Responses",
		"entity.audit.process.rollback": "Rollback",
		"entity.shippingmethodrate.addresszone": "Address Zone",
		"permission.pricing.listpromotion": "Promotion - List",
		"admin.entity.ordertabs.orderpayments.credits": "Credits",
		"setting.integrationorbitalpassword_hint": "Orbital Gateway Password",
		"admin.entity.permissiongrouptabs.actionpermissions": "Action Permissions",
		"entity.loyaltyaccruement.accruementtype.orderclosed": "Order Closed",
		"processobject.sku_changeeventdates.schedulestartdate": "Schedule Starts On",
		"entity.file": "File",
		"entity.report.dynamicdaterangeendtype.thisweekendsunday": "Current Week ( Ending Sunday )",
		"setting.integrationpayflowproaccountpaymentcommentonetemplate_hint": "This template will be string replaced based on the order payment, and then passed as custom comment 1 to PayFlow Pro.  An Example would be: ${accountPaymentID} or ${myCustomAccountPaymentAttributeCode}.  Plain text works as well",
		"admin.entity.accounttabs.accountpaymentmethods.adddisabled": "You cannot add any account payment methods because there are no payment methods configured that have 'Allow Save' set to yes.  Please update one of your payment methods under Config > Payment Methods to have 'Allow Save' set to yes.",
		"entity.accountauthentication.accesskey": "Access Key",
		"entity.shippingmethodrate.shippingrate": "Shipping Charge",
		"entity.account.process.createpassword": "Create Password",
		"admin.main.update_permission": "Update Slatwall",
		"setting.integrationpayflowproorderpaymentcommenttwotemplate_hint": "This template will be string replaced based on the order payment, and then passed as custom comment 2 to PayFlow Pro.  An Example would be: ${orderPaymentID} or ${myCustomOrderPaymentAttributeCode}.  Plain text works as well\"",
		"setting.paymentmethodstorecreditcardnumberwithaccount": "Auto Store Credit Card Number With Account",
		"entity.task": "Task",
		"entity.promotionapplied": "Promotion Applied",
		"admin.editfilteritem.saveandfinish": "Save And Finish",
		"entity.account.accountname": "Account Name",
		"entity.subscriptionterm.renewalterm": "Renewal Term",
		"entity.product.price": "Price",
		"validate.promotioncode.invaliddatetime": "The promotion code that you have entered is valid, but it is not currently available.  Verify the date / time that the promotion was running.",
		"entity.define.urltitle_hint": "This field is used to create the front-end URL for SEO purposes.  The value must contain only alpha-numeric charecters as well as - or _.  Best practice is to leave this value as all lower case",
		"admin.entity.orderitemgiftrecipient.email": "Email Address",
		"validate.processsubscriptionusage_renew.order.newflag": "The Subscription Usage could not be renewed because there was already an open renewal order. Please complete this order before attempting to renew.",
		"entity.file.fileupload": "File",
		"admin.entity.editskucurrency_disabled": "This default sku currency cannot be edited, if you would like to change the amount in this currency then just update the price values on the sku itself.",
		"setting.skuallowbackorderflag_hint": "Indicate whether this product can be backordered",
		"entity.stockhold.stockholdid": "Stock Hold ID",
		"admin.define.process_permission": "${itemEntityName} - Process",
		"entity.subscriptionusage.process.renew": "Renew",
		"entity.type.childrequiressystemcodeflag": "Child Requires System Code Flag",
		"permission.setting.listaddresszone": "Address Zone - List",
		"admin.entity.processorder.removepromotioncode_success": "Promotion code removed.",
		"entity.eventregistration.process_confrm": "Confirm",
		"entity.order.process.updateorderfulfillments": "Update Order Fulfillments",
		"defaultmessage_boolean": "{1} must be a valid boolean.",
		"entity.updateprice": "Price",
		"entity.shippingmethodrate.haspricegroups": "Price Groups",
		"define.confirm": "Confirm",
		"entity.roundingrule_plural": "Rounding Rules",
		"admin.entity.detailorderpayment.changeamount": "Change Amount",
		"entity.shippingmethodoptionsplitshipment.shipmentweight": "Shipment Weight",
		"define.totals": "Totals",
		"entity.subscriptionusage": "Subscription Usage",
		"entity.currencyrate.effectivestartdatetime_hint": "Set this as the datetime that you would like for the conversion rate to start applying.  The value can not be edited, and it needs to be something in the future.  If you leave it blank it will set the value as 'Now'.",
		"entity.vendor.brands": "Brands Offered",
		"defaultmessage_isvalidobjectemptystruct": "validation failed because a valid structure cannot be empty.",
		"entity.productbundlegroup.none": "None",
		"entity.vendor.emailaddress": "Email Address",
		"admin.entity.ordertabs.saleorderitems": "Sale Order Items",
		"entity.emailtemplate.emailtemplateid": "Email Template ID",
		"entity.subscriptionusage.mostrecentorder": "Most Recent Order",
		"admin.entity.ordertabs.orderpayments": "Order Payments",
		"entity.skualternate.skutype": "skuType",
		"validate.addorderpayment.order_addorderpayment.giftcardid.canpurchasewithgiftcard": "The gift card you're are trying to use either doesn't exists, isn't active, or is expired.",
		"processobject.physical_addphysicalcount.locationid": "Location ID",
		"admin.entity.createpromotionqualifiersubscription": "Subscription Item Qualifier",
		"entity.vendororder.taxtotal": "Tax",
		"entity.print_plural": "Prints",
		"define.global": "Global",
		"entity.location.locationconfigurations": "Location Configurations",
		"validate.account.emailaddress.exists": "This Email Address is already in use with another Account",
		"admin.entity.processorder.takeoffhold_success": "This order has been taken off 'On Hold' status.",
		"setting.brandmetadescriptionstring": "Brand Meta Description String",
		"entity.order.paymentauthorizedtotal": "Authorized Amount",
		"permission.order.editorderfullfillment": "Order Fulfillment - Edit",
		"entity.form.emailto": "Email To",
		"entity.sku.defaultflag": "Is Default",
		"processobject.subscriptionusage_cancel.effectivedatetime": "Effective Date Time",
		"entity.fulfillmentbatchitem.quantityonbatch": "Quantity On Batch",
		"entity.stockreceivervendororder.boxcount": "Box Count",
		"entity.stockadjustmentitem.quantity": "Qty.",
		"entity.integration.integrationpackage": "Integration Package",
		"entity.skuprice.price": "Price",
		"entity.order.orderid": "Order ID",
		"validate.createpassword.account_createpassword.password.minlength": "Account Password should be at least 6 characters long.",
		"entity.taxapplied.taxamount": "Tax Amount",
		"entity.product.promotionqualifierexclusions": "Promotion Qualifier Exclusions",
		"entity.sku.purchasestartdatetime": "Purchase Start Date",
		"entity.accountpayment.paymentmethod": "Payment Method",
		"setting.integrationvirtualmerchanttestaccountflag": "Test Mode",
		"define.friday": "Friday",
		"entity.taskschedule": "Task Schedule",
		"permission.vendor.deletevendor": "Vendor - Delete",
		"admin.main.log": "Slatwall Log",
		"setting.integrationstripelivesecretkey": "Live Secret Key",
		"entity.accountpayment.termoffsetunassigned": "(Additional Unassigned Amount)",
		"entity.skualternate.sku": "sku",
		"define.developerdocs": "Developer Docs",
		"setting.integrationvertexwebservicesurl_hint": "This is the URL of where the web services application is setup.  For example: http://127.0.0.1/vertex-ws/services",
		"validation.define.unique": "This value must be unique.",
		"entity.shippingmethodrate.maximumshipmentitemprice": "Max Fulfillment Subtotal",
		"entity.subscriptionusagebenefit.subscriptionbenefit": "Subscription Benefit",
		"admin.entity.createpromotionqualifierorder": "Order Qualifier",
		"mura.main_permission": "Dashboard",
		"processobject.subscriptionusage_renew.saveaccountpaymentmethodflag": "Save as Account Payment",
		"setting.integrationupsshipfromcity": "Shipping From City ",
		"entity.eventregistration.process.register": "Change to Registered",
		"entity.skualternate.skuvalue": "skuValue",
		"entity.accountpayment.termoffsetamount": "Amount",
		"setting.integrationipaymenttransactionsecuritykey": "Transaction Security Key",
		"entity.collection.filter.norecordsfound": "No filters have been created",
		"entity.shippingmethodrate.maximumshipmentweight": "Max Fulfillment Weight",
		"entity.pricegroup.subscriptionbenefits": "Subscription Benefits",
		"entity.paymentmethod.paymentmethodcode": "Payment Method Code",
		"entity.eventtrigger.eventtriggertype": "Event Trigger Type",
		"entity.task_plural": "Tasks",
		"entity.addresszone.shippingmethods": "Shipping Methods",
		"define.title": "Title",
		"validate.account_setupinitialadmin.password.minlength": "Your password must be at least 6 characters long",
		"entity.stockadjustmentdelivery.deliveryopendatetime": "Delivery Open Date Time",
		"entity.setting.account": "Account",
		"setting.productimagemediumheight": "Medium Image Height",
		"entity.attribute.attributecode_hint": "A unique string (alphanumeric, no spaces) to identify the attribute.",
		"setting.integrationsagepayvendorid": "Vendor ID",
		"admin.entity.sku.renewalsubscriptionbenefits": "Renewal Subscription Benefits",
		"entity.fulfillmentmethod.shippingmethods": "Shipping Methods",
		"setting.emailimapserverusername": "Bounced Email Server Username",
		"entity.task.taskname": "Task Name",
		"define.now": "Now",
		"entity.audit.sessionipaddress": "IP",
		"entity.accountauthentication.accesskeypassword": "Access Key Password",
		"entity.form": "Form",
		"setting.skueligiblepaymentmethods": "Eligible Payment Methods",
		"entity.loyaltyaccruement.accruementtype.enrollment": "Program Enrollment",
		"setting.fulfillmentmethodautominreceivedpercentage": "Min. Amount Received Percentage",
		"entity.sku.listprice": "List Price",
		"entity.measurementunit.unitname": "Unit Name",
		"entity.account.primarypaymentmethod": "Account Primary Payment Method",
		"entity.orderdelivery.process.create.cannotfulfillitem": "This item will not be fulfilled at this time.",
		"define.yesno": "Yes / No",
		"entity.category.categoryname": "Category Name",
		"entity.loyaltyredemption.pricegroup": "Price Group",
		"entity.email.eventname": "Event Name",
		"define.disabled": "Disabled",
		"define.qmax.full": "Maximum",
		"admin.entity.listproduct.createnocontent": "You cannot create a 'Content Access' product until you have content records defined.  This is typically done by integrating with a CMS, and adding content in that CMS.",
		"entity.task.taskid": "Task ID",
		"entity.attributevalue.attributevalueid": "attributeValueID",
		"admin.entity.settingstabs.advanced": "Advanced Settings",
		"admin.main.unlockaccount_info": "You have successfully unlocked this account.",
		"setting.skuallowpreorderflag": "Preorder OK",
		"entity.accountpaymentmethod.creditcardnumberencrypted": "Credit Card Number  Encrypted",
		"admin.entity.stockreceivertabs.stockreceiveritems": "Items Received",
		"permission.setting.detailorderorigin": "Order Origin - Detail",
		"setting.globalnosessionipregex": "Ignore Session Tracking IP Regex",
		"entity.permission.processcontext": "Process Context",
		"entity.locationconfiguration.locationtree": "Location",
		"entity.commentrelationship.product": "Product",
		"define.autoincrement": "Auto Increment",
		"entity.workflowtrigger.norecordsfound": "No triggers have been created",
		"admin.entity.sitetabs.sitesettings": "Site Settings",
		"permission.vendor.createvendor": "Vendor - Create",
		"admin.entity.apptabs.sitesettings": "Site Settings",
		"entity.productschedule.weeklyrepeatdays": "Days of the Week",
		"admin.entity.settingstabs.globaladvanced": "Global Advanced Settings",
		"entity.integration.integrationid": "Integration ID",
		"entity.order": "Order",
		"admin.entity.preprocessorder_addorderitem.fulfillmentdetails": "Fulfillment Details",
		"entity.account.promotioncodes": "Promotion Codes",
		"entity.accountpayment.termoffsettotal": "Total",
		"entity.paymentmethod.accountpaymentmethods": "Account Payment Methods",
		"api.define.save_error": "There was an error trying to save the ${EntityName}.",
		"entity.vendor.vendorwebsite": "Vendor Website",
		"validate.rollback.audit.audittype.inlist": "The audit type does not allow for rollback.",
		"entity.order.process.removeorderpayment": "Remove Order Payment",
		"entity.session.sessioncookiepsid": "Persistent Session ID",
		"entity.vendor": "Vendor",
		"entity.define.shortreferenceid": "Short Reference ID",
		"setting.integrationfullcirclefcftpusesecure_hint": "Should files be pushed and pulled via secure FTP",
		"entity.taxapplied.taxjurisdictionname": "Tax Jurisdiction Name",
		"entity.subscriptionusage.subscriptionstatus": "Status",
		"entity.attribute.attributeinputtype.file": "File",
		"entity.product.productdisplaytemplate": "Product Display Template",
		"report.orderitemreport.quantityreturned": "Quantity Returned",
		"setting.integrationupsapikey": "API Key ",
		"entity.orderorigin_plural": "Order Origins",
		"entity.attribute.attributedescription": "Attribute Description",
		"entity.product.process.deletedefaultimage": "Delete Default Image",
		"validate.addorderitem.order_addorderitem.price.minvalue": "Price needs to be a positive number",
		"entity.option.productimages": "Product Images",
		"frontend.account.detail": "My Account",
		"validate.addorderpayment.order.statuscode.inlist": "You're not able to add an order payment with the order's current status.",
		"entity.orderitemgiftrecipient.orderitem": "Order Item",
		"admin.entity.promotionqualifiertabs.brands": "Brands",
		"entity.productrelationship.product": "Product",
		"admin.entity.settingstabs.globalpage": "Global Page Settings",
		"admin.entity.processorder.createreturn_success": "Return order created successfully",
		"defaultmessage_equalto": "{1} must be the same as {2}{3}.",
		"setting.skuqatsincludesqnrovoflag": "QATS Includes QNROVO",
		"permission.product.editproduct": "Product - Edit",
		"admin.pricing.promotionperiod.editdisabled_info": "This promotion period cannot be edited because it has expired.",
		"entity.subscriptionusagebenefitaccount.subsusagebenefitaccountid": "Subscription Usage Benefit Account ID",
		"permission.setting.listlocation": "Location - List",
		"entity.fulfillmentmethod.fulfillmentmethodname": "Fulfillment Method Name",
		"admin.entity.detailorderitem.currentskuprice": "Current Sku Price",
		"admin.entity.locationtabs.locationconfigurationsettings": "Location Configuration Settings",
		"entity.subscriptionusage.totalnumberofsubscriptionorderitems": "Total Subscription Order Items",
		"entity.orderitem.orderitemstatustype": "Order Item Status",
		"entity.orderpayment.purchaseordernumber": "Purchase Order Number",
		"setting.integrationauthorizenetduplicatewindow": "Duplicate Transaction Time Window",
		"entity.account.accountpaymentmethods": "Payment Methods",
		"define.average": "Average",
		"admin.default.accounts_nav": "Accounts",
		"admin.entity.detailpermissiongroup.superuser_info": "This is the super user permission group that can not be deleted or modified.  There is no need to set permissions for this group because any accounts assigned to this group has access to the entire application.",
		"entity.attribute.defaultvalue": "Default Value",
		"entity.order.referencedordertype.duplicate": "Duplicate",
		"admin.entity.promotionperiodtabs.promotionqualifiers": "Promotion Qualifiers",
		"entity.promotionreward.maximumuseperqualification_hint": "This setting is mostly used in defining things like buy one get one free where you would qualify by having a quantity of 2 of an item, and then this would be set to 1 with 100% discount.  If there are no qualifiers than this setting is never used.",
		"entity.productschedule_plural": "Product Schedules",
		"entity.pricegroup.pricegroupcode_hint": "A unique string (alphanumerc, no spaces) to identify the price group.",
		"setting.emailreplytoaddress": "Email Reply To Address",
		"entity.product.qc": "QC",
		"entity.promotionreward.maximumuseperqualification": "Max. Use Per Qualification",
		"mura.main.default_permission": "Mura Integration",
		"entity.eventregistration_plural": "Event Registrations",
		"entity.address.name": "Name",
		"admin.entity.processaudit.rollback_success": "Rollback was successful",
		"entity.paymentterm.orderpayments": "Order Payments",
		"entity.producttype.producttypeid": "productTypeID",
		"entity.sku.process.makeupbundledskus": "Makeup Sku Bundle",
		"setting.integrationmuralegacycheckout": "Legacy Checkout Filename",
		"admin.pricing.detailpromotion.norewards_info": "Currently there are no rewards assigned to this promotion. You have created the promotion and setup an initial period, but you need to open that promotion period below and define what this promotion will be for.",
		"permission.vendor.detailvendor": "Vendor - Detail",
		"entity.session.sessioncookieextendedpsid": "Session Cookie Extended PSID",
		"entity.integration.authenticationactiveflag": "Auth Active",
		"admin.entityas.pricegrouptabs.pricegrouprates": "Price Group Rates",
		"entity.vendorphone.phone": "phone",
		"admin.entity.createloyaltyterm": "Add Loyalty Term",
		"entity.workflowtask.taskname": "Task Name",
		"entity.sku.options": "Options",
		"define.true": true,
		"entity.promotionreward.amount": "Amount",
		"processobject.product_addoptiongroup.optiongroup": "Option Group",
		"entity.accountemailaddress.accountemailaddressid": "accountEmailAddressID",
		"admin.entity.settingstabs.shippingmethod": "Shipping Method Settings",
		"define.annually": "Annually",
		"setting.fulfillmentmethodemailsubjectstring": "Email Subject Template",
		"entity.subscriptionusage.subscriptionusageid": "Subscription Usage ID",
		"admin.entity.settingstabs.product": "Product Settings",
		"define.sort": "Sort",
		"entity.fulfillmentmethod.sortorder": "Sort Order",
		"setting.integrationvirtualmerchantpin": "Virtual Merchant PIN",
		"entity.roundingrule.roundingruleexpression": "Rounding Rule Expression",
		"entity.attribute.attributeinputtype.atselectbox": "Select Box",
		"validate.processproduct_create.scheduleenddate_valid": "Schedule end date must occur after schedule start date.",
		"processobject.account_generateapiaccesskey.authenticationdescription": "Access Key Description",
		"entity.account.remoteemployeeid": "Remote Employee ID",
		"entity.accountpaymentmethod": "Account Payment Method",
		"entity.profile.profiletemplate": "profileTemplate",
		"permission.product.deleteoptiongroup": "Option Group - Delete",
		"admin.entity.listcontent": "Content",
		"validate.save.collection.collectioncode.uniqueornull": "CollectionCode entered is not unique",
		"setting.integrationupsshipfromcountrycode": "Shipping From Country Code ",
		"entity.fulfillmentbatchitem.quantitypicked": "Quantity Picked",
		"admin.entity.locationtabs.locationstocks": "Location Stocks",
		"entity.loyaltyaccruement": "Loyalty Program Accruement Criteria",
		"defaultmessage_collectionsize_gte": "{1} size is not equal to or greater than {2}.",
		"entity.shippingmethodrate": "Shipping Method Rate",
		"entity.audit.baseobject": "Base Object",
		"entity.content.contentidpath": "Content ID Path",
		"entity.accountcontentaccess": "Account Content Access",
		"entity.entityqueuehistory_plural": "Entity Queue History",
		"entity.sku.exclusive": "Image is exclusive for this sku",
		"admin.entity.brandtabs.brandsettings": "Brand Settings",
		"entity.accountpayment.termoffsettotals": "Totals",
		"entity.commentrelationship.stockadjustment": "Stock Adjustment",
		"entity.giftcardtransaction_plural": "Gift Card Transactions",
		"entity.attributevalue.producttype": "Product Type",
		"admin.entity.processaccount.addaccountpayment_success": "Account payment created successfully",
		"entity.productbundlegroupitem.productbundlegroupitemid": "Product Bundle Group Item ID",
		"admin.entity.downloadfile_permission": "Download Files",
		"admin.entity.promotionperiodtabs.promotionrewards": "Promotion Rewards",
		"entity.product.sortorder": "Sort Order",
		"entity.type.typedescription": "Type Description",
		"permission.setting.deletelocation": "Location - Delete",
		"entity.sku.imagepath": "Image Path",
		"entity.form_plural": "Forms",
		"entity.accountaddress.accountaddressid": "accountAddressID",
		"entity.workflowtaskaction.delete": "Delete",
		"admin.define.process_error": "There was an error trying to process the ${entityName}",
		"admin.entity.createaddresszonelocation": "Add Location to Zone",
		"define.selectall": "Select All",
		"entity.stockreceiveritem.stockadjustmentitem": "Stock Adjustment Item",
		"entity.permissiongroup": "Permission Group",
		"entity.orderitemgiftrecipient.emailaddress": "Email Address",
		"setting.integrationupspickuptypecode": "Pickup Type Code (advanced optional)",
		"permission.order.editorder": "Order - Edit",
		"admin.editfilteritem.criteria": "Criteria",
		"entity.orderitem.stock": "stock",
		"setting.globalnosessionpersistdefault": "Ignore Session Tracking until Logged In or Cart Created",
		"entity.sku.eventattendancecode": "Attendance Code",
		"entity.printtemplate_plural": "Print Templates",
		"permission.product.editproductreview": "Product review - Edit",
		"api.define.create_success": "The ${EntityName} was created successfully",
		"entity.currency.currencyname": "Currency Name",
		"entity.permissiongroup.permissiongroupname": "Permission Group Name",
		"entity.orderfulfillment.appliedpromotions": "Applied Promotions",
		"validate.save.subscriptionterm.autopayflag.gethaspaymentmethodthatallowsaccountstosave": "When auto pay is selected, at least one payment method needs to be setup with the option 'allow account to save' turned on.",
		"admin.report.default.customreports": "Custom Reports",
		"admin.entity.detailshippingmethod.norates_info": "Currently there are no rates defined for this shipping method.  You need to define at least one rate for this shipping method to be able to be used on the frontend.  When creating a new rate, you will be able to define which of the active shipping provider integrations you would like to use for the rate, or just define a static amount",
		"entity.account.productreviews": "Product Reviews",
		"entity.setting.cmscontentid": "CMS Content ID",
		"setting.producttitlestring": "Product Title Format",
		"report.orderitemreport.saleprediscount": "Pre Discount Sale",
		"entity.physical_plural": "Physicals",
		"admin.define.create": "Create ${itemEntityName}",
		"entity.orderfulfillment.registrants": "Registrants",
		"defaultmessage_regex": "{1} must match the specified pattern.",
		"entity.accountpayment.termoffsetordernum": "Order Number",
		"entity.comment.childcomment": "Related Children Comment",
		"entity.country.cityshowflag": "Show City",
		"define.july": "July",
		"entity.promotionqualifier.brands": "Brands",
		"entity.attributeset.sortorder": "Sort Order",
		"admin.entity.processphysical.commit_success": "The physical count has been successfully committed and the stock has been updated.",
		"setting.globalclientsecret": "Client Secret",
		"entity.accountauthentication.accountauthenticationid": "Account Authentication ID",
		"setting.integrationauthorizenetgatewayurl": "API Gateway URL",
		"entity.audit.changedetails.propertychanged.old": "Changed From",
		"validation.define.neq": "The value entered is not correct",
		"setting.integrationvertexwebservicesusername": "Vertex Username",
		"define.qndorvo.full": "Not Delivered On Return Vendor Order",
		"entity.pricegroupratecurrency.pricegroupratecurrencyid": "Price Group Currency Rate ID",
		"permission.setting.deleteroundingrule": "Rounding Rule - Delete",
		"admin.entity.orderdeliveryitemtabs.giftcards": "Gift Cards",
		"define.june": "June",
		"entity.email.emailbodyhtml": "Email Body HTML",
		"admin.entity.subscriptiontermtabs.subscriptionusagesettings": "Subscription Usage Settings",
		"entity.productlistingpage": "Product Listing Page",
		"entity.promotionqualifier.rewardmatchingtype.sku": "Sku",
		"entity.updatescript.maxexecutioncount": "Max Execution Count",
		"entity.permission_plural": "Permissions",
		"entity.orderfulfillment.accountemailaddress": "Account Email Address",
		"entity.report.reportdatetime": "Report Date Time",
		"entity.paymentmethod.placeorderchargetransactiontype": "Checkout Charge Trans.",
		"setting.integrationfullcirclefcftpdirecotry": "Full Circle FTP Directory",
		"entity.accountrelationship.relatedaccount": "relatedAccount",
		"admin.entity.settings_permission": "Global Setting Access",
		"entity.accountaddress_plural": "Account Addresses",
		"entity.printtemplate.printtemplateobject": "Print Template Object",
		"admin.pricing.createpromotionrewardorder": "Create Promotion Reward Order",
		"setting.globalorderplacedemailcc": "New Order Placed Email CC",
		"setting.integrationclickandbuysandboxisactive": "Sandbox active",
		"entity.accountpayment.account": "Account",
		"entity.skuprice.listprice": "List Price",
		"entity.promotionperiod": "Promotion Period",
		"permission.warehouse.detailstockreceiver": "Stock Receiver - Detail",
		"admin.entity.locationconfigurationtabs.locationconfigurationsettings": "Location Configuration Settings",
		"validate.create.product_create.purchasestartdatetime.ltdatetimeproperty": "Purchase Start Date must occur before the event.",
		"entity.sku.pricegrouprates": "Price Group Rates",
		"entity.promotionreward.shippingamount": "Shipping Rate Fixed Amount",
		"permission.warehouse.createstockreceiver": "Stock Receiver - Create",
		"validate.save.accountemailaddress.emailaddress.getemailaddressnotinuseflag": "The email address that you have entered is already in use by another authenticated account.",
		"entity.setting.settingname": "Setting Name",
		"admin.entity.listloyaltyterm": "Loyalty Terms",
		"setting.subscriptionusagerenewalreminderemailtemplate": "Subscription Renewal Reminder Email Template",
		"define.adjustment": "Adjustment",
		"setting.integrationstripetestsecretkey": "Test Secret Key",
		"entity.orderfulfillment.chargeafterdiscount": "Total Fulfillment Charge",
		"entity.orderreturn.returnlocation": "Return Location",
		"entity.task.taskmethod.subscriptionusagerenewalreminder": "Subscription Usage - Renewal Reminder",
		"setting.integrationpayflowprovendorid": "Vendor ID",
		"entity.setting_plural": "Settings",
		"entity.currencyrate_plural": "Currency Rates",
		"setting.integrationvertexorigincity": "Origin City",
		"admin.account.processsubscriptionusage.cancelsubscription_nav": "Cancel Subscription",
		"admin.entity.createreturnorder_nav": "Create Return Order",
		"entity.attributeoption": "Attribute Option",
		"entity.task.schedule": "Task Schedule",
		"entity.skuoption.sku": "sku",
		"entity.updatescript": "Update Script",
		"entity.subscriptionbenefit_plural": "Subscription Benefits",
		"entity.currencyrate": "Currency Rate",
		"entity.setting.shippingmethod": "Shipping Method",
		"define.definedin": "Defined In",
		"validate.order.orderitems.toomanyeventregistrations": "There are more event registrations defined than the specified quantity allows.",
		"setting.accounteligiblepaymentterms_hint": "This should be a list of all the available payment terms an account can utilize on a given order.",
		"entity.app": "Application",
		"setting.integrationfedexcontactpersonname": "Contact Full Name",
		"entity.emailbounce.relatedobjectid": "Related Object ID",
		"entity.email.emailtemplate": "Email Template",
		"entity.paymentmethod.saveorderpaymenttransactiontype_hint": "Typically used to generate 'tokens' from the processor, which are then stored with the 'Order Payment' to avoid encrypting & storing data.",
		"admin.entity.detailorder.overview": "Overview",
		"entity.productrelationship.relationshiptype": "Relationship Type",
		"entity.account.superuserflag": "Super User",
		"entity.subscriptionusage.process.cancel": "Cancel Subscription",
		"setting.contentrestrictaccessflag_hint": "By selecting this option the only way this page will be viewed is if the current account has purchased it, or has a subscription to the content.",
		"admin.entity.promotionrewardtabs.producttypes": "Product Types",
		"entity.report.dynamicdaterangeendtype.lastweekendsunday": "Previous Week ( Ending Sunday )",
		"admin.entity.updateproductcache": "Update Product Cache",
		"define.qnrosa.full": "Not Received On Stock Adjustment",
		"entity.stockadjustment.process.additems": "Process Stock Adjustment",
		"setting.contentdefaultproductsperpage_hint": "Default number of products per page",
		"setting.integrationupsshipfromemailaddress": "Shipping Email Address ",
		"entity.product.option.select": "Please select an option...",
		"entity.physicalcountitem": "Physical Count Item",
		"entity.accountpayment.process.createtransaction": "Create Transaction",
		"admin.entity.processproduct.create.renewalskumethod": "Renewal Sku Method",
		"setting.skutaxcategory": "Tax Category",
		"validate.delete.accountloyalty.accountloyaltyid.maxlength": "The account loyalty program cannot be deleted.",
		"defaultmessage_nohtml": "{1} cannot contain HTML tags.",
		"entity.loyaltyredemption.accountloyaltytransactions": "Account Loyalty Transactions",
		"entity.currency.currencylocal": "Currency Local",
		"entity.country": "Country",
		"validate.account_forgotpassword.loginblocked": "You may not reset your password while your account is locked, please contact your adminstrator.",
		"processobject.accountloyalty_manualtransaction.expirationdatetime": "Expiration Date/Time",
		"entity.giftcard.process.updateemailaddress": "Update Email Address & Resend",
		"entity.shippingmethod.useratetableflag": "Use Rate Table",
		"admin.entity.loyaltyaccruementtabs.products": "Products",
		"entity.accountpayment.termoffsetunappliedwarning2": "that will not be assigned to any orders",
		"entity.accountpayment.termoffsetunappliedwarning1": "Warning: There is",
		"entity.vendorphone.vendorphoneid": "vendorPhoneID",
		"permission.setting.editfulfillmentmethod": "Fulfillment Method - Edit",
		"validate.addsku.sku.redemptionamount.minvalue": "Please select an amount greater than zero.",
		"permission.warehouse.editstockreceiver": "Stock Receiver - Edit",
		"admin.define.detail_title": "View ${itemEntityName}",
		"setting.globalweightunitcode": "Weight Measurement Unit",
		"entity.skuprice.sku": "Sku",
		"entity.attributeset.attributes": "Attributes",
		"entity.stockreceiver.receivertype.order": "Return / Exchange Order",
		"entity.accountpaymentmethod_plural": "Account Payment Methods",
		"paypalexpress.main_permission": "PayPal Express Integration",
		"entity.product.calltoorderflag": "Phone Order Only",
		"permission.vendor.editvendor": "Vendor - Edit",
		"admin.define.configuration": "Configuration",
		"setting.integrationstripelogenabled": "Enable Logging",
		"setting.integrationavataxsourceregion": "Source State (Region)",
		"entity.shippingmethod.shippingmethodtype": "Shipping Method Type",
		"processobject.order_addorderpayment.saveaccountpaymentmethodflag_hint": "Selecting yes will save this payment method against the account for future orders.",
		"entity.productschedule.schedulesummary": "Summary",
		"setting.globalallowedoutsideredirectsites_hint": "A comma delimited list of all outside sites that you want to allow Slatwall to be able to redirect to. Example site: http://www.example.com/",
		"define.to": "to",
		"setting.globalimageextension": "Image Extension",
		"entity.orderitemgiftrecipient.lastname": "Last Name",
		"entity.stockadjustmentitem_plural": "Stock Adjustment Items",
		"entity.physicalcountitem.physicalcount": "Physical Count",
		"admin.entity.createpromotionrewardorder": "Order Discount",
		"setting.producthtmltitlestring": "Product HTML Title String",
		"entity.location": "Location",
		"setting.integrationparcel2goshippercountrycode": "Shipping From Country Code",
		"entity.audit.changedetails.propertychanged.update": "Changed",
		"entity.orderitem.quantityreceived": "Qty. Received",
		"entity.vendor.primaryaddress": "Primary Address",
		"validate.delete.giftcard.giftcardcode.caneditordelete": "Gift Cards that have been issued can not be deleted.",
		"entity.promotionreward.itemdiscounttype": "Discount Type",
		"defaultmessage_pastdate_withbefore": "{1} must be a date in the past. The date entered must come before {2}.",
		"report.orderitemreport.quantitysold": "Quantity Sold",
		"admin.entity.processsku.logattendance_success": "Attendance has been logged successfully.",
		"entity.attribute.attributeinputtype.email": "Email",
		"entity.loyaltyaccruement.pointtype": "Point Type",
		"setting.sitemissingimagepath": "Site Missing Image Path",
		"admin.define.save": "Save ${itemEntityName}",
		"entity.attributevalue.attribute": "attribute",
		"entity.account.process.updatepassword_success": "You have successfully updated your password.",
		"setting.integrationfedexshipperpostalcode": "Shipping From Postal Code ",
		"entity.vendororderitem.stocklocation": "Location",
		"admin.entity.subscriptionbenefittabs.contents": "Content",
		"entity.pricegrouprate.roundingrule": "Rounding Rule",
		"entity.option.sortorder": "Sort Order",
		"entity.accountpayment.giftcardnumberencrypted": "Gift Card Number",
		"define.export": "Export",
		"entity.taxcategory.taxcategoryid": "Tax Category ID",
		"entity.vendoraccount.vendoraccountid": "Vendor Account ID",
		"setting.integrationupstestingflag": "Test Mode ",
		"entity.inventory.quantityout": "Quantity Out",
		"entity.promotionqualifier.shippingaddresszones": "Address Zones",
		"entity.country.postalcodeshowflag": "Show Postal Code",
		"entity.subscriptionusage.subscriptionorderitemname": "Subscription Item",
		"entity.comment_plural": "Comments",
		"admin.entity.physicaltabs.discrepancies.norows": "There aren't any Physical Count Items.",
		"define.checkboxgroup": "Checkbox Group",
		"entity.productbundlebuilditem": "Product Bundle Build Item",
		"entity.stockadjustment.stockreceivers": "Stock Receivers",
		"entity.sku.redemptionamounttype.select": "Please select a Redemption Amount Type.",
		"entity.stockreceiver.stockreceiveritems": "Stock Receiver Items",
		"entity.audit.changedetails": "Change Details",
		"entity.skucurrency.currency": "Currency",
		"setting.integrationmuralegacyorderconfirmation_hint": "If you have upgraded from a previous version of Slatwall that used the filename hooks, and the 'frontend' subsystem, then the filename of that page should be in this field",
		"admin.define.save_title": "Save ${itemEntityName}",
		"entity.filerelationship_plural": "Files",
		"entity.vendororder_plural": "Vendor Orders",
		"define.local": "Local",
		"entity.accountphonenumber_plural": "Account Phone Numbers",
		"entity.pricegroup": "Price Group",
		"entity.promotionperiod.promotionperiodid": "Promotion Period ID",
		"entity.permission.entityname": "Entity Name",
		"entity.order.orderpayments": "Order Payments",
		"permission.setting.createattributeset": "Attribute Set - Create",
		"validate.addeventschedule.product_addeventschedule.eventstartdatetime.gtnow": "Event start date must occur in the future.",
		"admin.entity.vendorordertabs.stockreceivers": "Stock Receivers",
		"entity.skuprice.skupriceid": "Sku Price ID",
		"entity.orderpayment.appliedaccountpayments": "Applied Account Payments",
		"admin.main.update.currentversion": "Current Version",
		"entity.session.account": "account",
		"setting.integrationendiciasyncftpsitesecure": "FTP Sync Secure?",
		"entity.report_plural": "Reports",
		"admin.define.bundledsku": "Bundled Sku",
		"entity.subscriptionbenefit.categories": "Categories",
		"entity.vendororder.total": "Total",
		"entity.accountpaymentapplied.accountpaymentappliedid": "Account Payment Applied ID",
		"entity.workflow.activeflag": "Active",
		"defaultmessage_rangelength": "{1} must be between {2} and {3} characters long.",
		"entity.product.producttype": "Product Type",
		"admin.define.list_title": "View A List of ${itemEntityNamePlural}",
		"entity.sku.optionsdisplay": "Options",
		"define.emailrequired": "Email address format is incorrect",
		"admin.entity.createformquestion": "Create Form Question",
		"entity.define.renewalprice": "Renewal Price",
		"admin.entity.settingstabs.sku": "Sku Settings",
		"entity.skuoption.skuoptionid": "skuOptionID",
		"entity.sku.physicals": "Physicals",
		"entity.sku.eventconflictexistsflag": "Event Conflict",
		"define.qe": "QE",
		"entity.content.cmscontentid": "CMS Content ID",
		"entity.sku.process.editcapacity": "Edit capacity",
		"permission.warehouse.liststockadjustment": "Stock Adjustment - List",
		"define.qc": "QC",
		"entity.audit.audittype.create": "Created",
		"setting.emailfromaddress": "Email From Address",
		"entity.remoteentity": "Remote Entity",
		"setting.fulfillmentmethodautolocation_hint": "This location will be used for an 'auto' fulfillment methods.  It can be overridden in each 'auto' fulfillment method if you create multiple of that type.",
		"validation.define.eq": "The value entered is not correct.",
		"define.lastname": "Last Name",
		"entity.productbundlegroup.skupricepercentageincrease": "Sku Price Percentage Increase",
		"define.from": "from",
		"define.qs": "QS",
		"define.qr": "QR",
		"entity.inventory.quantityin": "Quantity In",
		"entity.accountpaymentmethod.bankaccountnumber": "Bank Account Number",
		"entity.pricegroup.appliedorderitems": "Applied Order Items",
		"setting.integrationendiciafrompostalcode": "From Postal Code",
		"entity.account.phonenumber": "Phone Number",
		"permission.product.saveproducttype": "Product Type - Save",
		"permission.order.saveorder": "Order - Save",
		"define.third": "Third",
		"entity.image.product": "Product",
		"entity.user.lastname": "lastName",
		"entity.account.subscriptionusages": "Subscriptions",
		"permission.vendor.savevendor": "Vendor - Save",
		"entity.term.termyears": "Term Years",
		"entity.taxapplied.taxliabilityamount": "Entity Tax Liability Amount",
		"gigya.main_permission": "Main Setup",
		"define.na": "N/A",
		"entity.vendor.vendorordertype": "Order Type",
		"validate.account.loginfailed": "The login you provided is invalid",
		"entity.accountauthentication.expirationdatetime": "Authentication Expiration",
		"processobject.sku_removelocation.editscope": "Edit scope",
		"define.no": false,
		"entity.schedule.daysofweektorun": "Days of Week",
		"entity.subscriptionusagebenefitaccount": "Subscription Usage Benefit Account",
		"define.ok": "Ok",
		"entity.subscriptionusagebenefit.excludedcontents": "Excluded Contents",
		"defaultmessage_minpatternsmatch_server": "{1} patterns were matched but {2} were required.",
		"entity.order.paymentamountdue": "Payment Amount Due",
		"define.showing": "Showing",
		"entity.product": "Product",
		"entity.subscriptionusage.mostrecentsubscriptionorderitem": "Most Recent Subscription Order Item",
		"define.of": "Of",
		"entity.setting.site": "Site",
		"entity.country.street2addressrequiredflag": "Require Street2 Address",
		"entity.taskhistory.endtime": "Task End Time",
		"admin.entity.processproduct.updatedefaultimagefilenames_success": "All default images have been reset.",
		"entity.vendorphonenumber.vendorphonenumberid": "Vendor Phone Number ID",
		"define.cancel": "Cancel",
		"setting.productimagedefaultextension": "Default Image Extension",
		"setting.integrationendiciasyncftpsitedropofffilename": "FTP Sync Dropoff Filename",
		"admin.define.process_success": "The ${itemEntityName} was processed successfully",
		"admin.entity.settingstabs.content": "Content Settings",
		"define.or": "Or",
		"admin.entity.producttabs.saleshistory": "Sales History",
		"entity.attribute.attributeinputtype.typeselect": "Type Select",
		"define.test_not_implemented": "Test has not been implemented",
		"entity.pricegrouprate.excludedproducttypes": "Exclude Product Types",
		"permission.vendor.detailvendororder": "Vendor Order - Detail",
		"entity.shippingmethodoption": "Shipping Method Option",
		"entity.attributeset.brands": "Brands",
		"entity.orderpayment": "Order Payment",
		"entity.order.promotioncodes": "Promotion Codes",
		"define.fulfillment": "Fulfillment",
		"setting.integrationauthorizenetloginid": "Login ID ",
		"entity.country.cityrequiredflag": "Require City",
		"entity.attribute.attributehint": "Attribute Hint",
		"defaultmessage_date": "{1} must be a valid date.",
		"admin.entity.pricegroupratetabs.products": "Products",
		"admin.entity.createmerchandiseproduct_nav": "New Merchandise Product",
		"entity.session.rblocale": "RB Locale",
		"define.august": "August",
		"entity.option.optiondescription": "Option Description",
		"setting.integrationupsshipfromphonenumber": "Shipping Phone Number",
		"entity.shippingmethod.promotionqualifiers": "Promotion Qualifiers",
		"entity.subscriptionusagebenefit.promotions": "Promotions",
		"setting.globaldefaultsite": "Default Site",
		"entity.product.productcode": "Product Code",
		"permission.vendor.listvendor": "Vendor - List",
		"validate.delete.orderitem.quantitydelivered.eq": "You cannot delete an order item which has been fulfilled.",
		"entity.giftcard_plural": "Gift Cards",
		"admin.entity.producttabs.productpages": "Product Pages",
		"entity.product.redemptionamounttype.select": "Please select a Redemption Amount Type...",
		"define.daily": "Daily",
		"permission.account.listaccount": "Account - List",
		"entity.attributevalue.attributevalueencrypted": "Attribute Value Encrypted",
		"entity.productschedule.eventendtime": "Event end time",
		"setting.accountauthenticationautologouttimespan": "Authentication Auto Logout Timespan",
		"entity.skuprice_plural": "Sku Prices",
		"entity.stockadjustmentdelivery.deliveryclosedatetime": "Delivery Close Date Time",
		"setting.integrationmuralegacyorderstatus": "Legacy Order Status Filename",
		"entity.shippingmethod.shippingprovidermethod": "Shipping Provider Method",
		"entity.entityqueuehistory": "Entity Queue History",
		"entity.giftcardtransaction.creditamount": "Credit Amount",
		"entity.define.creditcardnumberencryptedgenerator": "Credit Card Number Encryption Generator",
		"admin.entity.producttypetabs.products": "Products",
		"define.payment": "Payment",
		"setting.globalorderplacedemailsubjectstring": "New Order Placed Email Subject",
		"entity.file.fileid": "File ID",
		"entity.attributeoption_plural": "Attribute Options",
		"admin.entity.detailpromotion.norewards_info": "Currently there are no rewards assigned to this promotion.  You have created the promotion and setup an initial period, but you need to open that promotion period below and define what this promotion will be for.",
		"defaultmessage_numeric": "{1} must be a number.",
		"entity.orderpayment.checknumberencrypted": "Check Number  Encrypted",
		"entity.taxapplied.taxappliedid": "Tax Applied ID",
		"entity.shippingmethod.shippingmethodrates": "Shipping Method Rates",
		"entity.promotioncode.promotioncode_validateunique": "This promotion code is already in use.",
		"validate.product.accesscontentsrequired": "You must select a content node to be used for this Content Access product.  If none are available then you need to go into the admin of your site, and specify a page as restricted",
		"entity.promotionreward.promotionrewards": "Promotion Reward",
		"entity.updatescript.lastexecuteddatetime": "Last Execution Date Time",
		"admin.main.ckfinder_nav": "File Manager",
		"validate.addeventschedule.product_addeventschedule.purchasestartdatetime.gtnow": "Purchase Start Date must occur in the future",
		"setting.orderfulfillmentemailtemplate": "order fulfillment email template",
		"entity.image.directory": "Directory",
		"entity.report.dynamicdaterangeendtype.thisyearend": "Current Year End",
		"entity.accountloyaltytransaction.accountloyaltytransactionid": "Account Loyalty Transaction ID",
		"setting.paymentmethodstorecreditcardnumberwithorder_hint": "If this is set to yes, then when orders get placed it will automatically encrypyt the value of the credit card number and store in the order payment",
		"entity.currencyrate.conversioncurrency": "Conversion Currency",
		"admin.entity.processaccountloyalty.manualtransaction_success": "The account loyalty program transaction has been created successfully.",
		"validate.processproduct_create.schedulestartdate": "Event start date and schedule start date must match",
		"permission.product.deleteproducttype": "Product Type - Delete",
		"permission.setting.listtask": "Task - List",
		"entity.loyaltyredemption.autoredemptiontype.loyaltytermend": "Loyalty Term End",
		"entity.accountpaymentmethod.bankaccountnumberencrypted": "Bank Account Number  Encrypted",
		"entity.inventory.inventoryid": "Inventory ID",
		"mura.muraevent.oncontentedit.contentskus.norecords": "There are currently no products defined to sell this content.",
		"setting.skueligiblefulfillmentmethods": "Eligible Fulfillment Methods",
		"admin.entity.settings_title": "Settings",
		"admin.entity.deletepromotionperiod_disabled": "This promotion period cannot be deleted because it has been used in a transaction and/or it has expired.",
		"validate.addsubscriptionsku.product_addsubscriptionsku.renewalsubscriptionbenefits.required": "You must define either a Renewal Sku or a Renewal Benefit and Price.",
		"entity.image": "Image",
		"admin.entity.preprocessorder_include.changestatuscomment": "Add Comment (optional)",
		"entity.productbundlegroup.amounttype": "Base Price Adjustment Type",
		"validate.updatepassword.account_updatepassword.password.regex": "Admin passwords should include at least 1 letter, 1 number, and be 7 or more characters long.",
		"admin.define.create_title": "Create New ${itemEntityName}",
		"entity.country.streetaddressshowflag": "Show Street Address",
		"setting.integrationuspsliveapiendpointurl": "USPS Live API Endpoint URL",
		"permission.setting.listsetting": "Setting - List",
		"entity.product.eventregistrations": "Event Registrations",
		"entity.access.subscriptionusagebenefit": "Subscription Usage Benefit",
		"setting.siterecaptchasitekey": "Recaptcha Site Key",
		"define.qoh.full": "On Hand",
		"entity.productreview.sku": "Sku",
		"setting.integrationsofortlanguage": "Language (ISO 639-1)",
		"define.initial": "Initial",
		"entity.fulfillmentbatchitem_plural": "Fullfillment Batch Items",
		"entity.paymentmethod.process.processcashpayment": "Process Cash Payment",
		"entity.option.optionid": "Option ID",
		"entity.paymenttransaction.paymenttransactionid": "Payment Transaction ID",
		"permission.setting.detailterm": "Term - Detail",
		"defaultmessage_minpatternsmatch": "{1} did not match the required number of patterns.",
		"defaultmessage_email": "{1} must be a valid email address.",
		"admin.main.update.backup": "IMPORTANT: Be sure to backup your files and database before performing an update.",
		"entity.loyaltyaccruement.activeflag": "Active Flag",
		"entity.category.allowproductassignmentflag": "Allow Product Assignment",
		"define.qndoo": "QNDOO",
		"entity.vendorskustock.availabledatetime": "availableDateTime",
		"admin.entity.processapp.create_success": "Application saved successfully",
		"entity.productschedule.scheduleendoccurrences": "Occurrences",
		"admin.entity.ordertabs.orderitems.returnitems": "Return Items",
		"entity.skuprice.minquantity.null": "any",
		"admin.entity.createorderpayment.processoption.transactiontype": "Transaction Type",
		"entity.pricegrouprate.excludedskus": "Exclude SKUs",
		"setting.integrationmuralegacyorderconfirmation": "Legacy Order Confirmation Filename",
		"entity.alternateskucode_plural": "Alternate Sku Codes",
		"validate.processphysical_addphysicalcount.skucodeerrorwarning": "The file you uploaded had ${skuCodeError} sku code(s) that could not be found in the system.  Please verify these code(s) can map to the correct skus.",
		"entity.site.cmssiteid": "CMS Site ID",
		"admin.entity.deletepromotionreward_disabled": "This promotion reward cannot be deleted because it has been used in a transaction and/or its promotion period has expired.",
		"entity.skuoption.option": "option",
		"entity.sku.skucode": "SKU Code",
		"entity.giftcardtransaction": "Gift Card Transaction",
		"entity.accountcontentaccess.accesscontents": "Access Contents",
		"admin.entity.loyaltyaccruementtabs.producttypes": "Product Types",
		"entity.subscriptionusage.graceperiodterm": "Grace Period",
		"entity.loyaltyredemption.autoredemptiontype.pointsadjusted": "Points Adjusted",
		"setting.integrationmuralegacyorderstatus_hint": "If you have upgraded from a previous version of Slatwall that used the filename hooks, and the 'frontend' subsystem, then the filename of that page should be in this field",
		"entity.address.norecords": "No Addresses Defined",
		"define.contentaccess": "Content Access",
		"entity.productbundlebuilditem.productbundlebuilditemid": "Product Bundle Build Item ID",
		"permission.setting.detailcountry": "Country - Detail",
		"entity.attributeoption.attributeoptionlabel": "Label",
		"entity.stockadjustmentdelivery.stockadjustmentdeliveryid": "Stock Adjustment Delivery ID",
		"admin.entity.processproduct.create.selectrenewalsku": "Select a Sku to be used upon renewal.",
		"entity.accountloyaltytransaction.accountloyalty": "Account Loyalty",
		"admin.entity.producttabs.skusettings": "Sku Settings",
		"define.primary": "Primary",
		"admin.entity.accounttabs.carts": "Carts",
		"entity.session_plural": "Sessions",
		"entity.loyaltyterm": "Loyalty Term",
		"api.main.get": "API GET Method",
		"defaultmessage_doesnotcontainotherproperties": "{1} must not contain the values of properties named: {2}.",
		"entity.promotionqualifier.minimumprice": "Minimum Order Total",
		"entity.content.title": "Content Title",
		"entity.order.orderplacedsite": "Order Placed Site",
		"entity.account.accountaddresses": "Addresses",
		"entity.accountaddress.accountaddressname": "Nickname",
		"entity.promotionreward.shippingmethods": "Shipping Methods",
		"entity.workflowtaskaction.import": "Import",
		"admin.entity.processcontent.create_success": "Content saved successfully",
		"admin.main.lockaccount.toomanyattempts_error": "<strong>IMPORTANT:</strong> This account has been locked because there were too many failed login attempts made. <a href='?slatAction=main.unlockAccount&accountid=${accountID}' target='_self' >Unlock this account.</a>",
		"report.paymenttransactionreport": "Payment Transaction",
		"report.productperformancereport.returnprediscount": "Pre Discount Return",
		"entity.orderitem.referencedorderitem": "Referenced Order Item",
		"entity.promotioncode.promotion": "Promotion",
		"admin.entity.createproduct.selectrenewalsubscriptionbenefits": "Select Renewal Subscription Benefit(s)",
		"admin.setting.settings_nav": "Settings",
		"entity.fulfillmentbatch": "Batch",
		"entity.integration.integrationname": "Integration Name",
		"entity.sku.userdefinedpriceflag": "User Defined Price",
		"entity.sku.renewalsubscriptionbenefits": "Renewal Subscription Benefits",
		"setting.skuordermaximumquantity": "Max Order Qty.",
		"setting.integrationvertexwebservicestimeout": "Vertext Request Timeout",
		"entity.orderitem.quantityundelivered": "Qty. Undelivered",
		"define.fifth": "fifth",
		"report.promotionusagereport.promotionapplieddatetime": "Discount Applied Date Time",
		"entity.previousorderpayment": "Previous Order Payment",
		"admin.entity.addresszonetabs.locations": "Locations",
		"entity.vendoremailaddress_plural": "Vendor Email Addresses",
		"validation.define.uniqueornull": "This value must be unique or empty",
		"entity.stockadjustment.createdatetime": "Created Date",
		"processobject.order_addorderitem.fulfillmentmethodid": "Fulfillment Method",
		"validate.define.numeric": "The value entered for ${propertyName} is not a number.",
		"permission.help.about": "About",
		"entity.product.process.addsubscriptionterm": "Add Subscription Term",
		"entity.paymentmethod.process.processpayment": "Process Payment",
		"admin.define.edit_title": "Edit ${itemEntityName}",
		"processobject.subscriptionusage_renew.renewalpaymenttype": "Pay For Renewal Via",
		"entity.address.addressid": "Address ID",
		"entity.vendoremail.vendoremailid": "vendorEmailID",
		"entity.promotionqualifier.shippingmethods": "Shipping Methods",
		"admin.define.notfound": "Not Found",
		"entity.attributevalue.attributevalue": "Attribute Value",
		"admin.main.processbouncedemails": "Process Bounced Emails",
		"entity.orderitemgiftrecipient": "Order Item Gift Recipient",
		"entity.remoteentity.remoteentityid": "Remote Entity ID",
		"entity.form.formid": "Form ID",
		"admin.entity.editreport_nav": "Update Config & Defaults",
		"admin.entity.producttypetabs.skusettings": "Sku Settings",
		"setting.brandhtmltitlestring": "Brand HTML Title String",
		"entity.loyaltyredemption.redemptiontype": "Loyalty Reward",
		"admin.entity.processprint.addtoqueue_success": "Print Successfully Queued",
		"permission.account.detailaccount": "Account - Detail",
		"define.metrics": "Metrics",
		"entity.workflowtaskaction.printtemplate": "Print Template",
		"entity.attribute.validationtype": "Validate",
		"entity.sku.qexp": "QEXP",
		"processobject.product_create.giftcardexpirationterm": "Expiration Term",
		"entity.taxapplied.taxstreet2address": "Tax Street 2 Address",
		"entity.promotionqualifier.rewardmatchingtype.any": "Any",
		"entity.brand.publishedflag": "Published Flag",
		"admin.define.save_nav": "Save ${itemEntityName}",
		"admin.entity.detailaccount.authenticationdetails_hint": "This section lists out all of the different forms of authentication this account can use to login.  If nothing is listed below you can create an authentication by going to 'Actions > Create Password'.  You can also remove authentications below including any temporary passwords might have been previously created using the forgot password tool.",
		"permission.product.editsubscriptionterm": "Subscription Term - Edit",
		"entity.content.childcontents": "Child Contents",
		"entity.stockadjustment.process.processadjustment": "Process Adjustment",
		"validate.addeventschedule.product_addeventschedule.purchaseenddatetime.gtdatetimeproperty": "Purchase End Date must occur after Purchase Start Date.",
		"admin.entity.stockadjustments.stockreceivers": "Stock Receivers",
		"entity.sku.options_validateunique": "This option combination already exists.",
		"define.qe.full": "Expected",
		"entity.subscriptionterm.graceperiodterm_hint": "If an auto-renewed subscription is unpaid for some reason, then this grace period will provide the duration that someone can continue to use services until their account is suspended",
		"setting.skuqatsincludesqnroroflag": "QATS Includes QNRORO",
		"entity.stockadjustment.stockadjustmenttype": "Type",
		"entity.product.brand": "Brand",
		"define.after": "After",
		"entity.sku.skucode_validateunique": "This SKU code is already in use.",
		"admin.main.about_nav": "About Slatwall",
		"entity.eventregistration.process.waitlist": "Add to Wait List",
		"setting.integrationupsshipfrompostalcode": "Shipping From Postal Code ",
		"permission.setting.saveattributeset": "Attribute Set - Save",
		"processobject.product_addeventschedule.bundlelocationconfigurationflag": "Single Registration",
		"entity.accountloyaltytransaction": "Account Loyalty Transaction",
		"entity.attributevalue.orderdelivery": "Order Delivery",
		"entity.option.images": "Images",
		"entity.promotionqualifier.maximumorderquantity": "Maximum Order Quantity",
		"define.bundle": "Bundle",
		"admin.entity.paymentmethodtabs.settings": "Payment Method Settings",
		"setting.siteverifyaccountemailaddressemailtemplate": "Verify Account Email Address Email Template",
		"admin.entity.loyaltyredemptiontabs.products": "Products",
		"define.weeks": "Weeks",
		"admin.define.process": "Process ${itemEntityName}",
		"frontend.cart.detail.noitems": "There are currently no items in your cart.",
		"entity.sku.purchaseenddatetime": "Purchase End Date",
		"entity.accountrelationship_plural": "Account Relationships",
		"entity.producttype.loyaltyaccruements": "Loyalty Accruements",
		"entity.taxapplied.taxstreetaddress": "Tax Street Address",
		"setting.integrationavataxtestingflag": "Test Mode ",
		"admin.pricing.promotionperiod.productortypeorskunotdefined_info": "There must be at least one sku, product, or product type selected for this reward to work.",
		"permission.product.saveproduct": "Product - Save",
		"entity.permission.permissionid": "Permission ID",
		"define.second": "second",
		"entity.shippingmethod.shippingprovider": "Shipping Provider",
		"entity.promotionqualifier.excludedproducts": "Product Exclusions",
		"entity.accountloyalty.manualadjustmenttype.manualout": "Manual Out",
		"admin.entity.detailstockadjustment.fromlocationname": "From Location",
		"entity.producttype.producttypenamepath": "Product Type Name Path",
		"setting.integrationauthorizenettestserverflag": "Use Test Server ",
		"admin.entity.fulfillmentmethodtypes.pickuptabs.settings": "Settings",
		"permission.product.saveoptiongroup": "Option Group - Save",
		"permission.setting.detailaddresszone": "Address Zone - Detail",
		"api.main.define.delete_success": "The ${EntityName} was deleted successfully",
		"entity.order.previouslyrefundedfulfillment": "Previously Refunded Fulfillment",
		"entity.addresszone.addresszoneid": "Address Zone ID",
		"entity.orderpayment.giftcardpaymentprocessedflag": "Gift Card Payment Processed Flag",
		"entity.loyaltyaccruement.loyalty": "Loyalty",
		"admin.main.dashboard.recentvendororderupdates": "Recently Updated Vendor Orders",
		"entity.order.defaultstocklocation": "Default Stock Location",
		"validate.promotioncode.overmaximumaccountusecount": "The promotion code that you have entered can not be used any more by this account.",
		"admin.entity.processproduct.addskubundle_success": "A sku bundle has been created successfully.",
		"entity.report.metrics": "Metrics",
		"admin.entity.processorder.addorderpayment_success": "Order payment added successfully",
		"entity.eventregistration.registrantattendancecode": "Registrant Attendance Code",
		"entity.loyaltyterm.loyaltytermstartdatetime": "Loyalty Term Start Date Time",
		"entity.accountloyalty.accountloyaltyid": "Account Loyalty ID",
		"admin.define.delete_permission": "${itemEntityName} - Delete",
		"setting.shippingmethodqualifiedrateselection": "Qualifying Shipping Rate Selection Method",
		"entity.stockadjustmentdelivery": "Stock Adjustment Delivery",
		"entity.promotioncode.promotioncode": "Promotion Code",
		"entity.option.optiongroup": "Option Group",
		"entity.workflowtriggerhistory.response": "Response",
		"defaultmessage_futuredate": "{1} must be a date in the future.",
		"entity.vendororder": "Vendor Order",
		"report.appliedtaxreport": "Applied Sales Tax",
		"endicia.main.syncpush_permission": "FTP Sync Push",
		"entity.task.taskmethod.subscriptionusagerenew": "Subscription Usage - Renew Subscriptions",
		"entity.integration.fw1activeflag": "FW1 Subsystem Active",
		"admin.entity.processorder.duplicateorder_success": "The duplicate order was created successfully.",
		"define.passwordconfirm": "Confirm Password",
		"admin.define.saveandfinish": "Save & Finish",
		"defaultmessage_inlist": "{1} was not found in the list: {2}.",
		"entity.define.countpostdatetime_hint": "This value defines the exact date/time when the discrepancy against this count should be calculated",
		"entity.sku.liveprice": "Live Price",
		"entity.loyaltyredemption.autoredemptionterm": "Auto Redemption Term",
		"entity.brand.brandid": "brandID",
		"entity.promotion.appliedpromotions": "Applied Promotions",
		"entity.eventregistration.skudefinition": "Location Configuration",
		"entity.product.publishedflag_hint": "Item is available and visible on the front-end (both 'Active' and 'Published' must be selected to display on the front-end)",
		"entity.promotionreward.maximumorderrewardquantity": "Max. Qty. per Order",
		"entity.physical.producttypes": "Product Types",
		"entity.content.allowpurchaseflag_hint": "By setting this value to 'yes' then this page will be available to be sold as a content access product.",
		"entity.physicalcount.location": "Physical Count Location",
		"entity.taxcategoryrate.taxcategory": "Tax Category",
		"entity.workflowtrigger.savetriggerhistoryflag": "Save trigger History",
		"entity.shippingmethodrate.shipmentweightrange": "Weight Range",
		"validate.setupinitialadmin.account_setupinitialadmin.password.minlength": "Password must be at least 6 characters long",
		"processobject.account_setupinitialadmin.sitetitle": "Site Title",
		"entity.stockreceiveritem": "Stock Receiver Item",
		"entity.session.accountauthentication": "Account Authentication",
		"entity.option.optionname": "Option Name",
		"define.date": "Date",
		"entity.accountloyaltytransaction.pointsin": "Points In",
		"define.amountoff": "Amount Off",
		"entity.orderdelivery": "Order Delivery",
		"setting.skueligiblecurrencies_hint": "This defines the active currencies that a sku is avalable for sale in.",
		"entity.comment.commentid": "Comment ID",
		"entity.shippingmethod.shippingmethodcode": "Shipping Method Code",
		"frontend.checkout.detail.guestcheckout": "Guest Checkout",
		"entity.sku.skudescription": "Sku Description",
		"entity.account.accountemails": "Account Emails",
		"entity.promotioncode.promotioncodeid": "Promotion Code ID",
		"admin.entity.createpromotionrewardfulfillment": "Fulfillment Discount",
		"define.renewal": "Renewal",
		"validate.create.account_create.password.regex": "Admin passwords should include at least 1 letter, 1 number, and be 7 or more characters long.",
		"entity.fulfillmentmethod.promotionqualifiers": "Promotion Qualifiers",
		"setting.globalurlkeyproduct": "Product URL Key",
		"admin.entity.ordertabs.depositorderitems": "Deposit Order Items",
		"admin.entity.settings_nav": "Settings",
		"entity.productschedule.eventstartdatetime": "Event End",
		"define.cost": "Cost",
		"entity.taxapplied.taximpositionid": "Tax Imposition ID",
		"entity.sku.startreservationdatetime": "Reservation Start Date",
		"entity.accountpayment.termoffsettotalamount": "Order Payment Amount",
		"admin.entity.producttabs.basic": "Basic",
		"entity.accountloyaltyaccruement.accruementtype.itemfulfilled": "Item Fulfilled",
		"entity.attributevalue.orderitem": "Order Item",
		"validate.delete.orderdeliveryitem.orderdeliveryitemid.maxlength": "You cannot delete and order delivery item.",
		"entity.setting.subscriptionusage": "Subscription Usage",
		"entity.sku.renewalmethod": "Renewal Method",
		"processobject.sku_changeeventdates.reservationendtime": "New reservation end time",
		"admin.define.cashdetails": "Cash Details",
		"admin.entity.physicaltabs.discrepancies": "Discrepancies",
		"entity.paymentterm.term": "Term",
		"entity.paymenttransaction.avsdescription": "AVS Description",
		"entity.orderfulfillment.subtotalafterdiscountswithtax": "Fulfillment Items Total After Discounts & Tax",
		"validate.changeeventdates.sku_changeeventdates.startreservationdatetime.ltdatetimeproperty": "The event reservation end date must occur after start date.",
		"entity.workflowtriggerhistory.workflowtriggerhistoryid": "Workflow Trigger History ID",
		"define.line": "Line",
		"define.here": "Here",
		"admin.entity.producttabs.productcategories": "Product Categories",
		"define.directory": "Directory",
		"entity.promotionqualifier.rewardmatchingtype": "Reward Matching Type",
		"entity.pickwave_plural": "Pick Waves",
		"entity.postalcode.postalcode": "Postal Code",
		"defaultmessage_integer": "{1} must be an integer.",
		"setting.skueligiblecurrencies": "Eligible Currencies",
		"entity.vendororderitem.estimatedreceivaldatetime": "Estimated Receival",
		"entity.sku.loyaltyredemptions": "Loyalty Redemptions",
		"entity.attribute.attributeinputtype": "Input Type",
		"entity.type.typeid": "typeID",
		"validate.save.content.urltitlepath.isuniqueurltitlepathbysite": "The URL Title Path is not unique.",
		"define.years": "years",
		"validate.account.accesscode": "The access code you provided is invalid.",
		"entity.report.dynamicdaterangetype": "Date Range Type",
		"report.orderitemreport.itemdiscountgiven": "Discount",
		"validate.save.orderitem.quantity.hasquantitywithinminorderquantity": "The quantity that you have entered is less than the minimum order quantity.",
		"entity.collection.collectionconfig": "Collection Config",
		"entity.address.company": "Company",
		"admin.entity.exporttask_title": "Export Task List",
		"entity.paymentmethod.saveaccountpaymentmethodtransactiontype": "Save APM Trans.",
		"entity.subscriptionusage.userenewalsku": "Use Renewal Sku?",
		"entity.productreview.reviewtitle": "Review Title",
		"entity.accountloyaltytransaction.loyaltyaccruement": "Loyalty Accruement",
		"entity.subscriptionusagebenefit": "Subscription Usage Benefit",
		"setting.integrationvertexoriginpostalcode": "Origin Postal Code",
		"entity.product.eventconflict": "There are event time and location conflicts with one of this product's events. Review the Skus tab for details.",
		"define.monthly": "Monthly",
		"entity.waitlistqueueterm_plural": "Waitlist Queue Terms",
		"processobject.sku_changeeventdates.editscope": "Edit schedule for",
		"admin.define.basic": "Basic",
		"setting.productimagelargewidth": "Large Image Width",
		"admin.entity.producttabs.skus": "Skus",
		"admin.entity.ordertabs.orderitemgiftrecipients": "Gift Card Recipients",
		"setting.locationconfigurationcapacity": "Location Configuration Capacity",
		"entity.taskschedule.failureemaillist": "Failure Emails",
		"entity.permission.allowcreateflag": "Allow Create Flag",
		"entity.content.skus": "Skus",
		"entity.sku.webwholesaleqoh": "webWholesaleQOH",
		"admin.main.update.availablestableversion": "Available Stable Version",
		"entity.currency": "Currency",
		"define.pricegroups": "Price Groups",
		"entity.workflow.createdby": "Created By",
		"define.search": "Search",
		"entity.subscriptionusage.autorenewflag": "Auto Renew",
		"entity.accountaddress.address": "Address",
		"processobject.sku_changeeventdates.reservationstarttime": "New reservation start time",
		"entity.orderitem.appliedtaxes": "Applied Taxes",
		"entity.permission.allowreadflag": "Allow Read Flag",
		"setting.globalencryptionkeysize": "Encryption Key Size",
		"validate.addeventschedule.product_addeventschedule.purchasestartdatetime.ltdatetimeproperty": "Purchase Start Date must occur before the event.",
		"admin.define.nosearchresults": "No Results Found",
		"validate.save.promotionperiod.enddatetime.gtproperty": "The end date should be greater than the start date.",
		"define.weekofthemonth": "Week of the Month",
		"setting.globalauditautoarchiveversionlimit": "Audit Auto-Archive After X Versions",
		"entity.type": "Type",
		"entity.attributevalue.account": "account",
		"setting.integrationvertexorigincountry": "Origin Country",
		"entity.pricegroup.subscriptionusagebenefits": "Subscription Usage Benefits",
		"entity.commentrelationship.vendororder": "Vender Order",
		"entity.profiletemplate.profiletemplateid": "profileTemplateID",
		"entity.taxcategoryrate": "Tax Category Rate",
		"entity.site_plural": "Sites",
		"entity.workflowtriggerhistory.starttime": "Start Time",
		"admin.entity.createpromotionqualifiercontentaccess": "Content Access Item Qualifier",
		"entity.loyaltyterm_plural": "Loyalty Terms",
		"entity.promotionapplied.orderitem": "Order Item",
		"admin.entity.processemail.addtoqueue_success": "Email Sent",
		"entity.commentrelationship.referencedexpressionend": "Referenced Expression End",
		"setting.accountfailedadminloginattemptcount": "Max Admin Failed Login Attempts",
		"define.qndorvo": "QNDORVO",
		"permission.setting.listtype": "Type - List",
		"setting.integrationvirtualmerchantmerchantid": "VirtualMerchant ID (6 Digit)",
		"admin.entity.skutabs.orderitems": "Order Items",
		"entity.location.primaryaddress": "Primary Address",
		"entity.define.calculatedqats": "QATS",
		"define.qs.full": "Sold",
		"permission.setting.savelocation": "Location - Save",
		"admin.entity.detailorderpayment.entireordertotal": "Entire Order Total",
		"entity.shippingmethod.promotionrewards": "Promotion Rewards",
		"entity.giftcard.process.toggleactive": "Toggle Active",
		"admin.main": "Dashboard",
		"admin.entity.define.addaccountpayment_error": "There was an error adding the Account Payment",
		"entity.promotionperiod.maximumaccountusecount": "Max. Account Use Count",
		"entity.brand.promotionqualifierexclusions": "Promotion Qualifier Exclusions",
		"entity.product.productyear": "Product Year",
		"entity.subscriptionusage.process.updatestatus": "Update Subscription Status",
		"entity.option.promotionqualifiers": "Promotion Qualifiers",
		"setting.subscriptionusagerenewalreminderdays_hint": "Comma seperated list of when you would like emails to go-out before a subscription expires",
		"admin.entity.producttabs.customattributes": "Custom Attributes",
		"entity.attributeoption.delete_success": "Attribute option deleted.",
		"entity.audit.sessionaccountfullname": "Account Name",
		"entity.audit.changedetails.propertychanged.new": "Changed To",
		"entity.report.reportcompareflag": "Report Compare Flag",
		"entity.vendoremailaddress": "Vendor Email Address",
		"entity.subscriptionterm.subscriptiontermname": "Subscription Term Name",
		"gigya_permission": "Gigya Integration",
		"entity.orderfulfillment.manualfulfillmentchargeflag": "Manual Fulfillment Charge Flag",
		"permission.pricing.listpricegroup": "Price Group - List",
		"permission.product.saveproductreview": "Product Review - Save",
		"entity.productrelationship.relatedproduct": "Related Product",
		"entity.addresszonelocation.addresszonelocationid": "Address Zone Location ID",
		"entity.waitlistqueueterm.waitlistqueuetermname": "Term Name",
		"entity.accountrelationship.accountrelationshipid": "accountRelationshipID",
		"entity.audit.sessionaccountid": "Session Account ID",
		"permission.product.listbrand": "Brand - List",
		"entity.promotioncode": "Promotion Code",
		"setting.skuallowbackorderflag": "Backorder OK",
		"entity.workflowtrigger.nextrundatetime": "Next Run Date Time",
		"admin.entity.ordertabs.stockreceivers": "Stock Receivers",
		"permission.order.saveorderfullfillment": "Order Fulfillment - Save",
		"define.time": "Time",
		"entity.promotionreward.promotionrewardcurrencies": "Promotion Reward Currencies",
		"entity.type_plural": "Types",
		"entity.collection_plural": "Collections",
		"entity.updatescript.executioncount": "Execution Count",
		"entity.paymentmethod.process.processtermaccountpayment": "Process Term Account Payment",
		"entity.orderitem.profile": "profile",
		"permission.product.savesubscriptionterm": "Subscription Term - Save",
		"entity.term.renewalsubscriptionterms": "Renewal Subscription Terms",
		"entity.workflowtask_plural": "Tasks",
		"entity.product.categories": "Categories",
		"entity.category.categorydescription": "Category Description",
		"entity.accountpaymentmethod.creditcardlastfour": "Credit Card",
		"entity.attributeset.globalflag": "Global Attribute Set",
		"entity.loyaltyredemption.amounttype.dollarperpoint": "Dollar Per Point",
		"entity.accountpayment.termoffsetaccountbalance": "Account Balance After",
		"entity.site.sitename": "Site Name",
		"entity.postalcode.longitude": "longitude",
		"setting.integrationclickandbuysecretkey": "Secret Key",
		"entity.promotionreward.excludedskus": "Sku Exclusions",
		"validate.orderitem.quantity.toomanyeventregistrations": "There are too many assigned event registration.",
		"validate.account_setupinitialadmin.password.regex": "Admin passwords should include at least 1 letter, 1 number, and be 7 or more characters long.",
		"permission.product.editbrand": "Brand - Edit",
		"entity.order.orderfulfillments": "Order Fulfillments",
		"entity.orderdelivery.totalquantitydelivered": "Total Qty. Delivered",
		"validate.offlinetransaction.giftcard_offlinetransaction.amount.lteproperty.giftcardbalanceamount": "You've entered an amount to charge greater than the balance of the gift card.",
		"entity.productschedule.scheduleendtype": "End Type",
		"setting.integrationavataxsourcepostalcode": "Source Postal Code",
		"entity.attributevalue_plural": "Attribute Values",
		"admin.entity.promotionqualifiertabs.skus": "Skus",
		"admin.physical.listphysical.status": "Status",
		"entity.accountpaymentmethod.bankroutingnumberencrypted": "Bank Routing Number  Encrypted",
		"entity.skucurrency.price": "Price",
		"entity.taxcategoryrate.taxaddresslookup": "Tax Address",
		"admin.pricing.createpromotionqualifiersubscription": "Create Promotion Qualifier Subscription",
		"entity.orderdeliveryitem": "Order Delivery Item",
		"entity.stockadjustmentitem.adjustmentquantity": "Adjustment Qty.",
		"entity.stockadjustment.stockadjustmentitems": "Stock Adjustment Items",
		"entity.postalcode.country": "country",
		"entity.define.remoteid": "Remote ID",
		"admin.entity.processeventregistration.pendingapproval_success": "Registration has been changed to Pending Approval.",
		"admin.entity.preprocessorder": "Create Order",
		"entity.locationconfiguration.locationconfigurationid": "Location Configuration ID",
		"setting.integrationupsshipfromaddressline": "Shipping Street Name",
		"entity.define.bundleflag": "SKU Bundle",
		"admin.entity.subscriptionusagetabs.subscriptionusagesettings": "Subscription Usage Settings",
		"admin.entity.processproduct.deletedefaultimage_success": "Imaged Deleted",
		"define.pie": "Pie",
		"setting.integrationfullcirclelocaltransferurlusername": "Local Transfer URL Username",
		"entity.orderitem.taxliabilityamount": "Tax Liability Amount",
		"entity.subscriptionusagebenefit.excludedcategories": "Excluded Categories",
		"entity.accountpaymentapplied.orderpayment": "Order Payment",
		"validate.create.product_create.renewalprice.required": "You must define a Renewal Price and it must be greater than zero.",
		"setting.header.sitesettings": "Site Settings",
		"entity.term.sortorder": "Sort Order",
		"entity.account.emailaddressconfirm": "Confirm Email Address",
		"permission.setting.saveterm": "Term - Save",
		"entity.site.domainnames": "Domain Names",
		"admin.main.encryptionreencryptdata": "Re-encrypt Database",
		"setting.accountfailedpublicloginattemptcount_hint": "This is the max number of login attempts than a public user gets before their account is locked.",
		"admin.entity.accounttabs.accountsettings": "Account Settings",
		"entity.accountloyalty.manualadjustmenttype.manualin": "Manual In",
		"entity.permissiongroup_plural": "Permission Groups",
		"entity.loyaltyterm.term": "Term",
		"entity.fulfillmentbatch.fulfillmentbatchid": "Fulfillment Batch ID",
		"entity.taxcategoryrate.taxaddresslookup.billing": "Billing Only",
		"setting.skuholdbackquantity_hint": "Qty. To Hold Back From ATS (Available To Sell) Calculations",
		"entity.report.dynamicdaterangetype.weektodatesunday": "Week to Date ( Starting Sunday )",
		"validate.giftcard.isexpired": "The gift card you are trying to use is expired.",
		"entity.producttype.pricegrouprates": "Price Group Rates",
		"admin.entity.processproduct.create.selectcustomrenewal": "Select a benefit and price to be used upon renewal.",
		"define.language.fr_fr": "French",
		"define.subscriptionbenefits": "Subscription Benefits",
		"setting.globaltimeformat": "Time Format",
		"entity.producttype": "Product Type",
		"entity.emailtemplate.logemailflag": "Log Email",
		"setting.integrationpaypalexpresspaypalaccountsandboxflag": "PayPal Account Sandbox",
		"admin.entity.accounttabs.giftcards": "Gift Cards",
		"entity.producttype.loyaltyredemptionexclusions": "Loyalty Redemption Exclusions",
		"entity.pricegrouprate.amount": "Amount",
		"define.multiselect": "Multiselect",
		"validate.changepassword.account_changepassword.password.minlength": "The password that you enter must be at least 6 characters long.",
		"entity.sku.locationconfigurations": "Location Configuration",
		"entity.sku_plural": "Skus",
		"entity.vendoraddress.vendoraddressname": "Nickname",
		"entity.promotionperiod.enddatetime": "End Date/Time",
		"entity.order.process.removepersonalinfo": "Remove Personal Info",
		"admin.entity.editorderitemgiftrecipient_disabled": "You cannot edit a gift recipient while it's gift cards are active.",
		"event.onapplicationfullupdate": "On Application Full Update",
		"entity.order.discounttotal": "Discount",
		"admin.metadismissed_info": "The /meta directory warning has been dismissed make sure you delete the /meta directory manually before deploying in production use.",
		"entity.vendororder.vendororderitems": "Vendor Order Items",
		"entity.ordertiem": "Order Item",
		"setting.productdisplaytemplate": "Product Display Template",
		"setting.fulfillmentmethodemailbcc": "fulfillment method email bcc",
		"entity.physical.process.commit": "Commit Physical Count",
		"entity.paymentmethod.paymentmethodtype": "Payment Method Type",
		"validate.delete.sku.transactionexistsflag.eq": "This sku can not be deleted it has been used on transactions.",
		"permission.setting.editcountry": "Country - Edit",
		"entity.country.statecoderequiredflag": "Require State Code",
		"entity.loyaltyredemption.brands": "Brands",
		"admin.entity.promotionqualifiertabs.shippingmethods": "Shipping Methods",
		"mura.main.default": "Mura Integration",
		"admin.entity.createphysicalcountitem": "Add Items",
		"admin.entity.processeventregistration.notplaced_success": "Registration status changed to Not Placed.",
		"entity.shippingmethodrate.shippingmethod": "Shipping Method",
		"entity.productschedule.scheduleenddate": "Schedule End Date",
		"entity.product.define.productname": "Product Name",
		"entity.taskhistory.taskhistoryid": "Task History ID",
		"admin.entity.listworkflow": "Workflows",
		"admin.entity.createproduct.selectrenewalsubscriptionbenifits": "Select the Renewal Subscription Benefit(s) that you would like to sell as this product.",
		"entity.taxcategory.taxcategoryname": "Tax Category Name",
		"admin.entity.preprocessphysical.addphysicalcount": "Add Physical Count",
		"entity.stockreceiver": "Stock Receiver",
		"admin.main.dashboard.neworders": "New Orders",
		"entity.loyaltyaccruement.enddatetime": "End Date/Time",
		"entity.paymentterm.accountpaymentmethods": "Account Payment Methods",
		"admin.entity.listproduct.createnoevent": "You cannot create an 'Event' product until you have defined at least one 'Location Configuration' inside of a 'Location'. ",
		"entity.physicalcountitem.skucode": "Sku Code",
		"entity.print.printid": "Print ID",
		"processobject.content_create.urltitle": "URL Title",
		"setting.locationconfigurationadditionalprereservationtime_hint": "This setting will allow for events using this configuration to add these minutes onto the begining of the location reservation for extra breakdown time for example",
		"entity.report.dynamicdaterangetype.quartertodate": "Quarter To Date",
		"entity.account.delete_success": "Account Deleted Successfully",
		"admin.entity.settingstabs.shippingmethodrate": "Shipping Rate Settings",
		"entity.loyaltyredemption.redemptionpointtype.current": "Current Point Balance",
		"define.address": "Address",
		"permission.superuser": "Super User",
		"validate.delete.orderfulfillment.orderfulfillmentid.maxvalue": "The order fulfillment cannot be deleted as the order has been placed.",
		"admin.main.dashboad": "Dashboad",
		"setting.globalordernumbergeneration": "Order Number Generation",
		"define.accesscode": "Access Code",
		"admin.define.list_nav": "${itemEntityNamePlural}",
		"entity.accountloyalty.lifetimebalance": "Lifetime Point Balance",
		"validate.processsubscriptionusage_renew.order.notplaced": "A renewal order was created, however it couldn't be placed which is most likely because of payment issues.  Please navigate to this order to finalize and place:",
		"entity.loyaltyredemption.skus": "Skus",
		"entity.giftcard.ownerfirstname": "First Name",
		"entity.order.process.closeorder": "Close Order",
		"admin.define.delete_error": "There was an error when trying to delete the ${itemEntityName}",
		"admin.entity.createphysicalcount": "Create New Physical Count",
		"setting.locationconfigurationadditionalpostreservationtime": "Post Event Reservation Minutes",
		"admin.pricing.detailpromotion.initialperiod": "Initial Period",
		"entity.vendoraccount.roletype": "Role Type",
		"define.reporttype": "Report Type",
		"email.deliveryconfirmation": "Delivery Confirmation",
		"entity.state_plural": "States",
		"permission.setting.createtask": "Task - Create",
		"entity.address.city": "City",
		"admin.entity.processproduct.addsubscriptionsku_success": "Subscription Sku Added",
		"entity.baseentity.updatekeys": "updateKeys",
		"entity.addresszone.shippingmethodrates": "Shipping Method Rates",
		"entity.attribute.attributeoptions": "Attribute Options",
		"entity.subscriptionorderitem.subscriptionorderitemid": "Subscription Order Item ID",
		"entity.accountpayment.checknumberencrypted": "Check Number Encrypted",
		"entity.account.accountcontentaccesses": "Account Content Accesses",
		"admin.entity.settingstabs.site": "Site Settings",
		"entity.stockadjustmentitem.tostock": "To Stock",
		"entity.subscriptionbenefit": "Subscription Benefit",
		"entity.stockadjustmentitem.stock": "Stock",
		"entity.define.billingaccountaddress": "Billing Account Address",
		"entity.file.filename": "File Name",
		"report.productperformancereport.saleprediscount": "Pre Discount Sale",
		"admin.pricing.createpromotionqualifiermerchandise": "Create Promotion Qualifier Merchandise",
		"entity.orderfulfillment.pickuplocation": "Pickup Location",
		"entity.stockadjustment.adjustmenttype": "adjustmentType",
		"entity.orderfulfillment.process.manualfulfillmentcharge": "Override Fulfillment Charge",
		"setting.taskfailureemailtemplate_hint": "This email template will be used to send out failure notifications in the event that a task does not run successfully",
		"admin.entity.promotionreward.discounttype.amountoff": "Amount Off",
		"entity.orderfulfillment.discountamount": "Discounts",
		"setting.productimagesmallheight": "Small Image Height",
		"entity.content.contenttemplatetype_hint": "There are special pages defined by Slatwall as 'Template' pages that get used as the template for a given product, brand, etc.  For example if you select 'Product' here, this page will then be available in the settings tab of the products in Slatwall to be used as a template.",
		"admin.entity.processapp.create_error": "There was a problem saving application",
		"entity.promotionqualifier.qualifiertype.merchandise": "Merchandise",
		"define.creditoffline": "Credit Offline",
		"entity.product_plural": "Products",
		"admin.entity.promotiontabs.promotionperiods": "Promotion Periods",
		"entity.product.process.create": "Create Product",
		"permission.setting.detailcontent": "Content - Detail",
		"processobject.sku_changeeventdates.eventendtime": "New end time",
		"entity.subscriptionstatus.subscriptionstatustype": "Subscription Status Type",
		"entity.pickwave.pickwaveid": "Pick Wave ID",
		"admin.pricing.createpromotionrewardmerchandise": "Create Promotion Reward Merchandise",
		"entity.loyaltyredemption.nextredemptiondatetime": "Next Redemption Date/Time",
		"validate.delete.sku.defaultflag.eq": "This sku can not be deleted because it is the default sku for this product.",
		"entity.productbundlegroup": "Product Bundle Group",
		"define.modifiedbyaccount": "Modified By",
		"entity.taxapplied.taxjurisdictionid": "Tax Jurisdiction ID",
		"entity.address.middleinitial": "Middle Initial",
		"entity.promotionreward.products": "Products",
		"entity.promotionqualifier.qualifiertype": "Qualifier Type",
		"entity.promotionreward.itemrewardquantity": "Qty. per Qualification",
		"entity.define.companypaymentmethodflag": "Company Payment Method",
		"admin.entity.producttypetabs.producttypesettings": "Product Type Settings",
		"admin.define.externaldetails": "External Details",
		"entity.accountemailaddress.accountemailtype": "Email Type",
		"entity.paymentmethod.allowsaveflag_hint": "If this is set to yes, then people will be able to save payment methods of this type to their account.",
		"setting.emailimapserverpassword": "Bounced Email Server Password",
		"permission.product.listproducttype": "Product Type - List",
		"admin.entity.optiongrouptabs.description": "Description",
		"entity.sku.eventcapacity": "Event capacity",
		"entity.accountemailaddress.emailaddress": "Email Address",
		"entity.orderitem.quantity": "Qty.",
		"processobject.account_create.createauthenticationflag_hint": "Selecting yes will allow you to save a password for this account so that it can be accessed later",
		"setting.globaldateformat": "Date Format",
		"entity.stockadjustment.tolocation": "To Location",
		"admin.entity.attributesettabs.attributes": "Attributes",
		"define.qualified": "Qualified",
		"define.month": "Month",
		"admin.entity.optiongrouptabs.options": "Options",
		"entity.sku.redemptionamounttype": "Redemption Amount Type",
		"admin.entity.promotionrewardtabs.currencies": "Currencies",
		"setting.paymentmethodstorecreditcardnumberwithaccount_hint": "If this is set to yes, then when orders get placed it will automatically create an account payment method, that is setup with the credit card number encrypted and saved",
		"admin.entity.processorder.closeorder_success": "The order has successfully been closed.",
		"admin.entity.emailtemplatetabs.htmlbody": "HTML Body",
		"entity.promotionqualifier.maximumitemprice": "Maximum Item Price",
		"admin.entity.orderitemtabs.orderitemgiftrecipients": "Gift Recipients",
		"api.main.define.save_success": "The ${EntityName} was saved successfully",
		"entity.collection.collectiontabletitle": "Collection Results",
		"entity.currencyrate.effectivestartdatetime": "Effective Start DateTime",
		"entity.term_plural": "Terms",
		"entity.orderitem.bundleitemquantity": "Package Quantity",
		"admin.main.update.bleedingedge": "Bleeding Edge",
		"entity.product.loyaltyredemptionexclusions": "Loyalty Redemption Exclusions",
		"entity.audit.frontendonly": "There is no audit history available, only front end updates have been performed",
		"entity.paymenttransaction.transactiontype": "Transaction Type",
		"entity.stockadjustment.adjustmentdatetime": "adjustmentDateTime",
		"entity.attribute.attributetype.atcheckbox": "Check Box",
		"entity.brand.loyaltyaccruements": "Loyalty Accruements",
		"admin.entity.createsubscriptionproduct_nav": "New Subscription Product",
		"entity.promotion.promotionsummary": "Promotion Summary",
		"entity.orderpayment.process.authorize": "Authroize",
		"entity.paymenttransaction.transactiondatetime": "Transaction Date Time",
		"validate.create.account_create.emailaddress.getprimaryemailaddressnotinuseflag": "The email address that you have entered is already in use as the primary email address for another account.  If this is your email address, you can use forgot password tool to reset your password via email.",
		"entity.promotionreward.fulfillmentmethods": "Fulfillment Methods",
		"entity.permissiongroup.accounts": "Accounts",
		"setting.integrationorbitalbin_hint": "Your 'BIN' setting is the orbital platform your merchant account is running on.  Contact your Technical Analyst or Relationship Manager if you are unsure which Platform your merchant account resides on.",
		"entity.orderitem.discountamount": "Discounts",
		"entity.promotionqualifier.maximumfulfillmentweight": "Maximum Weight",
		"admin.entity.emailtabs.htmlbody": "HTML Body",
		"entity.sku.eventenddatetime": "Event End",
		"entity.account.accountphonenumbers": "Phone Numbers",
		"admin.define.create_nav": "Add ${itemEntityName}",
		"entity.attributevalue.attributevalueencryptedgenerator": "Attribute Value Encryption Generator",
		"entity.sku.skucode_hint": "A unique string (alphanumerc, no spaces) to identify the sku.",
		"entity.product.process.uploaddefaultimage": "Upload Image",
		"entity.product.process.addoption": "Add Option",
		"admin.entity.createproduct.searchproductbundletype": "Search or Add Bundle Group Type...",
		"entity.workflowtaskaction.process": "Process",
		"entity.product.process.addoptiongroup": "Add Option Group",
		"entity.promotionreward.rewardcanapplytoqualifierflag": "Include Qualifier in Reward",
		"permission.setting.listcountry": "Country - List",
		"validate.changeeventdates.sku_changeeventdates.startreservationdatetime.gtnow": "The start reservation date cannot be before now.",
		"entity.promotionreward.roundingrule": "Rounding Rule",
		"entity.permission": "Permission",
		"entity.pricegrouprate.pricegrouprateappliesto": "Applies To",
		"validate.account.passwordconfirmmismatch": "The passwords that you entered do not match",
		"permission.setting.detailschedule": "Schedule - Detail",
		"entity.taskhistory.starttime": "Task Start Time",
		"entity.schedule.frequencyinterval": "Frequency Repeat Minutes",
		"setting.integrationvertexoriginmaindivision": "Origin Main Division (State)",
		"admin.entity.processcontent.create_error": "There was a problem saving content",
		"entity.subscriptionusage.process.sendrenewalreminder": "Send Renewal Reminder",
		"entity.accountemailaddress.verifiedflag": "Verified",
		"entity.sku.formattedredemptionamount": "Redemption Amount",
		"entity.app.appcode": "Application  Code",
		"entity.accountloyaltyaccruement.accruementtype.orderclosed": "Order Closed",
		"entity.schedule.recuringtype": "Recurring Type",
		"entity.optiongroup.globalflag": "Global Object Group",
		"entity.order.referencingpaymentamountcreditedtotal": "Credited on Referencing",
		"setting.globalremoteidshowflag": "View RemoteID Fields in Administrator",
		"admin.entity.stockadjustments.products": "Products",
		"entity.state": "State",
		"define.emailaddress": "Email Address",
		"admin.editfilteritem.saveandaddanotherfilter": "Save And Add Another Filter",
		"define.quantitymustbegreaterthanzero": "Quantity Must Be Numeric and Greater Than Zero",
		"setting.integrationfullcirclefcftpdirecotry_hint": "Full Circle FTP Directory",
		"admin.main.update_title": "Update Slatwall",
		"validate.save.country.countrycode.maxlength": "Country Code cannot have more than 3 characters",
		"validation.define.gte": "This value is invalid",
		"define.international": "International",
		"entity.accountloyalty.accountloyaltynumber": "Account Loyalty Program Number",
		"entity.address.statecode_validaterequired": "Please enter a valid State",
		"setting.integrationavataxsourcestreetaddress": "Source Street Address",
		"entity.vendororder.vendorordercreateddatetime": "Date Created",
		"permission.order.deleteorder": "Order - Delete",
		"entity.sku.endreservationdatetime": "Reservation End Date",
		"entity.subscriptionterm.autopayflag": "Auto Pay",
		"admin.define.giftcarddetails": "Gift Card Details",
		"processobject.orderdelivery_create.trackingnumber": "Tracking Number",
		"entity.audit.audittype.logout": "Logout",
		"processobject.subscriptionusage_renew.updatesubscriptionusageaccountpaymentmethodflag": "Use For Future Renewals",
		"entity.paymentmethod.saveaccountpaymentmethodencryptflag": "Encrypted & Save (APM)",
		"validate.account.password": "Invalid password",
		"event.onapplicationbootstraprequeststart": "On Application Bootstrap Request Start",
		"report.productperformancereport.itemdiscount": "Discount",
		"entity.vendororderitem": "Vendor Order Item",
		"setting.skuallowpreorderflag_hint": "Indicate whether this product can be preordered",
		"admin.entity.attributesettabs.producttypes": "Product Types",
		"setting.integrationvertextaxcategoriestoinvoice": "Tax Categories to Invoice",
		"define.occurs": "Occurs",
		"admin.entity.listaudit": "Audit Log",
		"entity.loyaltyredemption.products": "Products",
		"entity.accountpayment.termoffsetterm": "Term",
		"setting.integrationvertexwebservicespassword": "Vertex Password",
		"validate.define.typeidrequired": "Type ID is Required",
		"entity.shippingmethodrate.maximumshipmentquantity": "Max Fulfillment Quantity",
		"validate.save.promotion.promotioncodes.hasuniquepromotioncodes": "There are duplicate promotion codes defined for this promotion.",
		"entity.promotionperiod.startdatetime": "Start Date/Time",
		"entity.productreview.review": "Review",
		"entity.optiongroup.optiongroupcode_hint": "A unique string (alphanumerc, no spaces) to identify the option group.",
		"entity.sku.skucurrencies": "SKU Currencies",
		"entity.optiongroup.optiongroupcode": "Option Group Code",
		"processobject.order_addorderitem.orderfulfillmentid": "Order Fulfillment",
		"entity.accountloyaltyaccruement.accruementtype.fulfillmentmethodused": "Fulfillment Method Used",
		"define.yes": true,
		"admin.entity.promotionrewardtabs.fulfillmentmethods": "Fulfillment Methods",
		"entity.loyaltyaccruement_plural": "Loyalty Program Accruements",
		"entity.attributeoption.attributeoptionid": "attributeOptionID",
		"entity.audit.audittype.logininvalid": "Login Invalid",
		"admin.entity.categorytabs.childcategories": "Child Categories",
		"define.backtolist": "Back To List",
		"admin.entity.permissiongrouptabs.entitypermissions": "Data Permissions",
		"setting.contentrestrictaccessflag": "Restrict Access",
		"admin.define.no_items_selected": "No items selected",
		"entity.subscriptionusage.initialsubscriptionorderitem": "Initial Subscription Order Item",
		"admin.entity.createreturnorder.processoption.quantity": "Return Qty.",
		"define.qomax": "QOMAX",
		"report.productperformancereport.saleafterdiscount": "Purchased",
		"entity.sku.image.exists": "Image Exists",
		"entity.term": "Term",
		"entity.loyaltyredemption.excludedproducts": "Excluded Products",
		"entity.content.createdby": "Created By",
		"entity.shortreference.referenceobjectid": "Reference Object ID",
		"admin.entity.contenttabs.products": "Products",
		"setting.integrationipaymentapplicationid": "Application ID",
		"setting.integrationpayflowproorderpaymentcommentonetemplate_hint": "This template will be string replaced based on the order payment, and then passed as custom comment 1 to PayFlow Pro.  An Example would be: ${orderPaymentID} or ${myCustomOrderPaymentAttributeCode}.  Plain text works as well\"",
		"entity.orderdelivery.createddatetime": "Delivered On",
		"entity.vendor.vendororders": "Vendor Orders",
		"entity.producttype.delete_validateisassigned": "This product type cannot be deleted because it has been assigned to a product and/or it has subtypes which must be moved or deleted first.",
		"entity.vendor.products": "Products",
		"entity.producttype.loyaltyaccruementexclusions": "Loyalty Accruement Exclusions",
		"define.qndosa.full": "Not Delivered On Stock Adjustment",
		"entity.orderdelivery.orderdeliveryitems_validatehasorderdeliveryitems": "No quantities from the orderfulfillment were indicated for delivery.",
		"permission.setting.createlocation": "Location - Create",
		"entity.shippingmethod.eligibleaddresszone": "Eligible Address Zone",
		"entity.product.loyaltyredemptionexclusion": "Loyalty Redemption Exclusions",
		"entity.accountauthentication.updatepasswordonnextloginflag": "Password Update Required",
		"validate.create.product_create.purchaseenddatetime.datatype.date": "Purchase End Date must be a valid date",
		"entity.contentaccess.subscriptionusagebenefit": "Subscription Usage Benefit",
		"validate.define.required": "The ${propertyName} is required.",
		"entity.emailbounce.rejectedemailto": "Rejected Email To",
		"permission.account.detailpermissiongroup": "Permission Group - Detail",
		"admin.main.encryption.iterationcount": "Iteration Count",
		"entity.report.dynamicdaterangeendtype.now": "Date Run",
		"permission.setting.detailpaymentmethod": "Payment Method - Detail",
		"validate.save.setting.settingvalue.minvalue": "The value that you have entered is below the minimum value allowed.",
		"entity.subscriptionterm.initialterm": "Initial Term",
		"admin.entity.fulfillmentmethodtypes.shippingtabs.settings": "Settings",
		"entity.product.process.updatedefaultimagefilenames": "Reset Default Image Filenames",
		"validate.create.product_create.purchaseenddatetime.gtdatetimeproperty": "Purchase End Date must occur after Purchase Start Date",
		"define.false": false,
		"entity.access.subscriptionusage": "Subscription Usage",
		"setting.globalpagecheckout": "Checkout Page",
		"entity.accountaddress.accountaddresstype": "Address Type",
		"entity.image.imageid": "Image ID",
		"validate.addeventschedule.product_addeventschedule.scheduleenddate.gtdatetimeproperty": "Schedule end date must occur after schedule start date.",
		"admin.entity.accounttabs.orders": "Orders",
		"entity.updatescript.updatescriptid": "Update Script ID",
		"setting.integrationupsshipfromstatecode": "Shipping From State Code ",
		"entity.orderorigin.orderorigintype": "Order Origin Type",
		"entity.integration.paymentactiveflag": "Payment Integration Active",
		"entity.site.siteid": "Site ID",
		"validate.save.file.fileupload.isfiletypewhitelisted": "The File Type you are trying to upload is not approved, this can be modified in advanced settings.",
		"frontend.checkout.detail.checkoutasguest": "Checkout As Guest",
		"entity.country.street2addressshowflag": "Show Street2 Address",
		"entity.shippingmethod.shippingrateincreasedollar": "Shipping Rate Increase Dollar",
		"entity.promotionreward": "Promotion Reward",
		"define.yearly": "Yearly",
		"permission.setting.createfulfillmentmethod": "Fullfillment Method - Create",
		"entity.paymentmethod_plural": "Payment Methods",
		"entity.giftcard.issueddate": "Issued Date",
		"report.orderitemreport.saleafterdiscount": "Purchased",
		"validate.processphysical_addphysicalcount.countfile": "The file you uploaded had no valid rows to be imported.",
		"entity.vendorphonenumber_plural": "Vendor Phone Numbers",
		"validate.delete.subscriptionusage.subscriptionusageid.maxlength": "Subscription Usages cannot be deleted.",
		"entity.formresponse.createddatetime": "Date Submitted",
		"entity.option.promotionrewardexclusions": "Promotion Reward Exclusions",
		"setting.integrationavataxsourcestreetaddress2": "Source Street Address 2",
		"entity.content.modifiedby": "Modified By",
		"admin.main.encryption.password": "Password",
		"permission.warehouse.editstockadjustment": "Stock Adjustment - Edit",
		"entity.contentaccess.account": "Account",
		"entity.loyaltyredemption.amounttype.fixed": "Fixed",
		"define.qvomax.full": "Max Per Order",
		"admin.entity.emailtemplatetabs.textbody": "Text Body",
		"entity.product.listprice_hint": "Optional field to specify an MSRP or a price that this product is usually listed as.  Typically this is to show that you offer the product at a lower rate",
		"entity.define.creditcardnumberencrypteddatetime": "Credit Card Encrypted Date Time",
		"entity.fulfillmentbatchitem.fulfillmentbatchitemid": "FulfillmentBatchItemID",
		"entity.emailverification": "Email Verification",
		"entity.product.publishedweight": "Published Weight",
		"entity.productlistingpage.productlistingpageid": "Product Listing Page ID",
		"setting.globalgiftcardmessagelength": "Gift Card Message Length",
		"entity.session.sessioncookienpsid": "Non-Persistent Session ID",
		"define.detail": "Detail",
		"entity.shippingmethod.shippingmethodid": "Shipping Method ID",
		"entity.sku.alternateskucodes": "Alternate SKU Codes",
		"entity.producttype.publishedflag": "Published Flag",
		"entity.subscriptionusage.subscriptionorderitems": "Subscription Order Items",
		"processobject.orderdelivery_create.captureauthorizedpaymentsflag": "Capture pre-authorized CC",
		"permission.help": "Help",
		"validate.save.content.contentid.required": "You are attempting to add content to a site that is not a Slatwall CMS, this cannot be done.",
		"admin.entity.processproduct.addoption_success": "The option has been successfully added to the sku.",
		"entity.promotioncode.delete_validateisassigned": "This promotion code cannot be deleted because it is in use.",
		"entity.report.dynamicdaterangeendtype.lastquarterend": "Previous Quarter End",
		"entity.content.disableproductassignmentflag": "Disable product assignment",
		"validate.addorderitem.order_addorderitem.sku.required": "Please select the option(s) for this product.",
		"entity.accountphonenumber.accountphonetype": "Account Phone Type",
		"entity.skuprice.expiresdatetime": "Expires Date Time",
		"validate.save.promotioncode.enddatetime.gtproperty": "Promotion code end date / time should be greater than start date / time.",
		"entity.subscriptionstatus_plural": "Subscription Statuses",
		"entity.comment.comment": "Comment",
		"entity.brand.products": "Products",
		"entity.optiongroup.optiongroupdescription": "Option Group Description",
		"entity.account.taxexemptflag": "Tax Exempt",
		"entity.shippingmethodoption.shiptocity": "Ship To City",
		"entity.define.modifieddatetime": "Modified Date Time",
		"entity.product.productschedules": "Product Schedules",
		"entity.entityqueuehistory.entityqueuetype": "Entity Queue Type",
		"entity.shippingmethodoption.shippingmethodrate": "Shipping Method Rate",
		"setting.globaladmindomainnames": "Admin Domain Names",
		"report.appliedpromotionreport": "Applied Promotion",
		"entity.stockreceiveritem.stockreceiver": "Stock Receiver",
		"entity.loyaltyredemption_plural": "Loyalty Program Redemptions",
		"entity.promotioncode.maximumaccountusecount": "Max. Account Use Count",
		"entity.term.termhours": "Term Hours",
		"entity.account.accountauthentications": "Account Authentications",
		"entity.stockadjustment.physical": "Physical",
		"admin.entity.preprocessorder_addorderitem.itemdetails": "Item Details",
		"setting.integrationavataxtaxexemptpropertyidentifier_hint": "This is optional and can be pointed to a boolean propertyIdentifier based on the order that will exempt the order for being taxed.",
		"entity.loyalty.loyaltyid": "Loyalty Program ID",
		"permission.setting.deleteattributeset": "Attribute Set - Delete",
		"entity.accountauthentication_plural": "Account Authentications",
		"entity.order.process.updateorderamounts": "Update Order Amounts",
		"entity.product.productdescription": "Product Description",
		"entity.order.process.placeorder.paymentprocessedmessage": "There were errors processing one or more of your order payments, however because some payment transactions were placed the order was forced through.  Please review payment transactions for futher detials",
		"define.language.en_us": "English (US)",
		"setting.integrationorbitalindustrytype": "Industry Type",
		"entity.account.process.forgotpassword_success": "A password reset email has been sent to the primary email address on your account.",
		"entity.account.primaryaccountpaymentmethod": "Primary Payment Method",
		"entity.type.type": "Type",
		"entity.audit.auditarchivestartdatetime": "Start Date",
		"entity.workflow.workflowid": "Workflow ID",
		"define.qomin": "QOMIN",
		"validate.define.eqproperty": "The values you have entered do not match.",
		"admin.entity.subscriptionbenefittabs.pricegroups": "Price Groups",
		"processobject.physical_addphysicalcount.countpostdatetime": "Count Post Date Time",
		"define.limitresults": "Limit Results",
		"entity.product.manufacturediscontinuedflag_hint": "Has this product been discontinued by the manufacturer?",
		"entity.sku.process.removelocation": "Remove location",
		"entity.eventtrigger.printtemplate": "Print Template",
		"entity.shippingmethod": "Shipping Method",
		"entity.print.printcontent": "Print Content",
		"define.manual": "Manual",
		"entity.product.subscriptionbenifitsrequired": "Subscription Benefits are Required",
		"define.total": "Total",
		"admin.entity.createproduct.selectsubscriptionbenefits": "Select Subscription Benefit(s)",
		"entity.attribute.attributeset": "Attribute Set",
		"entity.order.ordernumbertooriginal": "Original Order Number",
		"admin.entity.skutabs.eventregistrations": "Event Registrations",
		"entity.promotionperiod_plural": "Promotion Periods",
		"validate.account_forgotpassword.emailaddress.notfound": "No account could be found with the supplied email address.",
		"entity.emailbounce.rejectedemailsendtime": "Rejected Email Send Time",
		"validate.create.product_create.redemptionamount.regex": "The value entered for Redemption Amount should be numeric.",
		"admin.entity.processorder.cancelorder_success": "The order has successfully been canceled",
		"setting.skutrackinventoryflag": "Track Inventory",
		"validation.define.required": "This value is required.",
		"entity.pricegrouprate.pricegroup": "Price Group",
		"entity.pickwave": "Pick Wave",
		"entity.content.productlistingpageflag": "Product Listing Page",
		"frontend.cart.clearitems": "Clear All Cart Items",
		"entity.loyaltyredemption": "Loyalty Program Redemption Criteria",
		"entity.shippingmethodrate.defaultamount_hint": "When using a 'manual' rate this is the amount that will be charged.  If you are using a shipping provider, then this value is the fallback amount if for some reason the shipping provider is inaccessible.",
		"admin.entity.workflowtabs.triggers.norecordsfound": "No trigger results found",
		"entity.accountloyalty.loyalty": "Loyalty",
		"define.createandlogin": "Create & Login",
		"entity.taxcategoryrate.taxaddresslookup.shipping_billing": "Shipping -> Billing",
		"define.forever": "Forever",
		"setting.globalusagestats": "Send Anonymous Usage Stats",
		"admin.entity.deletesetting_nav": "Remove Setting Override",
		"entity.report.dynamicdaterangeendtype.thismonthend": "Current Month End",
		"admin.entity.producttabs.productreviews": "Product Reviews",
		"entity.accountauthentication.integrationrefreshtoken": "Integration Refresh Token",
		"validate.define.mincollection": "Atleast one ${propertyName} has to be selected.",
		"entity.session.lastrequestdatetime": "Last Request Date/Time",
		"define.pickup": "Pickup",
		"entity.order.ordertype": "Order Type",
		"entity.promotionreward.skus": "Sku",
		"entity.skuprice": "Sku Price",
		"entity.promotionreward.rewardtype.order": "Order",
		"entity.skuprice.maxquantity.null": "any",
		"entity.loyaltyredemption.excludedskus": "Excluded Skus",
		"validate.delete.sku.stocksdeletableflag.eq": "This sku cannot be deleted because it has stocks assigned to it.",
		"entity.order.process.removeorderitem.parentfailsvalidationerror": "The order item can not be removed because it is required by the product bundle.",
		"define.comments": "Comments",
		"entity.setting.brand": "Brand",
		"entity.account.password": "Password",
		"admin.entity.ordertabs.orderitems.noresults": "No Order Items Have Been Added To This Order",
		"permission.account.deletepermissiongroup": "Permission Group - Delete",
		"entity.order.ordershipments": "Order Shipments",
		"entity.account.orders": "Orders",
		"entity.form.formcode": "Form Code",
		"entity.sku.listprice_hint": "Optional field to specify an MSRP or a price that this product is usually listed as.  Typically this is to show that you offer the product at a lower rate",
		"setting.globaluseproductcacheflag": "User Product Cache",
		"entity.loyaltyaccruement.accruementtype.itemfulfilled": "Item Fulfilled",
		"processobject.product_create.generateskusflag": "Generate Sku(s)",
		"entity.emailtemplate": "Email Template",
		"setting.integrationuspstestapiendpointurl": "USPS Test API Endpoint URL",
		"admin.entity.processgiftcard.offlinetransaction_success": "You have sucessfully adjusted the gift card balance.",
		"define.refund": "Refund",
		"entity.order.process.addorderpayment": "Add Order Payment",
		"entity.content.cmscontentidpath": "CMS Content ID Path",
		"entity.stockhold_plural": "Stock Holds",
		"setting.skumarkattendanceasbundle": "sku mark attendance as bundle",
		"entity.loyaltyredemption.redemptiontype.pricegroupassignment": "Price Group Assignment",
		"admin.entity.promotionrewardtabs.shippingmethods": "Shipping Methods",
		"admin.entity.editorderdeliveryitem_disabled": "The order delivery item cannot be edited as the order has been placed.",
		"entity.subscriptionusage.nextbilldate": "Next Bill Date",
		"entity.pricegroup.promotionrewards": "Promotion Rewards",
		"entity.option.promotionrewards": "Promotion Rewards",
		"entity.order.orderopendatetime": "Date Placed",
		"entity.stockadjustmentdeliveryitem.stockadjustmentdelivery": "Stock Adjustment Delivery",
		"permission.setting.deleteaddresszone": "Address Zone - Delete",
		"permission.setting.detailfulfillmentmethod": "Fulfillment Method - Detail",
		"entity.promotionapplied.promotionappliedid": "Promotion Applied ID",
		"entity.taxapplied.taxcity": "Tax City",
		"entity.brand.brandname": "Brand Name",
		"setting.integrationsofortcurrency": "Currency (ISO4217)",
		"validate.giftcardcode.invalid": "The gift card you have entered is invalid.",
		"setting.integrationpaypalexpresspaypalaccountsignature": "PayPal Classic API  Signature",
		"admin.entity.emailtabs.emailsettings": "Email Settings",
		"setting.integrationfullcirclefcftppassword_hint": "Password to connect to FC Server via FTP",
		"entity.sku.promotionqualifierexclusions": "Promotion Qualifier Exclusions",
		"entity.loyaltyredemption.loyalty": "Loyalty",
		"validate.processorder_forceitemquantityupdate.forceditemremoved": "${sku.product.title} - ${sku.skuDefinition} was removed from your order because of availability constraints.",
		"admin.entity.detailorderfulfillment.fulfillment_totals": "Fulfillment Totals",
		"entity.entityqueue.entityqueuetype": "Entity Queue Type",
		"defaultmessage_required_condition": "{1} is required {2}.",
		"admin.define.checkdetails": "Check Details",
		"entity.orderfulfillment.orderfulfillmentid": "Order Fulfillment ID",
		"entity.promotionreward.shippingdiscounttype": "Shipping Discount Type",
		"setting.integrationfedextransactionkey": "FedEx Transaction Key ",
		"define.january": "January",
		"setting.brandmetakeywordsstring": "Brand Meta Keywords String",
		"entity.content.productsortproperty": "Product Sort Property",
		"validate.offlinetransaction.giftcard_offlinetransaction.amount.gt": "You've entered an invalid amount, please enter a positive number",
		"setting.integrationvertexwebservicesurl": "Vertex Server Location",
		"permission.pricing.deletepricegroup": "Price Group - Delete",
		"validate.order.orderitemwrongcurrency": "The current order is of a different currency than the item you are trying to add.  Please clear your order before trying again, or select the currency that matches your order.",
		"endicia.main_permission": "Dashboard",
		"define.dayofthemonth": "Day of the Month",
		"validate.changepassword.account_changepassword.password.regex": "Admin passwords should include at least 1 letter, 1 number, and be 7 or more characters long.",
		"define.modifieddatetime": "Modified on",
		"processobject.product_addsku.bundlelocationconfigurationflag": "Bundle Locations",
		"define.return": "Return",
		"entity.attribute.attributeclasstype": "attributeClassType",
		"setting.emailimapserverport": "Bounced Email Server Port (IMAP)",
		"admin.entity.workflowtabs.tasks": "Tasks",
		"entity.define.amountauthorized": "Amount Authorized",
		"setting.integrationmuralegacycheckout_hint": "If you have upgraded from a previous version of Slatwall that used the filename hooks, and the 'frontend' subsystem, then the filename of that page should be in this field",
		"entity.shippingmethodrate_plural": "Shipping Method Rates",
		"entity.orderitem.quantitydelivered": "Qty. Delivered",
		"define.youhave": "You Have",
		"validate.save.sku.listprice.minvalue": "The sku list price cannot be a negative value.",
		"processobject.sku_changeeventdates.recurringtimeunit": "Occuring",
		"entity.product.options": "Product Options",
		"admin.entity.addorderitemgiftrecipient.hint": "Use the \"search or add recipient\" field below to assign recipients to gift cards.",
		"setting.productmissingimagepath": "Product Missing Image Path",
		"entity.producttype.attributesets": "Attribute Sets",
		"entity.roundingrule.roundingruledirection": "Rounding Direction",
		"entity.orderpayment.orderpaymentid": "Order Payment ID",
		"processobject.order_addorderpayment.saveaccountpaymentmethodflag": "Save as Account Payment",
		"defaultmessage_min": "{1} must be at least {2}.",
		"validate.save.subscriptionterm.autoretrypaymentdays.regex": "The value entered for ${propertyName} should be numeric and optionally can be comma seperated.",
		"entity.eventtrigger.eventtriggerid": "Event Trigger ID",
		"entity.product.manufacturediscontinuedflag": "Discontinued by Manufacturer",
		"entity.roundingrule.roundingruleid": "Rounding Rule ID",
		"entity.address.streetaddress": "Street Address",
		"setting.integrationfedexcontactphonenumber": "Contact Phone Number",
		"validate.save.setting.settingvalue.maxvalue": "The value that you have entered is above the maximum value allowed.",
		"setting.skuholdbackquantity": "Hold Back Qty.",
		"entity.order.ordertotal": "Order Total",
		"entity.shippingmethodoption_plural": "Shipping Method Options",
		"admin.entity.createproductimage_nav": "Add Product Image",
		"entity.permission.allowdeleteflag": "Allow Delete Flag",
		"entity.attributeset.attributesetcode": "Attribute Set Code",
		"entity.promotion.promotiondescription": "Promotion Description",
		"entity.attribute.delete_success": "The Attribute was successfully deleted.",
		"entity.shippingmethodrate.shippingintegration": "Shipping Integration",
		"entity.order.process.addpromotioncode": "Add Promotion Code",
		"validate.processorder_placeorder.incompletepayment": "The order could not be placed because the current order payments do not have sufficient funds to purchase the whole amount.",
		"define.qhb": "QHB",
		"entity.productbundlebuilditem.selectbundlegroup": "Please add one or more items to this bundle group",
		"admin.entity.skutabs.subscription": "Subscription",
		"entity.orderreturn.orderreturnid": "Order Return ID",
		"entity.promotionreward.maximumuseperitem": "Max. Use Per Item",
		"validate.addpromotioncode.order_addpromotioncode.promotioncode.promotioncodenotalreadyapplied": "This promotion code has already been applied to this order.",
		"permission.vendor.createvendororder": "Vendor Order - Create",
		"admin.entity.listcartandquote_nav": "Carts & Quotes",
		"entity.accountloyaltytransaction_plural": "Account Loyalty Program Transactions",
		"define.option": "Option",
		"setting.integrationpayflowproorderpaymentcommentonetemplate": "Order Pyament Comment One Template",
		"entity.currency.currencysymbol": "Currency Symbol",
		"admin.entity.processstockadjustment.processadjustment_success": "The stock adjustment has been processed successfully.",
		"entity.merchandiseproducttype": "Merchandise Product Type",
		"entity.productbundlegroup.skuprice": "Sku Price",
		"entity.eventtrigger.eventtriggerobject": "Trigger Object",
		"permission.setting.createaddresszone": "Address Zone - Create",
		"entity.accountaddress": "Account Address",
		"entity.skubundle.skubundleid": "Sku Bundle ID",
		"entity.content.site.sitename": "Site Name",
		"entity.product.process.image.norecordsfound": "Missing Image",
		"setting.globalmaximumfulfillmentsperorder": "The maximum number of fulfillments allowed on a single order.",
		"entity.eventregistration.firstname": "First Name",
		"admin.entity.accounttabs.pricegroups": "Price Groups",
		"admin.main.log_title": "Slatwall Log Viewer",
		"entity.taskschedule.enddatetime": "End Date",
		"setting.integrationpayflowproorderpaymentcommenttwotemplate": "Order Pyament Comment Two Template",
		"entity.vendororder.subtotal": "Subtotal",
		"setting.fulfillmentmethodautominreceivedpercentage_hint": "In order for an auto fulfillment to occur this percentage can be set so that X% of the amount for the items being fulfilled actually be received before fulfillment takes place.  Typically this is set to 0 or 100 saying that you either require or don't require payment to be received before the fulfillment automatically happens",
		"admin.entity.orderitemgiftrecipient.giftmessage": "Gift Message",
		"admin.report": "Reporting Dashboard",
		"admin.define.delete_nav": "Delete ${itemEntityName}",
		"define.wysiwyg": "Wysiwyg (Rich Text)",
		"entity.paymenttransaction.avsdescription.b": "Street address matches, but postal code not verified.",
		"admin.entity.orderitemgiftrecipient.quantity": "Quantity",
		"entity.paymenttransaction.avsdescription.a": "Street address matches, but 5-digit and 9-digit postal code do not match.",
		"entity.paymenttransaction.avsdescription.d": "Street address and postal code match. Code \"M\" is equivalent.",
		"entity.printtemplate": "Print Template",
		"entity.paymenttransaction.avsdescription.c": "Street address and postal code do not match.",
		"entity.loyaltyredemption.amounttype": "Amount Type",
		"permission.setting.savetaxcategory": "Tax Category - Save",
		"entity.account.permissiongroups": "Permission Groups",
		"entity.term.termdays": "Term Days",
		"entity.report.dynamicdaterangeendtype.thisquarterend": "Current Quarter End",
		"entity.promotionqualifier.excludedproducttypes": "Product Type Exclusions",
		"endicia_permission": "Endicia",
		"entity.attributevalue.subscriptionbenefit": "Subscription Benefit",
		"entity.physical.skus": "Physical Skus",
		"admin.entity.processaccount.generateapiaccesskey_success": "The API Access Key has been generated successfully.",
		"setting.integrationfedexshippercity": "Shipping From City ",
		"validate.edit.orderitem.orderstatuscode.inlist": "The order Item cannot be edited as the order has been placed.",
		"entity.subscriptionbenefit.promotions": "Promotions",
		"define.default": "Default",
		"entity.audit.audittype.delete": "Deleted",
		"permission.setting.edittask": "Task - Edit",
		"entity.paymenttransaction.avsdescription.v": "Card member's name, billing address, and billing postal code match.",
		"entity.paymenttransaction.avsdescription.u": "Address information unavailable. Returned if the U.S. bank does not support non-U.S. AVS or if the AVS in a U.S. bank is not functioning properly.",
		"entity.report.reporttitle": "Report Title",
		"admin.entity.createcontentaccessproduct_nav": "New Content Access Product",
		"entity.paymenttransaction.avsdescription.x": "Street address and 9-digit postal code match.",
		"entity.paymenttransaction.avsdescription.w": "Street address does not match, but 9-digit postal code matches.",
		"entity.orderfulfillment_plural": "Order Fulfillments",
		"entity.paymenttransaction.avsdescription.z": "Street address does not match, but 5-digit postal code matches.",
		"entity.paymenttransaction.avsdescription.y": "Street address and 5-digit postal code match.",
		"entity.fulfillmentmethod.orderfulfillments": "Order Fulfillments",
		"entity.physicalcount": "Physical Count",
		"entity.paymenttransaction.avsdescription.n": "Street address and postal code do not match.",
		"processobject.sku_changeeventdates.scheduleendoccurrences": "Occurrences",
		"entity.paymenttransaction.avsdescription.m": "Street address and postal code match. Code \"D\" is equivalent.",
		"entity.paymenttransaction.avsdescription.p": "Postal code matches, but street address not verified.",
		"entity.paymenttransaction.avsdescription.o": "Card member's name and billing address match, but billing postal code does not match.",
		"entity.loyaltyaccruement.pointtype.fixed": "Fixed",
		"entity.paymenttransaction.avsdescription.r": "System unavailable.",
		"processobject.product_addeventschedule.createbundleflag": "Create a bundle?",
		"entity.workflowtaskaction.updatedata": "Update Data",
		"entity.paymenttransaction.avsdescription.q": "Card member's name, billing address, and postal code match.",
		"admin.entity.promotionqualifiertabs.products": "Products",
		"entity.paymenttransaction.avsdescription.t": "Card member's name does not match, but street address matches.",
		"entity.schedule.frequencyendtime_hint": "Defining this will allow for the schedule to run multiple times in a given day.",
		"permission.account": "Account",
		"entity.paymenttransaction.avsdescription.s": "Bank does not support AVS.",
		"entity.paymenttransaction.avsdescription.f": "Card member's name does not match, but billing postal code matches.",
		"entity.workflowtask.taskconditionsconfig": "Task Condidtion Config",
		"entity.paymenttransaction.avsdescription.e": "AVS data is invalid or AVS is not allowed for this card type.",
		"entity.order.paymentamounttotal": "Total Payments",
		"entity.report.dynamicdaterangeendtype.lastmonthend": "Previous Month End",
		"entity.paymenttransaction.avsdescription.h": "Card member's name does not match. Street address and postal code match.",
		"setting.integrationorbitalmerchantid_hint": "This is the 6 digit ID that defines your Merchant ID, also sometimes refured to as you Transaction Division Number.",
		"entity.attribute.formemailconfirmationflag": "Form Confirmation Email",
		"define.qomax.full": "Max Per Order",
		"setting.locationconfigurationadditionalprereservationtime": "Pre Event Reservation Minutes",
		"entity.paymenttransaction.avsdescription.g": "Non-U.S. issuing bank does not support AVS.",
		"entity.paymenttransaction.avsdescription.j": "Card member's name, billing address, and postal code match.",
		"entity.task.enddatetime": "Task End Date",
		"entity.define.activeflag_hint": "Item is available for utilization in the back-end",
		"entity.paymenttransaction.avsdescription.i": "Address not verified.",
		"entity.paymenttransaction.avsdescription.l": "Card member's name and billing postal code match, but billing address does not match.",
		"entity.paymenttransaction.avsdescription.k": "Card member's name matches but billing address and billing postal code do not match.",
		"entity.category.products": "Products",
		"entity.orderitem.taxamount": "Tax Amount",
		"entity.orderpayment.orderpaymenttype": "Order Payment Type",
		"setting.skuminimumpaymentpercentagetowaitlist": "sku minimum payment percentage to waitlist",
		"entity.vendoremailaddress.vendoremailaddressid": "Vendor Email Address ID",
		"entity.accountphonenumber.account": "Account",
		"entity.productcustomizationattributeset": "Product Customization Attribute Set",
		"entity.order.appliedpromotions": "Applied Promotions",
		"entity.vendororder.stockreceivers": "Stock Receivers",
		"admin.entity.createcontentaccessproducttype_nav": "New Content Access Product Type",
		"entity.paymentmethod.saveorderpaymenttransactiontype": "Save OP Trans.",
		"entity.schedule_plural": "Schedules",
		"entity.loyalty_plural": "Loyalty Programs",
		"admin.define.delete_disabled": "The ${itemEntityName} can not be deleted because it is in use, or has been involved in a previous transaction.  You can however make the ${itemEntityName} inactive",
		"entity.shippingmethod.shippingrateincreasepercentage": "Shipping Rate Increase Percentage",
		"validate.create.product_create.eventenddatetime.gtdatetimeproperty": "Event End Date must occur after Event Start Date",
		"admin.entity.processphysical_addphysicalcount.additems": "Add Physical Count Items",
		"entity.define.createdbyaccountid": "Created By AccountID",
		"setting.integrationstripeapiversion": "API Version",
		"report.orderitemreport.itemtax": "Tax",
		"define.auto": "Auto",
		"permission.setting.savecountry": "Country - Save",
		"entity.remoteentity.deletedflag": "Deleted",
		"entity.session.deviceid": "Device ID",
		"define.reset": "Reset",
		"admin.entity.processform.addformquestion_success": "You have successfully added a question to this form.",
		"entity.accountloyalty": "Account Loyalty Program",
		"permission.product.deletesubscriptionbenefit": "Subscription Benefit - Delete",
		"entity.define.amountcredited": "Amount Credited",
		"entity.sku.publishedflag": "Published",
		"entity.entityqueue": "Entity Queue",
		"entity.fulfillmentmethod.fulfillmentmethodtype": "Fulfillment Method Type",
		"permission.pricing": "Pricing",
		"entity.sku.webwholesaleqc": "webWholesaleQC",
		"setting.fulfillmentmethodautolocation": "Automatic Fulfillment Location",
		"entity.subscriptionusagebenefit.maxusecount": "Max Use Count",
		"define.qoh": "QOH",
		"entity.filerelationship.filerelationshipid": "File Relationship ID",
		"admin.export.list": "Export Entire List",
		"entity.accountpayment.accountpaymenttype": "Account Payment Tyoe",
		"define.textarea": "Text Area",
		"entity.addresszone.delete_validateisdeletable": "This Address Zone cannot be deleted because it is in use.",
		"entity.taskschedule.taskscheduleid": "Task Schedule ID",
		"setting.integrationavataxsourcecountry": "Source Country",
		"entity.accountpaymentapplied_plural": "Account Payments Applied",
		"entity.address.firstname": "First Name",
		"entity.sku.eventstartdatetime": "Event Start",
		"entity.locationconfiguration.locationpathname": "Location",
		"validate.create.product_create.purchasestartdatetime.datatype.date": "Purchase Start Date must be a valid date",
		"entity.taxcategoryrate.taxaddresslookup.billing_shipping": "Billing -> Shipping",
		"define.qnc": "QNC",
		"entity.report.dimensions": "Dimensions",
		"entity.stockhold.stock": "Stock",
		"entity.permission.allowupdateflag": "Allow Update Flag",
		"setting.skushippingweight_hint": "Shipping weight of a single Qty. of a SKU",
		"entity.vendoremailaddress.vendor": "Vendor",
		"entity.content.disableproductassignmentflag_hint": "Disable product assignment",
		"admin.entity.orderfulfillmenttabs.orderfulfillmentitems": "Order Fulfillment Items",
		"setting.integrationauthorizenettranskey": "Transaction Key ",
		"admin.main.noaccess": "Access Denied",
		"permission.setting.deletetask": "Task - Delete",
		"entity.taxapplied.taxpostalcode": "Tax Postal Code",
		"entity.session.shippingaddresspostalcode": "Shipping Address Postal Code",
		"entity.attribute.attributetype.attextarea": "Text Area",
		"entity.stockadjustmentitem.stockreceiveritems": "Stock Receiver Items",
		"admin.entity.promotionperiodtabs.promotionperiodcodes": "Promotion Codes",
		"entity.task.taskurl": "Task URL",
		"defaultmessage_url": "{1} must be a valid URL.",
		"entity.commentrelationship.commentrelationshipid": "Comment Relationship ID",
		"admin.entity.emailtemplatetabs.body": "Email Body",
		"processobject.subscriptionusage_renew.renewalpaymenttype.accountpaymentmethod": "Saved Account Payment Method",
		"entity.workflowtask": "Workflow Task",
		"setting.integrationfullcirclefcftpaddress": "Full Circle FTP Address",
		"entity.vendororderitem.vendororderitemid": "Vendor Order Item ID",
		"setting.integrationmuralookuplistingcontentobjects_hint": "Selecting this option will add additional overhead to the request of product details but it will also inherit content objects from the listing page the use came from.",
		"entity.site.resetsettingcache": "Reset Setting Cache",
		"entity.country.postalcodelabel": "Postal Code Label",
		"admin.entity.stocktabs.inventoryhistory": "Inventory History",
		"entity.loyaltyredemption.redemptionpointtype": "Redemption Point Type",
		"permission.setting.savetaskhistory": "Task History - Save",
		"entity.product.physicals": "Physicals",
		"entity.entityqueue.baseid": "Base ID",
		"entity.pricegrouprate.pricegroupratecurrencies": "Price Group Rate Currencies",
		"defaultmessage_max": "{1} must be no more than {2}.",
		"setting.integrationfullcirclefcftpport": "Full Circle FTP Port",
		"entity.subscriptionusage.allowprorateflag": "Allow Prorate",
		"entity.vendor.phonenumbers": "Phone Numbers",
		"admin.entity.brandtabs.vendors": "Vendors",
		"entity.accountpayment.termoffsetduedate": "Due Date",
		"validate.create.product_create.renewalsku.required": "You must define a renewal sku.",
		"admin.report.exportxls": "Export XLS",
		"setting.productmetadescriptionstring": "Product Meta Description String",
		"admin.pricing.createpromotionrewardsubscription": "Create Promotion Reward Subscription",
		"admin.entity.editemail_disabled": "You cannot edit a logged email.",
		"entity.orderpayment.paymentduedate": "Payment Due Date",
		"setting.globalencryptionkeylocation": "Encryption Key Location",
		"entity.cartandquote": "Cart and Quote",
		"entity.accountauthentication.integrationaccountid": "Integration AccountID",
		"processobject.order_addorderitem.shippingaccountaddressid": "Shipping Account Address",
		"entity.option.optionimage": "Option Image",
		"admin.entity.processtask.runtask_success": "Task Successfully Run",
		"entity.promotion.defaultimage": "Default Image",
		"entity.pricegroup.pricegroupidpath": "Price Group ID Path",
		"entity.attributeoption.attribute": "Attribute",
		"entity.accountrelationship.relationshiptype": "relationshipType",
		"entity.promotionapplied.discountamount": "Discount Amount",
		"admin.entity.processeventregistration.pendingconfirmation_success": "Registration has been changed to Pending Confirmation.",
		"entity.orderpayment.giftcardnumberencrypted": "Gift Card Number",
		"validate.save.paymentmethod.allowsaveflag.getsubscriptiontermhasautopayflagset": "This option can't be turned off until all subscription terms with auto pay turned on, have auto pay turned off.",
		"validate.define.creditcard": "The value entered  is not a valid ${propertyName}.",
		"validate.fileupload": "There was an error trying to upload your file, please verify that you are uploading the correct file type.",
		"entity.stockadjustmentdelivery.stockadjustmentdeliveryitems": "Stock Adjustment Delivery Items",
		"processobject.order_addorderpayment.amount.usetotal": "Use Order Total",
		"processobject.product_addsubscriptionsku.subscriptiontermid": "Subscription Term",
		"entity.workflowtaskaction.workflowtaskactionid": "Workflow Task Action ID",
		"entity.define.urltitle": "URL Title",
		"entity.orderdelivery.location": "Location",
		"processobject.physical_addphysicalcount.countfile": "Count File",
		"entity.producttype.subproducttypes": "subProductTypes",
		"define.qr.full": "Received",
		"entity.sku.giftcardexpirationterm": "Expiration Term",
		"entity.accountphonenumber.accountphonenumberid": "accountPhoneNumberID",
		"email.orderconfirmation": "Order Confirmation",
		"define.showreport": "Show Report",
		"entity.measurementunit": "Measurement Unit",
		"entity.paymentmethod.orderpayments": "Order Payments",
		"entity.attributevalue.orderpayment": "Order Payment",
		"define.wednesday": "Wednesday",
		"admin.main.ckfinder_title": "File Manager",
		"entity.order.process.createreturn": "Create Return Order",
		"permission.warehouse.savestockreceiver": "Stock Receiver - Save",
		"entity.formresponse": "Form Response",
		"define.qty": "Qty.",
		"entity.term.graceperiodsubscriptionterms": "Grace Period Subscription Terms",
		"admin.entity.detailpromotion.currentperiodwithnocurrentpromocode_info": "There is a current promotion period & this promotion also requires a promotion code, however all of the existing promotion codes have expired.",
		"entity.accountpayment.creditcardnumberencrypted": "Credit Card Number Encrypted",
		"entity.printtemplate.printtemplatename": "Print Template Name",
		"entity.attribute.attributeinputtype.relatedobjectmultiselect": "Related Object Multiselect",
		"entity.image.imagefile": "Image",
		"permission.setting.deletefulfillmentmethod": "Fulfillment Method - Delete",
		"entity.account.emailaddress": "Email Address",
		"permission.vendor.deletevendororder": "Vendor Order - Delete",
		"entity.taskhistory.task": "Task",
		"define.once": "Once",
		"entity.vendororder.vendorordertype": "Order Type",
		"define.userguide": "User Guide",
		"permission.vendor.savevendororder": "Vendor Order - Save",
		"processobject.account_redeemgiftcard.giftcardcode": "Gift Card Number",
		"entity.attributevalue.sku": "Sku",
		"validate.create.order_create.password.minlength": "Password Must be at least 6 charecters long.",
		"entity.filerelationship": "File Relationship",
		"entity.workflowtrigger.workflowtriggerid": "Workflow Trigger ID",
		"entity.audit.norecords": "There is no audit history available",
		"entity.shippingmethodoption.totalshippingweight": "Total Shipping Weight",
		"validate.processproduct_create.productbundlegroup.invalid": "Your product bundle configuration is invalid. Please make sure your bundle has all required fields, a type and bundle items.",
		"entity.subscriptionterm": "Subscription Term",
		"admin.entity.accounttabs.cartsandquotes": "Carts & Quotes",
		"entity.order.totalamounttoberefunded": "Total Amount To Be Refunded",
		"admin.entity.subscriptionusagetabs.usagebenefits.renewalbenefits": "Renewal Benefits",
		"entity.order.process.addorderitem": "Add",
		"entity.report": "Report",
		"entity.order.process.removepromotioncode": "Remove Promotion Code",
		"entity.fulfillmentmethod_plural": "Fulfillment Methods",
		"define.required": "required",
		"entity.pricegroupratecurrency_plural": "Price Group Currency Rates",
		"entity.producttype.products": "Products",
		"setting.integrationavataxcommittaxdocumentflag": "Commit Tax Document Flag",
		"permission.account.savepermissiongroup": "Permission Group - Save",
		"entity.stockreceivervendororder.packingslipnumber": "Packing Slip Number",
		"entity.optiongroup.optiongroupimage_hint": "Associate an image for this option Group. Supported Formats. JPG,PNG,GIF.",
		"permission.product.listoptiongroup": "Option Group - List",
		"entity.productschedule": "Product Schedule",
		"entity.eventregistration.process.cancel": "Cancel Registration",
		"entity.option_plural": "Options",
		"entity.schedule": "Schedule",
		"admin.editfilteritem.selectfrom": "Select From",
		"entity.sku.accesscontents": "Access Contents",
		"entity.profiletemplate.profiletemplatedescription": "profileTemplateDescription",
		"entity.locationaddress_plural": "Location Addresses",
		"entity.email.emailbodytext": "Email Body Text",
		"entity.type.typecode": "Type Code",
		"defaultmessage_maxlength": "{1} must be no more than {2} characters long.",
		"entity.workflowtriggerhistory.successflag": "Success",
		"define.action": "Action",
		"admin.entity.listproduct.createnosubscriptionbenefitorterm": "You cannot create a 'Subscription' product until you have defined at least one 'Subscription Benefit' and at least one 'Subscription Term'.",
		"entity.order.orderorigin": "Order Origin",
		"entity.subscriptionusagebenefit.subscriptionusagebenefitid": "Subscription Usage Benefit ID",
		"entity.pricegroup_plural": "Price Groups",
		"admin.entity.orderreturntabs.orderreturnitems": "Order Return Items",
		"admin.entity.processproduct.addsku_success": "Sku has been added successfully",
		"entity.shippingmethodoptionsplitshipment.shipmentorderitems": "Shipment Order Items",
		"admin.entity.subscriptionusagetabs.renewalusagebenefits": "Renewal Usage Benefits",
		"permission.setting.deleteorderorigin": "Order Origin - Delete",
		"permission.comment": "Comment",
		"entity.skubundle": "Sku Bundle",
		"entity.promotioncode.orders": "Orders",
		"permission.setting.detailtaxcategory": "Tax Category - Detail",
		"admin.main.update.availablebleedingedgeversion": "Available Bleeding Edge Version",
		"setting.paymentmethodcheckouttransactiontype": "Checkout Transaction Type",
		"admin.entity.skutabs.productschedules": "Event Schedule",
		"entity.file.filetype": "File Type",
		"setting.siteforgotpasswordemailtemplate_hint": "This setting defines the account based e-mail template that is going to be sent for 'forgot password' emails",
		"entity.promotionapplied.orderfulfillment": "Order Fulfillment",
		"admin.entity.stockreceivers.missingproducts": "You must enter order items before processing",
		"setting.fulfillmentmethodemailfrom": "Email From",
		"validate.save.loyaltyaccruement.pointtype.inlist": "Point per dollar is not a allowed point type for accruement type program enrollment",
		"entity.define.sortorder": "Sort Order",
		"admin.entity.processsku.addlocation_success": "Location configuration added successfully.",
		"entity.define.billingaddress": "Billing Address",
		"entity.define.expirationdatetime": "Expiration Date Time",
		"validate.edit.orderitemgiftrecipient.giftcards.caneditordelete": "You cannot edit a gift recipient once it's gift cards are active.",
		"validate.processphysical_addphysicalcount.rowerrorwarning": "The file you uploaded had ${rowError} invalid row(s) that could not be imported.",
		"define.eventname": "Event Name",
		"entity.promotionreward.applicableterm": "Applicable Subscription Term",
		"entity.promotionreward.excludedproducttypes": "Product Type Exclusions",
		"entity.shortreference.referenceobject": "Reference Object",
		"entity.product.defaultsku": "Default Sku",
		"admin.entity.updateslatwall_title": "Update Slatwall",
		"entity.productbundlebuild.productbundlebuildid": "Product Bundle Build ID",
		"entity.define.nextestimatedfulfillmentdatetime": "Next Estimated Order Fulfillment Date Time",
		"setting.skutrackinventoryflag_hint": "Select this if you would like the system to track inventory at this level.",
		"processobject.product_create.bundlecontentaccessflag": "Bundle Content Access Flag",
		"entity.order.process.placeonhold": "Place Order On Hold",
		"entity.pricegroup.delete_success": "PriceGroup Deleted",
		"admin.entity.workflowtabs.basic": "Basic",
		"entity.product.process.addproductreview": "Add Product Review",
		"admin.entity.accounttabs.contactdetails": "Contact Details",
		"setting.accountadminforcepasswordresetafterdays": "Force Admin Password Reset Every x Days",
		"entity.audit.audittype.archive": "Archived",
		"entity.define.norecords": "There aren't any ${entityNamePlural}.",
		"entity.subscriptionusagebenefit.accesstype": "Access Type",
		"admin.default.configure_nav": "Config",
		"permission.product.listproduct": "Product - List",
		"entity.subscriptionusage_plural": "Subscription Usages",
		"entity.orderitem.process.addrecipientstoorderitem": "Add Recipients to This Order Item",
		"entity.fulfillmentbatch.fulfillmentbatchname": "Fulfillment Batch Name ",
		"define.success": "Success",
		"permission.vendor": "Vendor",
		"define.saturday": "Saturday",
		"validate.save.orderfulfillment.orderfulfillmentid.hasquantityoforderfulfillmentswithinmaxorderquantity": "The maximum number of fulfillments allowed for a single order has been exceeded. Either remove fulfillments or create a new order.",
		"entity.attributevalue": "Attribute Value",
		"entity.taskschedule.task": "Task",
		"permission.setting.edittype": "Type - Edit",
		"entity.subscriptionusagebenefitaccount.subscriptionusagebenefit": "Subscription Usage Benefit",
		"entity.access": "Access",
		"entity.attributevalue.product": "product",
		"entity.content.titlepath": "Content Title Path",
		"entity.account.remotecustomerid": "Remote Customer ID",
		"define.inheritance": "Inheritance",
		"define.remainingcharacters": "Remaining Characters",
		"entity.define.calculatedqnc": "QNC",
		"entity.country.countryname": "Country Name",
		"entity.product.pricegrouprates": "Price Group Rates",
		"entity.stockadjustmentdeliveryitem_plural": "Stock Adjustment Delivery Items",
		"admin.entity.loyaltytabs.loyaltyaccruement": "Loyalty Program Accruement Criteria",
		"entity.eventregistration.registrationstatustitle": "Registration Status",
		"entity.orderdelivery.orderdeliveryitems": "Order Delivery Items",
		"validate.save.option.optioncode.uniqueornull": "The Option Code is required and must be unique.",
		"entity.report.dynamicdaterangetype.days": "Days(s)",
		"entity.account.process.addaccountloyalty": "Add Account Loyalty Program",
		"entity.product.vendors": "Vendors",
		"setting.locationconfigurationadditionalpostreservationtime_hint": "This setting will allow for events using this configuration to add these minutes onto the end of the location reservation for extra breakdown time for example",
		"define.before": "Before",
		"entity.define.calculatedqoh": "QOH",
		"entity.comment.publicflag": "Public",
		"setting.skucurrency": "Default Currency",
		"admin.entity.listorderfulfillment": "Order Fulfillments",
		"entity.orderfulfillment.orderfulfillmentstatustype": "Order Fulfillment Status",
		"admin.entity.deletepromotionqualifier_disabled": "This promotion qualifier cannot be deleted because it has been used in a transaction and/or its promotion period has expired.",
		"entity.account.primaryphonenumber": "Account Primary Phone Number",
		"entity.accountauthentication": "Account Authentication",
		"validate.account.forgotsuccess": "Login information was sent to the email you provided",
		"entity.report.dynamicdaterangetype.years": "Year(s)",
		"entity.workflowtaskaction_plural": "Workflow Task Actions",
		"entity.locationconfiguration.locationconfigurationname": "Location Configuration",
		"entity.file.filerelationships": "File Relationships",
		"entity.report.dynamicdaterangeendtype.lastweekendsaturday": "Previous Week ( Ending Saturday )",
		"entity.task.timeouttime": "Task Timeout",
		"entity.accountrelationship": "Account Relationship",
		"permission.warehouse.deletestockreceiver": "Stock Receiver - Delete",
		"validate.processsku_editcapacity.eventcapacityinvalid.notenoughseats": "The submitted event capacity would result in an overbooked event.",
		"entity.define.activeflag": "Active",
		"admin.entity.producttabs.images": "Images",
		"admin.entity.detailpaymenttransaction_permission": "View Payment Transaction Details",
		"setting.integrationvertexwebservicestrustedid": "Vertex Trusted ID",
		"setting.integrationclickandbuymerchantid": "Merchant ID",
		"entity.sku": "SKU",
		"define.orderby": "Order By",
		"entity.printtemplate.printtemplatefile": "Print Template File",
		"admin.order.accountdetails.termaccountcreditdetails.info": "Term Account Credit Details",
		"validate.processorder_forceitemquantityupdate": "The quantities on your order exceeded the maximum allowed for purchase and were adjusted to reflect what is available.",
		"admin.entity.workflowtabs.triggers": "Triggers",
		"report.promotionusagereport": "Promotion Usage",
		"validate.create.product_create.redemptionamount.minvalue": "Tbe value entered for Redemption Amount must be greater than zero.",
		"processobject.account_addaccountloyalty.loyalty": "Loyalty Program",
		"define.october": "October",
		"entity.orderitemgiftrecipient.firstname": "First Name",
		"admin.entity.giftcard": "Gift Card",
		"entity.inventory": "Inventory",
		"define.initialsku": "Initial Sku",
		"entity.contentaccess.content": "Content",
		"entity.address.countrycode": "Country",
		"entity.product.productimages": "Product Images",
		"permission.setting.detailroundingrule": "Rounding Rule - Detail",
		"entity.loyaltyaccruement.pointtype.pointperdollar": "Point Per Dollar",
		"define.fixedamount": "Fixed Amount",
		"entity.attribute.requiredflag": "Required",
		"admin.entity.promotiontabs.promotioncodes": "Promotion Codes",
		"setting.globaladminautologoutminutes": "Log Out Admin Accounts After X Minutes of Inactivity",
		"frontend.checkout.detail.saveaccount": "Save Account",
		"admin.define.detail": "${itemEntityName} Detail",
		"entity.orderfulfillment.shippingcharge": "Shipping Charge",
		"entity.define.changedatetime": "Change Date Time",
		"admin.entity.processsku.changeeventdates_error": "There was a problem saving event date changes.",
		"api.main_permission": "API Access Permission",
		"setting.shippingmethodrateadjustmenttype": "Rate Adjustment Type",
		"entity.stockhold.sku": "Sku",
		"setting.integrationavataxaccesskey": "Avatax License Key",
		"entity.entityqueuehistory.entityqueuehistorydatetime": "Entity Queue History Date Time",
		"defaultmessage_required_dependentpropertyvalue": "{1} is required based on what you entered for {2}{3}.",
		"entity.define.bankroutingnumber": "Bank Routing Number",
		"entity.promotionaccount_plural": "Promotion Accounts",
		"entity.emailtemplate.emailtemplateobject": "Email Template Object",
		"entity.accountpaymentmethod.paymentterm": "Payment Term",
		"setting.integrationavataxcustomerusagetypepropertyidentifier": "Customer Usage Type Property Identifier",
		"entity.updatescript_plural": "Update Scripts",
		"admin.default.orders_nav": "Orders",
		"entity.productschedule.schedulestartdate": "Schedule Start Date",
		"entity.promotionrewardcurrency_plural": "Promotion Reward Currencies",
		"admin.define.save_success": "The ${itemEntityName} was saved successfully.",
		"admin.entity.loyaltyredemptiontabs.skus": "Skus",
		"entity.product.calculatedtitle": "Title",
		"entity.accountloyalty_plural": "Account Loyalty Programs",
		"api.main.define.save_error": "There was an error trying to save the ${EntityName}",
		"entity.shippingmethodoption.shippingmethodoptionid": "Shipping Method Option ID",
		"entity.order.paymentamountcreditedtotal": "Credited Amount",
		"entity.order.orderdeliveries": "Order Deliveries",
		"permission.setting.createmeasurementunit": "Measurement Unit - Create",
		"entity.workflowtaskaction.actiontype": "Action Type",
		"admin.entity.formtabs.formquestions": "Form Questions",
		"entity.physical.stockadjustments": "Stock Adjustments",
		"entity.orderpayment.creditcardnumberencrypted": "Credit Card Number Encrypted",
		"entity.optiongroup": "Option Group",
		"entity.orderpayment.securitycode": "CVV Code",
		"entity.orderfulfillment.quantitydelivered": "Quantity Delivered",
		"validate.create.product_create.eventenddatetime.gtnow": "Event End Date must occur in the future",
		"entity.define.startdatetime": "Start",
		"validate.save.schedule.frequencyendtime.gtproperty": "The End Time needs to be greater than the Start Time",
		"admin.entity.skutabs.options": "Options",
		"validate.delete.collection.collectionid.hasnoassociatedcollection": "This collection cannot be deleted. It is associated to other collection.",
		"entity.paymenttransaction.amountreceived": "Amount Received",
		"processobject.product_addeventschedule.schedulingtype": "Occuring",
		"entity.loyaltyaccruement.producttypes": "Product Types",
		"entity.account.loginlockexpiresdatetime": "Account Locked",
		"entity.orderfulfillment.accountaddress": "Account Address",
		"setting.contentdefaultproductsperpage": "Products per page",
		"validate.create.account_create.password.minlength": "The account password should be atleast 6 characters long.",
		"entity.inventory.stock": "Stock",
		"entity.loyaltyaccruement.excludedproducts": "Excluded Products",
		"entity.paymenttransaction.providertransactionid": "Provider Transaction ID",
		"entity.physical.locations": "Locations",
		"entity.accountpayment.appliedaccountpayments": "Applied Account Payments",
		"entity.workflowtaskaction.print": "Print",
		"permission.setting.createorderorigin": "Order Origin - Create",
		"entity.accountcontentaccess_plural": "Account Content Accesses",
		"entity.brand.physicals": "Physicals",
		"defaultmessage_true": "{1} must be true.",
		"entity.define.estimateddeliverydatetime": "Estimated Order Delivery Date time",
		"define.workflow": "Workflow",
		"admin.entity.orderitemtabs.deliveryitems": "Delivery Items",
		"entity.setting.emailtemplate": "Email Template",
		"entity.productbundlegroup.minimumquantity": "Min Quantity",
		"entity.stockadjustmentitem.newquantity": "New Qty.",
		"permission.setting.deletetype": "Type - Delete",
		"admin.entity.editorderpayment_disabled": "The order payment cannot be edited as the order has been placed.",
		"define.salutationmrs": "Mrs.",
		"entity.brand_plural": "Brands",
		"permission.setting.savefulfillmentmethod": "Fulfillment Method - Save",
		"entity.product.process.addeventschedule": "Add Event Schedule",
		"entity.address.postalcode": "Postal Code",
		"admin.default.warehouse_nav": "Warehouse",
		"entity.session.loggedoutdatetime": "Logged Out Date Time",
		"entity.collection.collectiondescription": "Description",
		"entity.vendor.emailaddresses": "Email Addresses",
		"entity.commentrelationship": "Comment Relationship",
		"entity.promotionqualifier.qualifiertype.fulfillment": "Fulfillment",
		"entity.comment.publicflag_hint": "This flag is used to determine if the comment should be shown publicly, if set to NO it will only appear in the admin.",
		"permission.setting.detailattributeset": "Attribute Set - Detail",
		"permission.setting.saveschedule": "Schedule - Save",
		"admin.entity.orderitemgiftrecipient.lastname": "Last Name",
		"setting.globalorderplacedemailfrom": "New Order Placed Email From",
		"entity.orderfulfillment.totalshippingweight": "Total Shipping Weight",
		"entity.audit": "Audit",
		"entity.permission.entityclassname": "Entity Class Name",
		"entity.promotionreward.shippingpercentageoff": "Shipping Rate % Off",
		"validate.addorderpayment.order_addorderpayment.giftcardid.canredeemgiftcardtoaccount": "This gift card can not be redeemed to this account, because it already has an account attached to it.",
		"entity.app.integration": "integration",
		"entity.paymenttransaction.accountpaymentmethod": "Account Payment Method",
		"entity.productattributeset": "Product Attribute Set",
		"setting.integrationavataxtaxexemptrequirescompanypaymentmethodflag": "Tax Exempt Requires Company Payment Method",
		"entity.accountpaymentmethod.giftcardnumber": "Gift Card Number",
		"entity.paymentterm.sortorder": "Sort Order",
		"entity.vendoremailaddress.emailaddress": "Email Address",
		"entity.paymentmethod.paymentmethodid": "Payment Method ID",
		"entity.vendorskustock.quantity": "Qty.",
		"entity.define.estimatedfulfillmentdatetime": "Estimated Order Fulfillment Date Time",
		"entity.audit.nosummary": "No summary available",
		"processobject.product_create.listprice": "List Price",
		"entity.orderfulfillmentshipping.discountamount": "Shipping Discount",
		"entity.loyaltyaccruement.accountloyaltytransactions": "Account Loyalty Transactions",
		"admin.entity.contenttabs.content": "Content",
		"entity.permission.permissiongroup": "Permission Group",
		"entity.accountemailaddress.verificationcode": "Verification Code",
		"setting.siteforgotpasswordemailtemplate": "Forgot Password Email Template",
		"entity.optiongroup.delete_validatehasoptions": "This option group cannot be deleted because it contains options.",
		"entity.loyaltyredemption.redemptionpointtype.loyaltytermbalance": "Loyalty Term Balance",
		"entity.pricegroup.pricegrouprates": "Price Group Rates",
		"setting.integrationorbitalusername_hint": "Orbital Gateway Username",
		"entity.stockreceiver.vendororder": "Vendor Order",
		"entity.eventtrigger.eventtriggername": "Event Trigger Name",
		"entity.account.process.redeemgiftcard": "Redeem Gift Card To Account",
		"entity.measurementunit_plural": "Measurement Units",
		"define.add": "Add",
		"entity.pricegroup.enabledonaccount": "Enabled",
		"setting.integrationpayflowproaccountpaymentcommenttwotemplate": "Account Payment Comment Two Template",
		"define.qats": "QATS",
		"entity.paymentmethod.paymentmethodtype.cash": "Cash",
		"entity.attribute.attributecode_validateunique": "The attribute code {attributeCode} is already in use by another attribute.",
		"validate.processphysical_addphysicalcount.validinfo": "The file you uploaded had ${valid} row(s) that imported sucessfully.",
		"admin.entity.physicaltabs.discrepancies.discrepancy": "Discrepancy",
		"setting.skuemailfulfillmenttemplate": "Sku Email Fulfillment Template",
		"entity.physical.physicalid": "Physical ID",
		"entity.productimage.imagetype": "Image Type",
		"setting.productimagemediumwidth": "Medium Image Width",
		"event.onsessionaccountlogin": "On Account Login",
		"api": "Api",
		"entity.accountpayment.accountpaymentid": "accountPaymentID",
		"entity.skuprice.minquantity": "Min Quantity",
		"entity.vendorskustock.vendorskustockid": "vendorSkuStockID",
		"admin.entity.processsubscriptionusage.cancel_success": "Subscription Canceled",
		"define.checkbox": "Checkbox",
		"setting.integrationauthorizenettestgatewayurl": "Test API Gateway URL",
		"entity.schedule.frequencyendtime.runonce": "Run Once",
		"entity.orderpayment.bankroutingnumberencrypted": "Bank Routing number  Encrypted",
		"entity.promotionqualifier.promotionqualifierid": "Promotion Qualifier ID",
		"entity.stock.qexp": "qexp",
		"entity.orderdelivery.paymenttransaction": "Payment Transaction",
		"entity.promotionqualifier.rewardmatchingtype_hint": "This allows you to specify how the item rewards are matched with this qualifier.  Such as 'only apply rewards to items that match the same x as this qualifier'",
		"entity.locationaddress.locationaddressname": "Nickname",
		"entity.promotionrewardcurrency": "Promotion Reward Currency",
		"entity.attributeset.attributesetdescription": "Attribute Set Description",
		"entity.subscriptionusage.expirationdate": "Expiration Date",
		"entity.loyaltyredemption.amount": "Amount",
		"entity.setting.global": "Global Setting",
		"permission.vendor.editvendororder": "Vendor Order - Edit",
		"entity.product.lastupdateddatetime": "Date Last Updated",
		"admin.main.encryption.batchsizelimit_placeholder": "All encrypted records",
		"entity.orderitemgiftrecipient.quantity": "Quantity",
		"entity.integration": "Integration",
		"admin.entity.shippingmethodratetabs.shippingmethodratepricegroups": "Price Groups",
		"entity.profile.profileid": "profileID",
		"processobject.sku_create.skucode": "SKU Code",
		"setting.accountadminforcepasswordresetafterdays_hint": "This should be the amount of days that you want your admins to be able to use their new password. Once they go over this amount they will be forced to reset their password upon their next log in. Max value of 90.",
		"validate.create.product_create.renewalprice.minvalue": "The Renewal Price must be greater than zero.",
		"admin.main.default_title": "Dashboard",
		"admin.entity.promotionqualifiertabs.options": "Options",
		"defaultmessage_time": "{1} must be a valid time, between 00:00 and 23:59.",
		"admin.processbouncedemails_success": "Successfully Processed Bounced Emails: A report email has been sent to your default \"Email To:\" address.",
		"admin.define.createskubundle": "Add Bundled Sku",
		"entity.stockreceiver.receivertype": "Receiver Type",
		"entity.subscriptionbenefit.subscriptionbenefitname": "Subscription Benefit Name",
		"admin.entity.orderitemtabs.stockreceiveritems": "Stock Receiver Items",
		"admin.define.save_error": "There was an error trying to save the ${itemEntityName}.",
		"entity.accountpaymentmethod.creditcardtype": "Card Type",
		"entity.accountloyaltytransaction.accruementtype": "Accruement Type",
		"entity.task.taskschedules": "Task Schedules",
		"admin.entity.tasktabs.tasksettings": "Task Settings",
		"entity.paymentmethod.paymentmethodtype.external": "External",
		"entity.shippingmethodoptionsplitshipment.shipmethodoptsplitshipmentid": "Shipping Method Option Split Shipment ID",
		"define.show": "Show",
		"define.duration": "Duration",
		"entity.setting.producttype": "Product Type",
		"permission.setting.listtaskhistory": "Task History - List",
		"admin.entity.createtaxcategoryrate_nav": "Manual Rate",
		"entity.attribute.attributeid": "attributeID",
		"entity.paymenttransaction.avscode": "AVS Code",
		"entity.brand.branddisplaytemplate": "Display Template",
		"entity.report.dynamicdaterangeendtype.lastyearend": "Previous Year End",
		"admin.entity.integrationtabs.settings": "Integration Settings",
		"entity.promotionrewardcurrency.promotionrewardcurrencyid": "Promotion Reward Currency ID",
		"entity.orderitem.extendedprice": "Extended Price",
		"entity.roundingrule.roundingrulename": "Rounding Rule Name",
		"entity.orderitem.sku": "Sku",
		"define.cart": "Order",
		"entity.orderfulfillment.shippingmethod": "Shipping Method",
		"entity.productreview.product": "Product",
		"entity.account.company": "Company",
		"define.termpayment": "Term Payment",
		"permission.setting.createschedule": "Schedule - Create",
		"entity.product.liveprice": "Price",
		"admin.entity.producttabs.images.alternateimages": "Alternate Images",
		"admin.pricing.createpromotionqualifiercontentaccess": "Create Promotion Qualifier Content Access",
		"entity.promotionaccount.promotion": "Promotion",
		"entity.skuprice.promotionreward": "Promotion Reward",
		"entity.order.process.updateorderfulfillment": "Update Order Fulfillment",
		"entity.sku.loyaltyredemptionexclusions": "Loyalty Redemption Exclusions",
		"processobject.subscriptionusage_renew.renewalpaymenttype.new": "New Payment",
		"entity.accountpaymentapplied": "Account Payment Applied",
		"validate.addeventschedule.product_addeventschedule.purchaseenddatetime.gtnow": "Purchase End Date must occur in the future.",
		"define.username": "Username",
		"entity.define.currentflag": "Is Current",
		"admin.entity.skutabs.eventconflicts": "Event Conflicts",
		"define.existingpassword": "Old Password",
		"entity.order.referencingorders": "Referencing Orders",
		"entity.fulfillmentmethod": "Fulfillment Method",
		"entity.stockadjustment.stockadjustmentid": "Stock Adjustment ID",
		"entity.attributeset.attributesetcode_hint": "A unique string (alphanumerc, no spaces) to identify the attribute set.",
		"validate.delete.sku.stocksdeletableflag": "This sku cannot be deleted because it has stocks assigned to it.",
		"entity.address.country": "Country",
		"admin.entity.orderitemgiftrecipient.emailaddress": "Email Address",
		"admin.entity.skutabs.inventory": "Inventory",
		"entity.define.quantityout": "Quantity Out",
		"entity.sku.subscriptionbenefits": "Subscription Benefits",
		"entity.sku.product": "Product",
		"admin.entity.skutabs.pricegroups": "Price Groups",
		"entity.image.imagename": "Image Name",
		"entity.report.dynamicdaterangetype.months": "Month(s)",
		"admin.entity.createmanualoutadjustment": "Manual Out Adjustment",
		"setting.globalpagecreateaccount": "Create Account Page",
		"entity.emailbounce_plural": "Email Bounces",
		"setting.emailbccaddress": "Email BCC Address",
		"entity.orderdelivery.shippingmethod": "Shipping Method",
		"entity.email.emailsubject": "Email Subject",
		"define.manualout": "Manual Out",
		"entity.product.title": "Product Title",
		"admin.entity.producttabs.relatedproducts": "Related Products",
		"admin.entity.processorder.updatestatus_success": "Status Updated",
		"entity.pricegrouprate.delete_success": "Price Group Rate Deleted",
		"admin.entity.ordertabs.orderpayments.charges": "Charges",
		"validate.resetpassword.account_resetpassword.password.minlength": "Please select a password that is 6 characters or greater.",
		"entity.shippingmethod.orderfulfillments": "Order Fulfillments",
		"admin.entity.listcartandquote_permission": "Carts & Quote - View List",
		"entity.promotionreward.producttypes": "Product Types",
		"entity.workflowtriggerhistory_plural": "Trigger Histories",
		"validate.save.collection.collectionid.cansavecollectionbycollectionobject": "You do not have read access to Collection Type",
		"define.contents": "Content",
		"setting.integrationupsshipfromcompany": "ShippingCompany",
		"entity.orderitemgiftrecipient.account": "Account",
		"entity.entityqueue.entityqueuedatetime": "Entity Queue Date Time",
		"define.both": "Both",
		"entity.contentaccess.accountcontentaccess": "Account Content Access",
		"processobject.product_create.renewalprice": "Renewal Price",
		"admin.entity.processorder.removepromotioncode_confirm": "Are you sure you want to remove this Promotion code from the order?",
		"entity.orderfulfillment.subtotalafterdiscounts": "Fulfillment Items Subtotal",
		"entity.paymenttransaction.transactionendtickcount": "Transaction End Tick Count",
		"setting.integrationvertexcompany": "Company",
		"setting.integrationvertextestingflag": "Test Mode ",
		"setting.integrationfullcirclecompanycode": "Full Circle Company Code",
		"validate.delete.orderdelivery.orderdeliveryid.maxlength": "You cannot delete and order delivery.",
		"setting.integrationgigyaenabledproviders": "Enabled Providers",
		"entity.access.accessid": "Access ID",
		"enity.orderfulfillment.orderfulfillmenttype.attend": "Order Fulfillment Type",
		"admin.entity.producttabs.vendors": "Vendors",
		"entity.promotionapplied.promotion": "Promotion",
		"admin.define.process_nav": "Process ${itemEntityName}",
		"define.all": "All",
		"entity.location.sellstockonweb": "Sell Stock On Web",
		"entity.addresszone.promotionqualifiers": "Promotion Qualifiers",
		"define.external": "External",
		"validate.save.shippingmethod.shippingmethodcode.uniqueornull": "Shipping Method Code Must Be Unique",
		"define.qomin.full": "Min Per Order",
		"entity.skuprice.currencycode": "Currency Code",
		"entity.subscriptionusage.process.addusagebenefit": "Add Subscription Benefit",
		"entity.orderpayment.checknumber": "Check Number",
		"setting.integrationparcel2goshipperpostalcode": "Shipping From Postal Code ",
		"entity.stockadjustmentdelivery_plural": "Stock Adjustment Deliveries",
		"setting.contentmetadescriptionstring": "Content Meta Description String",
		"setting.integrationavataxtaxexemptnumberpropertyidentifier_hint": "This is the property at the Account level where the user's Tax Exemption number is stored. Sending any value in this field will flag the transaction as exempt. ",
		"setting.globalforcecreditcardoverssl": "Force Credit Card Over SSL",
		"entity.promotionperiod.promotionqualifiers": "Promotion Qualifiers",
		"entity.fulfillmentbatchitem": "Fulfillment Batch Item",
		"defaultmessage_required": "{1} is required.",
		"entity.accountpayment_plural": "Account Payments",
		"define.quantity": "Quantity",
		"entity.skuprice.renewalprice": "Renewal Price",
		"setting.skugiftcardemailfulfillmenttemplate": "Gift Card Email Fulfillment Template",
		"entity.state.statecode": "State Code",
		"processobject.product_create.redemptionamounttype": "Redemption Amount Type",
		"define.percentageoff": "Percentage Off",
		"entity.brand.delete_validateisassigned": "Brand cannot be deleted because it has been assigned to products",
		"entity.taxcategoryrate.taxcategoryratecode": "Tax Category Rate Code",
		"validate.account.authorizeaccount.invalidpassword": "The password that was provided was invalid.",
		"report.productperformancereport.revenue": "Revenue",
		"entity.inventory.stockadjustmentdeliveryitem": "Stock Adjustment Delivery Item",
		"setting.integrationusaepaytestingflag": "Test Mode ",
		"entity.orderitem.appliedpricegroup": "Applied Price Group",
		"admin.main.update.unexpected_error": "An unexpected error was encountered trying to update Slatwall.  Please try again, and if the problem persists you can check the Slatwall Log for more details about the error.",
		"setting.integrationorbitalusername": "User Name",
		"admin.entity.shippingmethodratetabs.shippingmethodratesettings": "Shipping Rate Settings",
		"entity.subscriptionstatus": "Subscription Status",
		"entity.orderitem.parentorderitem": "Parent Order Item",
		"admin.entity.producttabs.productsettings": "Product Settings",
		"entity.subscriptionbenefit.accesstype": "Access Code Generation Type",
		"entity.content.cmssiteid": "CMS Site ID",
		"entity.promotion.delete_validateisdeletable": "This promotion cannot be deleted because it is in use.",
		"define.range": "Range",
		"entity.attribute.displayonorderdetailflag": "Display On Order Detail Page",
		"entity.vendororder.process.receivestock": "Receive Stock",
		"validate.addsubscriptionsku.product_addsubscriptionsku.renewalprice.required": "You must define either a Renewal Sku or a Renewal Benefit and Price.",
		"entity.orderitem.towaitlist": "There are not enough seats available. Entering account information here will cause this registrant to be placed on a waitlist.",
		"entity.promotionqualifier_plural": "Promotion Qualifiers",
		"entity.subscriptionstatus.subscriptionstatusid": "Subscription Status ID",
		"permission.setting.createcountry": "Country - Create",
		"permission.setting.detaillocation": "Location - Detail",
		"validate.save.sku.eventconflictexistsflag": "There is a conflict with an existing event. Please choose a different location or time.",
		"entity.skucurrency_plural": "Sku Currencies",
		"entity.promotionreward.promotionrewardid": "Promotion Reward ID",
		"entity.entityqueue.baseobject": "Base Object",
		"entity.order_plural": "Orders",
		"entity.subscriptionterm.initialterm_hint": "This defines the duration of the first term for a given subscription.",
		"define.and": "and",
		"define.tuesday": "Tuesday",
		"processobject.accountloyalty_manualtransaction.manualadjustmenttype": "Manual Adjustment Type",
		"entity.subscriptionterm.autorenewflag": "Auto Renew",
		"define.any": "Any",
		"define.subscription": "Subscription",
		"admin.processbouncedemails_failure": "There was a problem processing your email, please check your server settings.",
		"entity.shippingmethodrate.minimumshipmentitemprice": "Min Fulfillment Subtotal",
		"define.renewalsubscriptionbenefits": "Renewal Subscription Benefits Name",
		"define.stockloss": "Stock Loss",
		"define.qnc.full": "Not Committed",
		"entity.eventtrigger": "Event Trigger",
		"setting.productimagelargeheight": "Large Image Height",
		"setting.integrationupsshippernumber": "Shipper Number (UPS Account Number)",
		"permission.basecontroller": "Base Controller",
		"validate.edit.orderfulfillment.orderstatuscode.inlist": "The order fulfillment cannot be edited as the order has been placed.",
		"entity.subscriptionusagebenefitaccount.enddatetime": "End Date Time",
		"define.active": "Active",
		"entity.report.dynamicdaterangeinterval": "Date Range Length",
		"permission.setting.listschedule": "Schedule - List",
		"entity.commentrelationship.referencedexpressionstart": "Referenced Expression Start",
		"setting.integrationclickandbuycurrency": "Currency (ISO 4217)",
		"permission.print": "Print",
		"validate.define.regex": "The value entered for ${propertyName} should be alphanumeric with no spaces.",
		"define.inherited": "Inherited",
		"entity.entityqueuehistory.baseobject": "Base Object",
		"entity.attribute.attributename": "Attribute Name",
		"entity.location.sellstockonwebwholesale": "Sell Stock On Web Wholesale",
		"entity.content": "Content",
		"entity.orderitem.accountloyaltytransactions": "Account Loyalty Transactions",
		"entity.audit.auditarchivecreateddatetime": "Created Date",
		"entity.subscriptionusage.account": "Account",
		"permission.setting.listpaymentmethod": "Payment Method - List",
		"entity.image.imagedescription": "Image Description",
		"admin.entity.createmerchandiseproducttype_nav": "New Merchandise Product Type",
		"admin.entity.attributetabs.attributeoptions": "Attribute Options",
		"entity.country.citylabel": "City Label",
		"setting.globalurlkeybrand": "Brand URL Key",
		"entity.workflowtriggerhistory.endtime": "End Time",
		"entity.pricegroup.childpricegroups": "Child Price Groups",
		"permission.integration.detailintegration": "Integration - Detail",
		"setting.integrationusaepaykey": "Source Key ",
		"entity.subscriptionusage.subscriptionusagebenefits": "Subscription Usage Benefits",
		"entity.sku.webqoh": "webQOH",
		"entity.attribute_plural": "Attributes",
		"admin.entity.preprocessphysical_addphysicalcount_title": "Add Physical Count Items",
		"entity.orderdeliveryitem.orderdeliveryitemid": "Order Delivery Item ID",
		"entity.report.dynamicdaterangetype.weeks": "Week(s)",
		"define.admin.orderdetail.title": "Title",
		"entity.optiongroup.imagegroupflag": "Product Image Group",
		"entity.define.changedbyaccount": "Changed By",
		"entity.task.process.runtask": "Run Task Now",
		"entity.productimage": "Product Image",
		"admin.entity.loyaltyaccruementtabs.brands": "Brands",
		"entity.content.productsortdefaultdirection": "Product Sort Default Direction",
		"entity.accountcontentaccess.account": "Account",
		"entity.attributeset.globalflag_hint": "Setting this to yes will make this attribute set automatically available based on the attribute set type selected. Otherwise you will need to explicitly assign the attribute set to where you want to use it.",
		"mura_permission": "Mura",
		"entity.task.nextrundatetime": "Next Run",
		"setting.contenttemplatefile": "Content Template File",
		"entity.report.reportid": "Report ID",
		"entity.loyaltyaccruement.excludedproducttypes": "Excluded Product Types",
		"permission.setting.edittaxcategory": "Tax Category - Edit",
		"entity.site.allowadminaccessflag": "Allow Admin Access",
		"admin.entity.skutabs.registrants": "Registrants",
		"entity.vendorskustock": "Vendor Sku Stock",
		"entity.orderitem.appliedpromotions": "Applied Promotions",
		"api.main.post": "API POST Method",
		"setting.integrationfullcirclelocaltransferdirctory_hint": "This is the full directory path on this web server to where you would like transfer files to go. Example: C:\\Inetpub\\wwwroot\\fctransfer",
		"entity.accountemailaddress": "Account Email Address",
		"entity.skucurrency.listprice": "List Price",
		"entity.attributeset.products": "Products",
		"admin.entity.vendorordertabs.products": "Products",
		"entity.subscriptionusagebenefit.subscriptionusage": "Subscription Usage",
		"entity.product.calculatedallowbackorderflag": "Calculated Allow Backorder Flag",
		"entity.define.creditcardnumber": "Credit Card Number",
		"entity.shippingmethodoption.orderfulfillment": "Order Fulfillment",
		"entity.promotion.promotionid": "Promotion ID",
		"setting.globalremoteideditflag": "Edit RemoteID Fields in Administration",
		"permission.main.ckfinder": "File Manager",
		"entity.product.template": "Design Template",
		"admin.entity.processeventregistration.approve_success": "Registration has been changed to Approved.",
		"entity.eventregistration.process.approve": "Change to Approved",
		"admin.main.encryption.reencryptdata_confirm": "Re-encrypting the database could take some time depending on the batch size limit.",
		"setting.globalmimetypewhitelist": "Allowed MIME Types",
		"permission.setting.detailsetting": "Setting - Detail",
		"entity.accountcontentaccess.accountcontentaccessid": "Account Content Access ID",
		"define.dayoftheweek": "Day of the Week",
		"validate.save.skucurrency.price.minvalue": "The sku currency price cannot be a negative value.",
		"entity.pricegroup.pricegroupcode": "Price Group Code",
		"admin.entity.detailaudit": "Audit",
		"entity.accountpaymentmethod.billingaccountaddress": "Billing Account Address",
		"entity.accountpaymentmethod.providertoken": "Provider Token",
		"define.name": "Name",
		"admin.entity.preprocessorder_addorderitem.returndetails": "Return Details",
		"define.language.en_gb": "English (UK)",
		"entity.subscriptionterm.allowprorateflag": "Allow Prorate",
		"entity.promotionqualifier.minimumordersubtotal": "Minimum Order Subtotal",
		"permission.setting.editcategory": "Category - Edit",
		"entity.accountpaymentmethod.expirationmonth": "Expiration Month",
		"entity.attribute.attributetype.relatedobjectselect": "Related Object Select",
		"admin.main.encryption.updatepassword_success": "The database encryption password was successfully updated.",
		"entity.orderfulfillment.shippingaddress": "Shipping Address",
		"entity.taxcategory.taxcategoryrates": "Tax Category Rates",
		"entity.define.createddatetime": "Created Date Time",
		"permission.pricing.savepromotion": "Promotion - Save",
		"entity.account.process.setupinitialadmin": "Setup Initial Admin",
		"entity.access.accesscode": "Access Code",
		"setting.contentrequiresubscriptionflag": "Require Subscription for Access",
		"processobject.task_updatecalculatedproperties.updateorderflag": "Update Orders",
		"entity.schedule.frequencystarttime_hint": "Defines the time of day that you would like the schedule to start.  If no end time is defined, then this is just the 1 time during the day where the schedule will run.",
		"entity.productbundlegroupitem": "Product Bundle Group Item",
		"setting.globalencryptionencoding": "Encryption Encoding",
		"setting.integrationvirtualmerchanttestpin": "Test Virtual Merchant PIN",
		"admin.entity.editskucurrency": "Edit Price for ${currencyCode} Currency",
		"admin.define.norecordsfound": "No Records Found.",
		"setting.productshowdetailwhennotpublishedflag": "Display Product Detail When Not Published"
	};

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/// <reference path='../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../typings/tsd.d.ts' />
	//import alertmodule = require('./alert/alert.module');
	var alert_module_1 = __webpack_require__(98);
	var collection_module_1 = __webpack_require__(109);
	var listing_module_1 = __webpack_require__(137);
	var dialog_module_1 = __webpack_require__(102);
	var entity_module_1 = __webpack_require__(153);
	var pagination_module_1 = __webpack_require__(159);
	var form_module_1 = __webpack_require__(162);
	var validation_module_1 = __webpack_require__(177);
	var workflow_module_1 = __webpack_require__(194);
	//directives
	var swsaveandfinish_1 = __webpack_require__(209);
	var hibachimodule = angular.module('hibachi', [
	    alert_module_1.alertmodule.name,
	    collection_module_1.collectionmodule.name,
	    entity_module_1.entitymodule.name,
	    dialog_module_1.dialogmodule.name,
	    listing_module_1.listingmodule.name,
	    pagination_module_1.paginationmodule.name,
	    form_module_1.formmodule.name,
	    validation_module_1.validationmodule.name,
	    workflow_module_1.workflowmodule.name
	]).config([function () {
	    }])
	    .constant('hibachiPartialsPath', 'hibachi/components/')
	    .directive('swSaveAndFinish', swsaveandfinish_1.SWSaveAndFinish.Factory());
	exports.hibachimodule = hibachimodule;


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/// <reference path='../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../typings/tsd.d.ts' />
	//modules
	var core_module_1 = __webpack_require__(3);
	//services
	var collectionconfigservice_1 = __webpack_require__(110);
	var collectionservice_1 = __webpack_require__(111);
	//controllers
	var collections_1 = __webpack_require__(112);
	var createcollection_1 = __webpack_require__(113);
	var confirmationcontroller_1 = __webpack_require__(114);
	var entity_createcollection_1 = __webpack_require__(115);
	//directives
	var swcollection_1 = __webpack_require__(116);
	var swaddfilterbuttons_1 = __webpack_require__(117);
	var swdisplayoptions_1 = __webpack_require__(118);
	var swdisplayitem_1 = __webpack_require__(119);
	var swdisplayitemaggregate_1 = __webpack_require__(120);
	var swcollectiontable_1 = __webpack_require__(121);
	var swcolumnitem_1 = __webpack_require__(122);
	var swconditioncriteria_1 = __webpack_require__(123);
	var swcriteria_1 = __webpack_require__(124);
	var swcriteriaboolean_1 = __webpack_require__(125);
	var swcriteriadate_1 = __webpack_require__(126);
	var swcriteriamanytomany_1 = __webpack_require__(127);
	var swcriteriamanytoone_1 = __webpack_require__(128);
	var swcriterianumber_1 = __webpack_require__(129);
	var swcriteriaonetomany_1 = __webpack_require__(130);
	var swcriteriarelatedobject_1 = __webpack_require__(131);
	var swcriteriastring_1 = __webpack_require__(132);
	var sweditfilteritem_1 = __webpack_require__(133);
	var swfiltergroups_1 = __webpack_require__(134);
	var swfilteritem_1 = __webpack_require__(135);
	var swfiltergroupitem_1 = __webpack_require__(136);
	var collectionmodule = angular.module('hibachi.collection', [core_module_1.coremodule.name])
	    .config([function () {
	    }]).run([function () {
	    }])
	    .constant('collectionPartialsPath', 'collection/components/')
	    .controller('collections', collections_1.CollectionController)
	    .controller('confirmationController', confirmationcontroller_1.ConfirmationController)
	    .controller('createCollection', createcollection_1.CreateCollection)
	    .controller('entity_createcollection', entity_createcollection_1.CollectionCreateController)
	    .factory('collectionConfigService', ['rbkeyService', '$hibachi', 'utilityService', 'observerService', function (rbkeyService, $hibachi, utilityService, observerService) { return new collectionconfigservice_1.CollectionConfig(rbkeyService, $hibachi, utilityService, observerService); }])
	    .service('collectionService', collectionservice_1.CollectionService)
	    .directive('swCollection', swcollection_1.SWCollection.Factory())
	    .directive('swAddFilterButtons', swaddfilterbuttons_1.SWAddFilterButtons.Factory())
	    .directive('swDisplayOptions', swdisplayoptions_1.SWDisplayOptions.Factory())
	    .directive('swDisplayItem', swdisplayitem_1.SWDisplayItem.Factory())
	    .directive('swDisplayItemAggregate', swdisplayitemaggregate_1.SWDisplayItemAggregate.Factory())
	    .directive('swCollectionTable', swcollectiontable_1.SWCollectionTable.Factory())
	    .directive('swColumnItem', swcolumnitem_1.SWColumnItem.Factory())
	    .directive('swConditionCriteria', swconditioncriteria_1.SWConditionCriteria.Factory())
	    .directive('swCriteria', swcriteria_1.SWCriteria.Factory())
	    .directive('swCriteriaBoolean', swcriteriaboolean_1.SWCriteriaBoolean.Factory())
	    .directive('swCriteriaDate', swcriteriadate_1.SWCriteriaDate.Factory())
	    .directive('swCriteriaManyToMany', swcriteriamanytomany_1.SWCriteriaManyToMany.Factory())
	    .directive('swCriteriaManyToOne', swcriteriamanytoone_1.SWCriteriaManyToOne.Factory())
	    .directive('swCriteriaNumber', swcriterianumber_1.SWCriteriaNumber.Factory())
	    .directive('swCriteriaOneToMany', swcriteriaonetomany_1.SWCriteriaOneToMany.Factory())
	    .directive('swCriteriaRelatedObject', swcriteriarelatedobject_1.SWCriteriaRelatedObject.Factory())
	    .directive('swCriteriaString', swcriteriastring_1.SWCriteriaString.Factory())
	    .directive('swEditFilterItem', sweditfilteritem_1.SWEditFilterItem.Factory())
	    .directive('swFilterGroups', swfiltergroups_1.SWFilterGroups.Factory())
	    .directive('swFilterItem', swfilteritem_1.SWFilterItem.Factory())
	    .directive('swFilterGroupItem', swfiltergroupitem_1.SWFilterGroupItem.Factory());
	exports.collectionmodule = collectionmodule;


/***/ },
/* 110 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var Column = (function () {
	    function Column(propertyIdentifier, title, isVisible, isDeletable, isSearchable, isExportable, persistent, ormtype, attributeID, attributeSetObject) {
	        if (isVisible === void 0) { isVisible = true; }
	        if (isDeletable === void 0) { isDeletable = true; }
	        if (isSearchable === void 0) { isSearchable = true; }
	        if (isExportable === void 0) { isExportable = true; }
	        this.propertyIdentifier = propertyIdentifier;
	        this.title = title;
	        this.isVisible = isVisible;
	        this.isDeletable = isDeletable;
	        this.isSearchable = isSearchable;
	        this.isExportable = isExportable;
	        this.persistent = persistent;
	        this.ormtype = ormtype;
	        this.attributeID = attributeID;
	        this.attributeSetObject = attributeSetObject;
	    }
	    return Column;
	}());
	exports.Column = Column;
	var Filter = (function () {
	    function Filter(propertyIdentifier, value, comparisonOperator, logicalOperator, displayPropertyIdentifier, displayValue, hidden, pattern) {
	        if (hidden === void 0) { hidden = false; }
	        this.propertyIdentifier = propertyIdentifier;
	        this.value = value;
	        this.comparisonOperator = comparisonOperator;
	        this.logicalOperator = logicalOperator;
	        this.displayPropertyIdentifier = displayPropertyIdentifier;
	        this.displayValue = displayValue;
	        this.hidden = hidden;
	        this.pattern = pattern;
	    }
	    return Filter;
	}());
	exports.Filter = Filter;
	var CollectionFilter = (function () {
	    function CollectionFilter(propertyIdentifier, displayPropertyIdentifier, displayValue, collectionID, criteria, fieldtype, readOnly) {
	        if (readOnly === void 0) { readOnly = false; }
	        this.propertyIdentifier = propertyIdentifier;
	        this.displayPropertyIdentifier = displayPropertyIdentifier;
	        this.displayValue = displayValue;
	        this.collectionID = collectionID;
	        this.criteria = criteria;
	        this.fieldtype = fieldtype;
	        this.readOnly = readOnly;
	    }
	    return CollectionFilter;
	}());
	exports.CollectionFilter = CollectionFilter;
	var Join = (function () {
	    function Join(associationName, alias) {
	        this.associationName = associationName;
	        this.alias = alias;
	    }
	    return Join;
	}());
	exports.Join = Join;
	var OrderBy = (function () {
	    function OrderBy(propertyIdentifier, direction) {
	        this.propertyIdentifier = propertyIdentifier;
	        this.direction = direction;
	    }
	    return OrderBy;
	}());
	exports.OrderBy = OrderBy;
	var CollectionConfig = (function () {
	    // @ngInject
	    function CollectionConfig(rbkeyService, $hibachi, utilityService, observerService, baseEntityName, baseEntityAlias, columns, keywordColumns, filterGroups, keywordFilterGroups, joins, orderBy, groupBys, id, currentPage, pageShow, keywords, allRecords, dirtyRead, isDistinct) {
	        if (keywordColumns === void 0) { keywordColumns = []; }
	        if (filterGroups === void 0) { filterGroups = [{ filterGroup: [] }]; }
	        if (keywordFilterGroups === void 0) { keywordFilterGroups = [{ filterGroup: [] }]; }
	        if (currentPage === void 0) { currentPage = 1; }
	        if (pageShow === void 0) { pageShow = 10; }
	        if (keywords === void 0) { keywords = ''; }
	        if (allRecords === void 0) { allRecords = false; }
	        if (dirtyRead === void 0) { dirtyRead = false; }
	        if (isDistinct === void 0) { isDistinct = false; }
	        var _this = this;
	        this.rbkeyService = rbkeyService;
	        this.$hibachi = $hibachi;
	        this.utilityService = utilityService;
	        this.observerService = observerService;
	        this.baseEntityName = baseEntityName;
	        this.baseEntityAlias = baseEntityAlias;
	        this.columns = columns;
	        this.keywordColumns = keywordColumns;
	        this.filterGroups = filterGroups;
	        this.keywordFilterGroups = keywordFilterGroups;
	        this.joins = joins;
	        this.orderBy = orderBy;
	        this.groupBys = groupBys;
	        this.id = id;
	        this.currentPage = currentPage;
	        this.pageShow = pageShow;
	        this.keywords = keywords;
	        this.allRecords = allRecords;
	        this.dirtyRead = dirtyRead;
	        this.isDistinct = isDistinct;
	        this.clearFilterGroups = function () {
	            _this.filterGroups = [{ filterGroup: [] }];
	            _this.keywordFilterGroups = [{ filterGroup: [] }];
	            return _this;
	        };
	        this.newCollectionConfig = function (baseEntityName, baseEntityAlias) {
	            return new CollectionConfig(_this.rbkeyService, _this.$hibachi, _this.utilityService, _this.observerService, baseEntityName, baseEntityAlias);
	        };
	        this.loadJson = function (jsonCollection) {
	            //if json then make a javascript object else use the javascript object
	            //if coldfusion has double encoded the json keep calling fromJson until it becomes an object
	            while (angular.isString(jsonCollection)) {
	                jsonCollection = angular.fromJson(jsonCollection);
	            }
	            _this.baseEntityAlias = jsonCollection.baseEntityAlias;
	            _this.baseEntityName = jsonCollection.baseEntityName;
	            if (angular.isDefined(jsonCollection.filterGroups)) {
	                _this.validateFilter(jsonCollection.filterGroups);
	                _this.filterGroups = jsonCollection.filterGroups;
	            }
	            _this.columns = jsonCollection.columns;
	            _this.joins = jsonCollection.joins;
	            _this.keywords = jsonCollection.keywords;
	            _this.orderBy = jsonCollection.orderBy;
	            _this.groupBys = jsonCollection.groupBys;
	            _this.pageShow = jsonCollection.pageShow;
	            _this.allRecords = jsonCollection.allRecords;
	            if (jsonCollection.dirtyRead) {
	                _this.dirtyRead = jsonCollection.dirtyRead;
	            }
	            _this.isDistinct = jsonCollection.isDistinct;
	            _this.currentPage = jsonCollection.currentPage || 1;
	            _this.pageShow = jsonCollection.pageShow || 10;
	            _this.keywords = jsonCollection.keywords;
	            return _this;
	        };
	        this.clone = function () {
	            return _this.newCollectionConfig(_this.baseEntityName, _this.baseEntityAlias).loadJson(JSON.parse(JSON.stringify(_this.getCollectionConfig())));
	        };
	        this.loadFilterGroups = function (filterGroupsConfig) {
	            if (filterGroupsConfig === void 0) { filterGroupsConfig = [{ filterGroup: [] }]; }
	            _this.filterGroups = filterGroupsConfig;
	            return _this;
	        };
	        this.loadColumns = function (columns) {
	            _this.columns = columns;
	            return _this;
	        };
	        this.getCollectionConfig = function () {
	            _this.validateFilter(_this.filterGroups);
	            return {
	                baseEntityAlias: _this.baseEntityAlias,
	                baseEntityName: _this.baseEntityName,
	                columns: _this.columns,
	                keywordColumns: _this.keywordColumns,
	                filterGroups: _this.filterGroups,
	                joins: _this.joins,
	                groupBys: _this.groupBys,
	                currentPage: _this.currentPage,
	                pageShow: _this.pageShow,
	                keywords: _this.keywords,
	                defaultColumns: (!_this.columns || !_this.columns.length),
	                allRecords: _this.allRecords,
	                dirtyRead: _this.dirtyRead,
	                isDistinct: _this.isDistinct,
	                orderBy: _this.orderBy
	            };
	        };
	        this.getEntityName = function () {
	            return _this.baseEntityName.charAt(0).toUpperCase() + _this.baseEntityName.slice(1);
	        };
	        this.getOptions = function () {
	            _this.validateFilter(_this.filterGroups);
	            if (_this.keywords && _this.keywords.length && _this.keywordColumns.length > 0) {
	                var columns = _this.keywordColumns;
	            }
	            else {
	                var columns = _this.columns;
	            }
	            if (_this.keywords && _this.keywords.length && _this.keywordFilterGroups[0].filterGroup.length > 0) {
	                var filters = _this.keywordFilterGroups;
	            }
	            else {
	                var filters = _this.filterGroups;
	            }
	            var options = {
	                columnsConfig: angular.toJson(columns),
	                filterGroupsConfig: angular.toJson(filters),
	                joinsConfig: angular.toJson(_this.joins),
	                orderByConfig: angular.toJson(_this.orderBy),
	                groupBysConfig: angular.toJson(_this.groupBys),
	                currentPage: _this.currentPage,
	                pageShow: _this.pageShow,
	                keywords: _this.keywords,
	                defaultColumns: (!_this.columns || !_this.columns.length),
	                allRecords: _this.allRecords,
	                dirtyRead: _this.dirtyRead,
	                isDistinct: _this.isDistinct
	            };
	            if (angular.isDefined(_this.id)) {
	                options['id'] = _this.id;
	            }
	            return options;
	        };
	        this.debug = function () {
	            return _this;
	        };
	        this.formatPropertyIdentifier = function (propertyIdentifier, addJoin) {
	            if (addJoin === void 0) { addJoin = false; }
	            //if already starts with alias, strip it out
	            if (propertyIdentifier.lastIndexOf(_this.baseEntityAlias, 0) === 0) {
	                propertyIdentifier = propertyIdentifier.slice(_this.baseEntityAlias.length + 1);
	            }
	            var _propertyIdentifier = _this.baseEntityAlias;
	            if (addJoin === true) {
	                _propertyIdentifier += _this.processJoin(propertyIdentifier);
	            }
	            else {
	                _propertyIdentifier += '.' + propertyIdentifier;
	            }
	            return _propertyIdentifier;
	        };
	        this.processJoin = function (propertyIdentifier) {
	            var _propertyIdentifier = '', propertyIdentifierParts = propertyIdentifier.split('.'), current_collection = _this.collection;
	            for (var i = 0; i < propertyIdentifierParts.length; i++) {
	                if (angular.isDefined(current_collection.metaData[propertyIdentifierParts[i]]) && ('cfc' in current_collection.metaData[propertyIdentifierParts[i]])) {
	                    current_collection = _this.$hibachi.getEntityExample(current_collection.metaData[propertyIdentifierParts[i]].cfc);
	                    _propertyIdentifier += '_' + propertyIdentifierParts[i];
	                    _this.addJoin(new Join(_propertyIdentifier.replace(/_([^_]+)$/, '.$1').substring(1), _this.baseEntityAlias + _propertyIdentifier));
	                }
	                else {
	                    _propertyIdentifier += '.' + propertyIdentifierParts[i];
	                }
	            }
	            return _propertyIdentifier;
	        };
	        this.addJoin = function (join) {
	            if (!_this.joins) {
	                _this.joins = [];
	            }
	            var joinFound = false;
	            angular.forEach(_this.joins, function (configJoin) {
	                if (configJoin.alias === join.alias) {
	                    joinFound = true;
	                }
	            });
	            if (!joinFound) {
	                _this.joins.push(join);
	            }
	            return _this;
	        };
	        this.addAlias = function (propertyIdentifier) {
	            var parts = propertyIdentifier.split('.');
	            if (parts.length > 1 && parts[0] !== _this.baseEntityAlias) {
	                return _this.baseEntityAlias + '.' + propertyIdentifier;
	            }
	            return propertyIdentifier;
	        };
	        this.addColumn = function (column, title, options) {
	            if (title === void 0) { title = ''; }
	            if (options === void 0) { options = {}; }
	            if (!_this.columns || options.aggregate != null || _this.utilityService.ArrayFindByPropertyValue(_this.columns, 'propertyIdentifier', column) === -1) {
	                var isVisible = true, isDeletable = true, isSearchable = true, isExportable = true, persistent, ormtype = 'string', lastProperty = column.split('.').pop(), isKeywordColumn = true, isOnlyKeywordColumn = false;
	                var lastEntity = _this.$hibachi.getEntityExample(_this.$hibachi.getLastEntityNameInPropertyIdentifier(_this.baseEntityName, column));
	                if (angular.isUndefined(lastEntity)) {
	                    throw ("You have passed an incorrect entity name to a collection config");
	                }
	                if (angular.isUndefined(_this.columns)) {
	                    _this.columns = [];
	                }
	                //hide id columns
	                if (angular.isDefined(options['isVisible'])) {
	                    isVisible = options['isVisible'];
	                }
	                if (angular.isUndefined(options.isVisible) &&
	                    column.substring(column.length - 2) === "ID") {
	                    isVisible = false;
	                }
	                if (angular.isDefined(options['isDeletable'])) {
	                    isDeletable = options['isDeletable'];
	                }
	                if (angular.isDefined(options['isSearchable'])) {
	                    isSearchable = options['isSearchable'];
	                }
	                if (angular.isDefined(options['isExportable'])) {
	                    isExportable = options['isExportable'];
	                }
	                if (angular.isUndefined(options['isExportable']) && !isVisible) {
	                    isExportable = false;
	                }
	                if (angular.isDefined(options['ormtype'])) {
	                    ormtype = options['ormtype'];
	                }
	                else if (lastEntity.metaData[lastProperty] && lastEntity.metaData[lastProperty].ormtype) {
	                    ormtype = lastEntity.metaData[lastProperty].ormtype;
	                }
	                if (angular.isDefined(options['isKeywordColumn'])) {
	                    isKeywordColumn = options['isKeywordColumn'];
	                }
	                if (angular.isDefined(options['isOnlyKeywordColumn'])) {
	                    isOnlyKeywordColumn = options['isOnlyKeywordColumn'];
	                }
	                if (angular.isDefined(lastEntity.metaData[lastProperty])) {
	                    persistent = lastEntity.metaData[lastProperty].persistent;
	                }
	                var columnObject = new Column(column, title, isVisible, isDeletable, isSearchable, isExportable, persistent, ormtype, options['attributeID'], options['attributeSetObject']);
	                if (options['aggregate']) {
	                    columnObject['aggregate'] = options['aggregate'],
	                        columnObject['aggregateAlias'] = title;
	                }
	                //add any non-conventional options
	                for (var key in options) {
	                    if (!columnObject[key]) {
	                        columnObject[key] = options[key];
	                    }
	                }
	                if (!isOnlyKeywordColumn) {
	                    _this.columns.push(columnObject);
	                }
	                if (isKeywordColumn) {
	                    _this.keywordColumns.push(columnObject);
	                }
	            }
	            return _this;
	        };
	        this.setDisplayProperties = function (propertyIdentifier, title, options) {
	            if (title === void 0) { title = ''; }
	            if (options === void 0) { options = {}; }
	            _this.addDisplayProperty(propertyIdentifier, title, options);
	            return _this;
	        };
	        this.addDisplayAggregate = function (propertyIdentifier, aggregateFunction, aggregateAlias, options) {
	            if (angular.isUndefined(aggregateAlias)) {
	                aggregateAlias = propertyIdentifier.replace(/\./g, '_') + aggregateFunction;
	            }
	            var column = {
	                propertyIdentifier: _this.formatPropertyIdentifier(propertyIdentifier, true),
	                title: _this.rbkeyService.getRBKey("entity." + _this.$hibachi.getLastEntityNameInPropertyIdentifier(_this.baseEntityName, propertyIdentifier) + "." + _this.utilityService.listLast(propertyIdentifier)),
	                aggregate: {
	                    aggregateFunction: aggregateFunction,
	                    aggregateAlias: aggregateAlias
	                }
	            };
	            angular.extend(column, options);
	            //Add columns
	            _this.addColumn(column.propertyIdentifier, undefined, column);
	            return _this;
	        };
	        this.addGroupBy = function (groupByAlias) {
	            if (!_this.groupBys) {
	                _this.groupBys = '';
	            }
	            _this.groupBys = _this.utilityService.listAppendUnique(_this.groupBys, groupByAlias);
	            return _this;
	        };
	        this.addDisplayProperty = function (propertyIdentifier, title, options) {
	            if (title === void 0) { title = ''; }
	            if (options === void 0) { options = {}; }
	            var _DividedColumns = propertyIdentifier.trim().split(',');
	            var _DividedTitles = title.trim().split(',');
	            var join = propertyIdentifier.split('.').length > 1;
	            _DividedColumns.forEach(function (column, index) {
	                column = column.trim();
	                if (angular.isDefined(_DividedTitles[index]) && _DividedTitles[index].trim() != '') {
	                    title = _DividedTitles[index].trim();
	                }
	                else {
	                    title = _this.rbkeyService.getRBKey("entity." + _this.$hibachi.getLastEntityNameInPropertyIdentifier(_this.baseEntityName, column) + "." + _this.utilityService.listLast(column, "."));
	                }
	                _this.addColumn(_this.formatPropertyIdentifier(column, join), title, options);
	            });
	            return _this;
	        };
	        this.addFilter = function (propertyIdentifier, value, comparisonOperator, logicalOperator, hidden, isKeywordFilter, isOnlyKeywordFilter) {
	            if (comparisonOperator === void 0) { comparisonOperator = '='; }
	            if (hidden === void 0) { hidden = false; }
	            if (isKeywordFilter === void 0) { isKeywordFilter = true; }
	            if (isOnlyKeywordFilter === void 0) { isOnlyKeywordFilter = false; }
	            if (!_this.filterGroups[0].filterGroup.length) {
	                logicalOperator = undefined;
	            }
	            if (propertyIdentifier.split('.').length > 1) {
	                _this.processJoin(propertyIdentifier);
	            }
	            //create filter
	            var filter = _this.createFilter(propertyIdentifier, value, comparisonOperator, logicalOperator, hidden);
	            if (!isOnlyKeywordFilter) {
	                _this.filterGroups[0].filterGroup.push(filter);
	            }
	            if (isKeywordFilter) {
	                _this.keywordFilterGroups[0].filterGroup.push(filter);
	            }
	            return _this;
	        };
	        this.addLikeFilter = function (propertyIdentifier, value, pattern, logicalOperator, displayPropertyIdentifier, hidden) {
	            if (pattern === void 0) { pattern = '%w%'; }
	            if (hidden === void 0) { hidden = false; }
	            //if filterGroups does not exists then set a default
	            if (!_this.filterGroups) {
	                _this.filterGroups = [{ filterGroup: [] }];
	            }
	            //if filterGroups is longer than 0 then we at least need to default the logical Operator to AND
	            if (_this.filterGroups[0].filterGroup.length && !logicalOperator)
	                logicalOperator = 'AND';
	            var join = propertyIdentifier.split('.').length > 1;
	            if (angular.isUndefined(displayPropertyIdentifier)) {
	                displayPropertyIdentifier = _this.rbkeyService.getRBKey("entity." + _this.$hibachi.getLastEntityNameInPropertyIdentifier(_this.baseEntityName, propertyIdentifier) + "." + _this.utilityService.listLast(propertyIdentifier));
	            }
	            //create filter group
	            var filter = new Filter(_this.formatPropertyIdentifier(propertyIdentifier, join), value, 'like', logicalOperator, displayPropertyIdentifier, value, hidden, pattern);
	            _this.filterGroups[0].filterGroup.push(filter);
	            return _this;
	        };
	        this.createFilter = function (propertyIdentifier, value, comparisonOperator, logicalOperator, hidden) {
	            if (comparisonOperator === void 0) { comparisonOperator = '='; }
	            if (hidden === void 0) { hidden = false; }
	            //if filterGroups does not exists then set a default
	            if (!_this.filterGroups) {
	                _this.filterGroups = [{ filterGroup: [] }];
	            }
	            //if filterGroups is longer than 0 then we at least need to default the logical Operator to AND
	            if (_this.filterGroups[0].filterGroup.length && !logicalOperator)
	                logicalOperator = 'AND';
	            var join = propertyIdentifier.split('.').length > 1;
	            //create filter group
	            var filter = new Filter(_this.formatPropertyIdentifier(propertyIdentifier, join), value, comparisonOperator, logicalOperator, propertyIdentifier.split('.').pop(), value, hidden);
	            return filter;
	        };
	        this.addFilterGroup = function (filterGroup) {
	            var group = {
	                filterGroup: []
	            };
	            for (var i = 0; i < filterGroup.length; i++) {
	                var filter = _this.createFilter(filterGroup[i].propertyIdentifier, filterGroup[i].comparisonValue, filterGroup[i].comparisonOperator, filterGroup[i].logicalOperator, filterGroup[i].hidden);
	                group.filterGroup.push(filter);
	            }
	            _this.filterGroups[0].filterGroup.push(group);
	            return _this;
	        };
	        this.removeFilter = function (propertyIdentifier, value, comparisonOperator) {
	            if (comparisonOperator === void 0) { comparisonOperator = '='; }
	            _this.removeFilterHelper(_this.filterGroups, propertyIdentifier, value, comparisonOperator);
	            return _this;
	        };
	        this.removeFilterByDisplayPropertyIdentifier = function (displayPropertyIdentifier) {
	            _this.removeFromFilterGroupsByPropertyIdentifier(_this.filterGroups, displayPropertyIdentifier);
	            _this.removeFromFilterGroupsByPropertyIdentifier(_this.keywordFilterGroups, displayPropertyIdentifier);
	        };
	        this.removeFromFilterGroupsByPropertyIdentifier = function (filterGroups, displayPropertyIdentifier) {
	            for (var j = 0; j < filterGroups.length; j++) {
	                var filterGroup = filterGroups[j].filterGroup;
	                for (var i = 0; i < filterGroup.length; i++) {
	                    var filter = filterGroup[i];
	                    if (filter.displayPropertyIdentifier == displayPropertyIdentifier) {
	                        filterGroup.splice(i, 1);
	                        i--;
	                    }
	                }
	            }
	        };
	        this.removeFilterHelper = function (filter, propertyIdentifier, value, comparisonOperator, currentGroup) {
	            if (angular.isUndefined(currentGroup)) {
	                currentGroup = filter;
	            }
	            if (angular.isArray(filter)) {
	                angular.forEach(filter, function (key) {
	                    _this.removeFilterHelper(key, propertyIdentifier, value, comparisonOperator, filter);
	                });
	            }
	            else if (angular.isArray(filter.filterGroup)) {
	                _this.removeFilterHelper(filter.filterGroup, propertyIdentifier, value, comparisonOperator, filter.filterGroup);
	            }
	            else {
	                if (filter.propertyIdentifier == propertyIdentifier && filter.value == value && filter.comparisonOperator == comparisonOperator) {
	                    currentGroup.splice(currentGroup.indexOf(filter), 1);
	                }
	            }
	        };
	        this.addCollectionFilter = function (propertyIdentifier, displayPropertyIdentifier, displayValue, collectionID, criteria, fieldtype, readOnly) {
	            if (criteria === void 0) { criteria = 'One'; }
	            if (readOnly === void 0) { readOnly = false; }
	            _this.filterGroups[0].filterGroup.push(new CollectionFilter(_this.formatPropertyIdentifier(propertyIdentifier), displayPropertyIdentifier, displayValue, collectionID, criteria, fieldtype, readOnly));
	            return _this;
	        };
	        //orderByList in this form: "property|direction" concrete: "skuName|ASC"
	        this.setOrderBy = function (orderByList) {
	            var orderBys = orderByList.split(',');
	            angular.forEach(orderBys, function (orderBy) {
	                _this.addOrderBy(orderBy);
	            });
	            return _this;
	        };
	        this.clearOrderBy = function () {
	            _this.orderBy = [];
	        };
	        this.addOrderBy = function (orderByString, formatPropertyIdentifier) {
	            if (formatPropertyIdentifier === void 0) { formatPropertyIdentifier = true; }
	            if (!_this.orderBy) {
	                _this.orderBy = [];
	            }
	            var propertyIdentifier = _this.utilityService.listFirst(orderByString, '|');
	            if (formatPropertyIdentifier) {
	                propertyIdentifier = _this.formatPropertyIdentifier(propertyIdentifier);
	            }
	            var direction = _this.utilityService.listLast(orderByString, '|');
	            var orderBy = {
	                propertyIdentifier: propertyIdentifier,
	                direction: direction
	            };
	            _this.orderBy.push(orderBy);
	        };
	        this.toggleOrderBy = function (formattedPropertyIdentifier, singleColumn) {
	            if (singleColumn === void 0) { singleColumn = false; }
	            if (!_this.orderBy) {
	                _this.orderBy = [];
	            }
	            var found = false;
	            for (var i = _this.orderBy.length - 1; i >= 0; i--) {
	                if (_this.orderBy[i].propertyIdentifier == formattedPropertyIdentifier) {
	                    found = true;
	                    if (_this.orderBy[i].direction.toUpperCase() == "DESC") {
	                        _this.orderBy[i].direction = "ASC";
	                    }
	                    else if (_this.orderBy[i].direction.toUpperCase() == "ASC") {
	                        _this.orderBy.splice(i, 1);
	                    }
	                    break;
	                }
	            }
	            if (!found) {
	                if (singleColumn) {
	                    _this.orderBy = [];
	                    for (var i = 0; i < _this.columns.length; i++) {
	                        if (_this.columns[i]["sorting"] && _this.columns[i]["sorting"]["active"]) {
	                            _this.columns[i]["sorting"]["active"] = false;
	                            _this.columns[i]["sorting"]["sortOrder"] = 'asc';
	                        }
	                    }
	                }
	                _this.addOrderBy(formattedPropertyIdentifier + '|DESC', false);
	            }
	        };
	        this.removeOrderBy = function (formattedPropertyIdentifier) {
	            angular.forEach(_this.orderBy, function (orderBy, index) {
	                if (orderBy.propertyIdentifier == formattedPropertyIdentifier) {
	                    _this.orderBy.splice(index, 1);
	                    return true;
	                }
	            });
	            return false;
	        };
	        this.setCurrentPage = function (pageNumber) {
	            _this.currentPage = pageNumber;
	            return _this;
	        };
	        this.getCurrentPage = function () {
	            return _this.currentPage;
	        };
	        this.setPageShow = function (NumberOfPages) {
	            _this.pageShow = NumberOfPages;
	            return _this;
	        };
	        this.getPageShow = function () {
	            return _this.pageShow;
	        };
	        this.setAllRecords = function (allFlag) {
	            if (allFlag === void 0) { allFlag = false; }
	            _this.allRecords = allFlag;
	            return _this;
	        };
	        this.setDistinct = function (flag) {
	            if (flag === void 0) { flag = true; }
	            _this.isDistinct = flag;
	            return _this;
	        };
	        this.setDirtyRead = function (flag) {
	            if (flag === void 0) { flag = false; }
	            _this.dirtyRead = flag;
	            return _this;
	        };
	        this.setKeywords = function (keyword) {
	            _this.keywords = keyword;
	            return _this;
	        };
	        this.setId = function (id) {
	            _this.id = id;
	            return _this;
	        };
	        this.hasFilters = function () {
	            return (_this.filterGroups.length && _this.filterGroups[0].filterGroup.length);
	        };
	        this.hasColumns = function () {
	            return _this.columns != null && _this.columns.length > 0;
	        };
	        this.clearFilters = function () {
	            _this.filterGroups = [{ filterGroup: [] }];
	            return _this;
	        };
	        this.getEntity = function (id) {
	            if (angular.isDefined(id)) {
	                _this.setId(id);
	            }
	            return _this.$hibachi.getEntity(_this.baseEntityName, _this.getOptions());
	        };
	        this.validateFilter = function (filter, currentGroup) {
	            if (angular.isUndefined(currentGroup)) {
	                currentGroup = filter;
	            }
	            if (angular.isArray(filter)) {
	                angular.forEach(filter, function (key) {
	                    _this.validateFilter(key, filter);
	                });
	            }
	            else if (angular.isArray(filter.filterGroup)) {
	                _this.validateFilter(filter.filterGroup, filter.filterGroup);
	            }
	            else {
	                if ((!filter.comparisonOperator || !filter.comparisonOperator.length) && (!filter.propertyIdentifier || !filter.propertyIdentifier.length)) {
	                    var index = currentGroup.indexOf(filter);
	                    if (index > -1) {
	                        _this.observerService.notify('filterItemAction', {
	                            action: 'remove',
	                            filterItemIndex: index
	                        });
	                        currentGroup.splice(index, 1);
	                    }
	                }
	            }
	        };
	        this.getColumns = function () {
	            if (!_this.columns) {
	                _this.columns = [];
	            }
	            return _this.columns;
	        };
	        this.setColumns = function (columns) {
	            _this.columns = columns;
	            return _this;
	        };
	        this.$hibachi = $hibachi;
	        this.rbkeyService = rbkeyService;
	        if (angular.isDefined(this.baseEntityName)) {
	            this.collection = this.$hibachi.getEntityExample(this.baseEntityName);
	            if (angular.isUndefined(this.baseEntityAlias)) {
	                this.baseEntityAlias = '_' + this.baseEntityName.toLowerCase();
	            }
	        }
	    }
	    return CollectionConfig;
	}());
	exports.CollectionConfig = CollectionConfig;


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var baseentityservice_1 = __webpack_require__(9);
	var CollectionService = (function (_super) {
	    __extends(CollectionService, _super);
	    //@ngInject
	    function CollectionService($injector, $hibachi, utilityService, $filter, $log) {
	        var _this = _super.call(this, $injector, $hibachi, utilityService, 'Collection') || this;
	        _this.$injector = $injector;
	        _this.$hibachi = $hibachi;
	        _this.utilityService = utilityService;
	        _this.$filter = $filter;
	        _this.$log = $log;
	        _this.get = function () {
	            return _this._pageDialogs || [];
	        };
	        //test
	        _this.setFilterCount = function (count) {
	            _this.$log.debug('incrementFilterCount');
	            _this._filterCount = count;
	        };
	        _this.getFilterCount = function () {
	            return _this._filterCount;
	        };
	        _this.getColumns = function () {
	            return _this._collection.collectionConfig.columns;
	        };
	        _this.getFilterPropertiesList = function () {
	            return _this._filterPropertiesList;
	        };
	        _this.getFilterPropertiesListByBaseEntityAlias = function (baseEntityAlias) {
	            return _this._filterPropertiesList[baseEntityAlias];
	        };
	        _this.setFilterPropertiesList = function (value, key) {
	            if (angular.isUndefined(_this._filterPropertiesList[key])) {
	                _this._filterPropertiesList[key] = value;
	            }
	        };
	        _this.stringifyJSON = function (jsonObject) {
	            var jsonString = angular.toJson(jsonObject);
	            return jsonString;
	        };
	        _this.removeFilterItem = function (filterItem, filterGroup) {
	            filterGroup.pop(filterGroup.indexOf(filterItem));
	        };
	        _this.selectFilterItem = function (filterItem) {
	            if (filterItem.$$isClosed) {
	                for (var i in filterItem.$$siblingItems) {
	                    filterItem.$$siblingItems[i].$$isClosed = true;
	                    filterItem.$$siblingItems[i].$$disabled = true;
	                }
	                filterItem.$$isClosed = false;
	                filterItem.$$disabled = false;
	                filterItem.setItemInUse(true);
	            }
	            else {
	                for (var i in filterItem.$$siblingItems) {
	                    filterItem.$$siblingItems[i].$$disabled = false;
	                }
	                filterItem.$$isClosed = true;
	                filterItem.setItemInUse(false);
	            }
	        };
	        _this.selectFilterGroupItem = function (filterGroupItem) {
	            if (filterGroupItem.$$isClosed) {
	                for (var i in filterGroupItem.$$siblingItems) {
	                    filterGroupItem.$$siblingItems[i].$$disabled = true;
	                }
	                filterGroupItem.$$isClosed = false;
	                filterGroupItem.$$disabled = false;
	            }
	            else {
	                for (var i in filterGroupItem.$$siblingItems) {
	                    filterGroupItem.$$siblingItems[i].$$disabled = false;
	                }
	                filterGroupItem.$$isClosed = true;
	            }
	            filterGroupItem.setItemInUse(!filterGroupItem.$$isClosed);
	        };
	        _this.newFilterItem = function (filterItemGroup, setItemInUse, prepareForFilterGroup) {
	            if (angular.isUndefined(prepareForFilterGroup)) {
	                prepareForFilterGroup = false;
	            }
	            var filterItem = {
	                displayPropertyIdentifier: "",
	                propertyIdentifier: "",
	                comparisonOperator: "",
	                value: "",
	                $$disabled: false,
	                $$isClosed: true,
	                $$isNew: true,
	                $$siblingItems: filterItemGroup,
	                setItemInUse: setItemInUse
	            };
	            if (filterItemGroup.length !== 0) {
	                filterItem.logicalOperator = "AND";
	            }
	            if (prepareForFilterGroup === true) {
	                filterItem.$$prepareForFilterGroup = true;
	            }
	            filterItemGroup.push(filterItem);
	            _this.selectFilterItem(filterItem);
	            return (filterItemGroup.length - 1);
	        };
	        _this.newFilterGroupItem = function (filterItemGroup, setItemInUse) {
	            var filterGroupItem = {
	                filterGroup: [],
	                $$disabled: "false",
	                $$isClosed: "true",
	                $$siblingItems: filterItemGroup,
	                $$isNew: "true",
	                setItemInUse: setItemInUse
	            };
	            if (filterItemGroup.length !== 0) {
	                filterGroupItem.logicalOperator = "AND";
	            }
	            filterItemGroup.push(filterGroupItem);
	            _this.selectFilterGroupItem(filterGroupItem);
	            _this.newFilterItem(filterGroupItem.filterGroup, setItemInUse, undefined);
	        };
	        _this.transplantFilterItemIntoFilterGroup = function (filterGroup, filterItem) {
	            var filterGroupItem = {
	                filterGroup: [],
	                $$disabled: "false",
	                $$isClosed: "true",
	                $$isNew: "true"
	            };
	            if (angular.isDefined(filterItem.logicalOperator)) {
	                filterGroupItem.logicalOperator = filterItem.logicalOperator;
	                delete filterItem.logicalOperator;
	            }
	            filterGroupItem.setItemInUse = filterItem.setItemInUse;
	            filterGroupItem.$$siblingItems = filterItem.$$siblingItems;
	            filterItem.$$siblingItems = [];
	            filterGroup.pop(filterGroup.indexOf(filterItem));
	            filterItem.$$prepareForFilterGroup = false;
	            filterGroupItem.filterGroup.push(filterItem);
	            filterGroup.push(filterGroupItem);
	        };
	        _this.formatFilterPropertiesList = function (filterPropertiesList, propertyIdentifier) {
	            _this.$log.debug('format Filter Properties List arguments 2');
	            _this.$log.debug(filterPropertiesList);
	            _this.$log.debug(propertyIdentifier);
	            var simpleGroup = {
	                $$group: 'simple',
	                displayPropertyIdentifier: '-----------------'
	            };
	            filterPropertiesList.data.push(simpleGroup);
	            var drillDownGroup = {
	                $$group: 'drilldown',
	                displayPropertyIdentifier: '-----------------'
	            };
	            filterPropertiesList.data.push(drillDownGroup);
	            var compareCollections = {
	                $$group: 'compareCollections',
	                displayPropertyIdentifier: '-----------------'
	            };
	            filterPropertiesList.data.push(compareCollections);
	            var attributeCollections = {
	                $$group: 'attribute',
	                displayPropertyIdentifier: '-----------------'
	            };
	            filterPropertiesList.data.push(attributeCollections);
	            for (var i in filterPropertiesList.data) {
	                if (angular.isDefined(filterPropertiesList.data[i].ormtype)) {
	                    if (angular.isDefined(filterPropertiesList.data[i].attributeID)) {
	                        filterPropertiesList.data[i].$$group = 'attribute';
	                    }
	                    else {
	                        filterPropertiesList.data[i].$$group = 'simple';
	                    }
	                }
	                if (angular.isDefined(filterPropertiesList.data[i].fieldtype)) {
	                    if (filterPropertiesList.data[i].fieldtype === 'id') {
	                        filterPropertiesList.data[i].$$group = 'simple';
	                    }
	                    if (filterPropertiesList.data[i].fieldtype === 'many-to-one') {
	                        filterPropertiesList.data[i].$$group = 'drilldown';
	                    }
	                    if (filterPropertiesList.data[i].fieldtype === 'many-to-many' || filterPropertiesList.data[i].fieldtype === 'one-to-many') {
	                        filterPropertiesList.data[i].$$group = 'compareCollections';
	                    }
	                }
	                filterPropertiesList.data[i].propertyIdentifier = propertyIdentifier + '.' + filterPropertiesList.data[i].name;
	            }
	            filterPropertiesList.data = _this._orderBy(filterPropertiesList.data, ['-$$group', 'propertyIdentifier'], false);
	        };
	        _this.orderBy = function (propertiesList, predicate, reverse) {
	            return _this._orderBy(propertiesList, predicate, reverse);
	        };
	        _this.$filter = $filter;
	        _this.$log = $log;
	        _this._collection = null;
	        _this._collectionConfig = null;
	        _this._filterPropertiesList = {};
	        _this._filterCount = 0;
	        _this._orderBy = $filter('orderBy');
	        return _this;
	    }
	    return CollectionService;
	}(baseentityservice_1.BaseEntityService));
	exports.CollectionService = CollectionService;


/***/ },
/* 112 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var CollectionController = (function () {
	    //@ngInject
	    function CollectionController($scope, $location, $log, $timeout, $hibachi, collectionService, metadataService, selectionService, paginationService, collectionConfigService, appConfig) {
	        //init values
	        //$scope.collectionTabs =[{tabTitle:'PROPERTIES',isActive:true},{tabTitle:'FILTERS ('+filterCount+')',isActive:false},{tabTitle:'DISPLAY OPTIONS',isActive:false}];
	        $scope.$id = "collectionsController";
	        /*used til we convert to use route params*/
	        var QueryString = function () {
	            // This function is anonymous, is executed immediately and
	            // the return value is assigned to QueryString!
	            var query_string = {};
	            var query = window.location.search.substring(1);
	            var vars = query.split("&");
	            for (var i = 0; i < vars.length; i++) {
	                var pair = vars[i].split("=");
	                // If first entry with this name
	                if (typeof query_string[pair[0]] === "undefined") {
	                    query_string[pair[0]] = pair[1];
	                }
	                else if (typeof query_string[pair[0]] === "string") {
	                    var arr = [query_string[pair[0]], pair[1]];
	                    query_string[pair[0]] = arr;
	                }
	                else {
	                    query_string[pair[0]].push(pair[1]);
	                }
	            }
	            return query_string;
	        }();
	        //get url param to retrieve collection listing
	        $scope.collectionID = QueryString.collectionID;
	        $scope.paginator = paginationService.createPagination();
	        $scope.appendToCollection = function () {
	            if ($scope.paginator.getPageShow() === 'Auto') {
	                $log.debug('AppendToCollection');
	                if ($scope.autoScrollPage < $scope.collection.totalPages) {
	                    $scope.autoScrollDisabled = true;
	                    $scope.autoScrollPage++;
	                    var collectionListingPromise = $hibachi.getEntity('collection', { id: $scope.collectionID, currentPage: $scope.paginator.autoScrollPage, pageShow: 50 });
	                    collectionListingPromise.then(function (value) {
	                        $scope.collection.pageRecords = $scope.collection.pageRecords.concat(value.pageRecords);
	                        $scope.autoScrollDisabled = false;
	                    }, function (reason) {
	                    });
	                }
	            }
	        };
	        $scope.keywords = "";
	        $scope.loadingCollection = false;
	        var searchPromise;
	        $scope.searchCollection = function () {
	            if (searchPromise) {
	                $timeout.cancel(searchPromise);
	            }
	            searchPromise = $timeout(function () {
	                $log.debug('search with keywords');
	                $log.debug($scope.keywords);
	                //Set current page here so that the pagination does not break when getting collection
	                $scope.paginator.setCurrentPage(1);
	                $scope.loadingCollection = true;
	            }, 500);
	        };
	        $scope.getCollection = function () {
	            var pageShow = 50;
	            if ($scope.paginator.getPageShow() !== 'Auto') {
	                pageShow = $scope.paginator.getPageShow();
	            }
	            //			$scope.currentPage = $scope.pagination.getCurrentPage();
	            var collectionListingPromise = $hibachi.getEntity('collection', { id: $scope.collectionID, currentPage: $scope.paginator.getCurrentPage(), pageShow: pageShow, keywords: $scope.keywords });
	            collectionListingPromise.then(function (value) {
	                $scope.collection = value;
	                $scope.paginator.setPageRecordsInfo($scope.collection);
	                $scope.collectionInitial = angular.copy($scope.collection);
	                if (angular.isUndefined($scope.collectionConfig)) {
	                    var test = collectionConfigService.newCollectionConfig();
	                    test.loadJson(value.collectionConfig);
	                    $scope.collectionConfig = test.getCollectionConfig();
	                }
	                //check if we have any filter Groups
	                if (angular.isUndefined($scope.collectionConfig.filterGroups)) {
	                    $scope.collectionConfig.filterGroups = [
	                        {
	                            filterGroup: []
	                        }
	                    ];
	                }
	                collectionService.setFilterCount(filterItemCounter());
	                $scope.loadingCollection = false;
	            }, function (reason) {
	            });
	            return collectionListingPromise;
	        };
	        $scope.paginator.getCollection = $scope.getCollection;
	        $scope.getCollection();
	        var unbindCollectionObserver = $scope.$watch('collection', function (newValue, oldValue) {
	            if (newValue !== oldValue) {
	                if (angular.isUndefined($scope.filterPropertiesList)) {
	                    $scope.filterPropertiesList = {};
	                    var filterPropertiesPromise = $hibachi.getFilterPropertiesByBaseEntityName($scope.collectionConfig.baseEntityAlias);
	                    filterPropertiesPromise.then(function (value) {
	                        metadataService.setPropertiesList(value, $scope.collectionConfig.baseEntityAlias);
	                        $scope.filterPropertiesList[$scope.collectionConfig.baseEntityAlias] = metadataService.getPropertiesListByBaseEntityAlias($scope.collectionConfig.baseEntityAlias);
	                        metadataService.formatPropertiesList($scope.filterPropertiesList[$scope.collectionConfig.baseEntityAlias], $scope.collectionConfig.baseEntityAlias);
	                    });
	                }
	                unbindCollectionObserver();
	            }
	        });
	        $scope.setCollectionForm = function (form) {
	            $scope.collectionForm = form;
	        };
	        $scope.collectionDetails = {
	            isOpen: false,
	            openCollectionDetails: function () {
	                $scope.collectionDetails.isOpen = true;
	            }
	        };
	        $scope.errorMessage = {};
	        var filterItemCounter = function (filterGroupArray) {
	            var filterItemCount = 0;
	            if (!angular.isDefined(filterGroupArray)) {
	                filterGroupArray = $scope.collectionConfig.filterGroups[0].filterGroup;
	            }
	            //Start out loop
	            for (var index in filterGroupArray) {
	                //If filter isn't new then increment the count
	                if (!filterGroupArray[index].$$isNew
	                    && !angular.isDefined(filterGroupArray[index].filterGroup)) {
	                    filterItemCount++;
	                }
	                else if (angular.isDefined(filterGroupArray[index].filterGroup)) {
	                    //Call function recursively
	                    filterItemCount += filterItemCounter(filterGroupArray[index].filterGroup);
	                }
	                else {
	                    break;
	                }
	            }
	            return filterItemCount;
	        };
	        $scope.saveCollection = function () {
	            $timeout(function () {
	                $log.debug('saving Collection');
	                var entityName = 'collection';
	                var collection = $scope.collection;
	                $log.debug($scope.collectionConfig);
	                if (isFormValid($scope.collectionForm)) {
	                    if (angular.isDefined($scope.collectionConfig)
	                        && angular.isDefined($scope.collectionConfig.groupBys)
	                        && $scope.collectionConfig.groupBys.split(',').length != $scope.collectionConfig.columns.length) {
	                        var groupbyArray = $scope.collectionConfig.groupBys.split(',');
	                        for (var column = 0; column < $scope.collectionConfig.columns.length; column++) {
	                            if (groupbyArray.indexOf($scope.collectionConfig.columns[column].propertyIdentifier) == -1) {
	                                groupbyArray.push($scope.collectionConfig.columns[column].propertyIdentifier);
	                            }
	                        }
	                        $scope.collectionConfig.groupBys = groupbyArray.join(',');
	                    }
	                    var collectionConfigString = collectionService.stringifyJSON($scope.collectionConfig);
	                    $log.debug(collectionConfigString);
	                    var data = angular.copy(collection);
	                    data.collectionConfig = collectionConfigString;
	                    //has to be removed in order to save transient correctly
	                    delete data.pageRecords;
	                    var saveCollectionPromise = $hibachi.saveEntity(entityName, collection.collectionID, data, 'save');
	                    saveCollectionPromise.then(function (value) {
	                        $scope.errorMessage = {};
	                        //Set current page here so that the pagination does not break when getting collection
	                        $scope.paginator.setCurrentPage(1);
	                        $scope.collectionDetails.isOpen = false;
	                    }, function (reason) {
	                        //revert to original
	                        angular.forEach(reason.errors, function (value, key) {
	                            $scope.collectionForm[key].$invalid = true;
	                            $scope.errorMessage[key] = value[0];
	                        });
	                        //$scope.collection = angular.copy($scope.collectionInitial);
	                    });
	                }
	                collectionService.setFilterCount(filterItemCounter());
	            });
	        };
	        var isFormValid = function (angularForm) {
	            $log.debug('validateForm');
	            var formValid = true;
	            for (var field in angularForm) {
	                // look at each form input with a name attribute set
	                // checking if it is pristine and not a '$' special field
	                if (field[0] != '$') {
	                    // need to use formValid variable instead of formController.$valid because checkbox dropdown is not an input
	                    // and somehow formController didn't invalid if checkbox dropdown is invalid
	                    if (angularForm[field].$invalid) {
	                        formValid = false;
	                        for (var error in angularForm[field].$error) {
	                            if (error == 'required') {
	                                $scope.errorMessage[field] = 'This field is required';
	                            }
	                        }
	                    }
	                    if (angularForm[field].$pristine) {
	                        if (angular.isUndefined(angularForm[field].$viewValue)) {
	                            angularForm[field].$setViewValue("");
	                        }
	                        else {
	                            angularForm[field].$setViewValue(angularForm[field].$viewValue);
	                        }
	                    }
	                }
	            }
	            return formValid;
	        };
	        $scope.copyExistingCollection = function () {
	            $scope.collection.collectionConfig = $scope.selectedExistingCollection;
	        };
	        $scope.setSelectedExistingCollection = function (selectedExistingCollection) {
	            $scope.selectedExistingCollection = selectedExistingCollection;
	        };
	        $scope.setSelectedFilterProperty = function (selectedFilterProperty) {
	            $scope.selectedFilterProperty = selectedFilterProperty;
	        };
	        $scope.filterCount = collectionService.getFilterCount;
	        //export action
	        $scope.exportCollection = function () {
	            var url = '/?' + appConfig.action + '=main.collectionExport&collectionExportID=' + $scope.collectionID + '&downloadReport=1';
	            var data = {
	                "ids": selectionService.getSelections('collectionSelection'),
	                "keywords": $scope.keywords
	            };
	            console.log('exportData', data);
	            var target = "downloadCollection";
	            $('body').append('<form action="' + url + '" method="post" target="' + target + '" id="postToIframe"></form>');
	            $.each(data, function (n, v) {
	                $('#postToIframe').append('<input type="hidden" name="' + n + '" value="' + v + '" />');
	            });
	            $('#postToIframe').submit().remove();
	        };
	    }
	    return CollectionController;
	}());
	exports.CollectionController = CollectionController;
	// 'use strict';
	// angular.module('slatwalladmin')
	// //using $location to get url params, this will probably change to using routes eventually
	// .controller('collections', [
	// 	'$scope',
	// '$location',
	// '$log',
	// '$timeout',
	// '$hibachi',
	// 'collectionService',
	// 'metadataService',
	// 'selectionService',
	// 'paginationService',
	// 	function(
	// 		$scope,
	// $location,
	// $log,
	// $timeout,
	// $hibachi,
	// collectionService,
	// metadataService,
	// selectionService,
	// paginationService
	// 	){
	//
	// 	}
	// ]);


/***/ },
/* 113 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var CreateCollection = (function () {
	    //@ngInject
	    function CreateCollection($scope, $log, $timeout, $hibachi, collectionService, metadataService, paginationService, dialogService, observerService, selectionService, collectionConfigService, rbkeyService, $window) {
	        $window.scrollTo(0, 0);
	        $scope.params = dialogService.getCurrentDialog().params;
	        $scope.readOnly = angular.isDefined($scope.params.readOnly) && $scope.params.readOnly == true;
	        $scope.myCollection = collectionConfigService.newCollectionConfig($scope.params.entityName);
	        var hibachiConfig = $hibachi.getConfig();
	        if ($scope.params.entityName == 'Type' && angular.isUndefined($scope.params.entityId) && angular.isDefined($scope.params.parentEntity)) {
	            $scope.params.parentEntity = $scope.params.parentEntity.replace(new RegExp('^' + hibachiConfig.applicationKey, 'i'), '');
	            var systemCode = $scope.params.parentEntity.charAt(0).toLowerCase() + $scope.params.parentEntity.slice(1) + 'Type';
	            $scope.myCollection.addFilter('parentType.systemCode', systemCode);
	        }
	        $scope.keywords = '';
	        $scope.paginator = paginationService.createPagination();
	        //$scope.isRadio = true;
	        $scope.hideEditView = true;
	        //$scope.closeSaving = true;
	        $scope.hasSelection = selectionService.getSelectionCount;
	        $scope.idsSelected = selectionService.getSelections;
	        $scope.unselectAll = function () {
	            selectionService.clearSelections('collectionSelection');
	            $scope.getCollection();
	        };
	        $scope.newCollection = $hibachi.newCollection();
	        $scope.newCollection.data.collectionCode = $scope.params.entityName + "-" + new Date().valueOf();
	        $scope.newCollection.data.collectionObject = $scope.params.entityName;
	        if (angular.isDefined($scope.params.entityId)) {
	            $scope.newCollection.data.collectionID = $scope.params.entityId;
	            $timeout(function () {
	                $scope.newCollection.forms['form.createCollection'].$setDirty();
	            });
	        }
	        if (angular.isDefined($scope.params.collectionName)) {
	            $scope.newCollection.data.collectionName = $scope.params.collectionName;
	            $timeout(function () {
	                $scope.newCollection.forms['form.createCollection'].$setDirty();
	            });
	        }
	        $scope.saveCollection = function () {
	            $scope.myCollection.loadJson($scope.collectionConfig);
	            $scope.getCollection();
	        };
	        $scope.getCollection = function () {
	            $scope.closeSaving = true;
	            $scope.myCollection.setPageShow($scope.paginator.getPageShow());
	            $scope.myCollection.setCurrentPage($scope.paginator.getCurrentPage());
	            $scope.myCollection.setKeywords($scope.keywords);
	            var collectionOptions;
	            if (angular.isDefined($scope.params.entityId)) {
	                collectionOptions = {
	                    id: $scope.params.entityId,
	                    currentPage: $scope.paginator.getCurrentPage(),
	                    pageShow: $scope.paginator.getPageShow(),
	                    keywords: $scope.keywords
	                };
	            }
	            else {
	                collectionOptions = $scope.myCollection.getOptions();
	            }
	            $log.debug($scope.myCollection.getOptions());
	            var collectionListingPromise = $hibachi.getEntity($scope.myCollection.getEntityName(), collectionOptions);
	            collectionListingPromise.then(function (value) {
	                if (angular.isDefined($scope.params.entityId)) {
	                    $scope.newCollection.data.collectionName = value.collectionName;
	                }
	                $scope.collection = value;
	                $scope.collection.collectionObject = $scope.myCollection.baseEntityName;
	                $scope.collectionInitial = angular.copy($scope.collection);
	                $scope.paginator.setRecordsCount($scope.collection.recordsCount);
	                $scope.paginator.setPageRecordsInfo($scope.collection);
	                if (angular.isUndefined($scope.myCollection.columns)) {
	                    var colConfig = angular.fromJson(value.collectionConfig);
	                    colConfig.baseEntityName = colConfig.baseEntityName.replace(new RegExp('^' + hibachiConfig.applicationKey, 'i'), '');
	                    $scope.myCollection.loadJson(colConfig);
	                }
	                if (angular.isUndefined($scope.collectionConfig)) {
	                    var tempCollectionConfig = collectionConfigService.newCollectionConfig();
	                    tempCollectionConfig.loadJson(value.collectionConfig);
	                    $scope.collectionConfig = tempCollectionConfig.getCollectionConfig();
	                }
	                if (angular.isUndefined($scope.collectionConfig.filterGroups) || !$scope.collectionConfig.filterGroups.length) {
	                    $scope.collectionConfig.filterGroups = [
	                        {
	                            filterGroup: []
	                        }
	                    ];
	                }
	                collectionService.setFilterCount(filterItemCounter());
	                $scope.loadingCollection = false;
	                $scope.closeSaving = false;
	            }, function (reason) {
	            });
	            return collectionListingPromise;
	        };
	        $scope.paginator.collection = $scope.newCollection;
	        $scope.paginator.getCollection = $scope.getCollection;
	        var unbindCollectionObserver = $scope.$watch('collection', function (newValue, oldValue) {
	            if (newValue !== oldValue) {
	                if (angular.isUndefined($scope.filterPropertiesList)) {
	                    $scope.filterPropertiesList = {};
	                    var filterPropertiesPromise = $hibachi.getFilterPropertiesByBaseEntityName($scope.collectionConfig.baseEntityAlias);
	                    filterPropertiesPromise.then(function (value) {
	                        metadataService.setPropertiesList(value, $scope.collectionConfig.baseEntityAlias);
	                        $scope.filterPropertiesList[$scope.collectionConfig.baseEntityAlias] = metadataService.getPropertiesListByBaseEntityAlias($scope.collectionConfig.baseEntityAlias);
	                        metadataService.formatPropertiesList($scope.filterPropertiesList[$scope.collectionConfig.baseEntityAlias], $scope.collectionConfig.baseEntityAlias);
	                    });
	                }
	                unbindCollectionObserver();
	            }
	        });
	        var filterItemCounter = function (filterGroupArray) {
	            var filterItemCount = 0;
	            if (!angular.isDefined(filterGroupArray)) {
	                filterGroupArray = $scope.collectionConfig.filterGroups[0].filterGroup;
	            }
	            //Start out loop
	            for (var index in filterGroupArray) {
	                //If filter isn't new then increment the count
	                if (!filterGroupArray[index].$$isNew && !angular.isDefined(filterGroupArray[index].filterGroup)) {
	                    filterItemCount++;
	                }
	                else if (angular.isDefined(filterGroupArray[index].filterGroup)) {
	                    //Call function recursively
	                    filterItemCount += filterItemCounter(filterGroupArray[index].filterGroup);
	                }
	                else {
	                    break;
	                }
	            }
	            return filterItemCount;
	        };
	        $scope.getCollection();
	        $scope.copyExistingCollection = function () {
	            $scope.collection.collectionConfig = $scope.selectedExistingCollection;
	        };
	        $scope.setSelectedExistingCollection = function (selectedExistingCollection) {
	            $scope.selectedExistingCollection = selectedExistingCollection;
	        };
	        $scope.setSelectedFilterProperty = function (selectedFilterProperty) {
	            $scope.selectedFilterProperty = selectedFilterProperty;
	        };
	        $scope.loadingCollection = false;
	        var searchPromise;
	        $scope.searchCollection = function () {
	            if (searchPromise) {
	                $timeout.cancel(searchPromise);
	            }
	            searchPromise = $timeout(function () {
	                //$log.debug('search with keywords');
	                //$log.debug($scope.keywords);
	                //Set current page here so that the pagination does not break when getting collection
	                $scope.paginator.setCurrentPage(1);
	                $scope.loadingCollection = true;
	                $scope.getCollection();
	            }, 500);
	        };
	        $scope.filterCount = collectionService.getFilterCount;
	        //
	        $scope.hideExport = true;
	        $scope.saveNewCollection = function ($index) {
	            if ($scope.closeSaving)
	                return;
	            $scope.closeSaving = true;
	            if (!angular.isUndefined(selectionService.getSelections('collectionSelection'))
	                && (selectionService.getSelections('collectionSelection').length > 0)) {
	                $scope.collectionConfig.filterGroups[0].filterGroup = [
	                    {
	                        "displayPropertyIdentifier": rbkeyService.getRBKey("entity." + $scope.myCollection.baseEntityName.toLowerCase() + "." + $scope.myCollection.collection.$$getIDName().toLowerCase()),
	                        "propertyIdentifier": $scope.myCollection.baseEntityAlias + "." + $scope.myCollection.collection.$$getIDName(),
	                        "comparisonOperator": "in",
	                        "value": selectionService.getSelections('collectionSelection').join(),
	                        "displayValue": selectionService.getSelections('collectionSelection').join(),
	                        "ormtype": "string",
	                        "fieldtype": "id",
	                        "conditionDisplay": "In List"
	                    }
	                ];
	            }
	            $scope.newCollection.data.collectionConfig = $scope.collectionConfig;
	            if ($scope.newCollection.data.collectionConfig.baseEntityName.lastIndexOf(hibachiConfig.applicationKey, 0) !== 0) {
	                $scope.newCollection.data.collectionConfig.baseEntityName = hibachiConfig.applicationKey + $scope.newCollection.data.collectionConfig.baseEntityName;
	            }
	            $scope.newCollection.$$save().then(function () {
	                observerService.notify('addCollection', $scope.newCollection.data);
	                selectionService.clearSelection('collectionSelection');
	                dialogService.removePageDialog($index);
	                $scope.closeSaving = false;
	            }, function () {
	                $scope.closeSaving = false;
	            });
	        };
	    }
	    return CreateCollection;
	}());
	exports.CreateCollection = CreateCollection;


/***/ },
/* 114 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var ConfirmationController = (function () {
	    //@ngInject
	    function ConfirmationController($scope, $log, $modalInstance) {
	        $scope.deleteEntity = function (entity) {
	            $log.debug("Deleting an entity.");
	            $log.debug($scope.entity);
	            this.close();
	        };
	        $scope.fireCallback = function (callbackFunction) {
	            callbackFunction();
	            this.close();
	        };
	        /**
	        * Closes the modal window
	        */
	        $scope.close = function () {
	            $modalInstance.close();
	        };
	        /**
	        * Cancels the modal window
	        */
	        $scope.cancel = function () {
	            $modalInstance.dismiss("cancel");
	        };
	    }
	    return ConfirmationController;
	}());
	exports.ConfirmationController = ConfirmationController;


/***/ },
/* 115 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var CollectionCreateController = (function () {
	    //@ngInject
	    function CollectionCreateController($scope, collectionConfigService) {
	        var _this = this;
	        this.$scope = $scope;
	        this.collectionConfigService = collectionConfigService;
	        this.$scope.entity_createcollectionCtrl = {};
	        this.$scope.entity_createcollectionCtrl.baseCollections = [];
	        this.collection = this.collectionConfigService.newCollectionConfig('Collection');
	        this.getBaseCollections('Access');
	        //on select change get collection
	        this.$scope.entity_createcollectionCtrl.collectionObjectChanged = function () {
	            _this.getBaseCollections(_this.$scope.entity_createcollectionCtrl.selectedOption);
	        };
	    }
	    CollectionCreateController.prototype.getBaseCollections = function (baseCollectionObject) {
	        var _this = this;
	        this.collection.clearFilters();
	        this.collection.addFilter('collectionObject', baseCollectionObject);
	        this.collection.getEntity().then(function (res) {
	            _this.$scope.entity_createcollectionCtrl.baseCollections = res.pageRecords;
	        });
	    };
	    return CollectionCreateController;
	}());
	exports.CollectionCreateController = CollectionCreateController;


/***/ },
/* 116 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWCollection = (function () {
	    //@ngInject
	    function SWCollection($http, $compile, $log, hibachiPathBuilder, collectionPartialsPath, collectionService) {
	        return {
	            restrict: 'A',
	            templateUrl: hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + "collection.html",
	            link: function (scope, $element, $attrs) {
	                scope.tabsUniqueID = Math.floor(Math.random() * 999);
	                scope.toggleCogOpen = $attrs.toggleoption;
	                //Toggles open/close of filters and display options
	                scope.toggleFiltersAndOptions = function () {
	                    if (scope.toggleCogOpen === false) {
	                        scope.toggleCogOpen = true;
	                    }
	                    else {
	                        scope.toggleCogOpen = false;
	                    }
	                };
	            }
	        };
	    }
	    SWCollection.Factory = function () {
	        var directive = function ($http, $compile, $log, hibachiPathBuilder, collectionPartialsPath, collectionService) { return new SWCollection($http, $compile, $log, hibachiPathBuilder, collectionPartialsPath, collectionService); };
	        directive.$inject = [
	            '$http',
	            '$compile',
	            '$log',
	            'hibachiPathBuilder',
	            'collectionPartialsPath',
	            'collectionService'
	        ];
	        return directive;
	    };
	    return SWCollection;
	}());
	exports.SWCollection = SWCollection;


/***/ },
/* 117 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWAddFilterButtons = (function () {
	    //@ngInject
	    function SWAddFilterButtons($http, $compile, $templateCache, collectionService, collectionPartialsPath, hibachiPathBuilder) {
	        return {
	            require: '^swFilterGroups',
	            restrict: 'E',
	            templateUrl: hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + "addfilterbuttons.html",
	            scope: {
	                itemInUse: "=",
	                readOnly: "="
	            },
	            link: function (scope, element, attrs, filterGroupsController) {
	                scope.filterGroupItem = filterGroupsController.getFilterGroupItem();
	                scope.addFilterItem = function () {
	                    collectionService.newFilterItem(filterGroupsController.getFilterGroupItem(), filterGroupsController.setItemInUse);
	                };
	                scope.addFilterGroupItem = function () {
	                    collectionService.newFilterItem(filterGroupsController.getFilterGroupItem(), filterGroupsController.setItemInUse, true);
	                };
	            }
	        };
	    }
	    SWAddFilterButtons.Factory = function () {
	        var directive = function ($http, $compile, $templateCache, collectionService, collectionPartialsPath, hibachiPathBuilder) { return new SWAddFilterButtons($http, $compile, $templateCache, collectionService, collectionPartialsPath, hibachiPathBuilder); };
	        directive.$inject = [
	            '$http',
	            '$compile',
	            '$templateCache',
	            'collectionService',
	            'collectionPartialsPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWAddFilterButtons;
	}());
	exports.SWAddFilterButtons = SWAddFilterButtons;


/***/ },
/* 118 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWDisplayOptions = (function () {
	    //@ngInject
	    function SWDisplayOptions($log, $hibachi, hibachiPathBuilder, collectionPartialsPath, rbkeyService) {
	        return {
	            restrict: 'E',
	            transclude: true,
	            scope: {
	                orderBy: "=",
	                columns: '=',
	                joins: "=",
	                groupBys: "=",
	                propertiesList: "=",
	                saveCollection: "&",
	                baseEntityAlias: "=?",
	                baseEntityName: "=?"
	            },
	            templateUrl: hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + "displayoptions.html",
	            controller: ['$scope', '$element', '$attrs', function ($scope, $element, $attrs) {
	                    $log.debug('display options initialize');
	                    $scope.breadCrumbs = [{
	                            entityAlias: $scope.baseEntityAlias,
	                            cfc: $scope.baseEntityAlias,
	                            propertyIdentifier: $scope.baseEntityAlias
	                        }];
	                    this.removeColumn = function (columnIndex) {
	                        $log.debug('parent remove column');
	                        $log.debug($scope.columns);
	                        if ($scope.columns.length) {
	                            $scope.columns.splice(columnIndex, 1);
	                        }
	                    };
	                    this.getPropertiesList = function () {
	                        return $scope.propertiesList;
	                    };
	                    $scope.addDisplayDialog = {
	                        isOpen: false,
	                        toggleDisplayDialog: function () {
	                            $scope.addDisplayDialog.isOpen = !$scope.addDisplayDialog.isOpen;
	                        }
	                    };
	                    var getTitleFromProperty = function (selectedProperty) {
	                        var baseEntityCfcName = $scope.baseEntityName.replace('Slatwall', '').charAt(0).toLowerCase() + $scope.baseEntityName.replace('Slatwall', '').slice(1);
	                        var propertyIdentifier = selectedProperty.propertyIdentifier;
	                        var title = '';
	                        var propertyIdentifierArray = propertyIdentifier.replace(/^_/, '').split(/[._]+/);
	                        var currentEntity;
	                        var currentEntityInstance;
	                        var prefix = 'entity.';
	                        if (selectedProperty.$$group == "attribute") {
	                            return selectedProperty.displayPropertyIdentifier;
	                        }
	                        angular.forEach(propertyIdentifierArray, function (propertyIdentifierItem, key) {
	                            //pass over the initial item
	                            if (key !== 0) {
	                                if (key === 1) {
	                                    currentEntityInstance = $hibachi['new' + $scope.baseEntityName.replace('Slatwall', '')]();
	                                    currentEntity = currentEntityInstance.metaData[propertyIdentifierArray[key]];
	                                    title += rbkeyService.getRBKey(prefix + baseEntityCfcName + '.' + propertyIdentifierItem);
	                                }
	                                else {
	                                    var currentEntityInstance = $hibachi['new' + currentEntity.cfc.charAt(0).toUpperCase() + currentEntity.cfc.slice(1)]();
	                                    currentEntity = currentEntityInstance.metaData[propertyIdentifierArray[key]];
	                                    title += rbkeyService.getRBKey(prefix + currentEntityInstance.metaData.className + '.' + currentEntity.name);
	                                }
	                                if (key < propertyIdentifierArray.length - 1) {
	                                    title += ' | ';
	                                }
	                            }
	                        });
	                        return title;
	                    };
	                    $scope.addColumn = function (closeDialog) {
	                        var selectedProperty = $scope.selectedProperty;
	                        if (angular.isDefined($scope.selectedAggregate)) {
	                            selectedProperty = $scope.selectedAggregate;
	                        }
	                        if (selectedProperty.$$group === 'simple' || 'attribute' || 'compareCollections') {
	                            $log.debug($scope.columns);
	                            if (angular.isDefined(selectedProperty)) {
	                                var column = {
	                                    title: getTitleFromProperty(selectedProperty),
	                                    propertyIdentifier: selectedProperty.propertyIdentifier,
	                                    isVisible: true,
	                                    isDeletable: true,
	                                    isSearchable: true,
	                                    isExportable: true
	                                };
	                                //only add attributeid if the selectedProperty is attributeid
	                                if (angular.isDefined(selectedProperty.attributeID)) {
	                                    column['attributeID'] = selectedProperty.attributeID;
	                                    column['attributeSetObject'] = selectedProperty.attributeSetObject;
	                                }
	                                if (angular.isDefined(selectedProperty.ormtype)) {
	                                    column['ormtype'] = selectedProperty.ormtype;
	                                }
	                                if (selectedProperty.hb_formattype) {
	                                    column['type'] = selectedProperty.hb_formattype;
	                                }
	                                else {
	                                    column['type'] = 'none';
	                                }
	                                if (angular.isDefined(selectedProperty.aggregate)) {
	                                    column['ormtype'] = 'string';
	                                    column['aggregate'] = {
	                                        aggregateFunction: selectedProperty.aggregate.toUpperCase(),
	                                        aggregateAlias: selectedProperty.propertyIdentifier.split(/[._]+/).pop() + selectedProperty.aggregate.charAt(0).toUpperCase() + selectedProperty.aggregate.slice(1)
	                                    };
	                                    column['title'] += ' ' + rbkeyService.getRBKey('define.' + column['aggregate']['aggregateFunction']);
	                                }
	                                $scope.columns.push(column);
	                                if ((selectedProperty.propertyIdentifier.match(/_/g) || []).length > 1) {
	                                    var PIlimit = selectedProperty.propertyIdentifier.length;
	                                    if (selectedProperty.propertyIdentifier.indexOf('.') != -1) {
	                                        PIlimit = selectedProperty.propertyIdentifier.indexOf('.');
	                                    }
	                                    var propertyIdentifierJoins = selectedProperty.propertyIdentifier.substring(1, PIlimit);
	                                    var propertyIdentifierParts = propertyIdentifierJoins.split('_');
	                                    var current_collection = $hibachi.getEntityExample($scope.baseEntityName);
	                                    var _propertyIdentifier = '';
	                                    var joins = [];
	                                    if (angular.isDefined($scope.joins)) {
	                                        joins = $scope.joins;
	                                    }
	                                    for (var i = 1; i < propertyIdentifierParts.length; i++) {
	                                        if (angular.isDefined(current_collection.metaData[propertyIdentifierParts[i]]) && ('cfc' in current_collection.metaData[propertyIdentifierParts[i]])) {
	                                            current_collection = $hibachi.getEntityExample(current_collection.metaData[propertyIdentifierParts[i]].cfc);
	                                            _propertyIdentifier += '_' + propertyIdentifierParts[i];
	                                            var newJoin = {
	                                                associationName: _propertyIdentifier.replace(/_([^_]+)$/, '.$1').substring(1),
	                                                alias: '_' + propertyIdentifierParts[0] + _propertyIdentifier
	                                            };
	                                            var joinFound = false;
	                                            for (var j = 0; j < joins.length; j++) {
	                                                if (joins[j].alias === newJoin.alias) {
	                                                    joinFound = true;
	                                                    break;
	                                                }
	                                            }
	                                            if (!joinFound) {
	                                                joins.push(newJoin);
	                                            }
	                                        }
	                                    }
	                                    $scope.joins = joins;
	                                    if (angular.isUndefined($scope.groupBys) || $scope.groupBys.split(',').length != $scope.columns.length) {
	                                        var groupbyArray = angular.isUndefined($scope.groupBys) ? [] : $scope.groupBys.split(',');
	                                        for (var col = 0; col < $scope.columns.length; col++) {
	                                            if ('attributeID' in $scope.columns[col])
	                                                continue;
	                                            if (groupbyArray.indexOf($scope.columns[col].propertyIdentifier) == -1) {
	                                                groupbyArray.push($scope.columns[col].propertyIdentifier);
	                                            }
	                                        }
	                                        $scope.groupBys = groupbyArray.join(',');
	                                    }
	                                }
	                                $scope.saveCollection();
	                                if (angular.isDefined(closeDialog) && closeDialog === true) {
	                                    $scope.addDisplayDialog.toggleDisplayDialog();
	                                    $scope.selectBreadCrumb(0);
	                                }
	                            }
	                        }
	                    };
	                    $scope.selectBreadCrumb = function (breadCrumbIndex) {
	                        //splice out array items above index
	                        var removeCount = $scope.breadCrumbs.length - 1 - breadCrumbIndex;
	                        $scope.breadCrumbs.splice(breadCrumbIndex + 1, removeCount);
	                        $scope.selectedPropertyChanged(null);
	                    };
	                    var unbindBaseEntityAlias = $scope.$watch('baseEntityAlias', function (newValue, oldValue) {
	                        if (newValue !== oldValue) {
	                            $scope.breadCrumbs = [{
	                                    entityAlias: $scope.baseEntityAlias,
	                                    cfc: $scope.baseEntityAlias,
	                                    propertyIdentifier: $scope.baseEntityAlias
	                                }];
	                            unbindBaseEntityAlias();
	                        }
	                    });
	                    $scope.selectedPropertyChanged = function (selectedProperty, aggregate) {
	                        // drill down or select field?
	                        if (!aggregate) {
	                            $scope.selectedProperty = selectedProperty;
	                            $scope.selectedAggregate = undefined;
	                        }
	                        else {
	                            $scope.selectedAggregate = selectedProperty;
	                        }
	                    };
	                    jQuery(function ($) {
	                        var panelList = angular.element($element).children('ul');
	                        panelList.sortable({
	                            // Only make the .panel-heading child elements support dragging.
	                            // Omit this to make then entire <li>...</li> draggable.
	                            handle: '.s-pannel-name',
	                            update: function (event, ui) {
	                                var tempColumnsArray = [];
	                                $('.s-pannel-name', panelList).each(function (index, elem) {
	                                    var newIndex = $(elem).attr('j-column-index');
	                                    var columnItem = $scope.columns[newIndex];
	                                    tempColumnsArray.push(columnItem);
	                                });
	                                $scope.$apply(function () {
	                                    $scope.columns = tempColumnsArray;
	                                });
	                                $scope.saveCollection();
	                            }
	                        });
	                    });
	                    /*var unbindBaseEntityAlaisWatchListener = scope.$watch('baseEntityAlias',function(){
	                     $("select").selectBoxIt();
	                     unbindBaseEntityAlaisWatchListener();
	                     });*/
	                }]
	        };
	    }
	    SWDisplayOptions.Factory = function () {
	        var directive = function ($log, $hibachi, hibachiPathBuilder, collectionPartialsPath, rbkeyService) { return new SWDisplayOptions($log, $hibachi, hibachiPathBuilder, collectionPartialsPath, rbkeyService); };
	        directive.$inject = [
	            '$log',
	            '$hibachi',
	            'hibachiPathBuilder',
	            'collectionPartialsPath',
	            'rbkeyService'
	        ];
	        return directive;
	    };
	    return SWDisplayOptions;
	}());
	exports.SWDisplayOptions = SWDisplayOptions;


/***/ },
/* 119 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWDisplayItem = (function () {
	    //@ngInject
	    function SWDisplayItem($hibachi, collectionPartialsPath, metadataService, hibachiPathBuilder) {
	        return {
	            require: '^swDisplayOptions',
	            restrict: 'A',
	            scope: {
	                selectedProperty: "=",
	                propertiesList: "=",
	                breadCrumbs: "=",
	                selectedPropertyChanged: "&"
	            },
	            templateUrl: hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + "displayitem.html",
	            link: function (scope, element, attrs, displayOptionsController) {
	                scope.showDisplayItem = false;
	                scope.selectedDisplayOptionChanged = function (selectedDisplayOption) {
	                    var breadCrumb = {
	                        entityAlias: scope.selectedProperty.name,
	                        cfc: scope.selectedProperty.cfc,
	                        propertyIdentifier: scope.selectedProperty.propertyIdentifier
	                    };
	                    scope.breadCrumbs.push(breadCrumb);
	                    scope.selectedPropertyChanged({ selectedProperty: selectedDisplayOption });
	                };
	                scope.$watch('selectedProperty', function (selectedProperty) {
	                    if (angular.isDefined(selectedProperty)) {
	                        if (angular.isUndefined(scope.propertiesList[selectedProperty.propertyIdentifier])) {
	                            var filterPropertiesPromise = $hibachi.getFilterPropertiesByBaseEntityName(selectedProperty.cfc);
	                            filterPropertiesPromise.then(function (value) {
	                                metadataService.setPropertiesList(value, selectedProperty.propertyIdentifier);
	                                scope.propertiesList[selectedProperty.propertyIdentifier] = metadataService.getPropertiesListByBaseEntityAlias(selectedProperty.propertyIdentifier);
	                                metadataService.formatPropertiesList(scope.propertiesList[selectedProperty.propertyIdentifier], selectedProperty.propertyIdentifier);
	                            }, function (reason) {
	                            });
	                        }
	                    }
	                });
	            }
	        };
	    }
	    SWDisplayItem.Factory = function () {
	        var directive = function ($hibachi, collectionPartialsPath, metadataService, hibachiPathBuilder) { return new SWDisplayItem($hibachi, collectionPartialsPath, metadataService, hibachiPathBuilder); };
	        directive.$inject = [
	            '$hibachi',
	            'collectionPartialsPath',
	            'metadataService',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWDisplayItem;
	}());
	exports.SWDisplayItem = SWDisplayItem;


/***/ },
/* 120 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWDisplayItemAggregate = (function () {
	    //@ngInject
	    function SWDisplayItemAggregate($hibachi, collectionPartialsPath, metadataService, hibachiPathBuilder) {
	        return {
	            require: '^swDisplayOptions',
	            restrict: 'A',
	            scope: {
	                selectedProperty: "=",
	                propertiesList: "=",
	                breadCrumbs: "=",
	                selectedPropertyChanged: "&"
	            },
	            templateUrl: hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + "displayitemaggregate.html",
	            link: function (scope, element, attrs, displayOptionsController) {
	                scope.showDisplayItem = false;
	                scope.aggegate = {};
	                scope.aggegate.selectedAggregate = '';
	                scope.aggregateOptions = [
	                    { id: 'average', value: 'Average' },
	                    { id: 'count', value: 'Count' },
	                    { id: 'sum', value: 'Sum' }
	                ];
	                scope.selectAggregate = function (aggregate) {
	                    if (aggregate == 'count') {
	                        scope.selectedProperty.aggregate = aggregate;
	                        scope.selectedPropertyChanged({ selectedProperty: scope.selectedProperty });
	                    }
	                    else {
	                        scope.aggegate.currentObject = scope.selectedProperty.cfc;
	                    }
	                };
	                scope.selectedDisplayOptionChanged = function (selectedDisplayOption) {
	                    selectedDisplayOption.aggregate = scope.aggegate.selectedAggregate;
	                    selectedDisplayOption.aggregateObject = scope.aggegate.currentObject;
	                    scope.selectedPropertyChanged({ selectedProperty: selectedDisplayOption });
	                };
	                scope.$watch('selectedProperty', function (selectedProperty) {
	                    if (angular.isDefined(selectedProperty)) {
	                        if (angular.isUndefined(scope.propertiesList[selectedProperty.propertyIdentifier])) {
	                            var filterPropertiesPromise = $hibachi.getFilterPropertiesByBaseEntityName(selectedProperty.cfc);
	                            filterPropertiesPromise.then(function (value) {
	                                metadataService.setPropertiesList(value, selectedProperty.propertyIdentifier);
	                                scope.propertiesList[selectedProperty.propertyIdentifier] = metadataService.getPropertiesListByBaseEntityAlias(selectedProperty.propertyIdentifier);
	                                metadataService.formatPropertiesList(scope.propertiesList[selectedProperty.propertyIdentifier], selectedProperty.propertyIdentifier);
	                            }, function (reason) {
	                            });
	                        }
	                        scope.showDisplayItem = true;
	                    }
	                });
	            }
	        };
	    }
	    SWDisplayItemAggregate.Factory = function () {
	        var directive = function ($hibachi, collectionPartialsPath, metadataService, hibachiPathBuilder) { return new SWDisplayItemAggregate($hibachi, collectionPartialsPath, metadataService, hibachiPathBuilder); };
	        directive.$inject = [
	            '$hibachi',
	            'collectionPartialsPath',
	            'metadataService',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWDisplayItemAggregate;
	}());
	exports.SWDisplayItemAggregate = SWDisplayItemAggregate;


/***/ },
/* 121 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWCollectionTable = (function () {
	    //@ngInject
	    function SWCollectionTable($http, $compile, $log, hibachiPathBuilder, collectionPartialsPath, paginationService, selectionService, $hibachi) {
	        return {
	            restrict: 'E',
	            templateUrl: hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + "collectiontable.html",
	            scope: {
	                collection: "=",
	                collectionConfig: "=",
	                isRadio: "=?",
	                //angularLink:true || false
	                angularLinks: "=?"
	            },
	            link: function (scope, element, attrs) {
	                if (angular.isUndefined(scope.angularLinks)) {
	                    scope.angularLinks = false;
	                }
	                scope.collectionObject = $hibachi['new' + scope.collection.collectionObject]();
	                var escapeRegExp = function (str) {
	                    return str.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
	                };
	                scope.replaceAll = function (str, find, replace) {
	                    return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);
	                };
	                /*
	                 * Handles setting the key on the data.
	                 * */
	                angular.forEach(scope.collectionConfig.columns, function (column) {
	                    $log.debug("Config Key : " + column);
	                    column.key = column.propertyIdentifier.replace(/\./g, '_').replace(scope.collectionConfig.baseEntityAlias + '_', '');
	                });
	                scope.addSelection = function (selectionid, selection) {
	                    selectionService.addSelection(selectionid, selection);
	                };
	            }
	        };
	    }
	    SWCollectionTable.Factory = function () {
	        var directive = function ($http, $compile, $log, hibachiPathBuilder, collectionPartialsPath, paginationService, selectionService, $hibachi) { return new SWCollectionTable($http, $compile, $log, hibachiPathBuilder, collectionPartialsPath, paginationService, selectionService, $hibachi); };
	        directive.$inject = [
	            '$http',
	            '$compile',
	            '$log',
	            'hibachiPathBuilder',
	            'collectionPartialsPath',
	            'paginationService',
	            'selectionService',
	            '$hibachi'
	        ];
	        return directive;
	    };
	    return SWCollectionTable;
	}());
	exports.SWCollectionTable = SWCollectionTable;


/***/ },
/* 122 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWColumnItem = (function () {
	    function SWColumnItem($log, hibachiPathBuilder, collectionPartialsPath) {
	        return {
	            restrict: 'A',
	            require: "^swDisplayOptions",
	            scope: {
	                column: "=",
	                columns: "=",
	                columnIndex: "=",
	                saveCollection: "&",
	                propertiesList: "=",
	                orderBy: "="
	            },
	            templateUrl: hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + "columnitem.html",
	            link: function (scope, element, attrs, displayOptionsController) {
	                scope.editingDisplayTitle = false;
	                scope.editDisplayTitle = function () {
	                    if (angular.isUndefined(scope.column.displayTitle) || !scope.column.displayTitle.length) {
	                        scope.column.displayTitle = scope.column.title;
	                    }
	                    scope.previousDisplayTitle = scope.column.displayTitle;
	                    scope.editingDisplayTitle = true;
	                };
	                scope.saveDisplayTitle = function () {
	                    scope.saveCollection();
	                    scope.editingDisplayTitle = false;
	                };
	                scope.cancelDisplayTitle = function () {
	                    scope.column.displayTitle = scope.previousDisplayTitle;
	                    scope.editingDisplayTitle = false;
	                };
	                $log.debug('displayOptionsController');
	                if (angular.isUndefined(scope.column.sorting)) {
	                    scope.column.sorting = {
	                        active: false,
	                        sortOrder: 'asc',
	                        priority: 0
	                    };
	                }
	                scope.toggleVisible = function (column) {
	                    $log.debug('toggle visible');
	                    if (angular.isUndefined(column.isVisible)) {
	                        column.isVisible = false;
	                    }
	                    column.isVisible = !column.isVisible;
	                    scope.saveCollection();
	                };
	                scope.toggleSearchable = function (column) {
	                    $log.debug('toggle searchable');
	                    if (angular.isUndefined(column.isSearchable)) {
	                        column.isSearchable = false;
	                    }
	                    column.isSearchable = !column.isSearchable;
	                    scope.saveCollection();
	                };
	                scope.toggleExportable = function (column) {
	                    $log.debug('toggle exporable');
	                    if (angular.isUndefined(column.isExportable)) {
	                        column.isExportable = false;
	                    }
	                    column.isExportable = !column.isExportable;
	                    scope.saveCollection();
	                };
	                var compareByPriority = function (a, b) {
	                    if (angular.isDefined(a.sorting) && angular.isDefined(a.sorting.priority)) {
	                        if (a.sorting.priority < b.sorting.priority) {
	                            return -1;
	                        }
	                        if (a.sorting.priority > b.sorting.priority) {
	                            return 1;
	                        }
	                    }
	                    return 0;
	                };
	                var updateOrderBy = function () {
	                    if (angular.isDefined(scope.columns)) {
	                        var columnsCopy = angular.copy(scope.columns);
	                        columnsCopy.sort(compareByPriority);
	                        scope.orderBy = [];
	                        angular.forEach(columnsCopy, function (column) {
	                            if (angular.isDefined(column.sorting) && column.sorting.active === true) {
	                                var orderBy = {
	                                    propertyIdentifier: column.propertyIdentifier,
	                                    direction: column.sorting.sortOrder
	                                };
	                                scope.orderBy.push(orderBy);
	                            }
	                        });
	                    }
	                };
	                scope.toggleSortable = function (column) {
	                    $log.debug('toggle sortable');
	                    if (angular.isUndefined(column.sorting)) {
	                        column.sorting = {
	                            active: true,
	                            sortOrder: 'asc',
	                            priority: 0
	                        };
	                    }
	                    if (column.sorting.active === true) {
	                        if (column.sorting.sortOrder === 'asc') {
	                            column.sorting.sortOrder = 'desc';
	                        }
	                        else {
	                            removeSorting(column);
	                            column.sorting.active = false;
	                        }
	                    }
	                    else {
	                        column.sorting.active = true;
	                        column.sorting.sortOrder = 'asc';
	                        column.sorting.priority = getActivelySorting().length;
	                    }
	                    updateOrderBy();
	                    scope.saveCollection();
	                };
	                var removeSorting = function (column, saving) {
	                    if (column.sorting.active === true) {
	                        for (var i in scope.columns) {
	                            if (scope.columns[i].sorting.active === true && scope.columns[i].sorting.priority > column.sorting.priority) {
	                                scope.columns[i].sorting.priority = scope.columns[i].sorting.priority - 1;
	                            }
	                        }
	                        column.sorting.priority = 0;
	                    }
	                    if (!saving) {
	                        updateOrderBy();
	                        scope.saveCollection();
	                    }
	                };
	                scope.prioritize = function (column) {
	                    if (column.sorting.priority === 1) {
	                        var activelySorting = getActivelySorting();
	                        for (var i in scope.columns) {
	                            if (scope.columns[i].sorting.active === true) {
	                                scope.columns[i].sorting.priority = scope.columns[i].sorting.priority - 1;
	                            }
	                        }
	                        column.sorting.priority = activelySorting.length;
	                    }
	                    else {
	                        for (var i in scope.columns) {
	                            if (scope.columns[i].sorting.active === true && scope.columns[i].sorting.priority === column.sorting.priority - 1) {
	                                scope.columns[i].sorting.priority = scope.columns[i].sorting.priority + 1;
	                            }
	                        }
	                        column.sorting.priority -= 1;
	                    }
	                    updateOrderBy();
	                    scope.saveCollection();
	                };
	                var getActivelySorting = function () {
	                    var activelySorting = [];
	                    for (var i in scope.columns) {
	                        if (scope.columns[i].sorting.active === true) {
	                            activelySorting.push(scope.columns[i]);
	                        }
	                    }
	                    return activelySorting;
	                };
	                scope.removeColumn = function (columnIndex) {
	                    $log.debug('remove column');
	                    $log.debug(columnIndex);
	                    removeSorting(scope.columns[columnIndex], true);
	                    displayOptionsController.removeColumn(columnIndex);
	                    updateOrderBy();
	                    scope.saveCollection();
	                };
	            }
	        };
	    }
	    SWColumnItem.Factory = function () {
	        var directive = function ($log, hibachiPathBuilder, collectionPartialsPath) { return new SWColumnItem($log, hibachiPathBuilder, collectionPartialsPath); };
	        directive.$inject = [
	            '$log',
	            'hibachiPathBuilder',
	            'collectionPartialsPath'
	        ];
	        return directive;
	    };
	    return SWColumnItem;
	}());
	exports.SWColumnItem = SWColumnItem;


/***/ },
/* 123 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWConditionCriteria = (function () {
	    function SWConditionCriteria($http, $compile, $templateCache, $log, $hibachi, $filter, workflowPartialsPath, collectionPartialsPath, collectionService, metadataService, hibachiPathBuilder) {
	        /* Template info begin*/
	        var getTemplate = function (selectedFilterProperty) {
	            var template = '';
	            var templatePath = '';
	            if (angular.isUndefined(selectedFilterProperty.ormtype) && angular.isUndefined(selectedFilterProperty.fieldtype)) {
	                templatePath = hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + "criteria.html";
	            }
	            else {
	                var criteriaormtype = selectedFilterProperty.ormtype;
	                var criteriafieldtype = selectedFilterProperty.fieldtype;
	                /*TODO: convert all switches to object literals*/
	                switch (criteriaormtype) {
	                    case 'boolean':
	                        templatePath = hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + "criteriaboolean.html";
	                        break;
	                    case 'string':
	                        templatePath = hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + "criteriastring.html";
	                        break;
	                    case 'timestamp':
	                        templatePath = hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + "criteriadate.html";
	                        break;
	                    case 'big_decimal':
	                    case 'integer':
	                    case 'float':
	                        templatePath = hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + "criterianumber.html";
	                        break;
	                }
	                switch (criteriafieldtype) {
	                    case "many-to-one":
	                        templatePath = hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + "criteriamanytoone.html";
	                        break;
	                    case "many-to-many":
	                        templatePath = hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + "criteriamanytomany.html";
	                        break;
	                    case "one-to-many":
	                        templatePath = hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + "criteriaonetomany.html";
	                        break;
	                }
	            }
	            var templateLoader = $http.get(templatePath, { cache: $templateCache });
	            return templateLoader;
	        };
	        /* Template info end*/
	        /* Options info begin */
	        var getStringOptions = function (type) {
	            var stringOptions = [];
	            if (angular.isUndefined(type)) {
	                type = 'filter';
	            }
	            if (type == 'filter') {
	                stringOptions = [
	                    {
	                        display: "Equals",
	                        comparisonOperator: "="
	                    },
	                    {
	                        display: "Doesn't Equal",
	                        comparisonOperator: "<>"
	                    },
	                    {
	                        display: "Contains",
	                        comparisonOperator: "like",
	                        pattern: "%w%"
	                    },
	                    {
	                        display: "Doesn't Contain",
	                        comparisonOperator: "not like",
	                        pattern: "%w%"
	                    },
	                    {
	                        display: "Starts With",
	                        comparisonOperator: "like",
	                        pattern: "w%"
	                    },
	                    {
	                        display: "Doesn't Start With",
	                        comparisonOperator: "not like",
	                        pattern: "w%"
	                    },
	                    {
	                        display: "Ends With",
	                        comparisonOperator: "like",
	                        pattern: "%w"
	                    },
	                    {
	                        display: "Doesn't End With",
	                        comparisonOperator: "not like",
	                        pattern: "%w"
	                    },
	                    {
	                        display: "In List",
	                        comparisonOperator: "in"
	                    },
	                    {
	                        display: "Not In List",
	                        comparisonOperator: "not in"
	                    },
	                    {
	                        display: "Defined",
	                        comparisonOperator: "is not",
	                        value: "null"
	                    },
	                    {
	                        display: "Not Defined",
	                        comparisonOperator: "is",
	                        value: "null"
	                    }
	                ];
	                if (type === 'condition') {
	                    stringOptions = [
	                        {
	                            display: "Equals",
	                            comparisonOperator: "="
	                        },
	                        {
	                            display: "In List",
	                            comparisonOperator: "in"
	                        },
	                        {
	                            display: "Defined",
	                            comparisonOperator: "is not",
	                            value: "null"
	                        },
	                        {
	                            display: "Not Defined",
	                            comparisonOperator: "is",
	                            value: "null"
	                        }
	                    ];
	                }
	            }
	            return stringOptions;
	        };
	        var getBooleanOptions = function (type) {
	            var booleanOptions = [];
	            if (angular.isUndefined(type)) {
	                type = 'filter';
	            }
	            if (type === 'filter' || type === 'condition') {
	                booleanOptions = [
	                    {
	                        display: "True",
	                        comparisonOperator: "=",
	                        value: "True"
	                    },
	                    {
	                        display: "False",
	                        comparisonOperator: "=",
	                        value: "False"
	                    },
	                    {
	                        display: "Defined",
	                        comparisonOperator: "is not",
	                        value: "null"
	                    },
	                    {
	                        display: "Not Defined",
	                        comparisonOperator: "is",
	                        value: "null"
	                    }
	                ];
	            }
	            return booleanOptions;
	        };
	        var getDateOptions = function (type) {
	            var dateOptions = [];
	            if (angular.isUndefined(type)) {
	                type = 'filter';
	            }
	            if (type === 'filter') {
	                dateOptions = [
	                    {
	                        display: "Date",
	                        comparisonOperator: "between",
	                        dateInfo: {
	                            type: 'exactDate',
	                        }
	                    },
	                    {
	                        display: "In Range",
	                        comparisonOperator: "between",
	                        dateInfo: {
	                            type: 'range'
	                        }
	                    },
	                    {
	                        display: "Not In Range",
	                        comparisonOperator: "not between",
	                        dateInfo: {
	                            type: 'range'
	                        }
	                    },
	                    {
	                        display: "Today",
	                        comparisonOperator: "between",
	                        dateInfo: {
	                            type: 'calculation',
	                            measureType: 'd',
	                            measureCount: 0,
	                            behavior: 'toDate'
	                        }
	                    },
	                    {
	                        display: "Yesterday",
	                        comparisonOperator: "between",
	                        dateInfo: {
	                            type: 'calculation',
	                            measureType: 'd',
	                            measureCount: -1,
	                            behavior: 'toDate'
	                        }
	                    },
	                    {
	                        display: "This Week",
	                        comparisonOperator: "between",
	                        dateInfo: {
	                            type: 'calculation',
	                            measureType: 'w',
	                            behavior: 'toDate'
	                        }
	                    },
	                    {
	                        display: "This Month",
	                        comparisonOperator: "between",
	                        dateInfo: {
	                            type: 'calculation',
	                            measureType: 'm',
	                            behavior: 'toDate'
	                        }
	                    },
	                    {
	                        display: "This Quarter",
	                        comparisonOperator: "between",
	                        dateInfo: {
	                            type: 'calculation',
	                            measureType: 'q',
	                            behavior: 'toDate'
	                        }
	                    },
	                    {
	                        display: "This Year",
	                        comparisonOperator: "between",
	                        dateInfo: {
	                            type: 'calculation',
	                            measureType: 'y',
	                            behavior: 'toDate'
	                        }
	                    },
	                    {
	                        display: "Last N Hour(s)",
	                        comparisonOperator: "between",
	                        dateInfo: {
	                            type: 'calculation',
	                            measureType: 'h',
	                            measureTypeDisplay: 'Hours'
	                        }
	                    },
	                    {
	                        display: "Last N Day(s)",
	                        comparisonOperator: "between",
	                        dateInfo: {
	                            type: 'calculation',
	                            measureType: 'd',
	                            measureTypeDisplay: 'Days'
	                        }
	                    },
	                    {
	                        display: "Last N Week(s)",
	                        comparisonOperator: "between",
	                        dateInfo: {
	                            type: 'calculation',
	                            measureType: 'w',
	                            measureTypeDisplay: 'Weeks'
	                        }
	                    },
	                    {
	                        display: "Last N Month(s)",
	                        comparisonOperator: "between",
	                        dateInfo: {
	                            type: 'calculation',
	                            measureType: 'm',
	                            measureTypeDisplay: 'Months'
	                        }
	                    },
	                    {
	                        display: "Last N Quarter(s)",
	                        comparisonOperator: "between",
	                        dateInfo: {
	                            type: 'calculation',
	                            measureType: 'q',
	                            measureTypeDisplay: 'Quarters'
	                        }
	                    },
	                    {
	                        display: "Last N Year(s)",
	                        comparisonOperator: "between",
	                        dateInfo: {
	                            type: 'calculation',
	                            measureType: 'y',
	                            measureTypeDisplay: 'Years'
	                        }
	                    },
	                    {
	                        display: "Defined",
	                        comparisonOperator: "is not",
	                        value: "null"
	                    },
	                    {
	                        display: "Not Defined",
	                        comparisonOperator: "is",
	                        value: "null"
	                    }
	                ];
	            }
	            if (type === 'condition') {
	                dateOptions = [
	                    {
	                        display: "Defined",
	                        comparisonOperator: "is not",
	                        value: "null"
	                    },
	                    {
	                        display: "Not Defined",
	                        comparisonOperator: "is",
	                        value: "null"
	                    }
	                ];
	            }
	            return dateOptions;
	        };
	        var getNumberOptions = function (type) {
	            var numberOptions = [];
	            if (angular.isUndefined(type)) {
	                type = 'filter';
	            }
	            if (type == 'filter') {
	                numberOptions = [
	                    {
	                        display: "Equals",
	                        comparisonOperator: "="
	                    },
	                    {
	                        display: "Doesn't Equal",
	                        comparisonOperator: "<>"
	                    },
	                    {
	                        display: "In Range",
	                        comparisonOperator: "between",
	                        type: "range"
	                    },
	                    {
	                        display: "Not In Range",
	                        comparisonOperator: "not between",
	                        type: "range"
	                    },
	                    {
	                        display: "Greater Than",
	                        comparisonOperator: ">"
	                    },
	                    {
	                        display: "Greater Than Or Equal",
	                        comparisonOperator: ">="
	                    },
	                    {
	                        display: "Less Than",
	                        comparisonOperator: "<"
	                    },
	                    {
	                        display: "Less Than Or Equal",
	                        comparisonOperator: "<="
	                    },
	                    {
	                        display: "In List",
	                        comparisonOperator: "in"
	                    },
	                    {
	                        display: "Not In List",
	                        comparisonOperator: "not in"
	                    },
	                    {
	                        display: "Defined",
	                        comparisonOperator: "is not",
	                        value: "null"
	                    },
	                    {
	                        display: "Not Defined",
	                        comparisonOperator: "is",
	                        value: "null"
	                    }
	                ];
	            }
	            if (type === 'condition') {
	                numberOptions = [
	                    {
	                        display: "Equals",
	                        comparisonOperator: "="
	                    },
	                    {
	                        display: "Doesn't Equal",
	                        comparisonOperator: "<>"
	                    },
	                    {
	                        display: "Greater Than",
	                        comparisonOperator: ">"
	                    },
	                    {
	                        display: "Greater Than Or Equal",
	                        comparisonOperator: ">="
	                    },
	                    {
	                        display: "Less Than",
	                        comparisonOperator: "<"
	                    },
	                    {
	                        display: "Less Than Or Equal",
	                        comparisonOperator: "<="
	                    },
	                    {
	                        display: "In List",
	                        comparisonOperator: "in"
	                    },
	                    {
	                        display: "Defined",
	                        comparisonOperator: "is not",
	                        value: "null"
	                    },
	                    {
	                        display: "Not Defined",
	                        comparisonOperator: "is",
	                        value: "null"
	                    }
	                ];
	            }
	            return numberOptions;
	        };
	        var getOneToManyOptions = function (type) {
	            var oneToManyOptions = [];
	            if (angular.isUndefined(type)) {
	                type = 'filter';
	            }
	            if (type == 'filter') {
	                oneToManyOptions = [
	                    {
	                        display: "All Exist In Collection",
	                        comparisonOperator: "All"
	                    },
	                    {
	                        display: "None Exist In Collection",
	                        comparisonOperator: "None"
	                    },
	                    {
	                        display: "Some Exist In Collection",
	                        comparisonOperator: "One"
	                    }
	                ];
	            }
	            if (type === 'condition') {
	                oneToManyOptions = [];
	            }
	            return oneToManyOptions;
	        };
	        var getManyToManyOptions = function (type) {
	            var manyToManyOptions = [];
	            if (angular.isUndefined(type)) {
	                type = 'filter';
	            }
	            if (type == 'filter') {
	                manyToManyOptions = [
	                    {
	                        display: "All Exist In Collection",
	                        comparisonOperator: "All"
	                    },
	                    {
	                        display: "None Exist In Collection",
	                        comparisonOperator: "None"
	                    },
	                    {
	                        display: "Some Exist In Collection",
	                        comparisonOperator: "One"
	                    },
	                    {
	                        display: "Empty",
	                        comparisonOperator: "is",
	                        value: "null"
	                    },
	                    {
	                        display: "Not Empty",
	                        comparisonOperator: "is not",
	                        value: "null"
	                    }
	                ];
	            }
	            if (type === 'condition') {
	                manyToManyOptions = [
	                    {
	                        display: "Empty",
	                        comparisonOperator: "is",
	                        value: "null"
	                    },
	                    {
	                        display: "Not Empty",
	                        comparisonOperator: "is not",
	                        value: "null"
	                    }
	                ];
	            }
	            return manyToManyOptions;
	        };
	        var getManyToOneOptions = function (type) {
	            var manyToOneOptions = [];
	            if (angular.isUndefined(type)) {
	                type = 'filter';
	            }
	            if (type == 'filter') {
	                manyToOneOptions = {
	                    drillEntity: {},
	                    hasEntity: {
	                        display: "Defined",
	                        comparisonOperator: "is not",
	                        value: "null"
	                    },
	                    notHasEntity: {
	                        display: "Not Defined",
	                        comparisonOperator: "is",
	                        value: "null"
	                    }
	                };
	            }
	            return manyToOneOptions;
	        };
	        /* Options info end */
	        var linker = function (scope, element, attrs) {
	            /*show the user the value without % symbols as these are reserved*/
	            scope.$watch('selectedFilterProperty.criteriaValue', function (criteriaValue) {
	                if (angular.isDefined(criteriaValue)) {
	                    scope.selectedFilterProperty.criteriaValue = $filter('likeFilter')(criteriaValue);
	                }
	            });
	            scope.$watch('selectedFilterProperty', function (selectedFilterProperty) {
	                if (angular.isDefined(selectedFilterProperty)) {
	                    $log.debug('watchSelectedFilterProperty');
	                    $log.debug(scope.selectedFilterProperty);
	                    /*prepopulate if we have a comparison operator and value*/
	                    if (selectedFilterProperty === null) {
	                        return;
	                    }
	                    if (angular.isDefined(selectedFilterProperty.ormtype)) {
	                        switch (scope.selectedFilterProperty.ormtype) {
	                            case "boolean":
	                                scope.conditionOptions = getBooleanOptions();
	                                break;
	                            case "string":
	                                scope.conditionOptions = getStringOptions();
	                                scope.selectedConditionChanged = function (selectedFilterProperty) {
	                                    //scope.selectedFilterProperty.criteriaValue = '';
	                                    if (angular.isDefined(selectedFilterProperty.selectedCriteriaType.value)) {
	                                        selectedFilterProperty.showCriteriaValue = false;
	                                    }
	                                    else {
	                                        selectedFilterProperty.showCriteriaValue = true;
	                                    }
	                                };
	                                break;
	                            case "timestamp":
	                                scope.conditionOptions = getDateOptions();
	                                scope.today = function () {
	                                    if (angular.isDefined(scope.selectedFilterProperty)) {
	                                        scope.selectedFilterProperty.criteriaRangeStart = new Date();
	                                        scope.selectedFilterProperty.criteriaRangeEnd = new Date();
	                                    }
	                                };
	                                scope.clear = function () {
	                                    scope.selectedFilterProperty.criteriaRangeStart = null;
	                                    scope.selectedFilterProperty.criteriaRangeEnd = null;
	                                };
	                                scope.openCalendarStart = function ($event) {
	                                    $event.preventDefault();
	                                    $event.stopPropagation();
	                                    scope.openedCalendarStart = true;
	                                };
	                                scope.openCalendarEnd = function ($event) {
	                                    $event.preventDefault();
	                                    $event.stopPropagation();
	                                    scope.openedCalendarEnd = true;
	                                };
	                                scope.formats = [
	                                    'dd-MMMM-yyyy',
	                                    'yyyy/MM/dd',
	                                    'dd.MM.yyyy',
	                                    'shortDate'
	                                ];
	                                scope.format = scope.formats[1];
	                                scope.selectedConditionChanged = function (selectedFilterProperty) {
	                                    $log.debug('selectedConditionChanged Begin');
	                                    var selectedCondition = selectedFilterProperty.selectedCriteriaType;
	                                    //check whether condition is checking for null values in date
	                                    if (angular.isDefined(selectedCondition.dateInfo)) {
	                                        //is condition a calculation
	                                        if (selectedCondition.dateInfo.type === 'calculation') {
	                                            selectedCondition.showCriteriaStart = true;
	                                            selectedCondition.showCriteriaEnd = true;
	                                            selectedCondition.disableCriteriaStart = true;
	                                            selectedCondition.disableCriteriaEnd = true;
	                                            //if item is a calculation of an N number of measure display the measure and number input
	                                            if (angular.isUndefined(selectedCondition.dateInfo.behavior)) {
	                                                $log.debug('Not toDate');
	                                                selectedCondition.showNumberOf = true;
	                                                selectedCondition.conditionDisplay = 'Number of ' + selectedCondition.dateInfo.measureTypeDisplay + ' :';
	                                            }
	                                            else {
	                                                $log.debug('toDate');
	                                                var today = Date.parse('today');
	                                                var todayEOD = today.setHours(23, 59, 59, 999);
	                                                selectedFilterProperty.criteriaRangeEnd = todayEOD;
	                                                //get this Measure to date
	                                                switch (selectedCondition.dateInfo.measureType) {
	                                                    case 'd':
	                                                        var dateBOD = Date.parse('today').add(selectedCondition.dateInfo.measureCount).days();
	                                                        dateBOD.setHours(0, 0, 0, 0);
	                                                        selectedFilterProperty.criteriaRangeStart = dateBOD.getTime();
	                                                        break;
	                                                    case 'w':
	                                                        var firstDayOfWeek = Date.today().last().monday();
	                                                        selectedFilterProperty.criteriaRangeStart = firstDayOfWeek.getTime();
	                                                        break;
	                                                    case 'm':
	                                                        var firstDayOfMonth = Date.today().moveToFirstDayOfMonth();
	                                                        selectedFilterProperty.criteriaRangeStart = firstDayOfMonth.getTime();
	                                                        break;
	                                                    case 'q':
	                                                        var month = Date.parse('today').toString('MM');
	                                                        var year = Date.parse('today').toString('yyyy');
	                                                        var quarterMonth = (Math.floor(month / 3) * 3);
	                                                        var firstDayOfQuarter = new Date(year, quarterMonth, 1);
	                                                        selectedFilterProperty.criteriaRangeStart = firstDayOfQuarter.getTime();
	                                                        break;
	                                                    case 'y':
	                                                        var year = Date.parse('today').toString('yyyy');
	                                                        var firstDayOfYear = new Date(year, 0, 1);
	                                                        selectedFilterProperty.criteriaRangeStart = firstDayOfYear.getTime();
	                                                        break;
	                                                }
	                                            }
	                                        }
	                                        if (selectedCondition.dateInfo.type === 'range') {
	                                            selectedCondition.showCriteriaStart = true;
	                                            selectedCondition.showCriteriaEnd = true;
	                                            selectedCondition.disableCriteriaStart = false;
	                                            selectedCondition.disableCriteriaEnd = false;
	                                            selectedCondition.showNumberOf = false;
	                                        }
	                                        if (selectedCondition.dateInfo.type === 'exactDate') {
	                                            selectedCondition.showCriteriaEnd = false;
	                                            selectedCondition.disableCriteriaStart = false;
	                                            selectedCondition.disableCriteriaEnd = true;
	                                            if (!selectedCondition.dateInfo.measureType) {
	                                                selectedCondition.conditionDisplay = '';
	                                                selectedCondition.showCriteriaStart = true;
	                                                selectedCondition.showNumberOf = false;
	                                                selectedFilterProperty.criteriaRangeStart = new Date(selectedFilterProperty.criteriaRangeStart).setHours(0, 0, 0, 0);
	                                                selectedFilterProperty.criteriaRangeEnd = new Date(selectedFilterProperty.criteriaRangeStart).setHours(23, 59, 59, 999);
	                                            }
	                                            else {
	                                                selectedCondition.conditionDisplay = 'How many ' + selectedCondition.dateInfo.measureTypeDisplay + ' ago?';
	                                                selectedCondition.showCriteriaStart = false;
	                                                selectedCondition.showNumberOf = true;
	                                            }
	                                        }
	                                    }
	                                    else {
	                                        selectedCondition.showCriteriaStart = false;
	                                        selectedCondition.showCriteriaEnd = false;
	                                        selectedCondition.showNumberOf = false;
	                                        selectedCondition.conditionDisplay = '';
	                                    }
	                                    $log.debug('selectedConditionChanged End');
	                                    $log.debug('selectedConditionChanged Result');
	                                    $log.debug(selectedCondition);
	                                    $log.debug(selectedFilterProperty);
	                                };
	                                scope.criteriaRangeChanged = function (selectedFilterProperty) {
	                                    var selectedCondition = selectedFilterProperty.selectedCriteriaType;
	                                    if (selectedCondition.dateInfo.type === 'calculation') {
	                                        var measureCount = selectedFilterProperty.criteriaNumberOf;
	                                        switch (selectedCondition.dateInfo.measureType) {
	                                            case 'h':
	                                                var today = Date.parse('today');
	                                                selectedFilterProperty.criteriaRangeEnd = today.getTime();
	                                                var todayXHoursAgo = Date.parse('today').add(-(measureCount)).hours();
	                                                selectedFilterProperty.criteriaRangeStart = todayXHoursAgo.getTime();
	                                                break;
	                                            case 'd':
	                                                var lastFullDay = Date.parse('today').add(-1).days();
	                                                lastFullDay.setHours(23, 59, 59, 999);
	                                                selectedFilterProperty.criteriaRangeEnd = lastFullDay.getTime();
	                                                var lastXDaysAgo = Date.parse('today').add(-(measureCount)).days();
	                                                selectedFilterProperty.criteriaRangeStart = lastXDaysAgo.getTime();
	                                                break;
	                                            case 'w':
	                                                var lastFullWeekEnd = Date.today().last().sunday();
	                                                lastFullWeekEnd.setHours(23, 59, 59, 999);
	                                                selectedFilterProperty.criteriaRangeEnd = lastFullWeekEnd.getTime();
	                                                var lastXWeeksAgo = Date.today().last().sunday().add(-(measureCount)).weeks();
	                                                selectedFilterProperty.criteriaRangeStart = lastXWeeksAgo.getTime();
	                                                break;
	                                            case 'm':
	                                                var lastFullMonthEnd = Date.today().add(-1).months().moveToLastDayOfMonth();
	                                                lastFullMonthEnd.setHours(23, 59, 59, 999);
	                                                selectedFilterProperty.criteriaRangeEnd = lastFullMonthEnd.getTime();
	                                                var lastXMonthsAgo = Date.today().add(-1).months().moveToLastDayOfMonth().add(-(measureCount)).months();
	                                                selectedFilterProperty.criteriaRangeStart = lastXMonthsAgo.getTime();
	                                                break;
	                                            case 'q':
	                                                var currentQuarter = Math.floor((Date.parse('today').getMonth() / 3));
	                                                var firstDayOfCurrentQuarter = new Date(Date.parse('today').getFullYear(), currentQuarter * 3, 1);
	                                                var lastDayOfPreviousQuarter = firstDayOfCurrentQuarter.add(-1).days();
	                                                lastDayOfPreviousQuarter.setHours(23, 59, 59, 999);
	                                                selectedFilterProperty.criteriaRangeEnd = lastDayOfPreviousQuarter.getTime();
	                                                var lastXQuartersAgo = new Date(Date.parse('today').getFullYear(), currentQuarter * 3, 1);
	                                                lastXQuartersAgo.add(-(measureCount * 3)).months();
	                                                selectedFilterProperty.criteriaRangeStart = lastXQuartersAgo.getTime();
	                                                break;
	                                            case 'y':
	                                                var lastFullYearEnd = new Date(new Date().getFullYear(), 11, 31).add(-1).years();
	                                                lastFullYearEnd.setHours(23, 59, 59, 999);
	                                                selectedFilterProperty.criteriaRangeEnd = lastFullYearEnd.getTime();
	                                                var lastXYearsAgo = new Date(new Date().getFullYear(), 11, 31).add(-(measureCount) - 1).years();
	                                                selectedFilterProperty.criteriaRangeStart = lastXYearsAgo.getTime();
	                                                break;
	                                        }
	                                    }
	                                    if (selectedCondition.dateInfo.type === 'exactDate') {
	                                        selectedFilterProperty.criteriaRangeStart = selectedFilterProperty.criteriaRangeStart.setHours(0, 0, 0, 0);
	                                        selectedFilterProperty.criteriaRangeEnd = new Date(selectedFilterProperty.criteriaRangeStart).setHours(23, 59, 59, 999);
	                                    }
	                                    if (selectedCondition.dateInfo.type === 'range') {
	                                        if (angular.isDefined(selectedFilterProperty.criteriaRangeStart)) {
	                                            selectedFilterProperty.criteriaRangeStart = new Date(selectedFilterProperty.criteriaRangeStart).setHours(0, 0, 0, 0);
	                                        }
	                                        if (angular.isDefined(selectedFilterProperty.criteriaRangeEnd)) {
	                                            selectedFilterProperty.criteriaRangeEnd = new Date(selectedFilterProperty.criteriaRangeEnd).setHours(23, 59, 59, 999);
	                                        }
	                                    }
	                                    $log.debug('criteriaRangeChanged');
	                                    $log.debug(selectedCondition);
	                                    $log.debug(selectedFilterProperty);
	                                };
	                                break;
	                            case "big_decimal":
	                            case "integer":
	                            case "float":
	                                scope.conditionOptions = getNumberOptions();
	                                scope.criteriaRangeChanged = function (selectedFilterProperty) {
	                                    var selectedCondition = selectedFilterProperty.selectedCriteriaType;
	                                };
	                                scope.selectedConditionChanged = function (selectedFilterProperty) {
	                                    selectedFilterProperty.showCriteriaValue = true;
	                                    //check whether the type is a range
	                                    if (angular.isDefined(selectedFilterProperty.selectedCriteriaType.type)) {
	                                        selectedFilterProperty.showCriteriaValue = false;
	                                        selectedFilterProperty.selectedCriteriaType.showCriteriaStart = true;
	                                        selectedFilterProperty.selectedCriteriaType.showCriteriaEnd = true;
	                                    }
	                                    //is null or is not null
	                                    if (angular.isDefined(selectedFilterProperty.selectedCriteriaType.value)) {
	                                        selectedFilterProperty.showCriteriaValue = false;
	                                    }
	                                };
	                                break;
	                        }
	                    }
	                    if (angular.isDefined(scope.selectedFilterProperty.fieldtype)) {
	                        switch (scope.selectedFilterProperty.fieldtype) {
	                            case "many-to-one":
	                                scope.conditionOptions = getManyToOneOptions(scope.comparisonType);
	                                $log.debug('many-to-one');
	                                $log.debug(scope.selectedFilterProperty);
	                                $log.debug(scope.filterPropertiesList);
	                                if (angular.isUndefined(scope.filterPropertiesList[scope.selectedFilterProperty.propertyIdentifier])) {
	                                    var filterPropertiesPromise = $hibachi.getFilterPropertiesByBaseEntityName(scope.selectedFilterProperty.cfc);
	                                    filterPropertiesPromise.then(function (value) {
	                                        scope.filterPropertiesList[scope.selectedFilterProperty.propertyIdentifier] = value;
	                                        metadataService.formatPropertiesList(scope.filterPropertiesList[scope.selectedFilterProperty.propertyIdentifier], scope.selectedFilterProperty.propertyIdentifier);
	                                    }, function (reason) {
	                                    });
	                                }
	                                break;
	                            case "many-to-many":
	                            case "one-to-many":
	                                scope.manyToManyOptions = getManyToManyOptions();
	                                scope.oneToManyOptions = getOneToManyOptions();
	                                var existingCollectionsPromise = $hibachi.getExistingCollectionsByBaseEntity(selectedFilterProperty.cfc);
	                                existingCollectionsPromise.then(function (value) {
	                                    scope.collectionOptions = value.data;
	                                    if (angular.isDefined(scope.workflowCondition.collectionID)) {
	                                        for (var i in scope.collectionOptions) {
	                                            if (scope.collectionOptions[i].collectionID === scope.workflowCondition.collectionID) {
	                                                scope.selectedFilterProperty.selectedCollection = scope.collectionOptions[i];
	                                            }
	                                        }
	                                        for (var i in scope.oneToManyOptions) {
	                                            if (scope.oneToManyOptions[i].comparisonOperator === scope.workflowCondition.criteria) {
	                                                scope.selectedFilterProperty.selectedCriteriaType = scope.oneToManyOptions[i];
	                                            }
	                                        }
	                                    }
	                                });
	                                break;
	                        }
	                    }
	                    $log.debug('workflowCondition');
	                    $log.debug(scope.workflowCondition);
	                    angular.forEach(scope.conditionOptions, function (conditionOption) {
	                        if (conditionOption.display == scope.workflowCondition.conditionDisplay) {
	                            scope.selectedFilterProperty.selectedCriteriaType = conditionOption;
	                            scope.selectedFilterProperty.criteriaValue = scope.workflowCondition.value;
	                            if (angular.isDefined(scope.selectedFilterProperty.selectedCriteriaType.dateInfo)
	                                && angular.isDefined(scope.workflowCondition.value)
	                                && scope.workflowCondition.value.length) {
	                                var dateRangeArray = scope.workflowCondition.value.split("-");
	                                scope.selectedFilterProperty.criteriaRangeStart = new Date(parseInt(dateRangeArray[0]));
	                                scope.selectedFilterProperty.criteriaRangeEnd = new Date(parseInt(dateRangeArray[1]));
	                            }
	                            if (angular.isDefined(scope.workflowCondition.criteriaNumberOf)) {
	                                scope.selectedFilterProperty.criteriaNumberOf = scope.workflowCondition.criteriaNumberOf;
	                            }
	                            if (angular.isDefined(scope.selectedConditionChanged)) {
	                                scope.selectedConditionChanged(scope.selectedFilterProperty);
	                            }
	                        }
	                    });
	                    $log.debug('templateLoader');
	                    $log.debug(selectedFilterProperty);
	                    var templateLoader = getTemplate(selectedFilterProperty);
	                    var promise = templateLoader.success(function (html) {
	                        element.html(html);
	                        $compile(element.contents())(scope);
	                    });
	                }
	            });
	            scope.selectedCriteriaChanged = function (selectedCriteria) {
	                $log.debug(selectedCriteria);
	                //update breadcrumbs as array of filterpropertylist keys
	                $log.debug(scope.selectedFilterProperty);
	                var breadCrumb = {
	                    entityAlias: scope.selectedFilterProperty.name,
	                    cfc: scope.selectedFilterProperty.cfc,
	                    propertyIdentifier: scope.selectedFilterProperty.propertyIdentifier
	                };
	                scope.workflowCondition.breadCrumbs.push(breadCrumb);
	                //populate editfilterinfo with the current level of the filter property we are inspecting by pointing to the new scope key
	                scope.selectedFilterPropertyChanged({ selectedFilterProperty: scope.selectedFilterProperty.selectedCriteriaType });
	                //update criteria to display the condition of the new critera we have selected
	            };
	        };
	        return {
	            restrict: 'A',
	            scope: {
	                workflowCondition: "=",
	                selectedFilterProperty: "=",
	                filterPropertiesList: "=",
	                selectedFilterPropertyChanged: "&"
	            },
	            link: linker
	        };
	    }
	    SWConditionCriteria.Factory = function () {
	        var directive = function ($http, $compile, $templateCache, $log, $hibachi, $filter, workflowPartialsPath, collectionPartialsPath, collectionService, metadataService, hibachiPathBuilder) { return new SWConditionCriteria($http, $compile, $templateCache, $log, $hibachi, $filter, workflowPartialsPath, collectionPartialsPath, collectionService, metadataService, hibachiPathBuilder); };
	        directive.$inject = [
	            '$http',
	            '$compile',
	            '$templateCache',
	            '$log',
	            '$hibachi',
	            '$filter',
	            'workflowPartialsPath',
	            'collectionPartialsPath',
	            'collectionService',
	            'metadataService',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWConditionCriteria;
	}());
	exports.SWConditionCriteria = SWConditionCriteria;


/***/ },
/* 124 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWCriteria = (function () {
	    function SWCriteria($log, $hibachi, $filter, collectionPartialsPath, collectionService, metadataService, hibachiPathBuilder) {
	        return {
	            restrict: 'E',
	            scope: {
	                filterItem: "=",
	                selectedFilterProperty: "=",
	                filterPropertiesList: "=",
	                selectedFilterPropertyChanged: "&",
	                comparisonType: "=",
	                collectionConfig: "="
	            },
	            templateUrl: hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + 'criteria.html',
	            link: function (scope, element, attrs) {
	            }
	        };
	    }
	    SWCriteria.Factory = function () {
	        var directive = function ($log, $hibachi, $filter, collectionPartialsPath, collectionService, metadataService, hibachiPathBuilder) { return new SWCriteria($log, $hibachi, $filter, collectionPartialsPath, collectionService, metadataService, hibachiPathBuilder); };
	        directive.$inject = [
	            '$log',
	            '$hibachi',
	            '$filter',
	            'collectionPartialsPath',
	            'collectionService',
	            'metadataService',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWCriteria;
	}());
	exports.SWCriteria = SWCriteria;


/***/ },
/* 125 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWCriteriaBoolean = (function () {
	    function SWCriteriaBoolean($log, $hibachi, $filter, collectionPartialsPath, collectionService, metadataService, hibachiPathBuilder) {
	        return {
	            restrict: 'E',
	            templateUrl: hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + 'criteriaboolean.html',
	            link: function (scope, element, attrs) {
	                var getBooleanOptions = function (type) {
	                    if (angular.isUndefined(type)) {
	                        type = 'filter';
	                    }
	                    var booleanOptions = [];
	                    if (type === 'filter') {
	                        booleanOptions = [
	                            {
	                                display: "True",
	                                comparisonOperator: "=",
	                                value: "True"
	                            },
	                            {
	                                display: "False",
	                                comparisonOperator: "=",
	                                value: "False"
	                            },
	                            {
	                                display: "Defined",
	                                comparisonOperator: "is not",
	                                value: "null"
	                            },
	                            {
	                                display: "Not Defined",
	                                comparisonOperator: "is",
	                                value: "null"
	                            }
	                        ];
	                    }
	                    else if (type === 'condition') {
	                        booleanOptions = [
	                            {
	                                display: "True",
	                                comparisonOperator: "eq",
	                                value: "True"
	                            },
	                            {
	                                display: "False",
	                                comparisonOperator: "eq",
	                                value: "False"
	                            },
	                            {
	                                display: "Defined",
	                                comparisonOperator: "null",
	                                value: "False"
	                            },
	                            {
	                                display: "Not Defined",
	                                comparisonOperator: "null",
	                                value: "True"
	                            }
	                        ];
	                    }
	                    return booleanOptions;
	                };
	                scope.conditionOptions = getBooleanOptions(scope.comparisonType);
	                angular.forEach(scope.conditionOptions, function (conditionOption) {
	                    if (conditionOption.display == scope.filterItem.conditionDisplay) {
	                        scope.selectedFilterProperty.selectedCriteriaType = conditionOption;
	                        scope.selectedFilterProperty.criteriaValue = scope.filterItem.value;
	                        if (angular.isDefined(scope.selectedConditionChanged)) {
	                            scope.selectedConditionChanged(scope.selectedFilterProperty);
	                        }
	                    }
	                });
	            }
	        };
	    }
	    SWCriteriaBoolean.Factory = function () {
	        var directive = function ($log, $hibachi, $filter, collectionPartialsPath, collectionService, metadataService, hibachiPathBuilder) { return new SWCriteriaBoolean($log, $hibachi, $filter, collectionPartialsPath, collectionService, metadataService, hibachiPathBuilder); };
	        directive.$inject = [
	            '$log',
	            '$hibachi',
	            '$filter',
	            'collectionPartialsPath',
	            'collectionService',
	            'metadataService',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWCriteriaBoolean;
	}());
	exports.SWCriteriaBoolean = SWCriteriaBoolean;


/***/ },
/* 126 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWCriteriaDate = (function () {
	    function SWCriteriaDate($log, collectionPartialsPath, hibachiPathBuilder) {
	        return {
	            restrict: 'E',
	            templateUrl: hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + 'criteriadate.html',
	            link: function (scope, element, attrs) {
	                var getDateOptions = function (type) {
	                    if (angular.isUndefined(type)) {
	                        type = 'filter';
	                    }
	                    var dateOptions = [];
	                    if (type === 'filter') {
	                        dateOptions = [
	                            {
	                                display: "Date",
	                                comparisonOperator: "between",
	                                dateInfo: {
	                                    type: 'exactDate',
	                                }
	                            },
	                            {
	                                display: "In Range",
	                                comparisonOperator: "between",
	                                dateInfo: {
	                                    type: 'range'
	                                }
	                            },
	                            {
	                                display: "Not In Range",
	                                comparisonOperator: "not between",
	                                dateInfo: {
	                                    type: 'range'
	                                }
	                            },
	                            {
	                                display: "Today",
	                                comparisonOperator: "between",
	                                dateInfo: {
	                                    type: 'calculation',
	                                    measureType: 'd',
	                                    measureCount: 0,
	                                    behavior: 'toDate'
	                                }
	                            },
	                            {
	                                display: "Yesterday",
	                                comparisonOperator: "between",
	                                dateInfo: {
	                                    type: 'calculation',
	                                    measureType: 'd',
	                                    measureCount: -1,
	                                    behavior: 'toDate'
	                                }
	                            },
	                            {
	                                display: "This Week",
	                                comparisonOperator: "between",
	                                dateInfo: {
	                                    type: 'calculation',
	                                    measureType: 'w',
	                                    behavior: 'toDate'
	                                }
	                            },
	                            {
	                                display: "This Month",
	                                comparisonOperator: "between",
	                                dateInfo: {
	                                    type: 'calculation',
	                                    measureType: 'm',
	                                    behavior: 'toDate'
	                                }
	                            },
	                            {
	                                display: "This Quarter",
	                                comparisonOperator: "between",
	                                dateInfo: {
	                                    type: 'calculation',
	                                    measureType: 'q',
	                                    behavior: 'toDate'
	                                }
	                            },
	                            {
	                                display: "This Year",
	                                comparisonOperator: "between",
	                                dateInfo: {
	                                    type: 'calculation',
	                                    measureType: 'y',
	                                    behavior: 'toDate'
	                                }
	                            },
	                            {
	                                display: "Last N Hour(s)",
	                                comparisonOperator: "between",
	                                dateInfo: {
	                                    type: 'calculation',
	                                    measureType: 'h',
	                                    measureTypeDisplay: 'Hours'
	                                }
	                            },
	                            {
	                                display: "Last N Day(s)",
	                                comparisonOperator: "between",
	                                dateInfo: {
	                                    type: 'calculation',
	                                    measureType: 'd',
	                                    measureTypeDisplay: 'Days'
	                                }
	                            },
	                            {
	                                display: "Last N Week(s)",
	                                comparisonOperator: "between",
	                                dateInfo: {
	                                    type: 'calculation',
	                                    measureType: 'w',
	                                    measureTypeDisplay: 'Weeks'
	                                }
	                            },
	                            {
	                                display: "Last N Month(s)",
	                                comparisonOperator: "between",
	                                dateInfo: {
	                                    type: 'calculation',
	                                    measureType: 'm',
	                                    measureTypeDisplay: 'Months'
	                                }
	                            },
	                            {
	                                display: "Last N Quarter(s)",
	                                comparisonOperator: "between",
	                                dateInfo: {
	                                    type: 'calculation',
	                                    measureType: 'q',
	                                    measureTypeDisplay: 'Quarters'
	                                }
	                            },
	                            {
	                                display: "Last N Year(s)",
	                                comparisonOperator: "between",
	                                dateInfo: {
	                                    type: 'calculation',
	                                    measureType: 'y',
	                                    measureTypeDisplay: 'Years'
	                                }
	                            },
	                            {
	                                display: "Exact N Day(s) Ago",
	                                comparisonOperator: "between",
	                                dateInfo: {
	                                    type: 'exactDate',
	                                    measureType: 'd',
	                                    measureTypeDisplay: 'Days'
	                                }
	                            },
	                            {
	                                display: "Exact N Month(s) Ago",
	                                comparisonOperator: "between",
	                                dateInfo: {
	                                    type: 'exactDate',
	                                    measureType: 'm',
	                                    measureTypeDisplay: 'Months'
	                                }
	                            },
	                            {
	                                display: "Exact N Year(s) Ago",
	                                comparisonOperator: "between",
	                                dateInfo: {
	                                    type: 'exactDate',
	                                    measureType: 'y',
	                                    measureTypeDisplay: 'Years'
	                                }
	                            },
	                            {
	                                display: "Exact N Day(s) Ago",
	                                comparisonOperator: "between",
	                                dateInfo: {
	                                    type: 'exactDate',
	                                    measureType: 'd',
	                                    measureTypeDisplay: 'Days'
	                                }
	                            },
	                            {
	                                display: "Exact N Month(s) Ago",
	                                comparisonOperator: "between",
	                                dateInfo: {
	                                    type: 'exactDate',
	                                    measureType: 'm',
	                                    measureTypeDisplay: 'Months'
	                                }
	                            },
	                            {
	                                display: "Exact N Year(s) Ago",
	                                comparisonOperator: "between",
	                                dateInfo: {
	                                    type: 'exactDate',
	                                    measureType: 'y',
	                                    measureTypeDisplay: 'Years'
	                                }
	                            },
	                            {
	                                display: "Defined",
	                                comparisonOperator: "is not",
	                                value: "null"
	                            },
	                            {
	                                display: "Not Defined",
	                                comparisonOperator: "is",
	                                value: "null"
	                            }
	                        ];
	                    }
	                    else if (type === 'condition') {
	                        dateOptions = [
	                            {
	                                display: "Equals",
	                                comparisonOperator: "eq"
	                            },
	                            {
	                                display: "Doesn't Equal",
	                                comparisonOperator: "neq"
	                            },
	                            {
	                                display: "Defined",
	                                comparisonOperator: "null",
	                                value: "False"
	                            },
	                            {
	                                display: "Not Defined",
	                                comparisonOperator: "null",
	                                value: "True"
	                            }
	                        ];
	                    }
	                    return dateOptions;
	                };
	                scope.conditionOptions = getDateOptions(scope.comparisonType);
	                scope.today = function () {
	                    if (angular.isDefined(scope.selectedFilterProperty)) {
	                        scope.selectedFilterProperty.criteriaRangeStart = new Date();
	                        scope.selectedFilterProperty.criteriaRangeEnd = new Date();
	                    }
	                };
	                scope.clear = function () {
	                    scope.selectedFilterProperty.criteriaRangeStart = null;
	                    scope.selectedFilterProperty.criteriaRangeEnd = null;
	                };
	                scope.openCalendarStart = function ($event) {
	                    $event.preventDefault();
	                    $event.stopPropagation();
	                    scope.openedCalendarStart = true;
	                };
	                scope.openCalendarEnd = function ($event) {
	                    $event.preventDefault();
	                    $event.stopPropagation();
	                    scope.openedCalendarEnd = true;
	                };
	                scope.formats = [
	                    'dd-MMMM-yyyy',
	                    'yyyy/MM/dd',
	                    'dd.MM.yyyy',
	                    'shortDate'
	                ];
	                scope.format = scope.formats[1];
	                scope.selectedConditionChanged = function (selectedFilterProperty) {
	                    $log.debug('selectedConditionChanged Begin');
	                    var selectedCondition = selectedFilterProperty.selectedCriteriaType;
	                    //check whether condition is checking for null values in date
	                    if (angular.isDefined(selectedCondition.dateInfo)) {
	                        //is condition a calculation
	                        if (selectedCondition.dateInfo.type === 'calculation') {
	                            selectedCondition.showCriteriaStart = true;
	                            selectedCondition.showCriteriaEnd = true;
	                            selectedCondition.disableCriteriaStart = true;
	                            selectedCondition.disableCriteriaEnd = true;
	                            //if item is a calculation of an N number of measure display the measure and number input
	                            if (angular.isUndefined(selectedCondition.dateInfo.behavior)) {
	                                $log.debug('Not toDate');
	                                selectedCondition.showNumberOf = true;
	                                selectedCondition.conditionDisplay = 'Number of ' + selectedCondition.dateInfo.measureTypeDisplay + ' :';
	                            }
	                            else {
	                                $log.debug('toDate');
	                                var today = Date.parse('today');
	                                var todayEOD = today.setHours(23, 59, 59, 999);
	                                selectedFilterProperty.criteriaRangeEnd = todayEOD;
	                                //get this Measure to date
	                                switch (selectedCondition.dateInfo.measureType) {
	                                    case 'd':
	                                        var dateBOD = Date.parse('today').add(selectedCondition.dateInfo.measureCount).days();
	                                        dateBOD.setHours(0, 0, 0, 0);
	                                        selectedFilterProperty.criteriaRangeStart = dateBOD.getTime();
	                                        break;
	                                    case 'w':
	                                        var firstDayOfWeek = Date.today().last().monday();
	                                        selectedFilterProperty.criteriaRangeStart = firstDayOfWeek.getTime();
	                                        break;
	                                    case 'm':
	                                        var firstDayOfMonth = Date.today().moveToFirstDayOfMonth();
	                                        selectedFilterProperty.criteriaRangeStart = firstDayOfMonth.getTime();
	                                        break;
	                                    case 'q':
	                                        var month = Date.parse('today').toString('MM');
	                                        var year = Date.parse('today').toString('yyyy');
	                                        var quarterMonth = (Math.floor(month / 3) * 3);
	                                        var firstDayOfQuarter = new Date(year, quarterMonth, 1);
	                                        selectedFilterProperty.criteriaRangeStart = firstDayOfQuarter.getTime();
	                                        break;
	                                    case 'y':
	                                        var year = Date.parse('today').toString('yyyy');
	                                        var firstDayOfYear = new Date(year, 0, 1);
	                                        selectedFilterProperty.criteriaRangeStart = firstDayOfYear.getTime();
	                                        break;
	                                }
	                            }
	                        }
	                        if (selectedCondition.dateInfo.type === 'range') {
	                            selectedCondition.showCriteriaStart = true;
	                            selectedCondition.showCriteriaEnd = true;
	                            selectedCondition.disableCriteriaStart = false;
	                            selectedCondition.disableCriteriaEnd = false;
	                            selectedCondition.showNumberOf = false;
	                        }
	                        if (selectedCondition.dateInfo.type === 'exactDate') {
	                            selectedCondition.showCriteriaStart = true;
	                            selectedCondition.showCriteriaEnd = false;
	                            selectedCondition.disableCriteriaStart = false;
	                            selectedCondition.disableCriteriaEnd = true;
	                            if (!selectedCondition.dateInfo.measureType) {
	                                selectedCondition.conditionDisplay = '';
	                                selectedCondition.showCriteriaStart = true;
	                                selectedCondition.showNumberOf = false;
	                                selectedFilterProperty.criteriaRangeStart = new Date(selectedFilterProperty.criteriaRangeStart).setHours(0, 0, 0, 0);
	                                selectedFilterProperty.criteriaRangeEnd = new Date(selectedFilterProperty.criteriaRangeStart).setHours(23, 59, 59, 999);
	                            }
	                            else {
	                                selectedCondition.conditionDisplay = 'How many ' + selectedCondition.dateInfo.measureTypeDisplay + ' ago?';
	                                selectedCondition.showCriteriaStart = false;
	                                selectedCondition.showNumberOf = true;
	                            }
	                        }
	                    }
	                    else {
	                        selectedCondition.showCriteriaStart = false;
	                        selectedCondition.showCriteriaEnd = false;
	                        selectedCondition.showNumberOf = false;
	                        selectedCondition.conditionDisplay = '';
	                    }
	                    $log.debug('selectedConditionChanged End');
	                    $log.debug('selectedConditionChanged Result');
	                    $log.debug(selectedCondition);
	                    $log.debug(selectedFilterProperty);
	                };
	                scope.criteriaRangeChanged = function (selectedFilterProperty) {
	                    $log.debug('criteriaRangeChanged');
	                    $log.debug(selectedFilterProperty);
	                    var selectedCondition = selectedFilterProperty.selectedCriteriaType;
	                    if (selectedCondition.dateInfo.type === 'calculation') {
	                        var measureCount = selectedFilterProperty.criteriaNumberOf;
	                        switch (selectedCondition.dateInfo.measureType) {
	                            case 'h':
	                                var today = Date.parse('today');
	                                selectedFilterProperty.criteriaRangeEnd = today.getTime();
	                                var todayXHoursAgo = Date.parse('today').add(-(measureCount)).hours();
	                                selectedFilterProperty.criteriaRangeStart = todayXHoursAgo.getTime();
	                                break;
	                            case 'd':
	                                var lastFullDay = Date.parse('today').add(-1).days();
	                                lastFullDay.setHours(23, 59, 59, 999);
	                                selectedFilterProperty.criteriaRangeEnd = lastFullDay.getTime();
	                                var lastXDaysAgo = Date.parse('today').add(-(measureCount)).days();
	                                selectedFilterProperty.criteriaRangeStart = lastXDaysAgo.getTime();
	                                break;
	                            case 'w':
	                                var lastFullWeekEnd = Date.today().last().sunday();
	                                lastFullWeekEnd.setHours(23, 59, 59, 999);
	                                selectedFilterProperty.criteriaRangeEnd = lastFullWeekEnd.getTime();
	                                var lastXWeeksAgo = Date.today().last().sunday().add(-(measureCount)).weeks();
	                                selectedFilterProperty.criteriaRangeStart = lastXWeeksAgo.getTime();
	                                break;
	                            case 'm':
	                                var lastFullMonthEnd = Date.today().add(-1).months().moveToLastDayOfMonth();
	                                lastFullMonthEnd.setHours(23, 59, 59, 999);
	                                selectedFilterProperty.criteriaRangeEnd = lastFullMonthEnd.getTime();
	                                var lastXMonthsAgo = Date.today().add(-1).months().moveToLastDayOfMonth().add(-(measureCount)).months();
	                                selectedFilterProperty.criteriaRangeStart = lastXMonthsAgo.getTime();
	                                break;
	                            case 'q':
	                                var currentQuarter = Math.floor((Date.parse('today').getMonth() / 3));
	                                var firstDayOfCurrentQuarter = new Date(Date.parse('today').getFullYear(), currentQuarter * 3, 1);
	                                var lastDayOfPreviousQuarter = firstDayOfCurrentQuarter.add(-1).days();
	                                lastDayOfPreviousQuarter.setHours(23, 59, 59, 999);
	                                selectedFilterProperty.criteriaRangeEnd = lastDayOfPreviousQuarter.getTime();
	                                var lastXQuartersAgo = new Date(Date.parse('today').getFullYear(), currentQuarter * 3, 1);
	                                lastXQuartersAgo.add(-(measureCount * 3)).months();
	                                selectedFilterProperty.criteriaRangeStart = lastXQuartersAgo.getTime();
	                                break;
	                            case 'y':
	                                var lastFullYearEnd = new Date(new Date().getFullYear(), 11, 31).add(-1).years();
	                                lastFullYearEnd.setHours(23, 59, 59, 999);
	                                selectedFilterProperty.criteriaRangeEnd = lastFullYearEnd.getTime();
	                                var lastXYearsAgo = new Date(new Date().getFullYear(), 11, 31).add(-(measureCount) - 1).years();
	                                selectedFilterProperty.criteriaRangeStart = lastXYearsAgo.getTime();
	                                break;
	                        }
	                    }
	                    if (selectedCondition.dateInfo.type === 'exactDate' && angular.isDefined(selectedFilterProperty.criteriaRangeStart) && angular.isDefined(selectedFilterProperty.criteriaRangeStart.setHours)) {
	                        selectedFilterProperty.criteriaRangeStart = selectedFilterProperty.criteriaRangeStart.setHours(0, 0, 0, 0);
	                        selectedFilterProperty.criteriaRangeEnd = new Date(selectedFilterProperty.criteriaRangeStart).setHours(23, 59, 59, 999);
	                    }
	                    if (selectedCondition.dateInfo.type === 'range') {
	                        if (angular.isDefined(selectedFilterProperty.criteriaRangeStart) && angular.isDefined(selectedFilterProperty.criteriaRangeStart)) {
	                            selectedFilterProperty.criteriaRangeStart = new Date(selectedFilterProperty.criteriaRangeStart).setHours(0, 0, 0, 0);
	                        }
	                        if (angular.isDefined(selectedFilterProperty.criteriaRangeEnd) && angular.isDefined(selectedFilterProperty.criteriaRangeStart)) {
	                            selectedFilterProperty.criteriaRangeEnd = new Date(selectedFilterProperty.criteriaRangeEnd).setHours(23, 59, 59, 999);
	                        }
	                    }
	                    $log.debug('criteriaRangeChanged');
	                    $log.debug(selectedCondition);
	                    $log.debug(selectedFilterProperty);
	                };
	                if (angular.isUndefined(scope.filterItem.$$isNew) || scope.filterItem.$$isNew === false) {
	                    angular.forEach(scope.conditionOptions, function (conditionOption) {
	                        if (conditionOption.display == scope.filterItem.conditionDisplay) {
	                            scope.selectedFilterProperty.selectedCriteriaType = conditionOption;
	                            scope.selectedFilterProperty.criteriaValue = scope.filterItem.value;
	                            if (angular.isDefined(scope.selectedFilterProperty.selectedCriteriaType.dateInfo)
	                                && angular.isDefined(scope.filterItem.value)
	                                && scope.filterItem.value.length) {
	                                var dateRangeArray = scope.filterItem.value.split("-");
	                                scope.selectedFilterProperty.criteriaRangeStart = new Date(parseInt(dateRangeArray[0]));
	                                scope.selectedFilterProperty.criteriaRangeEnd = new Date(parseInt(dateRangeArray[1]));
	                            }
	                            if (angular.isDefined(scope.selectedConditionChanged)) {
	                                scope.selectedConditionChanged(scope.selectedFilterProperty);
	                            }
	                        }
	                    });
	                }
	                else {
	                    scope.selectedFilterProperty.criteriaValue = '';
	                    scope.selectedFilterProperty.criteriaRangeStart = '';
	                    scope.selectedFilterProperty.criteriaRangeEnd = '';
	                }
	            }
	        };
	    }
	    SWCriteriaDate.Factory = function () {
	        var directive = function ($log, collectionPartialsPath, hibachiPathBuilder) { return new SWCriteriaDate($log, collectionPartialsPath, hibachiPathBuilder); };
	        directive.$inject = [
	            '$log',
	            'collectionPartialsPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWCriteriaDate;
	}());
	exports.SWCriteriaDate = SWCriteriaDate;


/***/ },
/* 127 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWCriteriaManyToMany = (function () {
	    function SWCriteriaManyToMany($log, $hibachi, $filter, collectionPartialsPath, collectionService, metadataService, dialogService, observerService, hibachiPathBuilder, rbkeyService) {
	        return {
	            restrict: 'E',
	            templateUrl: hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + 'criteriamanytomany.html',
	            link: function (scope, element, attrs) {
	                scope.data = {};
	                scope.collectionOptionsOpen = false;
	                scope.toggleCollectionOptions = function (flag) {
	                    scope.collectionOptionsOpen = (!angular.isUndefined(flag)) ? flag : !scope.collectionOptionsOpen;
	                };
	                scope.selectCollection = function (collection) {
	                    scope.toggleCollectionOptions();
	                    scope.selectedFilterProperty.selectedCollection = collection;
	                    scope.selectedFilterProperty.selectedCriteriaType = scope.manyToManyOptions[2];
	                };
	                scope.cleanSelection = function () {
	                    scope.toggleCollectionOptions(false);
	                    scope.data.collectionName = "";
	                    scope.selectedFilterProperty.selectedCollection = null;
	                };
	                var getManyToManyOptions = function (type) {
	                    if (angular.isUndefined(type)) {
	                        type = 'filter';
	                    }
	                    $log.debug('type', type);
	                    var manyToManyOptions = [];
	                    if (type == 'filter') {
	                        manyToManyOptions = [
	                            {
	                                display: "All Exist In Collection",
	                                comparisonOperator: "All"
	                            },
	                            {
	                                display: "None Exist In Collection",
	                                comparisonOperator: "None"
	                            },
	                            {
	                                display: "Some Exist In Collection",
	                                comparisonOperator: "One"
	                            },
	                            {
	                                display: "Empty",
	                                comparisonOperator: "is",
	                                value: "null"
	                            },
	                            {
	                                display: "Not Empty",
	                                comparisonOperator: "is not",
	                                value: "null"
	                            }
	                        ];
	                    }
	                    else if (type === 'condition') {
	                        manyToManyOptions = [];
	                    }
	                    return manyToManyOptions;
	                };
	                scope.manyToManyOptions = getManyToManyOptions(scope.comparisonType);
	                var existingCollectionsPromise = $hibachi.getExistingCollectionsByBaseEntity(scope.selectedFilterProperty.cfc);
	                existingCollectionsPromise.then(function (value) {
	                    scope.collectionOptions = value.data;
	                    if (angular.isDefined(scope.filterItem.collectionID)) {
	                        for (var i in scope.collectionOptions) {
	                            if (scope.collectionOptions[i].collectionID === scope.filterItem.collectionID) {
	                                scope.selectedFilterProperty.selectedCollection = scope.collectionOptions[i];
	                            }
	                        }
	                        for (var i in scope.manyToManyOptions) {
	                            if (scope.manyToManyOptions[i].comparisonOperator === scope.filterItem.criteria) {
	                                scope.selectedFilterProperty.selectedCriteriaType = scope.manyToManyOptions[i];
	                            }
	                        }
	                    }
	                });
	                function populateUI(collection) {
	                    scope.collectionOptions.push(collection);
	                    scope.selectedFilterProperty.selectedCollection = collection;
	                    scope.selectedFilterProperty.selectedCriteriaType = scope.manyToManyOptions[2];
	                }
	                observerService.attach(populateUI, 'addCollection', 'addCollection');
	                scope.selectedCriteriaChanged = function (selectedCriteria) {
	                    $log.debug(selectedCriteria);
	                    //update breadcrumbs as array of filterpropertylist keys
	                    $log.debug(scope.selectedFilterProperty);
	                    var breadCrumb = {
	                        entityAlias: scope.selectedFilterProperty.name,
	                        cfc: scope.selectedFilterProperty.cfc,
	                        propertyIdentifier: scope.selectedFilterProperty.propertyIdentifier,
	                        rbKey: rbkeyService.getRBKey('entity.' + scope.selectedFilterProperty.cfc.replace('_', ''))
	                    };
	                    scope.filterItem.breadCrumbs.push(breadCrumb);
	                    //populate editfilterinfo with the current level of the filter property we are inspecting by pointing to the new scope key
	                    scope.selectedFilterPropertyChanged({ selectedFilterProperty: scope.selectedFilterProperty.selectedCriteriaType });
	                    //update criteria to display the condition of the new critera we have selected
	                };
	                scope.addNewCollection = function () {
	                    dialogService.addPageDialog('org/Hibachi/client/src/collection/components/criteriacreatecollection', {
	                        entityName: scope.selectedFilterProperty.cfc,
	                        collectionName: scope.data.collectionName,
	                        parentEntity: scope.collectionConfig.baseEntityName
	                    });
	                    scope.cleanSelection();
	                };
	                scope.viewSelectedCollection = function () {
	                    dialogService.addPageDialog('org/Hibachi/client/src/collection/components/criteriacreatecollection', {
	                        entityName: 'collection',
	                        entityId: scope.selectedFilterProperty.selectedCollection.collectionID,
	                        parentEntity: scope.collectionConfig.baseEntityName
	                    });
	                };
	            }
	        };
	    }
	    SWCriteriaManyToMany.Factory = function () {
	        var directive = function ($log, $hibachi, $filter, collectionPartialsPath, collectionService, metadataService, dialogService, observerService, hibachiPathBuilder, rbkeyService) { return new SWCriteriaManyToMany($log, $hibachi, $filter, collectionPartialsPath, collectionService, metadataService, dialogService, observerService, hibachiPathBuilder, rbkeyService); };
	        directive.$inject = [
	            '$log',
	            '$hibachi',
	            '$filter',
	            'collectionPartialsPath',
	            'collectionService',
	            'metadataService',
	            'dialogService',
	            'observerService',
	            'hibachiPathBuilder',
	            'rbkeyService',
	        ];
	        return directive;
	    };
	    return SWCriteriaManyToMany;
	}());
	exports.SWCriteriaManyToMany = SWCriteriaManyToMany;


/***/ },
/* 128 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWCriteriaManyToOne = (function () {
	    function SWCriteriaManyToOne($log, $hibachi, $filter, collectionPartialsPath, collectionService, metadataService, hibachiPathBuilder, rbkeyService) {
	        return {
	            restrict: 'E',
	            templateUrl: hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + 'criteriamanytoone.html',
	            link: function (scope, element, attrs) {
	                var getManyToOneOptions = function () {
	                    var manyToOneOptions = {
	                        drillEntity: {},
	                        hasEntity: {
	                            display: "Defined",
	                            comparisonOperator: "is not",
	                            value: "null"
	                        },
	                        notHasEntity: {
	                            display: "Not Defined",
	                            comparisonOperator: "is",
	                            value: "null"
	                        }
	                    };
	                    return manyToOneOptions;
	                };
	                scope.manyToOneOptions = getManyToOneOptions();
	                scope.conditionOptions = getManyToOneOptions();
	                $log.debug('many-to-one');
	                $log.debug(scope.selectedFilterProperty);
	                $log.debug(scope.filterPropertiesList);
	                scope.$watch('selectedFilterProperty', function (selectedFilterProperty) {
	                    if (angular.isUndefined(scope.filterPropertiesList[scope.selectedFilterProperty.propertyIdentifier])) {
	                        var filterPropertiesPromise = $hibachi.getFilterPropertiesByBaseEntityName(selectedFilterProperty.cfc);
	                        filterPropertiesPromise.then(function (value) {
	                            scope.filterPropertiesList[scope.selectedFilterProperty.propertyIdentifier] = value;
	                            metadataService.formatPropertiesList(scope.filterPropertiesList[scope.selectedFilterProperty.propertyIdentifier], scope.selectedFilterProperty.propertyIdentifier);
	                        }, function (reason) {
	                        });
	                    }
	                    scope.selectedCriteriaChanged = function (selectedCriteria) {
	                        $log.debug(selectedCriteria);
	                        $log.debug('changed');
	                        //update breadcrumbs as array of filterpropertylist keys
	                        $log.debug(scope.selectedFilterProperty);
	                        var breadCrumb = {
	                            entityAlias: scope.selectedFilterProperty.name,
	                            cfc: scope.selectedFilterProperty.cfc,
	                            propertyIdentifier: scope.selectedFilterProperty.propertyIdentifier,
	                            rbKey: rbkeyService.getRBKey('entity.' + scope.selectedFilterProperty.cfc.replace('_', ''))
	                        };
	                        $log.debug('breadcrumb');
	                        $log.debug(breadCrumb);
	                        $log.debug(scope.filterItem.breadCrumbs);
	                        scope.filterItem.breadCrumbs.push(breadCrumb);
	                        //populate editfilterinfo with the current level of the filter property we are inspecting by pointing to the new scope key
	                        scope.selectedFilterPropertyChanged({ selectedFilterProperty: scope.selectedFilterProperty.selectedCriteriaType });
	                        //update criteria to display the condition of the new critera we have selected
	                        $log.debug(scope.selectedFilterProperty);
	                    };
	                });
	            }
	        };
	    }
	    SWCriteriaManyToOne.Factory = function () {
	        var directive = function ($log, $hibachi, $filter, collectionPartialsPath, collectionService, metadataService, hibachiPathBuilder, rbkeyService) { return new SWCriteriaManyToOne($log, $hibachi, $filter, collectionPartialsPath, collectionService, metadataService, hibachiPathBuilder, rbkeyService); };
	        directive.$inject = [
	            '$log',
	            '$hibachi',
	            '$filter',
	            'collectionPartialsPath',
	            'collectionService',
	            'metadataService',
	            'hibachiPathBuilder',
	            'rbkeyService'
	        ];
	        return directive;
	    };
	    return SWCriteriaManyToOne;
	}());
	exports.SWCriteriaManyToOne = SWCriteriaManyToOne;
	// 'use strict';
	// angular.module('slatwalladmin')
	// .directive('swCriteriaManyToOne', [
	// 	'$log',
	// 	'$hibachi',
	// 	'$filter',
	// 	'collectionPartialsPath',
	// 	'collectionService',
	// 	'metadataService',
	// 	function(
	// 		$log,
	// 		$hibachi,
	// 		$filter,
	// 		collectionPartialsPath,
	// 		collectionService,
	// 		metadataService
	// 	){
	// 		return {
	// 			restrict: 'E',
	// 			templateUrl:collectionPartialsPath+'criteriamanytoone.html',
	// 			link: function(scope, element, attrs){
	// 				var getManyToOneOptions = function(){
	// 			    	var manyToOneOptions = {
	// 			            drillEntity:{},
	// 						hasEntity:{
	// 							display:"Defined",
	// 							comparisonOperator:"is not",
	// 							value:"null"
	// 						},
	// 						notHasEntity:{
	// 							display:"Not Defined",
	// 							comparisonOperator:"is",
	// 							value:"null"
	// 						}
	// 			    	};
	// 			    	return manyToOneOptions;
	// 			    };
	// 			    scope.manyToOneOptions = getManyToOneOptions();
	// 			    scope.conditionOptions = getManyToOneOptions();
	// 				$log.debug('many-to-one');
	// 				$log.debug(scope.selectedFilterProperty);
	// 				$log.debug(scope.filterPropertiesList);
	// 				scope.$watch('selectedFilterProperty',function(selectedFilterProperty){
	// 					if(angular.isUndefined(scope.filterPropertiesList[scope.selectedFilterProperty.propertyIdentifier])){
	// 						var filterPropertiesPromise = $hibachi.getFilterPropertiesByBaseEntityName(selectedFilterProperty.cfc);
	// 						filterPropertiesPromise.then(function(value){
	// 							scope.filterPropertiesList[scope.selectedFilterProperty.propertyIdentifier] = value;
	// 							metadataService.formatPropertiesList(scope.filterPropertiesList[scope.selectedFilterProperty.propertyIdentifier],scope.selectedFilterProperty.propertyIdentifier);
	// 						}, function(reason){
	// 						});
	// 					}
	// 					scope.selectedCriteriaChanged = function(selectedCriteria){
	// 						$log.debug(selectedCriteria);
	// 						$log.debug('changed');
	// 						//update breadcrumbs as array of filterpropertylist keys
	// 						$log.debug(scope.selectedFilterProperty);
	// 						var breadCrumb = {
	// 								entityAlias:scope.selectedFilterProperty.name,
	// 								cfc:scope.selectedFilterProperty.cfc,
	// 								propertyIdentifier:scope.selectedFilterProperty.propertyIdentifier,
	// 								rbKey:rbkeyService.getRBKey('entity.'+scope.selectedFilterProperty.cfc.replace('_',''))
	// 						};
	// 						$log.debug('breadcrumb');
	// 						$log.debug(breadCrumb);
	// 						$log.debug(scope.filterItem.breadCrumbs);
	// 						scope.filterItem.breadCrumbs.push(breadCrumb);
	// 						//populate editfilterinfo with the current level of the filter property we are inspecting by pointing to the new scope key
	// 						scope.selectedFilterPropertyChanged({selectedFilterProperty:scope.selectedFilterProperty.selectedCriteriaType});
	// 						//update criteria to display the condition of the new critera we have selected
	// 						$log.debug(scope.selectedFilterProperty);
	// 					};
	// 				});
	// 			}
	// 		};
	// 	}
	// ]);


/***/ },
/* 129 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWCriteriaNumber = (function () {
	    function SWCriteriaNumber($log, $hibachi, $filter, collectionPartialsPath, collectionService, metadataService, hibachiPathBuilder) {
	        return {
	            restrict: 'E',
	            templateUrl: hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + 'criterianumber.html',
	            link: function (scope, element, attrs) {
	                var getNumberOptions = function (type) {
	                    if (angular.isUndefined(type)) {
	                        type = 'filter';
	                    }
	                    var numberOptions = [];
	                    if (type === 'filter') {
	                        numberOptions = [
	                            {
	                                display: "Equals",
	                                comparisonOperator: "="
	                            },
	                            {
	                                display: "Doesn't Equal",
	                                comparisonOperator: "<>"
	                            },
	                            {
	                                display: "In Range",
	                                comparisonOperator: "between",
	                                type: "range"
	                            },
	                            {
	                                display: "Not In Range",
	                                comparisonOperator: "not between",
	                                type: "range"
	                            },
	                            {
	                                display: "Greater Than",
	                                comparisonOperator: ">"
	                            },
	                            {
	                                display: "Greater Than Or Equal",
	                                comparisonOperator: ">="
	                            },
	                            {
	                                display: "Less Than",
	                                comparisonOperator: "<"
	                            },
	                            {
	                                display: "Less Than Or Equal",
	                                comparisonOperator: "<="
	                            },
	                            {
	                                display: "In List",
	                                comparisonOperator: "in"
	                            },
	                            {
	                                display: "Not In List",
	                                comparisonOperator: "not in"
	                            },
	                            {
	                                display: "Defined",
	                                comparisonOperator: "is not",
	                                value: "null"
	                            },
	                            {
	                                display: "Not Defined",
	                                comparisonOperator: "is",
	                                value: "null"
	                            }
	                        ];
	                    }
	                    else if (type === 'condition') {
	                        numberOptions = [
	                            {
	                                display: "Equals",
	                                comparisonOperator: "eq"
	                            },
	                            {
	                                display: "Greater Than",
	                                comparisonOperator: "gt"
	                            },
	                            {
	                                display: "Greater Than Or Equal",
	                                comparisonOperator: "gte"
	                            },
	                            {
	                                display: "Less Than",
	                                comparisonOperator: "lt"
	                            },
	                            {
	                                display: "Less Than Or Equal",
	                                comparisonOperator: "lte"
	                            },
	                            {
	                                display: "Doesn't Equal",
	                                comparisonOperator: "neq"
	                            },
	                            {
	                                display: "Defined",
	                                comparisonOperator: "null",
	                                value: "False"
	                            },
	                            {
	                                display: "Not Defined",
	                                comparisonOperator: "null",
	                                value: "True"
	                            }
	                        ];
	                    }
	                    return numberOptions;
	                };
	                scope.$watch('selectedFilterProperty.criteriaValue', function (criteriaValue) {
	                    if (angular.isDefined(criteriaValue)) {
	                        scope.selectedFilterProperty.criteriaValue = criteriaValue;
	                        $log.debug(scope.selectedFilterProperty);
	                    }
	                });
	                scope.conditionOptions = getNumberOptions(scope.comparisonType);
	                scope.criteriaRangeChanged = function (selectedFilterProperty) {
	                    var selectedCondition = selectedFilterProperty.selectedCriteriaType;
	                };
	                scope.selectedConditionChanged = function (selectedFilterProperty) {
	                    selectedFilterProperty.showCriteriaValue = true;
	                    //check whether the type is a range
	                    if (angular.isDefined(selectedFilterProperty.selectedCriteriaType.type)) {
	                        selectedFilterProperty.showCriteriaValue = false;
	                        selectedFilterProperty.selectedCriteriaType.showCriteriaStart = true;
	                        selectedFilterProperty.selectedCriteriaType.showCriteriaEnd = true;
	                    }
	                    //is null or is not null
	                    if (angular.isDefined(selectedFilterProperty.selectedCriteriaType.value)) {
	                        selectedFilterProperty.showCriteriaValue = false;
	                    }
	                };
	                angular.forEach(scope.conditionOptions, function (conditionOption) {
	                    $log.debug('populate');
	                    if (conditionOption.display == scope.filterItem.conditionDisplay) {
	                        scope.selectedFilterProperty.selectedCriteriaType = conditionOption;
	                        $log.debug(scope.filterItem);
	                        if (scope.filterItem.comparisonOperator === 'between' || scope.filterItem.comparisonOperator === 'not between') {
	                            var criteriaRangeArray = scope.filterItem.value.split('-');
	                            $log.debug(criteriaRangeArray);
	                            scope.selectedFilterProperty.criteriaRangeStart = parseInt(criteriaRangeArray[0]);
	                            scope.selectedFilterProperty.criteriaRangeEnd = parseInt(criteriaRangeArray[1]);
	                        }
	                        else {
	                            scope.selectedFilterProperty.criteriaValue = scope.filterItem.value;
	                        }
	                        if (angular.isDefined(scope.filterItem.criteriaNumberOf)) {
	                            scope.selectedFilterProperty.criteriaNumberOf = scope.filterItem.criteriaNumberOf;
	                        }
	                        if (angular.isDefined(scope.selectedConditionChanged)) {
	                            scope.selectedConditionChanged(scope.selectedFilterProperty);
	                        }
	                    }
	                });
	            }
	        };
	    }
	    SWCriteriaNumber.Factory = function () {
	        var directive = function ($log, $hibachi, $filter, collectionPartialsPath, collectionService, metadataService, hibachiPathBuilder) { return new SWCriteriaNumber($log, $hibachi, $filter, collectionPartialsPath, collectionService, metadataService, hibachiPathBuilder); };
	        directive.$inject = [
	            '$log',
	            '$hibachi',
	            '$filter',
	            'collectionPartialsPath',
	            'collectionService',
	            'metadataService',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWCriteriaNumber;
	}());
	exports.SWCriteriaNumber = SWCriteriaNumber;


/***/ },
/* 130 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWCriteriaOneToMany = (function () {
	    function SWCriteriaOneToMany($log, $hibachi, $filter, collectionPartialsPath, collectionService, metadataService, dialogService, observerService, hibachiPathBuilder, rbkeyService) {
	        return {
	            restrict: 'E',
	            templateUrl: hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + 'criteriaonetomany.html',
	            link: function (scope, element, attrs) {
	                scope.data = {};
	                scope.collectionOptionsOpen = false;
	                scope.toggleCollectionOptions = function (flag) {
	                    scope.collectionOptionsOpen = (!angular.isUndefined(flag)) ? flag : !scope.collectionOptionsOpen;
	                };
	                scope.selectCollection = function (collection) {
	                    scope.toggleCollectionOptions();
	                    scope.selectedFilterProperty.selectedCollection = collection;
	                    scope.selectedFilterProperty.selectedCriteriaType = scope.oneToManyOptions[2];
	                };
	                scope.cleanSelection = function () {
	                    scope.toggleCollectionOptions(false);
	                    scope.data.collectionName = "";
	                    scope.selectedFilterProperty.selectedCollection = null;
	                };
	                var getOneToManyOptions = function (type) {
	                    if (angular.isUndefined(type)) {
	                        type = 'filter';
	                    }
	                    var oneToManyOptions = [];
	                    if (type == 'filter') {
	                        oneToManyOptions = [
	                            {
	                                display: "All Exist In Collection",
	                                comparisonOperator: "All"
	                            },
	                            {
	                                display: "None Exist In Collection",
	                                comparisonOperator: "None"
	                            },
	                            {
	                                display: "Some Exist In Collection",
	                                comparisonOperator: "One"
	                            }
	                        ];
	                    }
	                    else if (type === 'condition') {
	                        oneToManyOptions = [];
	                    }
	                    return oneToManyOptions;
	                };
	                $log.debug('onetomany');
	                $log.debug(scope.selectedFilterProperty);
	                scope.oneToManyOptions = getOneToManyOptions(scope.comparisonType);
	                var existingCollectionsPromise = $hibachi.getExistingCollectionsByBaseEntity(scope.selectedFilterProperty.cfc);
	                existingCollectionsPromise.then(function (value) {
	                    scope.collectionOptions = value.data;
	                    if (angular.isDefined(scope.filterItem.collectionID)) {
	                        for (var i in scope.collectionOptions) {
	                            if (scope.collectionOptions[i].collectionID === scope.filterItem.collectionID) {
	                                scope.selectedFilterProperty.selectedCollection = scope.collectionOptions[i];
	                            }
	                        }
	                        for (var i in scope.oneToManyOptions) {
	                            if (scope.oneToManyOptions[i].comparisonOperator === scope.filterItem.criteria) {
	                                scope.selectedFilterProperty.selectedCriteriaType = scope.oneToManyOptions[i];
	                            }
	                        }
	                    }
	                });
	                function populateUI(collection) {
	                    scope.collectionOptions.push(collection);
	                    scope.selectedFilterProperty.selectedCollection = collection;
	                    scope.selectedFilterProperty.selectedCriteriaType = scope.oneToManyOptions[2];
	                }
	                observerService.attach(populateUI, 'addCollection', 'addCollection');
	                scope.selectedCriteriaChanged = function (selectedCriteria) {
	                    $log.debug(selectedCriteria);
	                    //update breadcrumbs as array of filterpropertylist keys
	                    $log.debug(scope.selectedFilterProperty);
	                    var breadCrumb = {
	                        entityAlias: scope.selectedFilterProperty.name,
	                        cfc: scope.selectedFilterProperty.cfc,
	                        propertyIdentifier: scope.selectedFilterProperty.propertyIdentifier,
	                        rbKey: rbkeyService.getRBKey('entity.' + scope.selectedFilterProperty.cfc.replace('_', '')),
	                        filterProperty: scope.selectedFilterProperty
	                    };
	                    scope.filterItem.breadCrumbs.push(breadCrumb);
	                    $log.debug('criteriaChanged');
	                    //$log.debug(selectedFilterPropertyChanged);
	                    $log.debug(scope.selectedFilterProperty);
	                    //populate editfilterinfo with the current level of the filter property we are inspecting by pointing to the new scope key
	                    scope.selectedFilterPropertyChanged({ selectedFilterProperty: scope.selectedFilterProperty.selectedCriteriaType });
	                    //update criteria to display the condition of the new critera we have selected
	                };
	                scope.addNewCollection = function () {
	                    dialogService.addPageDialog('org/Hibachi/client/src/collection/components/criteriacreatecollection', {
	                        entityName: scope.selectedFilterProperty.cfc,
	                        collectionName: scope.data.collectionName,
	                        parentEntity: scope.collectionConfig.baseEntityName
	                    });
	                    scope.cleanSelection();
	                };
	                scope.viewSelectedCollection = function () {
	                    scope.toggleCollectionOptions();
	                    dialogService.addPageDialog('org/Hibachi/client/src/collection/components/criteriacreatecollection', {
	                        entityName: 'collection',
	                        entityId: scope.selectedFilterProperty.selectedCollection.collectionID,
	                        parentEntity: scope.collectionConfig.baseEntityName
	                    });
	                };
	            }
	        };
	    }
	    SWCriteriaOneToMany.Factory = function () {
	        var directive = function ($log, $hibachi, $filter, collectionPartialsPath, collectionService, metadataService, dialogService, observerService, hibachiPathBuilder, rbkeyService) { return new SWCriteriaOneToMany($log, $hibachi, $filter, collectionPartialsPath, collectionService, metadataService, dialogService, observerService, hibachiPathBuilder, rbkeyService); };
	        directive.$inject = [
	            '$log',
	            '$hibachi',
	            '$filter',
	            'collectionPartialsPath',
	            'collectionService',
	            'metadataService',
	            'dialogService',
	            'observerService',
	            'hibachiPathBuilder',
	            'rbkeyService'
	        ];
	        return directive;
	    };
	    return SWCriteriaOneToMany;
	}());
	exports.SWCriteriaOneToMany = SWCriteriaOneToMany;


/***/ },
/* 131 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWCriteriaRelatedObject = (function () {
	    function SWCriteriaRelatedObject($log, $hibachi, $filter, collectionPartialsPath, collectionService, metadataService, hibachiPathBuilder, rbkeyService) {
	        return {
	            restrict: 'E',
	            templateUrl: hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + 'criteriarelatedobject.html',
	            link: function (scope, element, attrs) {
	                var getRelatedObjectOptions = function () {
	                    var relatedObjectOptions = {
	                        drillEntity: null,
	                        hasEntity: {
	                            display: "Defined",
	                            comparisonOperator: "is not",
	                            value: "null"
	                        },
	                        notHasEntity: {
	                            display: "Not Defined",
	                            comparisonOperator: "is",
	                            value: "null"
	                        },
	                        aggregate: {
	                            aggregate: ""
	                        }
	                    };
	                    return relatedObjectOptions;
	                };
	                scope.aggegate = {};
	                scope.aggegate.selectedAggregate = '';
	                scope.aggregateOptions = ['Average', 'Count', 'Sum'];
	                scope.selectAggregate = function (aggregate) {
	                    scope.selectedFilterProperty.selectedCriteriaType.aggregate = aggregate;
	                };
	                scope.relatedObjectOptions = getRelatedObjectOptions();
	                scope.conditionOptions = getRelatedObjectOptions();
	                $log.debug('many-to-one');
	                $log.debug(scope.selectedFilterProperty);
	                $log.debug(scope.filterPropertiesList);
	                scope.$watch('selectedFilterProperty', function (selectedFilterProperty) {
	                    if (angular.isUndefined(scope.filterPropertiesList[scope.selectedFilterProperty.propertyIdentifier])) {
	                        var filterPropertiesPromise = $hibachi.getFilterPropertiesByBaseEntityName(selectedFilterProperty.cfc);
	                        filterPropertiesPromise.then(function (value) {
	                            scope.filterPropertiesList[scope.selectedFilterProperty.propertyIdentifier] = value;
	                            metadataService.formatPropertiesList(scope.filterPropertiesList[scope.selectedFilterProperty.propertyIdentifier], scope.selectedFilterProperty.propertyIdentifier);
	                        }, function (reason) {
	                        });
	                    }
	                    scope.selectedCriteriaChanged = function (selectedCriteria, selectedAggregate) {
	                        var breadCrumb = {
	                            entityAlias: scope.selectedFilterProperty.name,
	                            cfc: scope.selectedFilterProperty.cfc,
	                            propertyIdentifier: scope.selectedFilterProperty.propertyIdentifier,
	                            rbKey: rbkeyService.getRBKey('entity.' + scope.selectedFilterProperty.cfc.replace('_', ''))
	                        };
	                        $log.debug('breadcrumb');
	                        $log.debug(breadCrumb);
	                        $log.debug(scope.filterItem.breadCrumbs);
	                        scope.filterItem.breadCrumbs.push(breadCrumb);
	                        if (selectedAggregate) {
	                            scope.selectedFilterProperty.selectedCriteriaType.ormtype = 'integer';
	                            scope.selectedFilterProperty.selectedCriteriaType.aggregate = selectedAggregate;
	                        }
	                        //populate editfilterinfo with the current level of the filter property we are inspecting by pointing to the new scope key
	                        scope.selectedFilterPropertyChanged({ selectedFilterProperty: scope.selectedFilterProperty.selectedCriteriaType });
	                        //update criteria to display the condition of the new critera we have selected
	                        $log.debug(scope.selectedFilterProperty);
	                    };
	                });
	            }
	        };
	    }
	    SWCriteriaRelatedObject.Factory = function () {
	        var directive = function ($log, $hibachi, $filter, collectionPartialsPath, collectionService, metadataService, hibachiPathBuilder, rbkeyService) { return new SWCriteriaRelatedObject($log, $hibachi, $filter, collectionPartialsPath, collectionService, metadataService, hibachiPathBuilder, rbkeyService); };
	        directive.$inject = [
	            '$log',
	            '$hibachi',
	            '$filter',
	            'collectionPartialsPath',
	            'collectionService',
	            'metadataService',
	            'hibachiPathBuilder',
	            'rbkeyService'
	        ];
	        return directive;
	    };
	    return SWCriteriaRelatedObject;
	}());
	exports.SWCriteriaRelatedObject = SWCriteriaRelatedObject;


/***/ },
/* 132 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWCriteriaString = (function () {
	    function SWCriteriaString($log, $hibachi, $filter, collectionPartialsPath, collectionService, metadataService, hibachiPathBuilder) {
	        return {
	            restrict: 'E',
	            templateUrl: hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + 'criteriastring.html',
	            link: function (scope, element, attrs) {
	                var getStringOptions = function (type) {
	                    if (angular.isUndefined(type)) {
	                        type = 'filter';
	                    }
	                    var stringOptions = [];
	                    if (type === 'filter') {
	                        stringOptions = [
	                            {
	                                display: "Equals",
	                                comparisonOperator: "="
	                            },
	                            {
	                                display: "Doesn't Equal",
	                                comparisonOperator: "<>"
	                            },
	                            {
	                                display: "Contains",
	                                comparisonOperator: "like",
	                                pattern: "%w%"
	                            },
	                            {
	                                display: "Doesn't Contain",
	                                comparisonOperator: "not like",
	                                pattern: "%w%"
	                            },
	                            {
	                                display: "Starts With",
	                                comparisonOperator: "like",
	                                pattern: "w%"
	                            },
	                            {
	                                display: "Doesn't Start With",
	                                comparisonOperator: "not like",
	                                pattern: "w%"
	                            },
	                            {
	                                display: "Ends With",
	                                comparisonOperator: "like",
	                                pattern: "%w"
	                            },
	                            {
	                                display: "Doesn't End With",
	                                comparisonOperator: "not like",
	                                pattern: "%w"
	                            },
	                            {
	                                display: "In List",
	                                comparisonOperator: "in"
	                            },
	                            {
	                                display: "Not In List",
	                                comparisonOperator: "not in"
	                            },
	                            {
	                                display: "Defined",
	                                comparisonOperator: "is not",
	                                value: "null"
	                            },
	                            {
	                                display: "Not Defined",
	                                comparisonOperator: "is",
	                                value: "null"
	                            }
	                        ];
	                    }
	                    else if (type === 'condition') {
	                        stringOptions = [
	                            {
	                                display: "Equals",
	                                comparisonOperator: "eq"
	                            },
	                            {
	                                display: "Doesn't Equal",
	                                comparisonOperator: "neq"
	                            },
	                            {
	                                display: "Defined",
	                                comparisonOperator: "null",
	                                value: "False"
	                            },
	                            {
	                                display: "Not Defined",
	                                comparisonOperator: "null",
	                                value: "True"
	                            }
	                        ];
	                    }
	                    return stringOptions;
	                };
	                //initialize values
	                scope.conditionOptions = getStringOptions(scope.comparisonType);
	                scope.inListArray = [];
	                if (angular.isDefined(scope.filterItem.value)) {
	                    scope.inListArray = scope.filterItem.value.split(',');
	                }
	                scope.newListItem = '';
	                //declare functions
	                scope.addToValueInListFormat = function (inListItem) {
	                    // Adds item into array
	                    scope.inListArray.push(inListItem);
	                    //set value field to the user generated list
	                    scope.filterItem.value = scope.inListArray.toString();
	                    scope.filterItem.displayValue = scope.inListArray.toString().replace(/,/g, ', ');
	                    scope.newListItem = '';
	                };
	                scope.removelistItem = function (argListIndex) {
	                    scope.inListArray.splice(argListIndex, 1);
	                    scope.filterItem.value = scope.inListArray.toString();
	                    scope.filterItem.displayValue = scope.inListArray.toString().replace(/,/g, ', ');
	                };
	                scope.clearField = function () {
	                    scope.newListItem = '';
	                };
	                scope.selectedConditionChanged = function (selectedFilterProperty) {
	                    //scope.selectedFilterProperty.criteriaValue = '';
	                    if (angular.isDefined(selectedFilterProperty.selectedCriteriaType.value)) {
	                        selectedFilterProperty.showCriteriaValue = false;
	                    }
	                    else {
	                        if (selectedFilterProperty.selectedCriteriaType.comparisonOperator === 'in' || selectedFilterProperty.selectedCriteriaType.comparisonOperator === 'not in') {
	                            selectedFilterProperty.showCriteriaValue = false;
	                            scope.comparisonOperatorInAndNotInFlag = true;
	                        }
	                        else {
	                            selectedFilterProperty.showCriteriaValue = true;
	                        }
	                    }
	                };
	                scope.$watch('filterItem.value', function (criteriaValue) {
	                    //remove percents for like values
	                    if (angular.isDefined(scope.filterItem) && angular.isDefined(scope.filterItem.value)) {
	                        scope.filterItem.value = scope.filterItem.value.replace('%', '');
	                    }
	                });
	                scope.$watch('selectedFilterProperty', function (selectedFilterProperty) {
	                    if (angular.isDefined(selectedFilterProperty)) {
	                        angular.forEach(scope.conditionOptions, function (conditionOption) {
	                            if (conditionOption.display == scope.filterItem.conditionDisplay) {
	                                scope.selectedFilterProperty.selectedCriteriaType = conditionOption;
	                                scope.selectedFilterProperty.criteriaValue = scope.filterItem.value;
	                                if (angular.isDefined(scope.selectedConditionChanged)) {
	                                    scope.selectedConditionChanged(scope.selectedFilterProperty);
	                                }
	                            }
	                        });
	                    }
	                });
	            }
	        };
	    }
	    SWCriteriaString.Factory = function () {
	        var directive = function ($log, $hibachi, $filter, collectionPartialsPath, collectionService, metadataService, hibachiPathBuilder) { return new SWCriteriaString($log, $hibachi, $filter, collectionPartialsPath, collectionService, metadataService, hibachiPathBuilder); };
	        directive.$inject = [
	            '$log',
	            '$hibachi',
	            '$filter',
	            'collectionPartialsPath',
	            'collectionService',
	            'metadataService',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWCriteriaString;
	}());
	exports.SWCriteriaString = SWCriteriaString;


/***/ },
/* 133 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWEditFilterItem = (function () {
	    function SWEditFilterItem($log, $filter, $timeout, $hibachi, collectionPartialsPath, collectionService, metadataService, hibachiPathBuilder, rbkeyService, observerService) {
	        return {
	            require: '^swFilterGroups',
	            restrict: 'E',
	            scope: {
	                collectionConfig: "=",
	                filterItem: "=",
	                filterPropertiesList: "=",
	                saveCollection: "&",
	                removeFilterItem: "&",
	                filterItemIndex: "=",
	                comparisonType: "=",
	                simple: "="
	            },
	            templateUrl: hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + "editfilteritem.html",
	            link: function (scope, element, attrs, filterGroupsController) {
	                function daysBetween(first, second) {
	                    // Copy date parts of the timestamps, discarding the time parts.
	                    var one = new Date(first.getFullYear(), first.getMonth(), first.getDate());
	                    var two = new Date(second.getFullYear(), second.getMonth(), second.getDate());
	                    // Do the math.
	                    var millisecondsPerDay = 1000 * 60 * 60 * 24;
	                    var millisBetween = two.getTime() - one.getTime();
	                    var days = millisBetween / millisecondsPerDay;
	                    // Round down.
	                    return Math.floor(days);
	                }
	                if (angular.isUndefined(scope.filterItem.breadCrumbs)) {
	                    scope.filterItem.breadCrumbs = [];
	                    if (scope.filterItem.propertyIdentifier === "") {
	                        scope.filterItem.breadCrumbs = [
	                            {
	                                rbKey: rbkeyService.getRBKey('entity.' + scope.collectionConfig.baseEntityAlias.replace('_', '')),
	                                entityAlias: scope.collectionConfig.baseEntityAlias,
	                                cfc: scope.collectionConfig.baseEntityAlias,
	                                propertyIdentifier: scope.collectionConfig.baseEntityAlias
	                            }
	                        ];
	                    }
	                    else {
	                        var entityAliasArrayFromString = scope.filterItem.propertyIdentifier.split('.');
	                        entityAliasArrayFromString.pop();
	                        for (var i in entityAliasArrayFromString) {
	                            var breadCrumb = {
	                                rbKey: rbkeyService.getRBKey('entity.' + scope.collectionConfig.baseEntityAlias.replace('_', '')),
	                                entityAlias: entityAliasArrayFromString[i],
	                                cfc: entityAliasArrayFromString[i],
	                                propertyIdentifier: entityAliasArrayFromString[i]
	                            };
	                            scope.filterItem.breadCrumbs.push(breadCrumb);
	                        }
	                    }
	                }
	                else {
	                    angular.forEach(scope.filterItem.breadCrumbs, function (breadCrumb, key) {
	                        if (angular.isUndefined(scope.filterPropertiesList[breadCrumb.propertyIdentifier])) {
	                            var filterPropertiesPromise = $hibachi.getFilterPropertiesByBaseEntityName(breadCrumb.cfc);
	                            filterPropertiesPromise.then(function (value) {
	                                metadataService.setPropertiesList(value, breadCrumb.propertyIdentifier);
	                                scope.filterPropertiesList[breadCrumb.propertyIdentifier] = metadataService.getPropertiesListByBaseEntityAlias(breadCrumb.propertyIdentifier);
	                                metadataService.formatPropertiesList(scope.filterPropertiesList[breadCrumb.propertyIdentifier], breadCrumb.propertyIdentifier);
	                                var entityAliasArrayFromString = scope.filterItem.propertyIdentifier.split('.');
	                                entityAliasArrayFromString.pop();
	                                entityAliasArrayFromString = entityAliasArrayFromString.join('.').trim();
	                                if (angular.isDefined(scope.filterPropertiesList[entityAliasArrayFromString])) {
	                                    for (var i in scope.filterPropertiesList[entityAliasArrayFromString].data) {
	                                        var filterProperty = scope.filterPropertiesList[entityAliasArrayFromString].data[i];
	                                        if (filterProperty.propertyIdentifier === scope.filterItem.propertyIdentifier) {
	                                            //selectItem from drop down
	                                            scope.selectedFilterProperty = filterProperty;
	                                            //decorate with value and comparison Operator so we can use it in the Condition section
	                                            scope.selectedFilterProperty.value = scope.filterItem.value;
	                                            scope.selectedFilterProperty.comparisonOperator = scope.filterItem.comparisonOperator;
	                                        }
	                                    }
	                                }
	                            });
	                        }
	                        else {
	                            var entityAliasArrayFromString = scope.filterItem.propertyIdentifier.split('.');
	                            entityAliasArrayFromString.pop();
	                            entityAliasArrayFromString = entityAliasArrayFromString.join('.').trim();
	                            if (angular.isDefined(scope.filterPropertiesList[entityAliasArrayFromString])) {
	                                for (var i in scope.filterPropertiesList[entityAliasArrayFromString].data) {
	                                    var filterProperty = scope.filterPropertiesList[entityAliasArrayFromString].data[i];
	                                    if (filterProperty.propertyIdentifier === scope.filterItem.propertyIdentifier) {
	                                        //selectItem from drop down
	                                        scope.selectedFilterProperty = filterProperty;
	                                        //decorate with value and comparison Operator so we can use it in the Condition section
	                                        scope.selectedFilterProperty.value = scope.filterItem.value;
	                                        scope.selectedFilterProperty.comparisonOperator = scope.filterItem.comparisonOperator;
	                                    }
	                                }
	                            }
	                        }
	                    });
	                }
	                if (angular.isUndefined(scope.filterItem.$$isClosed)) {
	                    scope.filterItem.$$isClosed = true;
	                }
	                scope.filterGroupItem = filterGroupsController.getFilterGroupItem();
	                scope.togglePrepareForFilterGroup = function () {
	                    scope.filterItem.$$prepareForFilterGroup = !scope.filterItem.$$prepareForFilterGroup;
	                };
	                //public functions
	                scope.selectBreadCrumb = function (breadCrumbIndex) {
	                    //splice out array items above index
	                    var removeCount = scope.filterItem.breadCrumbs.length - 1 - breadCrumbIndex;
	                    scope.filterItem.breadCrumbs.splice(breadCrumbIndex + 1, removeCount);
	                    $log.debug('selectBreadCrumb');
	                    $log.debug(scope.selectedFilterProperty);
	                    //scope.selectedFilterPropertyChanged(scope.filterItem.breadCrumbs[scope.filterItem.breadCrumbs.length -1].filterProperty);
	                    scope.selectedFilterPropertyChanged(null);
	                };
	                scope.selectedFilterPropertyChanged = function (selectedFilterProperty) {
	                    $log.debug('selectedFilterProperty');
	                    $log.debug(selectedFilterProperty);
	                    if (angular.isDefined(scope.selectedFilterProperty) && scope.selectedFilterProperty === null) {
	                        scope.selectedFilterProperty = {};
	                    }
	                    if (angular.isDefined(scope.selectedFilterProperty) && angular.isDefined(scope.selectedFilterProperty.selectedCriteriaType)) {
	                        delete scope.selectedFilterProperty.selectedCriteriaType;
	                    }
	                    if (angular.isDefined(scope.filterItem.value)) {
	                        delete scope.filterItem.value;
	                    }
	                    scope.selectedFilterProperty.showCriteriaValue = false;
	                    scope.selectedFilterProperty = selectedFilterProperty;
	                };
	                scope.addFilterItem = function () {
	                    collectionService.newFilterItem(filterGroupsController.getFilterGroupItem(), filterGroupsController.setItemInUse);
	                };
	                scope.cancelFilterItem = function () {
	                    $log.debug('cancelFilterItem');
	                    $log.debug(scope.filterItemIndex);
	                    //scope.deselectItems(scope.filterGroupItem[filterItemIndex]);
	                    scope.filterItem.setItemInUse(false);
	                    scope.filterItem.$$isClosed = true;
	                    for (var siblingIndex in scope.filterItem.$$siblingItems) {
	                        scope.filterItem.$$siblingItems[siblingIndex].$$disabled = false;
	                    }
	                    if (scope.filterItem.$$isNew === true) {
	                        observerService.notify('filterItemAction', { action: 'remove', filterItemIndex: scope.filterItemIndex });
	                        scope.removeFilterItem({ filterItemIndex: scope.filterItemIndex });
	                    }
	                    else {
	                        observerService.notify('filterItemAction', { action: 'close', filterItemIndex: scope.filterItemIndex });
	                    }
	                };
	                scope.saveFilter = function (selectedFilterProperty, filterItem, callback) {
	                    $log.debug('saveFilter begin');
	                    if (angular.isDefined(selectedFilterProperty.selectedCriteriaType) && angular.equals({}, selectedFilterProperty.selectedCriteriaType)) {
	                        return;
	                    }
	                    if ((selectedFilterProperty.propertyIdentifier.match(/_/g) || []).length > 1) {
	                        var propertyIdentifierStart = (selectedFilterProperty.propertyIdentifier.charAt(0) == '_') ? 1 : 0;
	                        var propertyIdentifierEnd = (selectedFilterProperty.propertyIdentifier.indexOf('.') == -1) ? selectedFilterProperty.propertyIdentifier.length : selectedFilterProperty.propertyIdentifier.indexOf('.');
	                        var propertyIdentifierJoins = selectedFilterProperty.propertyIdentifier.substring(propertyIdentifierStart, propertyIdentifierEnd);
	                        var propertyIdentifierParts = propertyIdentifierJoins.split('_');
	                        var current_collection = $hibachi.getEntityExample(scope.collectionConfig.baseEntityName);
	                        var _propertyIdentifier = '';
	                        var joins = [];
	                        if (angular.isDefined(scope.collectionConfig.joins)) {
	                            joins = scope.collectionConfig.joins;
	                        }
	                        for (var i = 1; i < propertyIdentifierParts.length; i++) {
	                            if (angular.isDefined(current_collection.metaData[propertyIdentifierParts[i]]) && ('cfc' in current_collection.metaData[propertyIdentifierParts[i]])) {
	                                current_collection = $hibachi.getEntityExample(current_collection.metaData[propertyIdentifierParts[i]].cfc);
	                                _propertyIdentifier += '_' + propertyIdentifierParts[i];
	                                var newJoin = {
	                                    associationName: _propertyIdentifier.replace(/_([^_]+)$/, '.$1').substring(1),
	                                    alias: '_' + propertyIdentifierParts[0] + _propertyIdentifier
	                                };
	                                var joinFound = false;
	                                for (var j = 0; j < joins.length; j++) {
	                                    if (joins[j].alias === newJoin.alias) {
	                                        joinFound = true;
	                                        break;
	                                    }
	                                }
	                                if (!joinFound) {
	                                    joins.push(newJoin);
	                                }
	                            }
	                        }
	                        scope.collectionConfig.joins = joins;
	                        if (angular.isDefined(scope.collectionConfig.columns) && (angular.isUndefined(scope.collectionConfig.groupBys) || scope.collectionConfig.groupBys.split(',').length != scope.collectionConfig.columns.length)) {
	                            var groupbyArray = angular.isUndefined(scope.collectionConfig.groupBys) ? [] : scope.collectionConfig.groupBys.split(',');
	                            for (var column = 0; column < scope.collectionConfig.columns.length; column++) {
	                                if (groupbyArray.indexOf(scope.collectionConfig.columns[column].propertyIdentifier) == -1) {
	                                    groupbyArray.push(scope.collectionConfig.columns[column].propertyIdentifier);
	                                }
	                            }
	                            scope.collectionConfig.groupBys = groupbyArray.join(',');
	                        }
	                    }
	                    if (angular.isDefined(selectedFilterProperty) && angular.isDefined(selectedFilterProperty.selectedCriteriaType)) {
	                        //populate filterItem with selectedFilterProperty values
	                        filterItem.$$isNew = false;
	                        filterItem.propertyIdentifier = selectedFilterProperty.propertyIdentifier;
	                        filterItem.displayPropertyIdentifier = selectedFilterProperty.displayPropertyIdentifier;
	                        switch (selectedFilterProperty.ormtype) {
	                            case 'boolean':
	                                filterItem.comparisonOperator = selectedFilterProperty.selectedCriteriaType.comparisonOperator;
	                                filterItem.value = selectedFilterProperty.selectedCriteriaType.value;
	                                filterItem.displayValue = filterItem.value;
	                                break;
	                            case 'string':
	                                if (angular.isDefined(selectedFilterProperty.attributeID)) {
	                                    filterItem.attributeID = selectedFilterProperty.attributeID;
	                                    filterItem.attributeSetObject = selectedFilterProperty.attributeSetObject;
	                                }
	                                filterItem.comparisonOperator = selectedFilterProperty.selectedCriteriaType.comparisonOperator;
	                                //retrieving implied value or user input | ex. implied:prop is null, user input:prop = "Name"
	                                if (angular.isDefined(selectedFilterProperty.selectedCriteriaType.value)) {
	                                    filterItem.value = selectedFilterProperty.selectedCriteriaType.value;
	                                }
	                                else if (angular.isDefined(selectedFilterProperty.selectedCriteriaType.pattern)) {
	                                    filterItem.pattern = selectedFilterProperty.selectedCriteriaType.pattern;
	                                }
	                                filterItem.displayValue = filterItem.value;
	                                break;
	                            //TODO:simplify timestamp and big decimal to leverage reusable function for null, range, and value
	                            case 'timestamp':
	                                //retrieving implied value or user input | ex. implied:prop is null, user input:prop = "Name"
	                                filterItem.comparisonOperator = selectedFilterProperty.selectedCriteriaType.comparisonOperator;
	                                //is it null or a range
	                                if (angular.isDefined(selectedFilterProperty.selectedCriteriaType.value)) {
	                                    filterItem.value = selectedFilterProperty.selectedCriteriaType.value;
	                                    filterItem.displayValue = filterItem.value;
	                                }
	                                else {
	                                    if (angular.isDefined(selectedFilterProperty.selectedCriteriaType.dateInfo.type) && selectedFilterProperty.selectedCriteriaType.dateInfo.type === 'calculation') {
	                                        var _daysBetween = daysBetween(new Date(selectedFilterProperty.criteriaRangeStart), new Date(selectedFilterProperty.criteriaRangeEnd));
	                                        filterItem.value = _daysBetween;
	                                        filterItem.displayValue = selectedFilterProperty.selectedCriteriaType.display;
	                                        if (angular.isDefined(selectedFilterProperty.criteriaNumberOf)) {
	                                            filterItem.criteriaNumberOf = selectedFilterProperty.criteriaNumberOf;
	                                        }
	                                    }
	                                    else if (angular.isDefined(selectedFilterProperty.selectedCriteriaType.dateInfo.type) && selectedFilterProperty.selectedCriteriaType.dateInfo.type === 'exactDate') {
	                                        if (angular.isUndefined(selectedFilterProperty.selectedCriteriaType.dateInfo.measureType)) {
	                                            filterItem.value = selectedFilterProperty.criteriaRangeStart + '-' + selectedFilterProperty.criteriaRangeEnd;
	                                            filterItem.displayValue = $filter('date')(angular.copy(selectedFilterProperty.criteriaRangeStart), 'MM/dd/yyyy @ h:mma') + '-' + $filter('date')(angular.copy(selectedFilterProperty.criteriaRangeEnd), 'MM/dd/yyyy @ h:mma');
	                                        }
	                                        else {
	                                            filterItem.measureType = selectedFilterProperty.selectedCriteriaType.dateInfo.measureType;
	                                            filterItem.measureCriteria = selectedFilterProperty.selectedCriteriaType.dateInfo.type;
	                                            filterItem.criteriaNumberOf = "0";
	                                            if (angular.isDefined(selectedFilterProperty.criteriaNumberOf)) {
	                                                filterItem.criteriaNumberOf = selectedFilterProperty.criteriaNumberOf;
	                                            }
	                                            filterItem.value = filterItem.criteriaNumberOf;
	                                            filterItem.displayValue = filterItem.criteriaNumberOf;
	                                            switch (filterItem.measureType) {
	                                                case 'd':
	                                                    filterItem.displayValue += ' Day';
	                                                    break;
	                                                case 'm':
	                                                    filterItem.displayValue += ' Month';
	                                                    break;
	                                                case 'y':
	                                                    filterItem.displayValue += ' Year';
	                                                    break;
	                                            }
	                                            filterItem.displayValue += ((filterItem.criteriaNumberOf > 1) ? 's' : '') + ' Ago';
	                                        }
	                                    }
	                                    else {
	                                        var dateValueString = selectedFilterProperty.criteriaRangeStart + '-' + selectedFilterProperty.criteriaRangeEnd;
	                                        filterItem.value = dateValueString;
	                                        var formattedDateValueString = $filter('date')(angular.copy(selectedFilterProperty.criteriaRangeStart), 'MM/dd/yyyy @ h:mma') + '-' + $filter('date')(angular.copy(selectedFilterProperty.criteriaRangeEnd), 'MM/dd/yyyy @ h:mma');
	                                        filterItem.displayValue = formattedDateValueString;
	                                        if (angular.isDefined(selectedFilterProperty.criteriaNumberOf)) {
	                                            filterItem.criteriaNumberOf = selectedFilterProperty.criteriaNumberOf;
	                                        }
	                                    }
	                                }
	                                break;
	                            case 'big_decimal':
	                            case 'integer':
	                            case 'float':
	                                filterItem.comparisonOperator = selectedFilterProperty.selectedCriteriaType.comparisonOperator;
	                                //is null, is not null
	                                if (angular.isDefined(selectedFilterProperty.selectedCriteriaType.value)) {
	                                    filterItem.value = selectedFilterProperty.selectedCriteriaType.value;
	                                }
	                                else {
	                                    if (angular.isUndefined(selectedFilterProperty.selectedCriteriaType.type)) {
	                                        filterItem.value = selectedFilterProperty.criteriaValue;
	                                    }
	                                    else {
	                                        var decimalValueString = selectedFilterProperty.criteriaRangeStart + '-' + selectedFilterProperty.criteriaRangeEnd;
	                                        filterItem.value = decimalValueString;
	                                    }
	                                }
	                                if (angular.isDefined(selectedFilterProperty.aggregate)) {
	                                    filterItem.aggregate = selectedFilterProperty.aggregate;
	                                }
	                                filterItem.displayValue = filterItem.value;
	                                break;
	                        }
	                        switch (selectedFilterProperty.fieldtype) {
	                            case 'one-to-many':
	                            case 'many-to-many':
	                            case 'many-to-one':
	                                filterItem.comparisonOperator = selectedFilterProperty.selectedCriteriaType.comparisonOperator;
	                                //is null, is not null
	                                if (angular.isDefined(selectedFilterProperty.selectedCriteriaType.value)) {
	                                    filterItem.value = selectedFilterProperty.selectedCriteriaType.value;
	                                }
	                                filterItem.displayValue = filterItem.value;
	                                break;
	                        }
	                        if (angular.isUndefined(filterItem.displayValue)) {
	                            filterItem.displayValue = filterItem.value;
	                        }
	                        if (angular.isDefined(selectedFilterProperty.ormtype)) {
	                            filterItem.ormtype = selectedFilterProperty.ormtype;
	                        }
	                        if (angular.isDefined(selectedFilterProperty.fieldtype)) {
	                            filterItem.fieldtype = selectedFilterProperty.fieldtype;
	                        }
	                        for (var siblingIndex in filterItem.$$siblingItems) {
	                            filterItem.$$siblingItems[siblingIndex].$$disabled = false;
	                        }
	                        filterItem.conditionDisplay = selectedFilterProperty.selectedCriteriaType.display;
	                        //if the add to New group checkbox has been checked then we need to transplant the filter item into a filter group
	                        if (filterItem.$$prepareForFilterGroup === true) {
	                            collectionService.transplantFilterItemIntoFilterGroup(filterGroupsController.getFilterGroupItem(), filterItem);
	                        }
	                        //persist Config and 
	                        scope.saveCollection();
	                        $log.debug(selectedFilterProperty);
	                        $log.debug(filterItem);
	                        observerService.notify('filterItemAction', { action: 'add', filterItemIndex: scope.filterItemIndex });
	                        $timeout(function () {
	                            callback();
	                        });
	                        $log.debug('saveFilter end');
	                    }
	                };
	            }
	        };
	    }
	    SWEditFilterItem.Factory = function () {
	        var directive = function ($log, $filter, $timeout, $hibachi, collectionPartialsPath, collectionService, metadataService, hibachiPathBuilder, rbkeyService, observerService) { return new SWEditFilterItem($log, $filter, $timeout, $hibachi, collectionPartialsPath, collectionService, metadataService, hibachiPathBuilder, rbkeyService, observerService); };
	        directive.$inject = [
	            '$log',
	            '$filter',
	            '$timeout',
	            '$hibachi',
	            'collectionPartialsPath',
	            'collectionService',
	            'metadataService',
	            'hibachiPathBuilder',
	            'rbkeyService',
	            'observerService'
	        ];
	        return directive;
	    };
	    return SWEditFilterItem;
	}());
	exports.SWEditFilterItem = SWEditFilterItem;


/***/ },
/* 134 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWFilterGroups = (function () {
	    function SWFilterGroups($log, collectionPartialsPath, hibachiPathBuilder) {
	        return {
	            restrict: 'EA',
	            scope: {
	                collectionConfig: "=?",
	                filterGroupItem: "=?",
	                filterPropertiesList: "=?",
	                saveCollection: "&",
	                filterGroup: "=?",
	                comparisonType: "=?",
	                simple: "=",
	                readOnly: "="
	            },
	            templateUrl: hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + "filtergroups.html",
	            controller: ['$scope', '$element', '$attrs', function ($scope, $element, $attrs) {
	                    //if the filter group comparisontype is not specified, then assume we are doing filters
	                    if (!angular.isDefined($scope.comparisonType)) {
	                        $scope.comparisonType = 'filter';
	                    }
	                    $scope.itemInUse = false;
	                    $log.debug('collectionConfig');
	                    $log.debug($scope.collectionConfig);
	                    this.getFilterGroup = function () {
	                        return $scope.filterGroup;
	                    };
	                    this.getFilterGroupItem = function () {
	                        return $scope.filterGroupItem;
	                    };
	                    this.setItemInUse = function (booleanValue) {
	                        $scope.itemInUse = booleanValue;
	                    };
	                    this.getItemInUse = function () {
	                        return $scope.itemInUse;
	                    };
	                    this.saveCollection = function () {
	                        $scope.saveCollection();
	                    };
	                    $scope.deselectItems = function (filterItem) {
	                        for (var i in filterItem.$$siblingItems) {
	                            filterItem.$$siblingItems[i].$$disabled = false;
	                        }
	                    };
	                    this.removeFilterItem = function (filterItemIndex) {
	                        if (angular.isDefined(filterItemIndex)) {
	                            $scope.deselectItems($scope.filterGroupItem[filterItemIndex]);
	                            $scope.filterGroupItem[filterItemIndex].setItemInUse(false);
	                            //remove item
	                            $log.debug('removeFilterItem');
	                            $log.debug(filterItemIndex);
	                            $scope.filterGroupItem.splice(filterItemIndex, 1);
	                            //make sure first item has no logical operator if it exists
	                            if ($scope.filterGroupItem.length) {
	                                delete $scope.filterGroupItem[0].logicalOperator;
	                            }
	                            $log.debug('removeFilterItem');
	                            $log.debug(filterItemIndex);
	                            $scope.saveCollection();
	                        }
	                    };
	                    this.removeFilterGroupItem = function (filterGroupItemIndex) {
	                        //remove Item
	                        $scope.deselectItems($scope.filterGroupItem[filterGroupItemIndex]);
	                        $scope.filterGroupItem[filterGroupItemIndex].setItemInUse(false);
	                        $scope.filterGroupItem.splice(filterGroupItemIndex, 1);
	                        //make sure first item has no logical operator if it exists
	                        if ($scope.filterGroupItem.length) {
	                            delete $scope.filterGroupItem[0].logicalOperator;
	                        }
	                        $log.debug('removeFilterGroupItem');
	                        $log.debug(filterGroupItemIndex);
	                        $scope.saveCollection();
	                    };
	                }]
	        };
	    }
	    SWFilterGroups.Factory = function () {
	        var directive = function ($log, collectionPartialsPath, hibachiPathBuilder) { return new SWFilterGroups($log, collectionPartialsPath, hibachiPathBuilder); };
	        directive.$inject = [
	            '$log',
	            'collectionPartialsPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWFilterGroups;
	}());
	exports.SWFilterGroups = SWFilterGroups;


/***/ },
/* 135 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWFilterItem = (function () {
	    function SWFilterItem($log, collectionService, collectionPartialsPath, hibachiPathBuilder) {
	        return {
	            restrict: 'A',
	            require: '^swFilterGroups',
	            scope: {
	                collectionConfig: "=",
	                filterItem: "=",
	                siblingItems: "=",
	                filterPropertiesList: "=",
	                filterItemIndex: "=",
	                saveCollection: "&",
	                comparisonType: "=",
	                simple: "="
	            },
	            templateUrl: hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + "filteritem.html",
	            link: function (scope, element, attrs, filterGroupsController) {
	                scope.baseEntityAlias = scope.collectionConfig.baseEntityAlias;
	                if (angular.isUndefined(scope.filterItem.$$isClosed)) {
	                    scope.filterItem.$$isClosed = true;
	                }
	                if (angular.isUndefined(scope.filterItem.$$disabled)) {
	                    scope.filterItem.$$disabled = false;
	                }
	                if (angular.isUndefined(scope.filterItem.siblingItems)) {
	                    scope.filterItem.$$siblingItems = scope.siblingItems;
	                }
	                scope.filterItem.setItemInUse = filterGroupsController.setItemInUse;
	                scope.selectFilterItem = function (filterItem) {
	                    collectionService.selectFilterItem(filterItem);
	                };
	                scope.removeFilterItem = function () {
	                    filterGroupsController.removeFilterItem(scope.filterItemIndex, filterGroupsController.getFilterGroupItem());
	                };
	                scope.filterGroupItem = filterGroupsController.getFilterGroupItem();
	                scope.logicalOperatorChanged = function (logicalOperatorValue) {
	                    $log.debug('logicalOperatorChanged');
	                    $log.debug(logicalOperatorValue);
	                    scope.filterItem.logicalOperator = logicalOperatorValue;
	                    filterGroupsController.saveCollection();
	                };
	            }
	        };
	    }
	    SWFilterItem.Factory = function () {
	        var directive = function ($log, collectionService, collectionPartialsPath, hibachiPathBuilder) { return new SWFilterItem($log, collectionService, collectionPartialsPath, hibachiPathBuilder); };
	        directive.$inject = [
	            '$log',
	            'collectionService',
	            'collectionPartialsPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWFilterItem;
	}());
	exports.SWFilterItem = SWFilterItem;


/***/ },
/* 136 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWFilterGroupItem = (function () {
	    function SWFilterGroupItem($http, $compile, $templateCache, $log, collectionService, collectionPartialsPath, hibachiPathBuilder) {
	        return {
	            restrict: 'A',
	            require: "^swFilterGroups",
	            scope: {
	                collectionConfig: "=",
	                filterGroupItem: "=",
	                siblingItems: "=",
	                filterPropertiesList: "=",
	                filterGroupItemIndex: "=",
	                saveCollection: "&",
	                comparisonType: "="
	            },
	            link: function (scope, element, attrs, filterGroupsController) {
	                var Partial = hibachiPathBuilder.buildPartialsPath(collectionPartialsPath) + "filtergroupitem.html";
	                var templateLoader = $http.get(Partial, { cache: $templateCache });
	                var promise = templateLoader.success(function (html) {
	                    element.html(html);
	                }).then(function (response) {
	                    element.replaceWith($compile(element.html())(scope));
	                });
	                //for(item in filterGroupItem){}
	                scope.filterGroupItem.setItemInUse = filterGroupsController.setItemInUse;
	                scope.filterGroupItem.$$index = scope.filterGroupItemIndex;
	                scope.removeFilterGroupItem = function () {
	                    filterGroupsController.removeFilterGroupItem(scope.filterGroupItemIndex);
	                };
	                scope.filterGroupItem.removeFilterGroupItem = scope.removeFilterGroupItem;
	                scope.filterGroupItem.$$disabled = false;
	                if (angular.isUndefined(scope.filterGroupItem.$$isClosed)) {
	                    scope.filterGroupItem.$$isClosed = true;
	                }
	                scope.filterGroupItem.$$siblingItems = scope.siblingItems;
	                scope.selectFilterGroupItem = function (filterGroupItem) {
	                    collectionService.selectFilterGroupItem(filterGroupItem);
	                };
	                scope.logicalOperatorChanged = function (logicalOperatorValue) {
	                    $log.debug('logicalOperatorChanged');
	                    $log.debug(logicalOperatorValue);
	                    scope.filterGroupItem.logicalOperator = logicalOperatorValue;
	                    filterGroupsController.saveCollection();
	                };
	            }
	        };
	    }
	    SWFilterGroupItem.Factory = function () {
	        var directive = function ($http, $compile, $templateCache, $log, collectionService, collectionPartialsPath, hibachiPathBuilder) { return new SWFilterGroupItem($http, $compile, $templateCache, $log, collectionService, collectionPartialsPath, hibachiPathBuilder); };
	        directive.$inject = [
	            '$http',
	            '$compile',
	            '$templateCache',
	            '$log',
	            'collectionService',
	            'collectionPartialsPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWFilterGroupItem;
	}());
	exports.SWFilterGroupItem = SWFilterGroupItem;


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/tsd.d.ts" />
	/// <reference path="../../typings/hibachiTypescript.d.ts" />
	"use strict";
	//modules
	var collection_module_1 = __webpack_require__(109);
	//services
	var listingservice_1 = __webpack_require__(138);
	//directives
	var swlistingdisplay_1 = __webpack_require__(139);
	var swlistingdisplaycell_1 = __webpack_require__(140);
	var swlistingcontrols_1 = __webpack_require__(141);
	var swlistingaggregate_1 = __webpack_require__(142);
	var swlistingcolorfilter_1 = __webpack_require__(143);
	var swlistingcolumn_1 = __webpack_require__(144);
	var swlistingdisablerule_1 = __webpack_require__(145);
	var swlistingexpandablerule_1 = __webpack_require__(146);
	var swlistingfilter_1 = __webpack_require__(147);
	var swlistingfiltergroup_1 = __webpack_require__(148);
	var swlistingorderby_1 = __webpack_require__(149);
	var swlistingrowsave_1 = __webpack_require__(150);
	var swlistingsearch_1 = __webpack_require__(151);
	var swlistingglobalsearch_1 = __webpack_require__(152);
	var listingmodule = angular.module('hibachi.listing', [collection_module_1.collectionmodule.name])
	    .run([function () {
	    }])
	    .service('listingService', listingservice_1.ListingService)
	    .directive('swListingDisplay', swlistingdisplay_1.SWListingDisplay.Factory())
	    .directive('swListingControls', swlistingcontrols_1.SWListingControls.Factory())
	    .directive('swListingAggregate', swlistingaggregate_1.SWListingAggregate.Factory())
	    .directive('swListingColorFilter', swlistingcolorfilter_1.SWListingColorFilter.Factory())
	    .directive('swListingColumn', swlistingcolumn_1.SWListingColumn.Factory())
	    .directive('swListingDisableRule', swlistingdisablerule_1.SWListingDisableRule.Factory())
	    .directive('swListingExpandableRule', swlistingexpandablerule_1.SWListingExpandableRule.Factory())
	    .directive('swListingDisplayCell', swlistingdisplaycell_1.SWListingDisplayCell.Factory())
	    .directive('swListingFilter', swlistingfilter_1.SWListingFilter.Factory())
	    .directive('swListingFilterGroup', swlistingfiltergroup_1.SWListingFilterGroup.Factory())
	    .directive('swListingOrderBy', swlistingorderby_1.SWListingOrderBy.Factory())
	    .directive('swListingRowSave', swlistingrowsave_1.SWListingRowSave.Factory())
	    .directive('swListingSearch', swlistingsearch_1.SWListingSearch.Factory())
	    .directive('swListingGlobalSearch', swlistingglobalsearch_1.SWListingGlobalSearch.Factory())
	    .constant('listingPartialPath', 'listing/components/');
	exports.listingmodule = listingmodule;


/***/ },
/* 138 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var ListingService = (function () {
	    //@ngInject
	    function ListingService($timeout, $q, collectionConfigService, filterService, historyService, observerService, rbkeyService, selectionService, utilityService, $hibachi) {
	        var _this = this;
	        this.$timeout = $timeout;
	        this.$q = $q;
	        this.collectionConfigService = collectionConfigService;
	        this.filterService = filterService;
	        this.historyService = historyService;
	        this.observerService = observerService;
	        this.rbkeyService = rbkeyService;
	        this.selectionService = selectionService;
	        this.utilityService = utilityService;
	        this.$hibachi = $hibachi;
	        this.listingDisplays = {};
	        //Event Functions
	        this.getListingPageRecordsUpdateEventString = function (listingID) {
	            return listingID + "pageRecordsUpdated";
	        };
	        this.getListingOrderByChangedEventString = function (listingID) {
	            return listingID + "orderByChanged";
	        };
	        this.getListingInitiatedEventString = function (listingID) {
	            return listingID + "initiated";
	        };
	        this.notifyListingPageRecordsUpdate = function (listingID) {
	            _this.observerService.notify(_this.getListingPageRecordsUpdateEventString(listingID), listingID);
	        };
	        this.attachToListingPageRecordsUpdate = function (listingID, callback, id) {
	            _this.observerService.attach(callback, _this.getListingPageRecordsUpdateEventString(listingID), id);
	        };
	        this.attachToOrderByChangedUpdate = function (listingID, callback, id) {
	            _this.observerService.attach(callback, _this.getListingOrderByChangedEventString(listingID), id);
	        };
	        this.attachToListingInitiated = function (listingID, callback) {
	            _this.observerService.attach(callback, _this.getListingInitiatedEventString(listingID));
	            if (_this.historyService.hasHistory(_this.getListingInitiatedEventString(listingID))) {
	                callback();
	            }
	        };
	        //End Event Functions
	        //core getters and setters
	        this.setListingState = function (listingID, state) {
	            _this.listingDisplays[listingID] = state;
	            _this.observerService.notifyAndRecord(_this.getListingInitiatedEventString(listingID));
	        };
	        this.getListing = function (listingID) {
	            return _this.listingDisplays[listingID];
	        };
	        this.getListingColumns = function (listingID) {
	            return _this.getListing(listingID).columns || _this.getListingCollectionConfigColumns(listingID);
	        };
	        this.getListingCollectionConfigColumns = function (listingID) {
	            if (_this.getListing(listingID).collectionConfig != null) {
	                return _this.getListing(listingID).collectionConfig.columns;
	            }
	        };
	        this.getListingExampleEntity = function (listingID) {
	            if (_this.getListing(listingID).exampleEntity != null) {
	                return _this.getListing(listingID).exampleEntity;
	            }
	            else {
	                _this.setupExampleEntity(listingID);
	            }
	        };
	        this.getListingCollectionConfigColumnIndexByPropertyIdentifier = function (listingID, propertyIdentifier) {
	            var columns = _this.getListingCollectionConfigColumns(listingID);
	            return _this.utilityService.ArrayFindByPropertyValue(columns, 'propertyIdentifier', propertyIdentifier);
	        };
	        this.getListingColumnIndexByPropertyIdentifier = function (listingID, propertyIdentifier) {
	            var columns = _this.getListingColumns(listingID);
	            return _this.utilityService.ArrayFindByPropertyValue(columns, 'propertyIdentifier', propertyIdentifier);
	        };
	        this.getListingBaseEntityName = function (listingID) {
	            var baseEntityName = _this.getListing(listingID).baseEntityName || _this.getListing(listingID).collectionObject;
	            if (baseEntityName == null && _this.getListing(listingID).collectionConfig != null) {
	                baseEntityName = _this.getListing(listingID).collectionConfig.baseEntityName;
	            }
	            if (baseEntityName == null && _this.getListing(listingID).collectionData != null) {
	                baseEntityName = _this.getListing(listingID).collectionData.collectionObject;
	            }
	            return baseEntityName;
	        };
	        this.getListingBaseEntityPrimaryIDPropertyName = function (listingID) {
	            if (_this.getListingExampleEntity(listingID) != null) {
	                return _this.getListingExampleEntity(listingID).$$getIDName();
	            }
	        };
	        this.getListingPrimaryEntityName = function (listingID) {
	            return _this.getListing(listingID).baseEntityName ||
	                _this.getListing(listingID).collectionObject ||
	                _this.getListing(listingID).collectionConfig.baseEntityName;
	        };
	        this.getListingEntityPrimaryIDPropertyName = function (listingID) {
	            return _this.$hibachi.getPrimaryIDPropertyNameByEntityName(_this.getListingPrimaryEntityName(listingID));
	        };
	        this.getListingPageRecords = function (listingID) {
	            if (angular.isDefined(_this.getListing(listingID)) &&
	                angular.isDefined(_this.getListing(listingID).collectionData) &&
	                angular.isDefined(_this.getListing(listingID).collectionData.pageRecords)) {
	                return _this.getListing(listingID).collectionData.pageRecords;
	            }
	        };
	        this.getCollection = function (listingID) {
	            return _this.getListing(listingID).getCollection();
	        };
	        this.getPageRecordsWithManualSortOrder = function (listingID) {
	            if (angular.isDefined(_this.getListing(listingID)) && _this.getListingPageRecords(listingID) != null) {
	                var pageRecords = _this.getListingPageRecords(listingID);
	                var primaryIDPropertyName = _this.getListingEntityPrimaryIDPropertyName(listingID);
	                var primaryIDWithBaseAlias = _this.getListing(listingID).collectionConfig.baseEntityAlias + '.' + primaryIDPropertyName;
	                var pageRecordsWithManualSortOrder = {};
	                _this.$timeout(function () {
	                    for (var j = 0; j < pageRecords.length; j++) {
	                        var pageRecord = pageRecords[j];
	                        var primaryID = pageRecords[j][primaryIDPropertyName];
	                        var sortOrder = j + 1;
	                        var primaryIDColumnIndex = _this.getListingCollectionConfigColumnIndexByPropertyIdentifier(listingID, primaryIDWithBaseAlias);
	                        if (angular.isDefined(primaryID)) {
	                            pageRecordsWithManualSortOrder[primaryID] = sortOrder;
	                        }
	                        else if (primaryIDColumnIndex !== -1) {
	                            var column = _this.getListingCollectionConfigColumns(listingID)[primaryIDColumnIndex];
	                            if (angular.isDefined(column.fallbackPropertyIdentifiers)) {
	                                var fallbackPropertyArray = column.fallbackPropertyIdentifiers.split(",");
	                                for (var i = 0; i < fallbackPropertyArray.length; i++) {
	                                    if (angular.isDefined(pageRecord[fallbackPropertyArray[i]])) {
	                                        pageRecordsWithManualSortOrder[pageRecord[fallbackPropertyArray[i]]] = sortOrder;
	                                    }
	                                }
	                            }
	                        }
	                    }
	                    _this.getListing(listingID).pageRecordsWithManualSortOrder = angular.toJson(pageRecordsWithManualSortOrder);
	                    return _this.getListing(listingID).pageRecordsWithManualSortOrders;
	                }, 0);
	            }
	            else {
	                return angular.toJson({});
	            }
	        };
	        //Begin Listing Page Record Functions
	        this.getListingPageRecordIndexByPageRecord = function (listingID, pageRecordToCompare) {
	            var pageRecords = _this.getListingPageRecords(listingID);
	            var primaryIDPropertyName = _this.getListingEntityPrimaryIDPropertyName(listingID);
	            for (var j = 0; j < pageRecords.length; j++) {
	                var pageRecord = pageRecords[j];
	                if (pageRecord[primaryIDPropertyName] == pageRecordToCompare[primaryIDPropertyName]) {
	                    return j;
	                }
	            }
	            return -1;
	        };
	        this.insertListingPageRecord = function (listingID, pageRecord) {
	            pageRecord.newFlag = true;
	            if (angular.isDefined(_this.getListingPageRecords(listingID))) {
	                _this.notifyListingPageRecordsUpdate(listingID);
	                _this.getListingPageRecords(listingID).unshift(pageRecord); //insert at beginning be default
	            }
	        };
	        this.removeListingPageRecord = function (listingID, pageRecord) {
	            var pageRecords = _this.getListingPageRecords(listingID);
	            if (_this.getListingPageRecordIndexByPageRecord(listingID, pageRecord) != -1) {
	                _this.notifyListingPageRecordsUpdate(listingID);
	                return pageRecords.splice(_this.getListingPageRecordIndexByPageRecord(listingID, pageRecord), 1)[0]; //this will always be an array of one element 
	            }
	        };
	        this.getPageRecordKey = function (propertyIdentifier) {
	            if (propertyIdentifier) {
	                var propertyIdentifierWithoutAlias = '';
	                if (propertyIdentifier.indexOf('_') === 0) {
	                    propertyIdentifierWithoutAlias = propertyIdentifier.substring(propertyIdentifier.indexOf('.') + 1, propertyIdentifier.length);
	                }
	                else {
	                    propertyIdentifierWithoutAlias = propertyIdentifier;
	                }
	                return _this.utilityService.replaceAll(propertyIdentifierWithoutAlias, '.', '_');
	            }
	            return '';
	        };
	        this.getPageRecordValueByColumn = function (pageRecord, column) {
	            var pageRecordValue = pageRecord[_this.getPageRecordKey(column.propertyIdentifier)];
	            if ((angular.isUndefined(pageRecordValue) ||
	                (angular.isString(pageRecordValue) && pageRecordValue.trim().length == 0)) &&
	                angular.isDefined(column.fallbackPropertyIdentifiers)) {
	                var fallbackPropertyArray = column.fallbackPropertyIdentifiers.replace('.', '_').split(",");
	                for (var i = 0; i < fallbackPropertyArray.length; i++) {
	                    if (angular.isDefined(pageRecord[_this.getPageRecordKey(fallbackPropertyArray[i])])) {
	                        pageRecordValue = pageRecord[_this.getPageRecordKey(fallbackPropertyArray[i])];
	                        break;
	                    }
	                }
	            }
	            return pageRecordValue;
	        };
	        this.selectCurrentPageRecords = function (listingID) {
	            if (!_this.getListing(listingID).collectionData.pageRecords)
	                return;
	            for (var i = 0; i < _this.getListing(listingID).collectionData.pageRecords.length; i++) {
	                if (_this.getListing(listingID).isCurrentPageRecordsSelected == true) {
	                    _this.getListing(listingID).selectionService.addSelection(_this.getListing(listingID).tableID, _this.getListingPageRecords(listingID)[i][_this.getListingBaseEntityPrimaryIDPropertyName(listingID)]);
	                }
	                else {
	                    _this.selectionService.removeSelection(_this.getListing(listingID).tableID, _this.getListingPageRecords(listingID)[i][_this.getListingBaseEntityPrimaryIDPropertyName(listingID)]);
	                }
	            }
	        };
	        this.getNGClassObjectForPageRecordRow = function (listingID, pageRecord) {
	            var classObjectString = "{";
	            angular.forEach(_this.getListing(listingID).colorFilters, function (colorFilter, index) {
	                classObjectString = classObjectString.concat("'" + colorFilter.colorClass + "':" + _this.getColorFilterConditionString(colorFilter, pageRecord));
	                classObjectString = classObjectString.concat(",");
	            });
	            classObjectString = classObjectString.concat(" 's-child':" + _this.getPageRecordIsChild(listingID, pageRecord));
	            var newFlag = false;
	            if (pageRecord.newFlag != null && typeof pageRecord.newFlag === 'string' && pageRecord.newFlag.trim() !== '') {
	                newFlag = pageRecord.newFlag;
	            }
	            classObjectString = classObjectString.concat(",'s-selected-row':" + newFlag);
	            classObjectString = classObjectString.concat(",'s-disabled':" + _this.getPageRecordMatchesDisableRule(listingID, pageRecord));
	            classObjectString = classObjectString.concat(",'s-edited':pageRecord.edited");
	            return classObjectString + "}";
	        };
	        this.getPageRecordIsChild = function (listingID, pageRecord) {
	            var isChild = false;
	            //todo implement
	            return isChild;
	        };
	        //End Listing Page Record Functions
	        //Row Save Functionality
	        this.determineRowEdited = function (pageRecords, pageRecordIndex) {
	            var fieldCount = 0;
	            for (var key in pageRecords[pageRecordIndex].editedFields) {
	                fieldCount++;
	                if (fieldCount > 1) {
	                    pageRecords[pageRecordIndex].edited = true;
	                    return true;
	                }
	            }
	            pageRecords[pageRecordIndex].edited = false;
	            return false;
	        };
	        this.markUnedited = function (listingID, pageRecordIndex, propertyDisplayID) {
	            var pageRecords = _this.getListingPageRecords(listingID);
	            if (angular.isDefined(pageRecords[pageRecordIndex].editedFields[propertyDisplayID])) {
	                delete pageRecords[pageRecordIndex].editedFields[propertyDisplayID];
	            }
	            return _this.determineRowEdited(pageRecords, pageRecordIndex);
	        };
	        this.markEdited = function (listingID, pageRecordIndex, propertyDisplayID, saveCallback) {
	            var pageRecords = _this.getListingPageRecords(listingID);
	            if (angular.isUndefined(pageRecords[pageRecordIndex].editedFields) && !angular.isObject(pageRecords[pageRecordIndex].editedFields)) {
	                pageRecords[pageRecordIndex].editedFields = {};
	            }
	            pageRecords[pageRecordIndex].editedFields[propertyDisplayID] = saveCallback;
	            return _this.determineRowEdited(pageRecords, pageRecordIndex);
	        };
	        this.markSaved = function (listingID, pageRecordIndex) {
	            var pageRecords = _this.getListingPageRecords(listingID);
	            var savePromises = [];
	            for (var key in pageRecords[pageRecordIndex].editedFields) {
	                if (angular.isFunction(pageRecords[pageRecordIndex].editedFields[key])) {
	                    savePromises.push(pageRecords[pageRecordIndex].editedFields[key]());
	                }
	            }
	            _this.$q.all(savePromises).then(function () {
	                delete pageRecords[pageRecordIndex].editedFields;
	                pageRecords[pageRecordIndex].edited = false;
	            });
	        };
	        //End Row Save Functionality
	        //Setup Functions
	        this.setupInSingleCollectionConfigMode = function (listingID, listingDisplayScope) {
	            if (_this.getListing(listingID).collectionObject != null &&
	                _this.getListing(listingID).collectionConfig != null) {
	                _this.getListing(listingID).collectionObject = _this.getListing(listingID).collectionConfig.baseEntityName;
	            }
	            _this.initCollectionConfigData(listingID, _this.getListing(listingID).collectionConfig);
	            _this.setupColumns(listingID, _this.getListing(listingID).collectionConfig, _this.getListing(listingID).collectionObject);
	            listingDisplayScope.$watch('swListingDisplay.collectionPromise', function (newValue, oldValue) {
	                if (newValue) {
	                    _this.$q.when(_this.getListing(listingID).collectionPromise).then(function (data) {
	                        _this.getListing(listingID).collectionData = data;
	                        _this.setupDefaultCollectionInfo(listingID);
	                        if (_this.getListing(listingID).collectionConfig != null && _this.getListing(listingID).collectionConfig.hasColumns()) {
	                            _this.setupColumns(listingID, _this.getListing(listingID).collectionConfig, _this.getListing(listingID).collectionObject);
	                        }
	                        else {
	                            _this.getListing(listingID).collectionConfig.loadJson(data.collectionConfig);
	                        }
	                        _this.notifyListingPageRecordsUpdate(listingID);
	                        _this.getListing(listingID).collectionData.pageRecords = _this.getListing(listingID).collectionData.pageRecords ||
	                            _this.getListing(listingID).collectionData.records;
	                        _this.getListing(listingID).paginator.setPageRecordsInfo(_this.getListing(listingID).collectionData);
	                        _this.getListing(listingID).searching = false;
	                    });
	                }
	            });
	        };
	        this.setupInMultiCollectionConfigMode = function (listingID) {
	            angular.forEach(_this.getListing(listingID).collectionConfigs, function (value, key) {
	                _this.getListing(listingID).collectionObjects[key] = value.baseEntityName;
	            });
	        };
	        this.setupDefaultCollectionInfo = function (listingID) {
	            if (_this.getListing(listingID).hasCollectionPromise
	                && angular.isDefined(_this.getListing(listingID).collection)
	                && _this.getListing(listingID).collectionConfig == null) {
	                _this.getListing(listingID).collectionObject = _this.getListing(listingID).collection.collectionObject;
	                _this.getListing(listingID).collectionConfig = _this.collectionConfigService.newCollectionConfig(_this.getListing(listingID).collectionObject);
	                _this.getListing(listingID).collectionConfig.loadJson(_this.getListing(listingID).collection.collectionConfig);
	            }
	            if (_this.getListing(listingID).multiSlot == false) {
	                _this.$timeout(function () {
	                    _this.getListing(listingID).collectionConfig.loadJson(_this.getListing(listingID).collectionData.collectionConfig);
	                    _this.getListing(listingID).columns = _this.getListing(listingID).collectionConfig.columns;
	                });
	            }
	            if (_this.getListing(listingID).paginator != null
	                && _this.getListing(listingID).collectionConfig != null) {
	                _this.getListing(listingID).collectionConfig.setPageShow(_this.getListing(listingID).paginator.getPageShow());
	                _this.getListing(listingID).collectionConfig.setCurrentPage(_this.getListing(listingID).paginator.getCurrentPage());
	            }
	        };
	        this.addColumn = function (listingID, column) {
	            if (_this.getListing(listingID).collectionConfig != null && _this.getListing(listingID).collectionConfig.baseEntityAlias != null) {
	                column.propertyIdentifier = _this.getListing(listingID).collectionConfig.baseEntityAlias + "." + column.propertyIdentifier;
	            }
	            else if (_this.getListingBaseEntityName(listingID) != null) {
	                column.propertyIdentifier = '_' + _this.getListingBaseEntityName(listingID).toLowerCase() + '.' + column.propertyIdentifier;
	            }
	            if (_this.getListingColumnIndexByPropertyIdentifier(listingID, column.propertyIdentifier) === -1) {
	                if (column.aggregate) {
	                    _this.getListing(listingID).aggregates.push(column.aggregate);
	                }
	                else {
	                    _this.getListing(listingID).columns.push(column);
	                }
	            }
	        };
	        this.setupColumns = function (listingID, collectionConfig, collectionObject) {
	            //assumes no alias formatting
	            if (_this.getListing(listingID).columns.length == 0 &&
	                collectionConfig != null) {
	                if (collectionConfig.columns == null) {
	                    collectionConfig.getEntity().then(function () {
	                        for (var j = 0; j < collectionConfig.columns.length; j++) {
	                            var column = collectionConfig.columns[j];
	                            if (column.isVisible) {
	                                _this.getListing(listingID).columns.push(column);
	                            }
	                        }
	                    }, function () {
	                        throw ("listing display couldn't initiate no columns");
	                    });
	                }
	                else {
	                    for (var j = 0; j < collectionConfig.columns.length; j++) {
	                        var column = collectionConfig.columns[j];
	                        if (column.isVisible) {
	                            _this.getListing(listingID).columns.push(column);
	                        }
	                    }
	                }
	            }
	            for (var i = 0; i < _this.getListing(listingID).columns.length; i++) {
	                var column = _this.getListing(listingID).columns[i];
	                if (_this.getListing(listingID).collectionConfig != null && !column.hasCellView) {
	                    _this.getListing(listingID).collectionConfig.addColumn(column.propertyIdentifier, undefined, column);
	                }
	                var baseEntityName = _this.getListingBaseEntityName(listingID);
	                //if we have entity information we can make some inferences about the column
	                if (baseEntityName != null) {
	                    var lastEntity = _this.$hibachi.getLastEntityNameInPropertyIdentifier(baseEntityName, column.propertyIdentifier);
	                    if (angular.isUndefined(column.title)) {
	                        column.title = _this.rbkeyService.getRBKey('entity.' + lastEntity.toLowerCase() + '.' + _this.utilityService.listLast(column.propertyIdentifier, '.'));
	                    }
	                    if (angular.isUndefined(column.isVisible)) {
	                        column.isVisible = true;
	                    }
	                    var metadata = _this.$hibachi.getPropertyByEntityNameAndPropertyName(lastEntity, _this.utilityService.listLast(column.propertyIdentifier, '.'));
	                    if (angular.isDefined(metadata) && angular.isDefined(metadata.hb_formattype)) {
	                        column.type = metadata.hb_formatType;
	                    }
	                    else {
	                        column.type = "none";
	                    }
	                    if (column.propertyIdentifier) {
	                        _this.getListing(listingID).allpropertyidentifiers = _this.utilityService.listAppend(_this.getListing(listingID).allpropertyidentifiers, column.propertyIdentifier);
	                    }
	                    else if (column.processObjectProperty) {
	                        column.searchable = false;
	                        column.sort = false;
	                        _this.getListing(listingID).allprocessobjectproperties = _this.utilityService.listAppend(_this.getListing(listingID).allprocessobjectproperties, column.processObjectProperty);
	                    }
	                    if (column.tdclass) {
	                        var tdclassArray = column.tdclass.split(' ');
	                        if (tdclassArray.indexOf("primary") >= 0 && _this.getListing(listingID).expandable) {
	                            _this.getListing(listingID).tableattributes = _this.utilityService.listAppend(_this.getListing(listingID).tableattributes, 'data-expandsortproperty=' + column.propertyIdentifier, " ");
	                            column.sort = false;
	                        }
	                    }
	                }
	                if (angular.isDefined(column.tooltip)) {
	                    var parsedProperties = _this.utilityService.getPropertiesFromString(column.tooltip);
	                    if (parsedProperties && parsedProperties.length) {
	                        collectionConfig.addDisplayProperty(_this.utilityService.arrayToList(parsedProperties), "", { isVisible: false });
	                    }
	                }
	                else {
	                    column.tooltip = '';
	                }
	                if (angular.isDefined(column.queryString)) {
	                    var parsedProperties = _this.utilityService.getPropertiesFromString(column.queryString);
	                    if (parsedProperties && parsedProperties.length) {
	                        collectionConfig.addDisplayProperty(_this.utilityService.arrayToList(parsedProperties), "", { isVisible: false });
	                    }
	                }
	                //if the passed in collection has columns perform some formatting
	                if (_this.getListing(listingID).hasCollectionPromise) {
	                    var lastEntity = _this.$hibachi.getLastEntityNameInPropertyIdentifier(collectionObject, _this.utilityService.listRest(column.propertyIdentifier, '.'));
	                    column.title = column.title || _this.rbkeyService.getRBKey('entity.' + lastEntity.toLowerCase() + '.' + _this.utilityService.listLast(column.propertyIdentifier, '.'));
	                    if (angular.isUndefined(column.isVisible)) {
	                        column.isVisible = true;
	                    }
	                }
	                _this.columnOrderBy(listingID, column);
	            }
	        };
	        this.initCollectionConfigData = function (listingID, collectionConfig) {
	            //kick off other essential setup 
	            _this.setupSelect(listingID);
	            _this.setupMultiselect(listingID);
	            _this.setupExampleEntity(listingID);
	            if (collectionConfig != null) {
	                angular.forEach(_this.getListing(listingID).filterGroups, function (filterGroup) {
	                    collectionConfig.addFilterGroup(filterGroup);
	                });
	                angular.forEach(_this.getListing(listingID).filters, function (filter) {
	                    collectionConfig.addFilter(filter.propertyIdentifier, filter.comparisonValue, filter.comparisonOperator, filter.logicalOperator, filter.hidden);
	                });
	                angular.forEach(_this.getListing(listingID).orderBys, function (orderBy) {
	                    collectionConfig.addOrderBy(orderBy.orderBy);
	                });
	                angular.forEach(_this.getListing(listingID).aggregates, function (aggregate) {
	                    collectionConfig.addDisplayAggregate(aggregate.propertyIdentifier, aggregate.aggregateFunction, aggregate.aggregateAlias);
	                });
	                //make sure we have necessary properties to make the actions 
	                angular.forEach(_this.getListing(listingID).actions, function (action) {
	                    if (angular.isDefined(action.queryString)) {
	                        var parsedProperties = _this.utilityService.getPropertiesFromString(action.queryString);
	                        if (parsedProperties && parsedProperties.length) {
	                            collectionConfig.addDisplayProperty(_this.utilityService.arrayToList(parsedProperties), "", { isVisible: false });
	                        }
	                    }
	                });
	                //also make sure we have necessary color filter properties
	                angular.forEach(_this.getListing(listingID).colorFilters, function (colorFilter) {
	                    if (angular.isDefined(colorFilter.propertyToCompare)) {
	                        collectionConfig.addDisplayProperty(colorFilter.propertyToCompare, "", { isVisible: false });
	                    }
	                });
	                if (_this.getListing(listingID).collectionConfig != null && _this.getListing(listingID).collectionConfig.hasColumns()) {
	                    collectionConfig.addDisplayProperty(_this.getListingExampleEntity(listingID).$$getIDName(), undefined, { isVisible: false });
	                }
	                collectionConfig.setPageShow(_this.getListing(listingID).paginator.pageShow);
	                collectionConfig.setCurrentPage(_this.getListing(listingID).paginator.currentPage);
	                if (_this.getListing(listingID).multiselectable && (!_this.getListing(listingID).columns || !_this.getListing(listingID).columns.length)) {
	                    //check if it has an active flag and if so then add the active flag
	                    if (_this.getListing(listingID).exampleEntity.metaData.activeProperty && !_this.getListing(listingID).hasCollectionPromise) {
	                        collectionConfig.addFilter('activeFlag', 1, '=', undefined, true);
	                    }
	                }
	                _this.setupHierarchicalExpandable(listingID, collectionConfig);
	            }
	            _this.setupSortable(listingID);
	            _this.updateColumnAndAdministrativeCount(listingID);
	        };
	        this.setupSortable = function (listingID) {
	            _this.attachToListingPageRecordsUpdate(listingID, _this.getPageRecordsWithManualSortOrder, _this.utilityService.createID(32));
	        };
	        this.setupSelect = function (listingID) {
	            if (_this.getListing(listingID).selectFieldName && _this.getListing(listingID).selectFieldName.length) {
	                _this.getListing(listingID).selectable = true;
	                _this.getListing(listingID).tableclass = _this.utilityService.listAppend(_this.getListing(listingID).tableclass, 'table-select', ' ');
	                _this.getListing(listingID).tableattributes = _this.utilityService.listAppend(_this.getListing(listingID).tableattributes, 'data-selectfield="' + _this.getListing(listingID).selectFieldName + '"', ' ');
	            }
	        };
	        this.setupMultiselect = function (listingID) {
	            if (_this.getListing(listingID).multiselectFieldName && _this.getListing(listingID).multiselectFieldName.length) {
	                _this.getListing(listingID).multiselectable = true;
	                _this.getListing(listingID).tableclass = _this.utilityService.listAppend(_this.getListing(listingID).tableclass, 'table-multiselect', ' ');
	                _this.getListing(listingID).tableattributes = _this.utilityService.listAppend(_this.getListing(listingID).tableattributes, 'data-multiselectpropertyidentifier="' + _this.getListing(listingID).multiselectPropertyIdentifier + '"', ' ');
	                //attach observer so we know when a selection occurs
	                _this.getListing(listingID).observerService.attach(_this.getListing(listingID).updateMultiselectValues, _this.getListing(listingID).defaultSelectEvent, _this.getListing(listingID).collectionObject);
	                //attach observer so we know when a pagination change occurs
	                _this.getListing(listingID).observerService.attach(_this.getListing(listingID).paginationPageChange, 'swPaginationAction');
	            }
	            if (_this.getListing(listingID).multiselectValues && _this.getListing(listingID).multiselectValues.length) {
	                //select all owned ids
	                angular.forEach(_this.getListing(listingID).multiselectValues, function (value) {
	                    _this.getListing(listingID).selectionService.addSelection(_this.getListing(listingID).tableID, value);
	                });
	            }
	            if (_this.getListing(listingID).multiselectIdPaths && _this.getListing(listingID).multiselectIdPaths.length) {
	                angular.forEach(_this.getListing(listingID).multiselectIdPaths.split(','), function (value) {
	                    var id = _this.getListing(listingID).utilityService.listLast(value, '/');
	                    _this.getListing(listingID).selectionService.addSelection(_this.getListing(listingID).tableID, id);
	                });
	            }
	        };
	        this.setupExampleEntity = function (listingID) {
	            _this.getListing(listingID).exampleEntity = _this.$hibachi.getEntityExample(_this.getListingBaseEntityName(listingID));
	            if (_this.getListing(listingID).exampleEntity != null) {
	                //Look for Hierarchy in example entity
	                if (!_this.getListing(listingID).parentPropertyName || (_this.getListing(listingID).parentPropertyName && !_this.getListing(listingID).parentPropertyName.length)) {
	                    if (_this.getListing(listingID).exampleEntity.metaData.hb_parentPropertyName) {
	                        _this.getListing(listingID).parentPropertyName = _this.getListing(listingID).exampleEntity.metaData.hb_parentPropertyName;
	                    }
	                }
	                if (!_this.getListing(listingID).childPropertyName || (_this.getListing(listingID).childPropertyName && !_this.getListing(listingID).childPropertyName.length)) {
	                    if (_this.getListing(listingID).exampleEntity.metaData.hb_childPropertyName) {
	                        _this.getListing(listingID).childPropertyName = _this.getListing(listingID).exampleEntity.metaData.hb_childPropertyName;
	                    }
	                }
	            }
	        };
	        this.setupHierarchicalExpandable = function (listingID, collectionConfig) {
	            //Setup Hierachy Expandable
	            if (_this.getListing(listingID).parentPropertyName && _this.getListing(listingID).parentPropertyName.length && _this.getListing(listingID).expandable != false) {
	                if (angular.isUndefined(_this.getListing(listingID).expandable)) {
	                    _this.getListing(listingID).expandable = true;
	                }
	                _this.getListing(listingID).tableclass = _this.utilityService.listAppend(_this.getListing(listingID).tableclass, 'table-expandable', ' ');
	                //add parent property root filter
	                if (!_this.getListing(listingID).hasCollectionPromise) {
	                    collectionConfig.addFilter(_this.getListing(listingID).parentPropertyName + '.' + _this.getListing(listingID).exampleEntity.$$getIDName(), 'NULL', 'IS', undefined, true, false, false);
	                }
	                //this.collectionConfig.addDisplayProperty(this.exampleEntity.$$getIDName()+'Path',undefined,{isVisible:false});
	                //add children column
	                if (_this.getListing(listingID).childPropertyName && _this.getListing(listingID).childPropertyName.length) {
	                    if (_this.getListing(listingID).getChildCount || !_this.getListing(listingID).hasCollectionPromise) {
	                        collectionConfig.addDisplayAggregate(_this.getListing(listingID).childPropertyName, 'COUNT', _this.getListing(listingID).childPropertyName + 'Count', { isVisible: false, isSearchable: false });
	                    }
	                }
	                _this.getListing(listingID).allpropertyidentifiers = _this.utilityService.listAppend(_this.getListing(listingID).allpropertyidentifiers, _this.getListing(listingID).exampleEntity.$$getIDName() + 'Path');
	                _this.getListing(listingID).tableattributes = _this.utilityService.listAppend(_this.getListing(listingID).tableattributes, 'data-parentidproperty=' + _this.getListing(listingID).parentPropertyName + '.' + _this.getListing(listingID).exampleEntity.$$getIDName(), ' ');
	            }
	        };
	        this.updateColumnAndAdministrativeCount = function (listingID) {
	            //Setup a variable for the number of columns so that the none can have a proper colspan
	            _this.getListing(listingID).columnCount = (_this.getListing(listingID).columns) ? _this.getListing(listingID).columns.length : 0;
	            if (_this.getListing(listingID).selectable) {
	                _this.getListing(listingID).columnCount++;
	            }
	            if (_this.getListing(listingID).multiselectable) {
	                _this.getListing(listingID).columnCount++;
	            }
	            if (_this.getListing(listingID).sortable) {
	                _this.getListing(listingID).columnCount++;
	            }
	            if (_this.getListing(listingID).administrativeCount) {
	                _this.getListing(listingID).administrativeCount++;
	            }
	        };
	        this.setupDefaultGetCollection = function (listingID) {
	            if (_this.getListing(listingID).collectionConfigs.length == 0) {
	                _this.getListing(listingID).collectionPromise = _this.getListing(listingID).collectionConfig.getEntity();
	                return function () {
	                    _this.getListing(listingID).collectionConfig.setCurrentPage(_this.getListing(listingID).paginator.getCurrentPage());
	                    _this.getListing(listingID).collectionConfig.setPageShow(_this.getListing(listingID).paginator.getPageShow());
	                    if (_this.getListing(listingID).multiSlot) {
	                        _this.getListing(listingID).getEntity().then(function (data) {
	                            _this.getListing(listingID).collectionData = data;
	                            _this.setupDefaultCollectionInfo(listingID);
	                            _this.getListing(listingID).collectionData.pageRecords = data.pageRecords || data.records;
	                            _this.getListing(listingID).paginator.setPageRecordsInfo(_this.getListing(listingID).collectionData);
	                        }, function (reason) {
	                            throw ("Listing Service encounter a problem when trying to get collection. Reason: " + reason);
	                        });
	                    }
	                    else {
	                        _this.getListing(listingID).collectionPromise.then(function (data) {
	                            _this.getListing(listingID).collectionData = data;
	                            _this.setupDefaultCollectionInfo(listingID);
	                            _this.getListing(listingID).collectionData.pageRecords = data.pageRecords || data.records;
	                            _this.getListing(listingID).paginator.setPageRecordsInfo(_this.getListing(listingID).collectionData);
	                        }, function (reason) {
	                            throw ("Listing Service encounter a problem when trying to get collection. Reason: " + reason);
	                        });
	                    }
	                };
	            }
	            else {
	                return function () {
	                    _this.getListing(listingID).collectionData = {};
	                    _this.getListing(listingID).collectionData.pageRecords = [];
	                    var allGetEntityPromises = [];
	                    angular.forEach(_this.getListing(listingID).collectionConfigs, function (collectionConfig, key) {
	                        allGetEntityPromises.push(collectionConfig.getEntity());
	                    });
	                    if (allGetEntityPromises.length) {
	                        _this.$q.all(allGetEntityPromises).then(function (results) {
	                            angular.forEach(results, function (result, key) {
	                                _this.getListing(listingID).listingService.setupColumns(listingID, _this.getListing(listingID).collectionConfigs[key], _this.getListing(listingID).collectionObjects[key]);
	                                _this.getListing(listingID).collectionData.pageRecords = _this.getListing(listingID).collectionData.pageRecords.concat(result.records);
	                            });
	                        }, function (reason) {
	                            throw ("listing service had trouble getting collection data because: " + reason);
	                        });
	                    }
	                };
	            }
	        };
	        //End Setup Functions
	        //Order By Functions
	        //for multi order by
	        this.columnOrderBy = function (listingID, column) {
	            var isfound = false;
	            if (_this.getListing(listingID).collectionConfigs != null) {
	                angular.forEach(_this.getListing(listingID).collectionConfig.orderBy, function (orderBy, index) {
	                    if (column.propertyIdentifier == orderBy.propertyIdentifier) {
	                        isfound = true;
	                        _this.getListing(listingID).orderByStates[column.propertyIdentifier] = orderBy.direction;
	                    }
	                });
	            }
	            if (!isfound) {
	                _this.getListing(listingID).orderByStates[column.propertyIdentifier] = '';
	            }
	            return _this.getListing(listingID).orderByStates[column.propertyIdentifier];
	        };
	        //for multi order by
	        this.columnOrderByIndex = function (listingID, column) {
	            var isfound = false;
	            if (_this.getListing(listingID).collectionConfig != null) {
	                angular.forEach(_this.getListing(listingID).collectionConfig.orderBy, function (orderBy, index) {
	                    if (column.propertyIdentifier == orderBy.propertyIdentifier) {
	                        isfound = true;
	                        _this.getListing(listingID).orderByIndices[column.propertyIdentifier] = index + 1;
	                    }
	                });
	            }
	            if (!isfound) {
	                _this.getListing(listingID).orderByIndices[column.propertyIdentifier] = '';
	            }
	            return _this.getListing(listingID).orderByIndices[column.propertyIdentifier];
	        };
	        //for single column order by
	        this.setSingleColumnOrderBy = function (listingID, propertyIdentifier, direction, notify) {
	            if (notify === void 0) { notify = true; }
	            if (direction.toUpperCase() === "ASC") {
	                var oppositeDirection = "DESC";
	            }
	            else {
	                var oppositeDirection = "ASC";
	            }
	            if (_this.getListing(listingID).collectionConfig != null) {
	                var found = false;
	                angular.forEach(_this.getListing(listingID).collectionConfig.orderBy, function (orderBy, index) {
	                    if (propertyIdentifier == orderBy.propertyIdentifier) {
	                        orderBy.direction = direction;
	                        found = true;
	                    }
	                    else {
	                        orderBy.direction = oppositeDirection;
	                    }
	                });
	                if (!found) {
	                    _this.getListing(listingID).collectionConfig.addOrderBy(propertyIdentifier + "|" + direction);
	                }
	                if (notify) {
	                    _this.observerService.notify(_this.getListingOrderByChangedEventString(listingID));
	                }
	                _this.getCollection(listingID);
	            }
	        };
	        //for manual sort
	        this.setManualSort = function (listingID, toggle) {
	            _this.getListing(listingID).sortable = toggle;
	            if (toggle) {
	                _this.setSingleColumnOrderBy(listingID, "sortOrder", "ASC");
	            }
	        };
	        //for single column order by
	        this.toggleOrderBy = function (listingID, column) {
	            if (_this.getListing(listingID).hasSingleCollectionConfig()) {
	                _this.getListing(listingID).collectionConfig.toggleOrderBy(column.propertyIdentifier, true);
	            }
	            _this.getCollection(listingID);
	        };
	        //End Order By Functions
	        this.getColorFilterConditionString = function (colorFilter, pageRecord) {
	            if (angular.isDefined(colorFilter.comparisonProperty)) {
	                return pageRecord[colorFilter.propertyToCompare.replace('.', '_')] + colorFilter.comparisonOperator + pageRecord[colorFilter.comparisonProperty.replace('.', '_')];
	            }
	            else {
	                return pageRecord[colorFilter.propertyToCompare.replace('.', '_')] + colorFilter.comparisonOperator + colorFilter.comparisonValue;
	            }
	        };
	        //Disable Row Functions
	        this.getKeyOfMatchedDisableRule = function (listingID, pageRecord) {
	            var disableRuleMatchedKey = -1;
	            if (angular.isDefined(_this.getListing(listingID).disableRules)) {
	                angular.forEach(_this.getListing(listingID).disableRules, function (rule, key) {
	                    if (angular.isDefined(pageRecord[rule.filterPropertyIdentifier])) {
	                        if (angular.isString(pageRecord[rule.filterPropertyIdentifier])) {
	                            var pageRecordValue = pageRecord[rule.filterPropertyIdentifier].trim();
	                        }
	                        else {
	                            var pageRecordValue = pageRecord[rule.filterPropertyIdentifier];
	                        }
	                        if (rule.filterComparisonValue == "null") {
	                            rule.filterComparisonValue = "";
	                        }
	                        if (_this.filterService.filterMatch(pageRecordValue, rule.filterComparisonOperator, rule.filterComparisonValue)) {
	                            disableRuleMatchedKey = key;
	                        }
	                        if (disableRuleMatchedKey != -1) {
	                            return disableRuleMatchedKey;
	                        }
	                    }
	                });
	            }
	            return disableRuleMatchedKey;
	        };
	        this.getPageRecordMatchesDisableRule = function (listingID, pageRecord) {
	            return _this.getKeyOfMatchedDisableRule(listingID, pageRecord) != -1;
	        };
	        //End disable rule functions
	        //Expandable Functions
	        this.setExpandable = function (listingID, value) {
	            if (angular.isDefined(_this.getListing(listingID))) {
	                _this.getListing(listingID).expandable = value;
	            }
	        };
	        this.getKeyOfMatchedExpandableRule = function (listingID, pageRecord) {
	            var expandableRuleMatchedKey = -1;
	            if (angular.isDefined(_this.getListing(listingID)) &&
	                angular.isDefined(_this.getListing(listingID).expandableRules)) {
	                angular.forEach(_this.getListing(listingID).expandableRules, function (rule, key) {
	                    if (angular.isDefined(pageRecord[rule.filterPropertyIdentifier])) {
	                        if (angular.isString(pageRecord[rule.filterPropertyIdentifier])) {
	                            var pageRecordValue = pageRecord[rule.filterPropertyIdentifier].trim();
	                        }
	                        else {
	                            var pageRecordValue = pageRecord[rule.filterPropertyIdentifier];
	                        }
	                        if (_this.filterService.filterMatch(pageRecordValue, rule.filterComparisonOperator, rule.filterComparisonValue)) {
	                            expandableRuleMatchedKey = key;
	                        }
	                        if (expandableRuleMatchedKey != -1) {
	                            return expandableRuleMatchedKey;
	                        }
	                    }
	                });
	            }
	            return expandableRuleMatchedKey;
	        };
	        this.getExampleEntityForExpandableRecord = function (listingID, pageRecord) {
	            var childCollectionConfig = _this.getListing(listingID).getPageRecordChildCollectionConfigForExpandableRule(pageRecord);
	            if (angular.isDefined(childCollectionConfig)) {
	                return _this.$hibachi.getEntityExample(_this.getListing(listingID).getPageRecordChildCollectionConfigForExpandableRule(pageRecord).baseEntityName);
	            }
	            return _this.getListing(listingID).exampleEntity;
	        };
	        this.getPageRecordMatchesExpandableRule = function (listingID, pageRecord) {
	            return _this.getKeyOfMatchedExpandableRule(listingID, pageRecord) != -1;
	        };
	        this.hasPageRecordRefreshChildrenEvent = function (listingID, pageRecord) {
	            return _this.getPageRecordRefreshChildrenEvent(listingID, pageRecord) != null;
	        };
	        this.getPageRecordRefreshChildrenEvent = function (listingID, pageRecord) {
	            var keyOfExpandableRuleMet = _this.getKeyOfMatchedExpandableRule(listingID, pageRecord);
	            if (keyOfExpandableRuleMet != -1) {
	                return _this.getListing(listingID).expandableRules[keyOfExpandableRuleMet].refreshChildrenEvent;
	            }
	        };
	        this.getPageRecordChildCollectionConfigForExpandableRule = function (listingID, pageRecord) {
	            var keyOfExpandableRuleMet = _this.getKeyOfMatchedExpandableRule(listingID, pageRecord);
	            if (_this.getListing(listingID) != null &&
	                angular.isFunction(_this.getListing(listingID).exampleEntity.$$getIDName) &&
	                angular.isDefined(pageRecord[_this.getListing(listingID).exampleEntity.$$getIDName()]) &&
	                angular.isDefined(_this.getListing(listingID).childCollectionConfigs[pageRecord[_this.getListing(listingID).exampleEntity.$$getIDName()]])) {
	                return _this.getListing(listingID).childCollectionConfigs[pageRecord[_this.getListing(listingID).exampleEntity.$$getIDName()]];
	            }
	            if (keyOfExpandableRuleMet != -1) {
	                var childCollectionConfig = _this.getListing(listingID).expandableRules[keyOfExpandableRuleMet].childrenCollectionConfig.clone();
	                angular.forEach(childCollectionConfig.filterGroups[0], function (filterGroup, key) {
	                    angular.forEach(filterGroup, function (filter, key) {
	                        if (angular.isString(filter.value)
	                            && filter.value.length
	                            && filter.value.charAt(0) == '$') {
	                            filter.value = _this.utilityService.replaceStringWithProperties(filter.value, pageRecord);
	                        }
	                    });
	                });
	                _this.getListing(listingID).childCollectionConfigs[pageRecord[_this.getListing(listingID).exampleEntity.$$getIDName()]] = childCollectionConfig;
	                return _this.getListing(listingID).childCollectionConfigs[pageRecord[_this.getListing(listingID).exampleEntity.$$getIDName()]];
	            }
	        };
	    }
	    return ListingService;
	}());
	exports.ListingService = ListingService;


/***/ },
/* 139 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWListingDisplayController = (function () {
	    //@ngInject
	    function SWListingDisplayController($scope, $transclude, $timeout, $q, $hibachi, utilityService, collectionConfigService, listingService, paginationService, selectionService, observerService, rbkeyService) {
	        var _this = this;
	        this.$scope = $scope;
	        this.$transclude = $transclude;
	        this.$timeout = $timeout;
	        this.$q = $q;
	        this.$hibachi = $hibachi;
	        this.utilityService = utilityService;
	        this.collectionConfigService = collectionConfigService;
	        this.listingService = listingService;
	        this.paginationService = paginationService;
	        this.selectionService = selectionService;
	        this.observerService = observerService;
	        this.rbkeyService = rbkeyService;
	        /* local state variables */
	        this.actions = [];
	        this.allpropertyidentifiers = "";
	        this.allprocessobjectproperties = "false";
	        this.aggregates = [];
	        this.buttonGroup = [];
	        this.childCollectionConfigs = {};
	        this.collectionConfigs = [];
	        this.collectionObjects = [];
	        this.colorFilters = [];
	        this.columns = [];
	        this.disableRules = [];
	        this.expandableRules = [];
	        this.exampleEntity = "";
	        this.filters = [];
	        this.filterGroups = [];
	        this.hideRules = [];
	        this.multiselectable = false;
	        this.orderBys = [];
	        this.orderByStates = {};
	        this.orderByIndices = {};
	        this.pageRecordsWithManualSortOrder = {};
	        this.searching = false;
	        this.selectable = false;
	        this.showSearchFilters = false;
	        this.sortable = false;
	        this.setupCollectionPromise = function () {
	            if (angular.isUndefined(_this.getCollection)) {
	                _this.getCollection = _this.listingService.setupDefaultGetCollection(_this.tableID);
	            }
	            _this.paginator.getCollection = _this.getCollection;
	            var getCollectionEventID = _this.tableID;
	            //this.observerService.attach(this.getCollectionObserver,'getCollection',getCollectionEventID);
	            _this.listingService.getCollection(_this.tableID);
	        };
	        this.getCollectionObserver = function (param) {
	            console.warn("getCollectionObserver", param);
	            _this.collectionConfig.loadJson(param.collectionConfig);
	            _this.collectionData = undefined;
	            _this.$timeout(function () {
	                _this.getCollection();
	            });
	        };
	        this.initializeState = function () {
	            if (angular.isDefined(_this.name)) {
	                _this.tableID = _this.name;
	            }
	            else {
	                _this.tableID = 'LD' + _this.utilityService.createID();
	            }
	            if (angular.isUndefined(_this.collectionConfig)) {
	                //make it available to swCollectionConfig
	                _this.collectionConfig = null;
	            }
	            if (angular.isUndefined(_this.multiSlot)) {
	                _this.multiSlot = false;
	            }
	            if (angular.isDefined(_this.administrativeCount)) {
	                _this.administrativeCount = parseInt(_this.administrativeCount);
	            }
	            else {
	                _this.administrativeCount = 0;
	            }
	            if (_this.recordDetailAction && _this.recordDetailAction.length) {
	                _this.administrativeCount++;
	                _this.adminattributes = _this.getAdminAttributesByType('detail');
	            }
	            if (_this.recordEditAction && _this.recordEditAction.length) {
	                _this.administrativeCount++;
	                _this.adminattributes = _this.getAdminAttributesByType('edit');
	            }
	            if (_this.recordDeleteAction && _this.recordDeleteAction.length) {
	                _this.administrativeCount++;
	                _this.adminattributes = _this.getAdminAttributesByType('delete');
	            }
	            if (_this.recordAddAction && _this.recordAddAction.length) {
	                _this.administrativeCount++;
	                _this.adminattributes = _this.getAdminAttributesByType('add');
	            }
	            if (_this.collectionConfig != null &&
	                angular.isDefined(_this.collection) &&
	                angular.isDefined(_this.collection.collectionConfig)) {
	                _this.collectionConfig = _this.collection.collectionConfig;
	            }
	            if (angular.isUndefined(_this.collectionObject) &&
	                angular.isDefined(_this.collection) &&
	                angular.isDefined(_this.collection.collectionObject)) {
	                _this.collectionObject = _this.collection.collectionObject;
	            }
	            //set defaults if value is not specifies
	            _this.processObjectProperties = _this.processObjectProperties || '';
	            _this.recordProcessButtonDisplayFlag = _this.recordProcessButtonDisplayFlag || true;
	            _this.norecordstext = _this.rbkeyService.getRBKey('entity.' + _this.collectionObject + '.norecords');
	            if (angular.isUndefined(_this.defaultSelectEvent)) {
	                _this.defaultSelectEvent = 'swSelectionToggleSelection' + _this.tableID;
	            }
	            if (angular.isUndefined(_this.isAngularRoute)) {
	                _this.isAngularRoute = true;
	            }
	            if (angular.isUndefined(_this.customListingControls)) {
	                _this.customListingControls = false;
	            }
	            if (angular.isUndefined(_this.hasSearch)) {
	                _this.hasSearch = true;
	                _this.showSearch = true;
	            }
	            if (angular.isUndefined(_this.showOrderBy)) {
	                _this.showOrderBy = true;
	            }
	            if (angular.isUndefined(_this.expandable)) {
	                _this.expandable = false;
	            }
	            //setup export action
	            if (angular.isDefined(_this.exportAction)) {
	                _this.exportAction = _this.$hibachi.buildUrl('main.collectionExport') + '&collectionExportID=';
	            }
	            _this.paginator = _this.paginationService.createPagination();
	            _this.hasCollectionPromise = false;
	            if (angular.isUndefined(_this.getChildCount)) {
	                _this.getChildCount = false;
	            }
	            //Setup table class
	            _this.tableclass = _this.tableclass || '';
	            _this.tableclass = _this.utilityService.listPrepend(_this.tableclass, 'table table-bordered table-hover', ' ');
	            if (angular.isDefined(_this.sortableFieldName)) {
	                _this.sortableFieldName = "sorting" + _this.tableID;
	            }
	        };
	        this.getListingPageRecordsUpdateEventString = function () {
	            return _this.listingService.getListingPageRecordsUpdateEventString(_this.tableID);
	        };
	        this.getKeyOfMatchedHideRule = function (pageRecord) {
	            return _this.listingService.getKeyOfMatchedHideRule(_this.tableID, pageRecord);
	        };
	        this.getPageRecordMatchesHideRule = function (pageRecord) {
	            return _this.listingService.getPageRecordMatchesHideRule(_this.tableID, pageRecord);
	        };
	        this.getPageRecordValueByColumn = function (pageRecord, column) {
	            return _this.listingService.getPageRecordValueByColumn(pageRecord, column);
	        };
	        this.getKeyOfMatchedDisableRule = function (pageRecord) {
	            return _this.listingService.getKeyOfMatchedExpandableRule(_this.tableID, pageRecord);
	        };
	        this.getPageRecordMatchesDisableRule = function (pageRecord) {
	            return _this.listingService.getPageRecordMatchesDisableRule(_this.tableID, pageRecord);
	        };
	        this.getKeyOfMatchedExpandableRule = function (pageRecord) {
	            return _this.listingService.getKeyOfMatchedExpandableRule(_this.tableID, pageRecord);
	        };
	        this.getPageRecordMatchesExpandableRule = function (pageRecord) {
	            return _this.listingService.getPageRecordMatchesExpandableRule(_this.tableID, pageRecord);
	        };
	        this.getPageRecordChildCollectionConfigForExpandableRule = function (pageRecord) {
	            return _this.listingService.getPageRecordChildCollectionConfigForExpandableRule(_this.tableID, pageRecord);
	        };
	        this.getPageRecordRefreshChildrenEvent = function (pageRecord) {
	            if (_this.listingService.hasPageRecordRefreshChildrenEvent(_this.tableID, pageRecord)) {
	                return _this.listingService.getPageRecordRefreshChildrenEvent(_this.tableID, pageRecord);
	            }
	            else {
	                return "";
	            }
	        };
	        this.getExampleEntityForExpandableRecord = function (pageRecord) {
	            return _this.listingService.getExampleEntityForExpandableRecord(_this.tableID, pageRecord);
	        };
	        this.getNGClassObjectForPageRecordRow = function (pageRecord) {
	            return _this.listingService.getNGClassObjectForPageRecordRow(_this.tableID, pageRecord);
	        };
	        this.getNGClassObjectForPageRecordCell = function (pageRecord, column) {
	            var classObjectString = "{";
	            return classObjectString + "}";
	        };
	        this.getColorFilterConditionString = function (colorFilter, pageRecord) {
	            return _this.listingService.getColorFilterConditionString(colorFilter, pageRecord);
	        };
	        this.hasSingleCollectionConfig = function () {
	            return _this.collectionConfig && _this.collectionConfigs.length == 0;
	        };
	        this.toggleOrderBy = function (column) {
	            _this.listingService.toggleOrderBy(_this.tableID, column);
	        };
	        this.columnOrderByIndex = function (column) {
	            return _this.listingService.columnOrderByIndex(_this.tableID, column);
	        };
	        this.updateMultiselectValues = function (res) {
	            _this.multiselectValues = _this.selectionService.getSelections(_this.tableID);
	            if (_this.selectionService.isAllSelected(_this.tableID)) {
	                _this.multiselectCount = _this.collectionData.recordsCount - _this.selectionService.getSelectionCount(_this.tableID);
	            }
	            else {
	                _this.multiselectCount = _this.selectionService.getSelectionCount(_this.tableID);
	            }
	            switch (res.action) {
	                case 'uncheck':
	                    _this.isCurrentPageRecordsSelected = false;
	                    break;
	                case 'selectAll':
	                    _this.allSelected = true;
	                    _this.isCurrentPageRecordsSelected = false;
	                    break;
	                case 'clear':
	                    _this.allSelected = false;
	                    _this.isCurrentPageRecordsSelected = false;
	                    break;
	            }
	        };
	        this.getPageRecordKey = function (propertyIdentifier) {
	            return _this.listingService.getPageRecordKey(propertyIdentifier);
	        };
	        this.getAdminAttributesByType = function (type) {
	            var recordActionName = 'record' + type.toUpperCase() + 'Action';
	            var recordActionPropertyName = recordActionName + 'Property';
	            var recordActionQueryStringName = recordActionName + 'QueryString';
	            var recordActionModalName = recordActionName + 'Modal';
	            _this.adminattributes = _this.utilityService.listAppend(_this.adminattributes, 'data-' + type + 'action="' + _this[recordActionName] + '"', " ");
	            if (_this[recordActionPropertyName] && _this[recordActionPropertyName].length) {
	                _this.adminattributes = _this.utilityService.listAppend(_this.adminattributes, 'data-' + type + 'actionproperty="' + _this[recordActionPropertyName] + '"', " ");
	            }
	            _this.adminattributes = _this.utilityService.listAppend(_this.adminattributes, 'data-' + type + 'querystring="' + _this[recordActionQueryStringName] + '"', " ");
	            _this.adminattributes = _this.utilityService.listAppend(_this.adminattributes, 'data-' + type + 'modal="' + _this[recordActionModalName] + '"', " ");
	        };
	        this.getExportAction = function () {
	            return _this.exportAction + _this.collectionID;
	        };
	        this.exportCurrentList = function (selection) {
	            if (selection === void 0) { selection = false; }
	            if (_this.collectionConfigs.length == 0) {
	                var exportCollectionConfig = angular.copy(_this.collectionConfig.getCollectionConfig());
	                if (selection && !angular.isUndefined(_this.selectionService.getSelections(_this.tableID))
	                    && (_this.selectionService.getSelections(_this.tableID).length > 0)) {
	                    exportCollectionConfig.filterGroups[0].filterGroup = [
	                        {
	                            "displayPropertyIdentifier": _this.rbkeyService.getRBKey("entity." + exportCollectionConfig.baseEntityName.toLowerCase() + "." + _this.exampleEntity.$$getIDName().toLowerCase()),
	                            "propertyIdentifier": exportCollectionConfig.baseEntityAlias + "." + _this.exampleEntity.$$getIDName(),
	                            "comparisonOperator": (_this.allSelected) ? "not in" : "in",
	                            "value": _this.selectionService.getSelections(_this.tableID).join(),
	                            "displayValue": _this.selectionService.getSelections(_this.tableID).join(),
	                            "ormtype": "string",
	                            "fieldtype": "id",
	                            "conditionDisplay": "In List"
	                        }
	                    ];
	                }
	            }
	            else {
	            }
	            $('body').append('<form action="/?' + _this.$hibachi.getConfigValue('action') + '=main.collectionConfigExport" method="post" id="formExport"></form>');
	            $('#formExport')
	                .append("<input type='hidden' name='collectionConfig' value='" + angular.toJson(exportCollectionConfig) + "' />")
	                .submit()
	                .remove();
	        };
	        this.paginationPageChange = function (res) {
	            _this.isCurrentPageRecordsSelected = false;
	        };
	        this.selectCurrentPageRecords = function () {
	            _this.listingService.selectCurrentPageRecords(_this.tableID);
	        };
	        //these are no longer going to work
	        this.clearSelection = function () {
	            _this.selectionService.clearSelection(_this.tableID);
	        };
	        this.selectAll = function () {
	            _this.selectionService.selectAll(_this.tableID);
	        };
	        //promises to determine which set of logic will run
	        this.multipleCollectionDeffered = $q.defer();
	        this.multipleCollectionPromise = this.multipleCollectionDeffered.promise;
	        this.singleCollectionDeferred = $q.defer();
	        this.singleCollectionPromise = this.singleCollectionDeferred.promise;
	        if (angular.isDefined(this.collection) && angular.isString(this.collection)) {
	            //not sure why we have two properties for this
	            this.baseEntityName = this.collection;
	            this.collectionObject = this.collection;
	            this.collectionConfig = this.collectionConfigService.newCollectionConfig(this.collectionObject);
	            this.$timeout(function () {
	                _this.collection = _this.collectionConfig;
	                _this.columns = _this.collectionConfig.columns;
	            });
	            this.multipleCollectionDeffered.reject();
	        }
	        this.initializeState();
	        this.hasCollectionPromise = angular.isDefined(this.collectionPromise);
	        if (angular.isDefined(this.collectionPromise)) {
	            this.hasCollectionPromise = true;
	            this.multipleCollectionDeffered.reject();
	        }
	        if (this.collectionConfig != null) {
	            this.multipleCollectionDeffered.reject();
	        }
	        this.listingService.setListingState(this.tableID, this);
	        //this is performed after the listing state is set above to populate columns and multiple collectionConfigs if present
	        this.$transclude(this.$scope, function () { });
	        console.log('multislot', this.multiSlot);
	        if (this.multiSlot) {
	            this.singleCollectionPromise.then(function () {
	                _this.multipleCollectionDeffered.reject();
	            });
	            this.multipleCollectionPromise.then(function () {
	                //now do the intial setup
	                _this.listingService.setupInMultiCollectionConfigMode(_this.tableID);
	            }).catch(function () {
	                //do the initial setup for single collection mode
	                _this.listingService.setupInSingleCollectionConfigMode(_this.tableID, _this.$scope);
	            }).finally(function () {
	                if (angular.isUndefined(_this.getCollection)) {
	                    _this.getCollection = _this.listingService.setupDefaultGetCollection(_this.tableID);
	                }
	                _this.paginator.getCollection = _this.getCollection;
	                var getCollectionEventID = _this.tableID;
	                _this.observerService.attach(_this.getCollectionObserver, 'getCollection', getCollectionEventID);
	            });
	        }
	        else if (this.multiSlot == false) {
	            this.setupCollectionPromise();
	        }
	    }
	    return SWListingDisplayController;
	}());
	var SWListingDisplay = (function () {
	    //@ngInject
	    function SWListingDisplay(listingPartialPath, hibachiPathBuilder) {
	        this.listingPartialPath = listingPartialPath;
	        this.hibachiPathBuilder = hibachiPathBuilder;
	        this.restrict = 'E';
	        this.scope = {};
	        this.transclude = {
	            addAction: "?swListingAddAction",
	            detailAction: "?swListingDetailAction",
	            deleteAction: "?swListingDeleteAction",
	            editAction: "?swListingEditAction",
	            saveAction: "?swListingSaveAction",
	            columns: "?swListingColumns",
	            collectionConfigs: "?swCollectionConfigs",
	            disableRules: "?swDisabledRowRules",
	            expandableRules: "?swExpandableRowRules",
	            customListingControls: "?swCustomListingControls"
	        };
	        this.bindToController = {
	            isRadio: "<?",
	            angularLinks: "<?",
	            isAngularRoute: "<?",
	            name: "@?",
	            /*required*/
	            collection: "<?",
	            collectionConfig: "<?",
	            getCollection: "&?",
	            collectionPromise: "<?",
	            edit: "<?",
	            /*Optional*/
	            title: "<?",
	            childPropertyName: "@?",
	            baseEntity: "<?",
	            baseEntityName: "@?",
	            baseEntityId: "@?",
	            /*Admin Actions*/
	            actions: "<?",
	            administrativeCount: "@?",
	            recordEditAction: "@?",
	            recordEditActionProperty: "@?",
	            recordEditQueryString: "@?",
	            recordEditModal: "<?",
	            recordEditDisabled: "<?",
	            recordDetailAction: "@?",
	            recordDetailActionProperty: "@?",
	            recordDetailQueryString: "@?",
	            recordDetailModal: "<?",
	            recordDeleteAction: "@?",
	            recordDeleteActionProperty: "@?",
	            recordDeleteQueryString: "@?",
	            recordAddAction: "@?",
	            recordAddActionProperty: "@?",
	            recordAddQueryString: "@?",
	            recordAddModal: "<?",
	            recordAddDisabled: "<?",
	            recordProcessesConfig: "<?",
	            /* record processes config is an array of actions. Example:
	            [
	            {
	                recordProcessAction:"@",
	                recordProcessActionProperty:"@",
	                recordProcessQueryString:"@",
	                recordProcessContext:"@",
	                recordProcessEntity:"=",
	                recordProcessEntityData:"=",
	                recordProcessUpdateTableID:"=",
	                recordProcessButtonDisplayFlag:"=",
	            }
	            ]
	            */
	            /*Hierachy Expandable*/
	            parentPropertyName: "@?",
	            //booleans
	            expandable: "<?",
	            expandableOpenRoot: "<?",
	            /*Searching*/
	            searchText: "<?",
	            /*Sorting*/
	            sortable: "<?",
	            sortableFieldName: "@?",
	            sortProperty: "@?",
	            sortContextIDColumn: "@?",
	            sortContextIDValue: "@?",
	            /*Single Select*/
	            selectFiledName: "@?",
	            selectValue: "@?",
	            selectTitle: "@?",
	            /*Multiselect*/
	            multiselectFieldName: "@?",
	            multiselectPropertyIdentifier: "@?",
	            multiselectIdPaths: "@?",
	            multiselectValues: "@?",
	            /*Helper / Additional / Custom*/
	            tableattributes: "@?",
	            tableclass: "@?",
	            typeaheadDataKey: "@?",
	            adminattributes: "@?",
	            /* Settings */
	            showheader: "<?",
	            showOrderBy: "<?",
	            showTopPagination: "<?",
	            showSearch: "<?",
	            showSearchFilters: "<?",
	            /* Basic Action Caller Overrides*/
	            createModal: "<?",
	            createAction: "@?",
	            createQueryString: "@?",
	            exportAction: "@?",
	            getChildCount: "<?",
	            hasSearch: "<?",
	            hasActionBar: "<?",
	            multiSlot: "<?",
	            customListingControls: "<?"
	        };
	        this.controller = SWListingDisplayController;
	        this.controllerAs = "swListingDisplay";
	        this.compile = function (element, attrs) {
	            return {
	                pre: function ($scope, element, attrs, transclude) {
	                },
	                post: function ($scope, element, attrs) {
	                }
	            };
	        };
	        this.listingPartialPath = listingPartialPath;
	        this.templateUrl = hibachiPathBuilder.buildPartialsPath(this.listingPartialPath) + 'listingdisplay.html';
	    }
	    SWListingDisplay.Factory = function () {
	        var directive = function (listingPartialPath, hibachiPathBuilder) { return new SWListingDisplay(listingPartialPath, hibachiPathBuilder); };
	        directive.$inject = [
	            'listingPartialPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWListingDisplay;
	}());
	exports.SWListingDisplay = SWListingDisplay;


/***/ },
/* 140 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWListingDisplayCellController = (function () {
	    //@ngInject
	    function SWListingDisplayCellController(listingPartialPath, hibachiPathBuilder, listingService, utilityService, $scope) {
	        var _this = this;
	        this.listingPartialPath = listingPartialPath;
	        this.hibachiPathBuilder = hibachiPathBuilder;
	        this.listingService = listingService;
	        this.utilityService = utilityService;
	        this.$scope = $scope;
	        this.expandable = false;
	        this.getDirectiveTemplate = function () {
	            var templateUrl = _this.hibachiPathBuilder.buildPartialsPath(_this.listingPartialPath) + 'listingdisplaycell.html';
	            if (_this.expandable || (_this.swListingDisplay.expandable && _this.column.tdclass && _this.column.tdclass === 'primary')) {
	                templateUrl = _this.hibachiPathBuilder.buildPartialsPath(_this.listingPartialPath) + 'listingdisplayselectablecellexpandable.html';
	            }
	            if (!_this.swListingDisplay.expandable || !_this.column.tdclass || _this.column.tdclass !== 'primary') {
	                if (_this.column.ormtype === 'timestamp') {
	                    templateUrl = _this.hibachiPathBuilder.buildPartialsPath(_this.listingPartialPath) + 'listingdisplaycelldate.html';
	                }
	                else if (_this.column.type === 'currency') {
	                    templateUrl = _this.hibachiPathBuilder.buildPartialsPath(_this.listingPartialPath) + 'listingdisplaycellcurrency.html';
	                }
	                else if (_this.column.aggregate) {
	                    _this.value = _this.pageRecord[_this.swListingDisplay.getPageRecordKey(_this.column.aggregate.aggregateAlias)];
	                    templateUrl = _this.hibachiPathBuilder.buildPartialsPath(_this.listingPartialPath) + 'listingdisplaycellaggregate.html';
	                }
	            }
	            return templateUrl;
	        };
	        this.hibachiPathBuilder = hibachiPathBuilder;
	        this.listingPartialPath = listingPartialPath;
	        this.$scope = $scope;
	        this.value = this.listingService.getPageRecordValueByColumn(this.pageRecord, this.column);
	        this.popover = this.utilityService.replaceStringWithProperties(this.column.tooltip, this.pageRecord);
	        this.hasActionCaller = false;
	        if (this.column.action && this.column.queryString) {
	            this.hasActionCaller = true;
	            this.actionCaller = {
	                action: this.column.action
	            };
	            if (this.column.queryString) {
	                this.actionCaller.action.queryString = this.swListingDisplay.replaceStringWithProperties(this.column.queryString, this.pageRecord);
	            }
	        }
	        if (this.cellView) {
	            var htmlCellView = this.utilityService.camelCaseToSnakeCase(this.cellView);
	            this.template = htmlCellView;
	            //convert the page records into attrs
	            this.templateVariables = this.pageRecord;
	            if (angular.isDefined(this.column.columnID)) {
	                this.templateVariables["column"] = this.column.columnID;
	            }
	            if (angular.isDefined(this.swListingDisplay.baseEntityName) && angular.isDefined(this.swListingDisplay.baseEntityId)) {
	                this.templateVariables["baseEntityId"] = this.swListingDisplay.baseEntityId;
	                this.templateVariables["baseEntityName"] = this.swListingDisplay.baseEntityName;
	            }
	            if (angular.isDefined(this.column.propertyIdentifier)) {
	                this.templateVariables["columnPropertyIdentifier"] = this.column.propertyIdentifier;
	            }
	            this.templateVariables["listingDisplayID"] = this.swListingDisplay.tableID;
	        }
	        else {
	            this.templateUrl = this.getDirectiveTemplate();
	        }
	    }
	    return SWListingDisplayCellController;
	}());
	var SWListingDisplayCell = (function () {
	    //@ngInject
	    function SWListingDisplayCell() {
	        this.restrict = 'E';
	        this.scope = {};
	        this.bindToController = {
	            swListingDisplay: "=?",
	            column: "=?",
	            pageRecord: "=?",
	            cellView: "@?",
	            expandableRules: "=?"
	        };
	        this.controller = SWListingDisplayCellController;
	        this.controllerAs = "swListingDisplayCell";
	        this.template = "\n        <div ng-if=\"swListingDisplayCell.template\" sw-directive data-variables=\"swListingDisplayCell.templateVariables\" data-directive-template=\"swListingDisplayCell.template\"></div>\n        <div ng-if=\"swListingDisplayCell.templateUrl\" ng-include src=\"swListingDisplayCell.templateUrl\"></div>\n        <sw-action-caller ng-if=\"swListingDisplayCell.hasActionCaller\"\n                    data-action=\"{{swListingDisplayCell.actionCaller.action}}\"\n                    data-query-string=\"{{swListingDisplayCell.actionCaller.action.queryString}}\"\n                    data-text=\"{{swListingDisplayCell.value}}\"\n                    data-tooltip-text=\"{{swListingDisplayCell.popover}}\"\n\n        >\n        </sw-action-caller>\n    ";
	    }
	    SWListingDisplayCell.Factory = function () {
	        var directive = function () { return new SWListingDisplayCell(); };
	        directive.$inject = [];
	        return directive;
	    };
	    return SWListingDisplayCell;
	}());
	exports.SWListingDisplayCell = SWListingDisplayCell;


/***/ },
/* 141 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWListingControlsController = (function () {
	    //@ngInject
	    function SWListingControlsController($hibachi, metadataService, collectionService, listingService, observerService) {
	        var _this = this;
	        this.$hibachi = $hibachi;
	        this.metadataService = metadataService;
	        this.collectionService = collectionService;
	        this.listingService = listingService;
	        this.observerService = observerService;
	        this.displayOptionsClosed = true;
	        this.filtersClosed = true;
	        this.columnIsControllableMap = {};
	        this.filterActions = function (res) {
	            if (res.action == 'add') {
	                _this.paginator.setCurrentPage(1);
	            }
	            _this.filtersClosed = true;
	        };
	        this.getSelectedSearchColumnName = function () {
	            return (angular.isUndefined(_this.selectedSearchColumn)) ? 'All' : _this.selectedSearchColumn.title;
	        };
	        this.canDisplayColumn = function (column) {
	            if (angular.isDefined(_this.columnIsControllableMap[column.propertyIdentifier])) {
	                return _this.columnIsControllableMap[column.propertyIdentifier];
	            }
	            for (var i = 0; i < _this.listingColumns.length; i++) {
	                if (column.propertyIdentifier == _this.listingColumns[i].propertyIdentifier) {
	                    _this.columnIsControllableMap[column.propertyIdentifier] = true;
	                }
	            }
	            if (!_this.columnIsControllableMap[column.propertyIdentifier]) {
	                _this.columnIsControllableMap[column.propertyIdentifier] = false;
	            }
	            return _this.columnIsControllableMap[column.propertyIdentifier];
	        };
	        this.addSearchFilter = function () {
	            if (angular.isUndefined(_this.selectedSearchColumn) || !_this.searchText)
	                return;
	            var keywords = _this.searchText.split(" ");
	            for (var i = 0; i < keywords.length; i++) {
	                _this.collectionConfig.addLikeFilter(_this.selectedSearchColumn.propertyIdentifier, keywords[i], '%w%', undefined, _this.selectedSearchColumn.title);
	            }
	            _this.searchText = '';
	            _this.collectionConfig.setKeywords(_this.searchText);
	            _this.paginator.setCurrentPage(1);
	        };
	        this.toggleDisplayOptions = function (closeButton) {
	            if (closeButton === void 0) { closeButton = false; }
	            if (closeButton) {
	                _this.displayOptionsClosed = true;
	            }
	            else {
	                _this.displayOptionsClosed = !_this.displayOptionsClosed;
	            }
	        };
	        this.setItemInUse = function (booleanValue) {
	            _this.itemInUse = booleanValue;
	        };
	        this.removeFilter = function (array, index, reloadCollection) {
	            if (reloadCollection === void 0) { reloadCollection = true; }
	            array.splice(index, 1);
	            if (reloadCollection) {
	                _this.paginator.setCurrentPage(1);
	            }
	        };
	        this.toggleFilters = function () {
	            if (_this.filtersClosed) {
	                _this.filtersClosed = false;
	                _this.newFilterPosition = _this.collectionService.newFilterItem(_this.collectionConfig.filterGroups[0].filterGroup, _this.setItemInUse);
	            }
	        };
	        this.selectFilterItem = function (filterItem) {
	            _this.filtersClosed = false;
	            _this.collectionService.selectFilterItem(filterItem);
	        };
	        this.saveCollection = function () {
	            _this.getCollection()();
	        };
	        if (angular.isUndefined(this.showToggleFilters)) {
	            this.showToggleFilters = true;
	        }
	        if (angular.isUndefined(this.showToggleDisplayOptions)) {
	            this.showToggleDisplayOptions = true;
	        }
	        if (angular.isUndefined(this.showFilters)) {
	            this.showFilters = false;
	        }
	        this.backupColumnsConfig = this.collectionConfig.getColumns();
	        if (angular.isDefined(this.tableId)) {
	            this.listingColumns = this.listingService.getListingColumns(this.tableId);
	        }
	        this.filterPropertiesList = {};
	        $hibachi.getFilterPropertiesByBaseEntityName(this.collectionConfig.baseEntityAlias).then(function (value) {
	            metadataService.setPropertiesList(value, _this.collectionConfig.baseEntityAlias);
	            _this.filterPropertiesList[_this.collectionConfig.baseEntityAlias] = metadataService.getPropertiesListByBaseEntityAlias(_this.collectionConfig.baseEntityAlias);
	            metadataService.formatPropertiesList(_this.filterPropertiesList[_this.collectionConfig.baseEntityAlias], _this.collectionConfig.baseEntityAlias);
	        });
	        this.observerService.attach(this.filterActions, 'filterItemAction');
	    }
	    return SWListingControlsController;
	}());
	var SWListingControls = (function () {
	    function SWListingControls(collectionPartialsPath, hibachiPathBuilder) {
	        this.collectionPartialsPath = collectionPartialsPath;
	        this.hibachiPathBuilder = hibachiPathBuilder;
	        this.restrict = 'E';
	        this.scope = {};
	        this.bindToController = {
	            collectionConfig: "=",
	            tableId: "=?",
	            paginator: "=",
	            getCollection: "&",
	            showFilters: "=?",
	            showToggleFilters: "=?",
	            showToggleDisplayOptions: "=?"
	        };
	        this.controller = SWListingControlsController;
	        this.controllerAs = 'swListingControls';
	        this.templateUrl = this.hibachiPathBuilder.buildPartialsPath(this.collectionPartialsPath) + "listingcontrols.html";
	    }
	    SWListingControls.Factory = function () {
	        var directive = function (listingPartialPath, hibachiPathBuilder) { return new SWListingControls(listingPartialPath, hibachiPathBuilder); };
	        directive.$inject = ['listingPartialPath', 'hibachiPathBuilder'];
	        return directive;
	    };
	    return SWListingControls;
	}());
	SWListingControls.$inject = ['listingPartialPath', 'hibachiPathBuilder'];
	exports.SWListingControls = SWListingControls;


/***/ },
/* 142 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWListingAggregateController = (function () {
	    function SWListingAggregateController() {
	        var _this = this;
	        this.init = function () {
	            _this.editable = _this.editable || false;
	        };
	        this.init();
	    }
	    return SWListingAggregateController;
	}());
	var SWListingAggregate = (function () {
	    function SWListingAggregate() {
	        this.restrict = 'EA';
	        this.scope = true;
	        this.bindToController = {
	            propertyIdentifier: "@",
	            aggregateFunction: "@",
	            aggregateAlias: "@?"
	        };
	        this.controller = SWListingAggregateController;
	        this.controllerAs = "swListingAggregate";
	        this.link = function (scope, element, attrs) {
	            var aggregate = {
	                propertyIdentifier: scope.swListingAggregate.propertyIdentifier,
	                aggregateFunction: scope.swListingAggregate.aggregateFunction,
	                aggregateAlias: scope.swListingAggregate.aggregateAlias,
	            };
	            scope.$parent.swListingDisplay.aggregates.push(aggregate);
	        };
	    }
	    SWListingAggregate.Factory = function () {
	        var directive = function () { return new SWListingAggregate(); };
	        directive.$inject = [];
	        return directive;
	    };
	    return SWListingAggregate;
	}());
	exports.SWListingAggregate = SWListingAggregate;


/***/ },
/* 143 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWListingColorFilterController = (function () {
	    function SWListingColorFilterController() {
	        this.init = function () {
	        };
	        this.init();
	    }
	    return SWListingColorFilterController;
	}());
	var SWListingColorFilter = (function () {
	    function SWListingColorFilter(utilityService) {
	        var _this = this;
	        this.utilityService = utilityService;
	        this.restrict = 'EA';
	        this.scope = true;
	        this.bindToController = {
	            propertyToCompare: "@",
	            comparisonOperator: "@",
	            comparisonValue: "@",
	            comparisonProperty: "@",
	            colorClass: "@",
	            color: "@"
	        };
	        this.controller = SWListingColorFilterController;
	        this.controllerAs = "swListingColorFilter";
	        this.link = function (scope, element, attrs) {
	            var colorFilter = {
	                propertyToCompare: scope.swListingColorFilter.propertyToCompare,
	                comparisonOperator: scope.swListingColorFilter.comparisonOperator,
	                comparisonValue: scope.swListingColorFilter.comparisonValue,
	                comparisonProperty: scope.swListingColorFilter.comparisonProperty,
	                colorClass: scope.swListingColorFilter.colorClass,
	                color: scope.swListingColorFilter.color
	            };
	            if (_this.utilityService.ArrayFindByPropertyValue(scope.$parent.swListingDisplay.colorFilters, 'propertyToCompare', colorFilter.propertyToCompare) === -1) {
	                scope.$parent.swListingDisplay.colorFilters.push(colorFilter);
	            }
	        };
	    }
	    SWListingColorFilter.Factory = function () {
	        var directive = function (utilityService) { return new SWListingColorFilter(utilityService); };
	        directive.$inject = [
	            'utilityService'
	        ];
	        return directive;
	    };
	    return SWListingColorFilter;
	}());
	exports.SWListingColorFilter = SWListingColorFilter;


/***/ },
/* 144 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWListingColumnController = (function () {
	    //@ngInject
	    function SWListingColumnController($injector) {
	        var _this = this;
	        this.$injector = $injector;
	        this.hasCellView = false;
	        this.hasHeaderView = false;
	        this.init = function () {
	            _this.editable = _this.editable || false;
	            //did a cellView get suggested, if so does it exist
	            if (_this.cellView) {
	                if (_this.$injector.has(_this.cellView + 'Directive')) {
	                    _this.hasCellView = true;
	                }
	                else {
	                    throw (_this.cellView + ' is not an existing directive');
	                }
	            }
	            if (_this.headerView) {
	                if (_this.$injector.has(_this.headerView + 'Directive')) {
	                    _this.hasHeaderView = true;
	                }
	                else {
	                    throw (_this.headerView + ' is not an existing directive');
	                }
	            }
	        };
	        this.$injector = $injector;
	        this.init();
	    }
	    return SWListingColumnController;
	}());
	var SWListingColumn = (function () {
	    function SWListingColumn(listingService, scopeService, utilityService) {
	        var _this = this;
	        this.listingService = listingService;
	        this.scopeService = scopeService;
	        this.utilityService = utilityService;
	        this.restrict = 'EA';
	        this.scope = true;
	        this.bindToController = {
	            propertyIdentifier: "@",
	            processObjectProperty: "@?",
	            //defined as aggregate = {aggregateFunction:'COUNT',aggregateAlias:'aliasstring'}
	            aggregate: "=?",
	            title: "@?",
	            tdclass: "@?",
	            search: "=?",
	            sort: "=?",
	            filter: "=?",
	            isVisible: "=?",
	            range: "=?",
	            editable: "=?",
	            buttonGroup: "=?",
	            cellView: "@?",
	            headerView: "@?",
	            fallbackPropertyIdentifiers: "@?"
	        };
	        this.controller = SWListingColumnController;
	        this.controllerAs = "swListingColumn";
	        this.link = function (scope, element, attrs) {
	            var column = {
	                columnID: "C" + _this.utilityService.createID(31),
	                propertyIdentifier: scope.swListingColumn.propertyIdentifier,
	                fallbackPropertyIdentifiers: scope.swListingColumn.fallbackPropertyIdentifiers,
	                processObjectProperty: scope.swListingColumn.processObjectProperty,
	                title: scope.swListingColumn.title,
	                tdclass: scope.swListingColumn.tdclass,
	                search: scope.swListingColumn.search,
	                sort: scope.swListingColumn.sort,
	                filter: scope.swListingColumn.filter,
	                range: scope.swListingColumn.range,
	                editable: scope.swListingColumn.editable,
	                buttonGroup: scope.swListingColumn.buttonGroup,
	                hasCellView: scope.swListingColumn.hasCellView,
	                hasHeaderView: scope.swListingColumn.hasHeaderView,
	                isVisible: scope.swListingColumn.isVisible || true
	            };
	            if (scope.swListingColumn.hasCellView) {
	                column.cellView = scope.swListingColumn.cellView;
	            }
	            if (scope.swListingColumn.hasHeaderView) {
	                column.headerView = _this.utilityService.camelCaseToSnakeCase(scope.swListingColumn.headerView);
	            }
	            //aggregate logic
	            if (scope.swListingColumn.aggregate) {
	                column.aggregate = scope.swListingColumn.aggregate;
	                column.aggregate.propertyIdentifier = scope.swListingColumn.propertyIdentifier;
	            }
	            var listingDisplayScope = _this.scopeService.getRootParentScope(scope, "swListingDisplay");
	            if (angular.isDefined(listingDisplayScope)
	                && angular.isDefined(listingDisplayScope.swListingDisplay)
	                && angular.isDefined(listingDisplayScope.swListingDisplay.tableID)
	                && listingDisplayScope.swListingDisplay.tableID.length) {
	                var listingDisplayID = listingDisplayScope.swListingDisplay.tableID;
	                _this.listingService.addColumn(listingDisplayID, column);
	            }
	            else {
	                throw ("listing display scope not available to sw-listing-column or there is no table id");
	            }
	        };
	    }
	    SWListingColumn.Factory = function () {
	        var directive = function (listingService, scopeService, utilityService) { return new SWListingColumn(listingService, scopeService, utilityService); };
	        directive.$inject = [
	            'listingService',
	            'scopeService',
	            'utilityService'
	        ];
	        return directive;
	    };
	    return SWListingColumn;
	}());
	SWListingColumn.$inject = ['utilityService'];
	exports.SWListingColumn = SWListingColumn;


/***/ },
/* 145 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	/* SwListingDisableRule
	 * defines a filter, by which to determine what rows will be disabled
	 */
	var SWListingDisableRuleController = (function () {
	    //@ngInject
	    function SWListingDisableRuleController($q) {
	        this.$q = $q;
	    }
	    return SWListingDisableRuleController;
	}());
	var SWListingDisableRule = (function () {
	    function SWListingDisableRule(scopeService, $q) {
	        var _this = this;
	        this.scopeService = scopeService;
	        this.$q = $q;
	        this.restrict = 'EA';
	        this.scope = true;
	        this.template = "\n        \n    ";
	        this.bindToController = {
	            filterPropertyIdentifier: "@",
	            filterComparisonOperator: "@",
	            filterComparisonValue: "@"
	        };
	        this.controller = SWListingDisableRuleController;
	        this.controllerAs = "swListingDisableRule";
	        this.link = function (scope, element, attrs) {
	            var rule = {
	                filterPropertyIdentifier: scope.swListingDisableRule.filterPropertyIdentifier,
	                filterComparisonOperator: scope.swListingDisableRule.filterComparisonOperator,
	                filterComparisonValue: scope.swListingDisableRule.filterComparisonValue
	            };
	            var listingDisplayScope = _this.scopeService.getRootParentScope(scope, "swListingDisplay");
	            if (angular.isDefined(listingDisplayScope.swListingDisplay)) {
	                listingDisplayScope = listingDisplayScope.swListingDisplay;
	            }
	            else {
	                throw ("listing display scope not available to sw-listing-disable-rule");
	            }
	            listingDisplayScope.disableRules.push(rule);
	        };
	    }
	    SWListingDisableRule.Factory = function () {
	        var directive = function (scopeService, $q) { return new SWListingDisableRule(scopeService, $q); };
	        directive.$inject = [
	            'scopeService',
	            '$q'
	        ];
	        return directive;
	    };
	    return SWListingDisableRule;
	}());
	exports.SWListingDisableRule = SWListingDisableRule;


/***/ },
/* 146 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	/* SWListingExpandableRule
	 * defines a filter, by which to determine what will be expanded
	 * supplies the collection config and any other necessary rules for what will be loaded and displayed
	 */
	var SWListingExpandableRuleController = (function () {
	    //@ngInject
	    function SWListingExpandableRuleController($q) {
	        this.$q = $q;
	        this.hasChildrenCollectionConfigDeferred = $q.defer();
	        this.hasChildrenCollectionConfigPromise = this.hasChildrenCollectionConfigDeferred.promise;
	        //why did I need this? 
	        this.childrenCollectionConfig = null;
	    }
	    return SWListingExpandableRuleController;
	}());
	var SWListingExpandableRule = (function () {
	    function SWListingExpandableRule(scopeService, $q) {
	        var _this = this;
	        this.scopeService = scopeService;
	        this.$q = $q;
	        this.restrict = 'EA';
	        this.scope = true;
	        this.transclude = {
	            collectionConfig: "?swConfig"
	        };
	        this.template = "\n        <div ng-transclude=\"collectionConfig\"></div> \n    ";
	        this.bindToController = {
	            childrenCollectionConfig: "=?",
	            filterPropertyIdentifier: "@",
	            filterComparisonOperator: "@",
	            filterComparisonValue: "@",
	            refreshChildrenEvent: "@?"
	        };
	        this.controller = SWListingExpandableRuleController;
	        this.controllerAs = "swListingExpandableRule";
	        this.link = function (scope, element, attrs) {
	            scope.swListingExpandableRule.hasChildrenCollectionConfigPromise.then(function () {
	                var rule = {
	                    filterPropertyIdentifier: scope.swListingExpandableRule.filterPropertyIdentifier,
	                    filterComparisonOperator: scope.swListingExpandableRule.filterComparisonOperator,
	                    filterComparisonValue: scope.swListingExpandableRule.filterComparisonValue,
	                    childrenCollectionConfig: scope.swListingExpandableRule.childrenCollectionConfig,
	                    refreshChildrenEvent: scope.swListingExpandableRule.refreshChildrenEvent
	                };
	                var listingDisplayScope = _this.scopeService.getRootParentScope(scope, "swListingDisplay");
	                if (angular.isDefined(listingDisplayScope.swListingDisplay)) {
	                    listingDisplayScope = listingDisplayScope.swListingDisplay;
	                }
	                else {
	                    throw ("listing display scope not available to sw-listing-expandable-rule");
	                }
	                listingDisplayScope.expandableRules.push(rule);
	            });
	        };
	    }
	    SWListingExpandableRule.Factory = function () {
	        var directive = function (scopeService, $q) { return new SWListingExpandableRule(scopeService, $q); };
	        directive.$inject = [
	            'scopeService',
	            '$q'
	        ];
	        return directive;
	    };
	    return SWListingExpandableRule;
	}());
	exports.SWListingExpandableRule = SWListingExpandableRule;


/***/ },
/* 147 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWListingFilterController = (function () {
	    function SWListingFilterController() {
	        this.init = function () {
	        };
	        this.init();
	    }
	    return SWListingFilterController;
	}());
	var SWListingFilter = (function () {
	    function SWListingFilter() {
	        this.restrict = 'EA';
	        this.scope = true;
	        this.bindToController = {
	            propertyIdentifier: "@",
	            comparisonOperator: "@",
	            comparisonValue: "@",
	            logicalOperator: "@",
	            hidden: "@?"
	        };
	        this.controller = SWListingFilterController;
	        this.controllerAs = "swListingFilter";
	        this.link = function (scope, element, attrs) {
	            var filter = {
	                propertyIdentifier: scope.swListingFilter.propertyIdentifier,
	                comparisonOperator: scope.swListingFilter.comparisonOperator,
	                comparisonValue: scope.swListingFilter.comparisonValue,
	                logicalOperator: scope.swListingFilter.logicalOperator,
	                hidden: false
	            };
	            if (angular.isDefined(scope.swListingFilter.hidden)) {
	                filter['hidden'] = scope.swListingFilter.hidden;
	            }
	            if (angular.isDefined(scope.$parent.swListingFilterGroup)) {
	                scope.$parent.swListingFilterGroup.filters.push(filter);
	            }
	            else {
	                scope.$parent.swListingDisplay.filters.push(filter);
	            }
	        };
	    }
	    SWListingFilter.Factory = function () {
	        var directive = function () { return new SWListingFilter(); };
	        directive.$inject = [];
	        return directive;
	    };
	    return SWListingFilter;
	}());
	exports.SWListingFilter = SWListingFilter;


/***/ },
/* 148 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWListingFilterGroupController = (function () {
	    function SWListingFilterGroupController($scope, $transclude) {
	        this.$scope = $scope;
	        this.$transclude = $transclude;
	        this.filters = [];
	        $transclude($scope, function () { });
	        $scope.$parent.swListingDisplay.filterGroups.push(this.filters);
	    }
	    return SWListingFilterGroupController;
	}());
	var SWListingFilterGroup = (function () {
	    function SWListingFilterGroup() {
	        this.restrict = 'EA';
	        this.transclude = true;
	        this.scope = true;
	        this.bindToController = {};
	        this.controller = SWListingFilterGroupController;
	        this.controllerAs = "swListingFilterGroup";
	    }
	    SWListingFilterGroup.Factory = function () {
	        var directive = function () { return new SWListingFilterGroup(); };
	        directive.$inject = [];
	        return directive;
	    };
	    return SWListingFilterGroup;
	}());
	SWListingFilterGroup.$inject = [];
	exports.SWListingFilterGroup = SWListingFilterGroup;


/***/ },
/* 149 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWListingOrderByController = (function () {
	    //@ngInject
	    function SWListingOrderByController() {
	        this.init = function () {
	        };
	        this.init();
	    }
	    return SWListingOrderByController;
	}());
	var SWListingOrderBy = (function () {
	    //@ngInject
	    function SWListingOrderBy(utilityService) {
	        this.utilityService = utilityService;
	        this.restrict = 'EA';
	        this.scope = true;
	        this.bindToController = {
	            orderBy: "@",
	        };
	        this.controller = SWListingOrderByController;
	        this.controllerAs = "swListingOrderBy";
	        this.link = function (scope, element, attrs) {
	            var orderBy = {
	                orderBy: scope.swListingOrderBy.orderBy,
	            };
	            scope.$parent.swListingDisplay.orderBys.push(orderBy);
	        };
	    }
	    SWListingOrderBy.Factory = function () {
	        var directive = function (utilityService) { return new SWListingOrderBy(utilityService); };
	        directive.$inject = [
	            'utilityService'
	        ];
	        return directive;
	    };
	    return SWListingOrderBy;
	}());
	exports.SWListingOrderBy = SWListingOrderBy;


/***/ },
/* 150 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWListingRowSaveController = (function () {
	    //@ngInject
	    function SWListingRowSaveController(listingService) {
	        var _this = this;
	        this.listingService = listingService;
	        this.save = function () {
	            _this.listingService.markSaved(_this.listingID, _this.pageRecordIndex);
	        };
	    }
	    return SWListingRowSaveController;
	}());
	var SWListingRowSave = (function () {
	    function SWListingRowSave(hibachiPathBuilder, listingPartialPath, utilityService, scopeService) {
	        var _this = this;
	        this.hibachiPathBuilder = hibachiPathBuilder;
	        this.listingPartialPath = listingPartialPath;
	        this.utilityService = utilityService;
	        this.scopeService = scopeService;
	        this.restrict = 'EA';
	        this.scope = true;
	        this.bindToController = {};
	        this.controller = SWListingRowSaveController;
	        this.controllerAs = "swListingRowSave";
	        this.link = function ($scope, element, attrs) {
	            var currentScope = _this.scopeService.getRootParentScope($scope, "pageRecord");
	            if (angular.isDefined(currentScope["pageRecord"])) {
	                $scope.swListingRowSave.pageRecord = currentScope["pageRecord"];
	            }
	            var currentScope = _this.scopeService.getRootParentScope($scope, "pageRecordKey");
	            if (angular.isDefined(currentScope["pageRecordKey"])) {
	                $scope.swListingRowSave.pageRecordIndex = currentScope["pageRecordKey"];
	            }
	            var currentScope = _this.scopeService.getRootParentScope($scope, "swListingDisplay");
	            if (angular.isDefined(currentScope["swListingDisplay"])) {
	                $scope.swListingRowSave.listingID = currentScope["swListingDisplay"].tableID;
	            }
	        };
	        this.templateUrl = hibachiPathBuilder.buildPartialsPath(this.listingPartialPath) + 'listingrowsave.html';
	    }
	    SWListingRowSave.Factory = function () {
	        var directive = function (hibachiPathBuilder, listingPartialPath, utilityService, scopeService) { return new SWListingRowSave(hibachiPathBuilder, listingPartialPath, utilityService, scopeService); };
	        directive.$inject = [
	            'hibachiPathBuilder',
	            'listingPartialPath',
	            'utilityService',
	            'scopeService'
	        ];
	        return directive;
	    };
	    return SWListingRowSave;
	}());
	SWListingRowSave.$inject = ['utilityService'];
	exports.SWListingRowSave = SWListingRowSave;


/***/ },
/* 151 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWListingSearchController = (function () {
	    //@ngInject
	    function SWListingSearchController($hibachi, metadataService, listingService, collectionService, observerService) {
	        var _this = this;
	        this.$hibachi = $hibachi;
	        this.metadataService = metadataService;
	        this.listingService = listingService;
	        this.collectionService = collectionService;
	        this.observerService = observerService;
	        this.displayOptionsClosed = true;
	        this.filtersClosed = true;
	        this.selectSearchColumn = function (column) {
	            _this.selectedSearchColumn = column;
	            if (_this.searchText) {
	                _this.search();
	            }
	        };
	        this.getSelectedSearchColumnName = function () {
	            return (angular.isUndefined(_this.selectedSearchColumn)) ? 'All' : _this.selectedSearchColumn.title;
	        };
	        this.search = function () {
	            if (_this.searchText.length > 0) {
	                _this.listingService.setExpandable(_this.listingId, false);
	            }
	            else {
	                _this.listingService.setExpandable(_this.listingId, true);
	            }
	            if (angular.isDefined(_this.selectedSearchColumn)) {
	                _this.backupColumnsConfig = angular.copy(_this.collectionConfig.getColumns());
	                var collectionColumns = _this.collectionConfig.getColumns();
	                for (var i = 0; i < collectionColumns.length; i++) {
	                    if (collectionColumns[i].propertyIdentifier != _this.selectedSearchColumn.propertyIdentifier) {
	                        collectionColumns[i].isSearchable = false;
	                    }
	                }
	                _this.collectionConfig.setKeywords(_this.searchText);
	                _this.paginator.setCurrentPage(1);
	                _this.collectionConfig.setColumns(_this.backupColumnsConfig);
	            }
	            else {
	                _this.collectionConfig.setKeywords(_this.searchText);
	                _this.paginator.setCurrentPage(1);
	            }
	        };
	        this.addSearchFilter = function () {
	            if (angular.isUndefined(_this.selectedSearchColumn) || !_this.searchText)
	                return;
	            var keywords = _this.searchText.split(" ");
	            for (var i = 0; i < keywords.length; i++) {
	                _this.collectionConfig.addLikeFilter(_this.selectedSearchColumn.propertyIdentifier, keywords[i], '%w%', undefined, _this.selectedSearchColumn.title);
	            }
	            _this.searchText = '';
	            _this.collectionConfig.setKeywords(_this.searchText);
	            _this.paginator.setCurrentPage(1);
	        };
	        if (angular.isUndefined(this.showToggleFilters)) {
	            this.showToggleFilters = true;
	        }
	        if (angular.isUndefined(this.showToggleDisplayOptions)) {
	            this.showToggleDisplayOptions = true;
	        }
	    }
	    return SWListingSearchController;
	}());
	var SWListingSearch = (function () {
	    //@ngInject
	    function SWListingSearch(scopeService, collectionPartialsPath, hibachiPathBuilder) {
	        var _this = this;
	        this.scopeService = scopeService;
	        this.collectionPartialsPath = collectionPartialsPath;
	        this.hibachiPathBuilder = hibachiPathBuilder;
	        this.restrict = 'EA';
	        this.scope = {};
	        this.bindToController = {
	            collectionConfig: "=?",
	            paginator: "=?",
	            getCollection: "&",
	            toggleFilters: "&?",
	            toggleDisplayOptions: "&?",
	            showToggleFilters: "=?",
	            showToggleDisplayOptions: "=?",
	            listingId: "@?"
	        };
	        this.controller = SWListingSearchController;
	        this.controllerAs = 'swListingSearch';
	        this.link = function (scope, element, attrs) {
	            if (angular.isUndefined(scope.swListingSearch.collectionConfig) && _this.scopeService.hasParentScope(scope, "swListingDisplay")) {
	                var listingDisplayScope = _this.scopeService.getRootParentScope(scope, "swListingDisplay")["swListingDisplay"];
	                if (listingDisplayScope.collectionConfig != null) {
	                    scope.swListingSearch.collectionConfig = listingDisplayScope.collectionConfig;
	                }
	                if (listingDisplayScope.paginator != null) {
	                    scope.swListingSearch.paginator = listingDisplayScope.paginator;
	                }
	                scope.swListingSearch.listingId = listingDisplayScope.tableID;
	            }
	            scope.swListingSearch.backupColumnsConfig = scope.swListingSearch.collectionConfig.getColumns();
	        };
	        this.templateUrl = this.hibachiPathBuilder.buildPartialsPath(this.collectionPartialsPath) + "listingsearch.html";
	    }
	    SWListingSearch.Factory = function () {
	        var directive = function (scopeService, listingPartialPath, hibachiPathBuilder) { return new SWListingSearch(scopeService, listingPartialPath, hibachiPathBuilder); };
	        directive.$inject = ['scopeService', 'listingPartialPath', 'hibachiPathBuilder'];
	        return directive;
	    };
	    return SWListingSearch;
	}());
	exports.SWListingSearch = SWListingSearch;


/***/ },
/* 152 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWListingGlobalSearchController = (function () {
	    //@ngInject
	    function SWListingGlobalSearchController($timeout) {
	        var _this = this;
	        this.$timeout = $timeout;
	        this.init = function () {
	            _this.searching = false;
	        };
	        this.search = function () {
	            _this.searching = true;
	            if (_this._timeoutPromise) {
	                _this.$timeout.cancel(_this._timeoutPromise);
	            }
	            _this._timeoutPromise = _this.$timeout(function () {
	                _this.getCollection();
	            }, 500);
	        };
	        this.init();
	    }
	    return SWListingGlobalSearchController;
	}());
	var SWListingGlobalSearch = (function () {
	    //@ngInject
	    function SWListingGlobalSearch(utilityService, listingPartialPath, hibachiPathBuilder) {
	        this.utilityService = utilityService;
	        this.restrict = 'EA';
	        this.scope = {};
	        this.bindToController = {
	            searching: "=",
	            searchText: "=",
	            getCollection: "="
	        };
	        this.controller = SWListingGlobalSearchController;
	        this.controllerAs = "swListingGlobalSearch";
	        this.link = function (scope, element, attrs) {
	        };
	        this.templateUrl = hibachiPathBuilder.buildPartialsPath(listingPartialPath) + "listingglobalsearch.html";
	    }
	    SWListingGlobalSearch.Factory = function () {
	        var directive = function (utilityService, listingPartialPath, hibachiPathBuilder) { return new SWListingGlobalSearch(utilityService, listingPartialPath, hibachiPathBuilder); };
	        directive.$inject = ['utilityService', 'listingPartialPath', 'hibachiPathBuilder'];
	        return directive;
	    };
	    return SWListingGlobalSearch;
	}());
	exports.SWListingGlobalSearch = SWListingGlobalSearch;


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/// <reference path='../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../typings/tsd.d.ts' />
	//services
	// import {AccountService} from "./services/accountservice";
	// import {CartService} from "./services/cartservice";
	// import {UtilityService} from "./services/utilityservice";
	// import {SelectionService} from "./services/selectionservice";
	// import {ObserverService} from "./services/observerservice";
	// import {FormService} from "./services/formservice";
	// import {MetaDataService} from "./services/metadataservice";
	//controllers
	var otherwisecontroller_1 = __webpack_require__(154);
	var routercontroller_1 = __webpack_require__(155);
	//directives
	var swdetailtabs_1 = __webpack_require__(156);
	var swdetail_1 = __webpack_require__(157);
	var swlist_1 = __webpack_require__(158);
	var core_module_1 = __webpack_require__(3);
	var entitymodule = angular.module('hibachi.entity', ['ngRoute', core_module_1.coremodule.name])
	    .config(['$routeProvider', '$injector', '$locationProvider', 'appConfig',
	    function ($routeProvider, $injector, $locationProvider, appConfig) {
	        //detect if we are in hashbang mode
	        var vars = {};
	        var parts = window.location.href.replace(/[?&]+([^=&]+)#([^/]*)/gi, function (m, key, value) {
	            vars[key] = value;
	        });
	        if (vars.ng) {
	            $locationProvider.html5Mode(false).hashPrefix('!');
	        }
	        var snakeToCapitalCase = function (s) {
	            return s.charAt(0).toUpperCase() + s.replace(/(\-\w)/g, function (m) { return m[1].toUpperCase(); }).slice(1);
	        };
	        $routeProvider.when('/entity/:entityName/', {
	            template: function (params) {
	                var entityDirectiveExists = $injector.has('sw' + snakeToCapitalCase(params.entityName) + 'ListDirective');
	                if (entityDirectiveExists) {
	                    return '<sw-' + params.entityName.toLowerCase() + '-list></sw-' + params.entityName.toLowerCase() + '-list>';
	                }
	                else {
	                    return '<sw-list></sw-list>';
	                }
	            },
	            controller: 'routerController'
	        }).when('/entity/:entityName/:entityID', {
	            template: function (params) {
	                var entityDirectiveExists = $injector.has('sw' + snakeToCapitalCase(params.entityName) + 'DetailDirective');
	                if (entityDirectiveExists) {
	                    return '<sw-' + params.entityName.toLowerCase() + '-detail></sw-' + params.entityName.toLowerCase() + '-detail>';
	                }
	                else {
	                    return '<sw-detail></sw-detail>';
	                }
	            },
	            controller: 'routerController',
	        });
	        //        .otherwise({
	        //         //controller:'otherwiseController'
	        //         templateUrl: appConfig.baseURL + '/admin/client/js/partials/otherwise.html',
	        //     });
	    }])
	    .constant('coreEntityPartialsPath', 'entity/components/')
	    .controller('otherwiseController', otherwisecontroller_1.OtherWiseController)
	    .controller('routerController', routercontroller_1.RouterController)
	    .directive('swDetail', swdetail_1.SWDetail.Factory())
	    .directive('swDetailTabs', swdetailtabs_1.SWDetailTabs.Factory())
	    .directive('swList', swlist_1.SWList.Factory());
	exports.entitymodule = entitymodule;


/***/ },
/* 154 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var OtherWiseController = (function () {
	    //@ngInject
	    function OtherWiseController($scope) {
	        $scope.$id = "otherwiseController";
	    }
	    return OtherWiseController;
	}());
	exports.OtherWiseController = OtherWiseController;


/***/ },
/* 155 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var RouterController = (function () {
	    //@ngInject
	    function RouterController($scope, $routeParams, $location, $log, partialsPath, baseURL, utilityService) {
	        $scope.$id = "routerController";
	        $scope.partialRoute = '';
	        $log.debug($routeParams);
	        $log.debug($location);
	        var path = $location.path();
	        $scope.controllerType = path.split('/')[1];
	        var type;
	        if ($scope.controllerType === 'entity') {
	            //remove all dashes
	            $scope.entityName = utilityService.snakeToCapitalCase($routeParams.entityName);
	            if (angular.isDefined($routeParams.entityID)) {
	                $scope.entityID = $routeParams.entityID || '';
	            }
	        }
	    }
	    return RouterController;
	}());
	exports.RouterController = RouterController;


/***/ },
/* 156 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWDetailTabs = (function () {
	    function SWDetailTabs($location, $log, $hibachi, coreEntityPartialsPath, hibachiPathBuilder) {
	        return {
	            restrict: 'E',
	            templateUrl: hibachiPathBuilder.buildPartialsPath(coreEntityPartialsPath) + 'detailtabs.html',
	            link: function (scope, element, attr) {
	            }
	        };
	    }
	    SWDetailTabs.Factory = function () {
	        var directive = function ($location, $log, $hibachi, coreEntityPartialsPath, hibachiPathBuilder) { return new SWDetailTabs($location, $log, $hibachi, coreEntityPartialsPath, hibachiPathBuilder); };
	        directive.$inject = [
	            '$location',
	            '$log',
	            '$hibachi',
	            'coreEntityPartialsPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWDetailTabs;
	}());
	exports.SWDetailTabs = SWDetailTabs;


/***/ },
/* 157 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWDetail = (function () {
	    function SWDetail($location, $log, $hibachi, coreEntityPartialsPath, hibachiPathBuilder) {
	        return {
	            restrict: 'E',
	            templateUrl: hibachiPathBuilder.buildPartialsPath(coreEntityPartialsPath) + '/detail.html',
	            link: function (scope, element, attr) {
	                scope.$id = "slatwallDetailController";
	                $log.debug('slatwallDetailController');
	                /*Sets the view dirty on save*/
	                scope.setDirty = function (entity) {
	                    angular.forEach(entity.forms, function (form) {
	                        form.$setSubmitted();
	                    });
	                };
	                var setupMetaData = function () {
	                    scope[scope.entityName.toLowerCase()] = scope.entity;
	                    scope.entity.metaData.$$getDetailTabs().then(function (value) {
	                        scope.detailTabs = value.data;
	                        $log.debug('detailtabs');
	                        $log.debug(scope.detailTabs);
	                    });
	                };
	                var propertyCasedEntityName = scope.entityName.charAt(0).toUpperCase() + scope.entityName.slice(1);
	                scope.tabPartialPath = hibachiPathBuilder.buildPartialsPath(coreEntityPartialsPath);
	                scope.getEntity = function () {
	                    if (scope.entityID === 'create') {
	                        scope.createMode = true;
	                        scope.entity = $hibachi['new' + propertyCasedEntityName]();
	                        setupMetaData();
	                    }
	                    else {
	                        scope.createMode = false;
	                        var entityPromise = $hibachi['get' + propertyCasedEntityName]({ id: scope.entityID });
	                        entityPromise.promise.then(function () {
	                            scope.entity = entityPromise.value;
	                            setupMetaData();
	                        });
	                    }
	                };
	                scope.getEntity();
	                scope.deleteEntity = function () {
	                    var deletePromise = scope.entity.$$delete();
	                    deletePromise.then(function () {
	                        $location.path('/entity/' + propertyCasedEntityName + '/');
	                    });
	                };
	                scope.allTabsOpen = false;
	            }
	        };
	    }
	    SWDetail.Factory = function () {
	        var directive = function ($location, $log, $hibachi, coreEntityPartialsPath, hibachiPathBuilder) { return new SWDetail($location, $log, $hibachi, coreEntityPartialsPath, hibachiPathBuilder); };
	        directive.$inject = [
	            '$location',
	            '$log',
	            '$hibachi',
	            'coreEntityPartialsPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWDetail;
	}());
	exports.SWDetail = SWDetail;


/***/ },
/* 158 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWList = (function () {
	    function SWList($log, $hibachi, coreEntityPartialsPath, hibachiPathBuilder) {
	        return {
	            restrict: 'E',
	            templateUrl: hibachiPathBuilder.buildPartialsPath(coreEntityPartialsPath) + '/list.html',
	            link: function (scope, element, attr) {
	                $log.debug('slatwallList init');
	                //scope.getCollection = function(){
	                //
	                //	var pageShow = 50;
	                //	if(scope.pageShow !== 'Auto'){
	                //		pageShow = scope.pageShow;
	                //	}
	                //	scope.entityName = scope.entityName.charAt(0).toUpperCase()+scope.entityName.slice(1);
	                //	var collectionListingPromise = $hibachi.getEntity(scope.entityName, {currentPage:scope.currentPage, pageShow:pageShow, keywords:scope.keywords});
	                //	collectionListingPromise.then(function(value){
	                //		scope.collection = value;
	                //		scope.collectionConfig = angular.fromJson(scope.collection.collectionConfig);
	                //	});
	                //};
	                //scope.getCollection();
	            }
	        };
	    }
	    SWList.Factory = function () {
	        var directive = function ($log, $hibachi, coreEntityPartialsPath, hibachiPathBuilder) { return new SWList($log, $hibachi, coreEntityPartialsPath, hibachiPathBuilder); };
	        directive.$inject = [
	            '$log',
	            '$hibachi',
	            'coreEntityPartialsPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWList;
	}());
	exports.SWList = SWList;


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/// <reference path="../../typings/tsd.d.ts" />
	/// <reference path="../../typings/hibachiTypescript.d.ts" />
	//services
	var paginationservice_1 = __webpack_require__(160);
	var swpaginationbar_1 = __webpack_require__(161);
	var core_module_1 = __webpack_require__(3);
	var paginationmodule = angular.module('hibachi.pagination', [core_module_1.coremodule.name])
	    .run([function () {
	    }])
	    .service('paginationService', paginationservice_1.PaginationService)
	    .directive('swPaginationBar', swpaginationbar_1.SWPaginationBar.Factory())
	    .constant('partialsPath', 'pagination/components/');
	exports.paginationmodule = paginationmodule;


/***/ },
/* 160 */
/***/ function(module, exports) {

	/// <reference path="../../../typings/tsd.d.ts" />
	/// <reference path="../../../typings/hibachiTypescript.d.ts" />
	/*collection service is used to maintain the state of the ui*/
	"use strict";
	var Pagination = (function () {
	    //@ngInject
	    function Pagination(observerService, uuid) {
	        var _this = this;
	        this.observerService = observerService;
	        this.uuid = uuid;
	        this.pageShow = 10;
	        this.currentPage = 1;
	        this.pageStart = 0;
	        this.pageEnd = 0;
	        this.recordsCount = 0;
	        this.totalPages = 0;
	        this.pageShowOptions = [
	            { display: 10, value: 10 },
	            { display: 20, value: 20 },
	            { display: 50, value: 50 },
	            { display: 250, value: 250 },
	            { display: "Auto", value: "Auto" }
	        ];
	        this.autoScrollPage = 1;
	        this.autoScrollDisabled = false;
	        this.getSelectedPageShowOption = function () {
	            return _this.selectedPageShowOption;
	        };
	        this.pageShowOptionChanged = function (pageShowOption) {
	            _this.setPageShow(pageShowOption.value);
	            _this.setCurrentPage(1);
	        };
	        this.getTotalPages = function () {
	            return _this.totalPages;
	        };
	        this.setTotalPages = function (totalPages) {
	            _this.totalPages = totalPages;
	        };
	        this.getPageStart = function () {
	            return _this.pageStart;
	        };
	        this.setPageStart = function (pageStart) {
	            _this.pageStart = pageStart;
	        };
	        this.getPageEnd = function () {
	            return _this.pageEnd;
	        };
	        this.setPageEnd = function (pageEnd) {
	            _this.pageEnd = pageEnd;
	        };
	        this.getRecordsCount = function () {
	            return _this.recordsCount;
	        };
	        this.setRecordsCount = function (recordsCount) {
	            _this.recordsCount = recordsCount;
	        };
	        this.getPageShowOptions = function () {
	            return _this.pageShowOptions;
	        };
	        this.setPageShowOptions = function (pageShowOptions) {
	            _this.pageShowOptions = pageShowOptions;
	        };
	        this.getPageShow = function () {
	            return _this.pageShow;
	        };
	        this.setPageShow = function (pageShow) {
	            _this.pageShow = pageShow;
	        };
	        this.getCurrentPage = function () {
	            return _this.currentPage;
	        };
	        this.setCurrentPage = function (currentPage) {
	            _this.currentPage = currentPage;
	            _this.getCollection();
	            _this.observerService.notify('swPaginationAction', { action: 'pageChange', currentPage: currentPage });
	        };
	        this.previousPage = function () {
	            if (_this.getCurrentPage() == 1)
	                return;
	            _this.setCurrentPage(_this.getCurrentPage() - 1);
	        };
	        this.nextPage = function () {
	            if (_this.getCurrentPage() < _this.getTotalPages()) {
	                _this.setCurrentPage(_this.getCurrentPage() + 1);
	            }
	        };
	        this.hasPrevious = function () {
	            return (_this.getPageStart() <= 1);
	        };
	        this.hasNext = function () {
	            return (_this.getPageEnd() === _this.getRecordsCount());
	        };
	        this.showPreviousJump = function () {
	            return (angular.isDefined(_this.getCurrentPage()) && _this.getCurrentPage() > 3);
	        };
	        this.showNextJump = function () {
	            return !!(_this.getCurrentPage() < _this.getTotalPages() - 3 && _this.getTotalPages() > 6);
	        };
	        this.previousJump = function () {
	            _this.setCurrentPage(_this.currentPage - 3);
	        };
	        this.nextJump = function () {
	            _this.setCurrentPage(_this.getCurrentPage() + 3);
	        };
	        this.showPageNumber = function (pageNumber) {
	            if (_this.getCurrentPage() >= _this.getTotalPages() - 3) {
	                if (pageNumber > _this.getTotalPages() - 6) {
	                    return true;
	                }
	            }
	            if (_this.getCurrentPage() <= 3) {
	                if (pageNumber < 6) {
	                    return true;
	                }
	            }
	            else {
	                var bottomRange = _this.getCurrentPage() - 2;
	                var topRange = _this.getCurrentPage() + 2;
	                if (pageNumber > bottomRange && pageNumber < topRange) {
	                    return true;
	                }
	            }
	            return false;
	        };
	        this.setPageRecordsInfo = function (collection) {
	            _this.setRecordsCount(collection.recordsCount);
	            if (_this.getRecordsCount() === 0) {
	                _this.setPageStart(0);
	            }
	            else {
	                _this.setPageStart(collection.pageRecordsStart);
	            }
	            _this.setPageEnd(collection.pageRecordsEnd);
	            _this.setTotalPages(collection.totalPages);
	            _this.totalPagesArray = [];
	            if (angular.isUndefined(_this.getCurrentPage()) || _this.getCurrentPage() < 5) {
	                var start = 1;
	                var end = (_this.getTotalPages() <= 10) ? _this.getTotalPages() + 1 : 10;
	            }
	            else {
	                var start = (!_this.showNextJump()) ? _this.getTotalPages() - 4 : _this.getCurrentPage() - 3;
	                var end = (_this.showNextJump()) ? _this.getCurrentPage() + 5 : _this.getTotalPages() + 1;
	            }
	            for (var i = start; i < end; i++) {
	                _this.totalPagesArray.push(i);
	            }
	        };
	        this.uuid = uuid;
	        this.selectedPageShowOption = this.pageShowOptions[0];
	    }
	    return Pagination;
	}());
	exports.Pagination = Pagination;
	var PaginationService = (function () {
	    //@ngInject
	    function PaginationService(utilityService, observerService) {
	        var _this = this;
	        this.utilityService = utilityService;
	        this.observerService = observerService;
	        this.paginations = {};
	        this.createPagination = function () {
	            var uuid = _this.utilityService.createID(10);
	            _this.paginations[uuid] = new Pagination(_this.observerService, uuid);
	            return _this.paginations[uuid];
	        };
	        this.getPagination = function (uuid) {
	            if (!uuid)
	                return;
	            return _this.paginations[uuid];
	        };
	    }
	    return PaginationService;
	}());
	exports.PaginationService = PaginationService;


/***/ },
/* 161 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	//import pagination = require('../services/paginationservice');
	//var PaginationService = pagination.PaginationService;
	//'use strict';
	var SWPaginationBarController = (function () {
	    //@ngInject
	    function SWPaginationBarController(paginationService) {
	        this.paginationService = paginationService;
	        if (angular.isUndefined(this.paginator)) {
	            this.paginator = paginationService.createPagination();
	        }
	    }
	    return SWPaginationBarController;
	}());
	exports.SWPaginationBarController = SWPaginationBarController;
	var SWPaginationBar = (function () {
	    //@ngInject
	    function SWPaginationBar(hibachiPathBuilder, partialsPath) {
	        this.restrict = 'E';
	        this.scope = {};
	        this.bindToController = {
	            paginator: "=?"
	        };
	        this.controller = SWPaginationBarController;
	        this.controllerAs = "swPaginationBar";
	        this.link = function (scope, element, attrs) { };
	        this.templateUrl = hibachiPathBuilder.buildPartialsPath(partialsPath) + 'paginationbar.html';
	    }
	    SWPaginationBar.Factory = function () {
	        var directive = function (hibachiPathBuilder, partialsPath) { return new SWPaginationBar(hibachiPathBuilder, partialsPath); };
	        directive.$inject = ['hibachiPathBuilder', 'partialsPath'];
	        return directive;
	    };
	    return SWPaginationBar;
	}());
	exports.SWPaginationBar = SWPaginationBar;


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path='../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../typings/tsd.d.ts' />
	"use strict";
	//module
	var core_module_1 = __webpack_require__(3);
	//services
	var fileservice_1 = __webpack_require__(163);
	//directives
	//  components
	//form
	var swinput_1 = __webpack_require__(164);
	var swfformfield_1 = __webpack_require__(165);
	var swform_1 = __webpack_require__(166);
	var swformfield_1 = __webpack_require__(167);
	var swformfieldfile_1 = __webpack_require__(168);
	var swformfieldjson_1 = __webpack_require__(169);
	var swformfieldsearchselect_1 = __webpack_require__(170);
	var swformregistrar_1 = __webpack_require__(171);
	var swerrordisplay_1 = __webpack_require__(172);
	var swaddressform_1 = __webpack_require__(173);
	var swpropertydisplay_1 = __webpack_require__(174);
	var swfpropertydisplay_1 = __webpack_require__(175);
	var swformsubscriber_1 = __webpack_require__(176);
	var formmodule = angular.module('hibachi.form', ['angularjs-datetime-picker', core_module_1.coremodule.name]).config(function () {
	})
	    .constant('coreFormPartialsPath', 'form/components/')
	    .service('fileService', fileservice_1.FileService)
	    .directive('swInput', swinput_1.SWInput.Factory())
	    .directive('swfFormField', swfformfield_1.SWFFormField.Factory())
	    .directive('swForm', swform_1.SWForm.Factory())
	    .directive('swFormField', swformfield_1.SWFormField.Factory())
	    .directive('swFormFieldFile', swformfieldfile_1.SWFormFieldFile.Factory())
	    .directive('swFormFieldJson', swformfieldjson_1.SWFormFieldJson.Factory())
	    .directive('swFormFieldSearchSelect', swformfieldsearchselect_1.SWFormFieldSearchSelect.Factory())
	    .directive('swFormRegistrar', swformregistrar_1.SWFormRegistrar.Factory())
	    .directive('swfPropertyDisplay', swfpropertydisplay_1.SWFPropertyDisplay.Factory(swfpropertydisplay_1.SWFPropertyDisplay, "swfpropertydisplay.html"))
	    .directive('swPropertyDisplay', swpropertydisplay_1.SWPropertyDisplay.Factory(swpropertydisplay_1.SWPropertyDisplay, "propertydisplay.html"))
	    .directive('swErrorDisplay', swerrordisplay_1.SWErrorDisplay.Factory())
	    .directive('swAddressForm', swaddressform_1.SWAddressForm.Factory())
	    .directive('swFormSubscriber', swformsubscriber_1.SWFormSubscriber.Factory());
	exports.formmodule = formmodule;


/***/ },
/* 163 */
/***/ function(module, exports) {

	"use strict";
	var FileService = (function () {
	    //@ngInject
	    function FileService($q, observerService) {
	        var _this = this;
	        this.$q = $q;
	        this.observerService = observerService;
	        this.fileStates = {};
	        this.imageExists = function (src) {
	            var deferred = _this.$q.defer();
	            var image = new Image();
	            image.onerror = function () {
	                deferred.reject();
	            };
	            image.onload = function () {
	                deferred.resolve();
	            };
	            image.src = src;
	            return deferred.promise;
	        };
	        this.uploadFile = function (file, object, property) {
	            var deferred = _this.$q.defer();
	            var promise = deferred.promise;
	            var fileReader = new FileReader();
	            fileReader.readAsDataURL(file);
	            fileReader.onload = function (result) {
	                object.data[property] = fileReader.result;
	                deferred.resolve(fileReader.result);
	            };
	            fileReader.onerror = function (result) {
	                deferred.reject();
	                throw ("fileservice couldn't read the file");
	            };
	            return promise;
	        };
	    }
	    return FileService;
	}());
	exports.FileService = FileService;


/***/ },
/* 164 */
/***/ function(module, exports) {

	"use strict";
	var SWInputController = (function () {
	    //@ngInject
	    function SWInputController($timeout, $scope, $log, $compile, $hibachi, $injector, listingService, utilityService, rbkeyService, observerService, metadataService) {
	        var _this = this;
	        this.$timeout = $timeout;
	        this.$scope = $scope;
	        this.$log = $log;
	        this.$compile = $compile;
	        this.$hibachi = $hibachi;
	        this.$injector = $injector;
	        this.listingService = listingService;
	        this.utilityService = utilityService;
	        this.rbkeyService = rbkeyService;
	        this.observerService = observerService;
	        this.metadataService = metadataService;
	        this.eventHandlers = "";
	        this.onSuccess = function () {
	            _this.utilityService.setPropertyValue(_this.swForm.object, _this.property, _this.value);
	            if (_this.swPropertyDisplay) {
	                _this.utilityService.setPropertyValue(_this.swPropertyDisplay.object, _this.property, _this.value);
	            }
	            if (_this.swfPropertyDisplay) {
	                _this.utilityService.setPropertyValue(_this.swfPropertyDisplay.object, _this.property, _this.value);
	                _this.swfPropertyDisplay.editing = false;
	            }
	            _this.utilityService.setPropertyValue(_this.swFormField.object, _this.property, _this.value);
	        };
	        this.getValidationDirectives = function () {
	            var spaceDelimitedList = '';
	            var name = _this.property;
	            var form = _this.form;
	            _this.$log.debug("Name is:" + name + " and form is: " + form);
	            if (_this.metadataService.isAttributePropertyByEntityAndPropertyIdentifier(_this.object, _this.propertyIdentifier)) {
	                _this.object.validations.properties[name] = [];
	                if (_this.object.metaData[_this.property].requiredFlag && _this.object.metaData[_this.property].requiredFlag.trim().toLowerCase() == "yes") {
	                    _this.object.validations.properties[name].push({
	                        contexts: "save",
	                        required: true
	                    });
	                }
	                if (_this.object.metaData[_this.property].validationRegex) {
	                    _this.object.validations.properties[name].push({
	                        contexts: "save", regex: _this.object.metaData[_this.property].validationRegex
	                    });
	                }
	            }
	            if (angular.isUndefined(_this.object.validations)
	                || angular.isUndefined(_this.object.validations.properties)
	                || angular.isUndefined(_this.object.validations.properties[_this.property])) {
	                return '';
	            }
	            var validations = _this.object.validations.properties[_this.property];
	            _this.$log.debug("Validations: ", validations);
	            _this.$log.debug(_this.form);
	            var validationsForContext = [];
	            //get the form context and the form name.
	            var formContext = _this.swForm.context;
	            var formName = _this.swForm.name;
	            _this.$log.debug("Form context is: ");
	            _this.$log.debug(formContext);
	            _this.$log.debug("Form Name: ");
	            _this.$log.debug(formName);
	            //get the validations for the current element.
	            var propertyValidations = _this.object.validations.properties[name];
	            /*
	            * Investigating why number inputs are not working.
	            * */
	            //check if the contexts match.
	            if (angular.isObject(propertyValidations)) {
	                //if this is a procesobject validation then the context is implied
	                if (angular.isUndefined(propertyValidations[0].contexts) && _this.object.metaData.isProcessObject) {
	                    propertyValidations[0].contexts = _this.object.metaData.className.split('_')[1];
	                }
	                if (propertyValidations[0].contexts === formContext) {
	                    _this.$log.debug("Matched");
	                    for (var prop in propertyValidations[0]) {
	                        if (prop != "contexts" && prop !== "conditions") {
	                            spaceDelimitedList += (" swvalidation" + prop.toLowerCase() + "='" + propertyValidations[0][prop] + "'");
	                        }
	                    }
	                }
	                _this.$log.debug(spaceDelimitedList);
	            }
	            //loop over validations that are required and create the space delimited list
	            _this.$log.debug(validations);
	            //get all validations related to the form context;
	            _this.$log.debug(form);
	            angular.forEach(validations, function (validation, key) {
	                if (validation.contexts && _this.utilityService.listFind(validation.contexts.toLowerCase(), _this.swForm.context.toLowerCase()) !== -1) {
	                    _this.$log.debug("Validations for context");
	                    _this.$log.debug(validation);
	                    validationsForContext.push(validation);
	                }
	            });
	            return spaceDelimitedList;
	        };
	        this.clear = function () {
	            if (_this.reverted) {
	                _this.reverted = false;
	                _this.showRevert = true;
	            }
	            _this.edited = false;
	            _this.value = _this.initialValue;
	            if (_this.inListingDisplay && _this.rowSaveEnabled) {
	                _this.listingService.markUnedited(_this.listingID, _this.pageRecordIndex, _this.propertyDisplayID);
	            }
	        };
	        this.revert = function () {
	            _this.showRevert = false;
	            _this.reverted = true;
	            _this.value = _this.revertToValue;
	            _this.onEvent({}, "change");
	        };
	        this.onEvent = function (event, eventName) {
	            var customEventName = _this.swForm.name + _this.name + eventName;
	            var data = {
	                event: event,
	                eventName: eventName,
	                form: _this.form,
	                swForm: _this.swForm,
	                swInput: _this,
	                inputElement: $('input').first()[0]
	            };
	            _this.observerService.notify(customEventName, data);
	        };
	        this.getTemplate = function () {
	            var template = '';
	            var validations = '';
	            var currencyTitle = '';
	            var currencyFormatter = '';
	            var style = "";
	            if (!_this.class) {
	                _this.class = "form-control";
	            }
	            if (!_this.noValidate) {
	                validations = _this.getValidationDirectives();
	            }
	            if (_this.object && _this.object.metaData && _this.object.metaData.$$getPropertyFormatType(_this.property) != undefined && _this.object.metaData.$$getPropertyFormatType(_this.property) == "currency") {
	                currencyFormatter = 'sw-currency-formatter ';
	                if (angular.isDefined(_this.object.data.currencyCode)) {
	                    currencyFormatter = currencyFormatter + 'data-currency-code="' + _this.object.data.currencyCode + '" ';
	                    currencyTitle = '<span class="s-title">' + _this.object.data.currencyCode + '</span>';
	                }
	            }
	            var appConfig = _this.$hibachi.getConfig();
	            var placeholder = '';
	            if (_this.object.metaData && _this.object.metaData[_this.property] && _this.object.metaData[_this.property].hb_nullrbkey) {
	                placeholder = _this.rbkeyService.getRBKey(_this.object.metaData[_this.property].hb_nullrbkey);
	            }
	            if (_this.fieldType.toLowerCase() === 'json') {
	                style = style += 'display:none';
	            }
	            var acceptedFieldTypes = ['email', 'text', 'password', 'number', 'time', 'date', 'datetime', 'json', 'file'];
	            if (acceptedFieldTypes.indexOf(_this.fieldType.toLowerCase()) >= 0) {
	                var inputType = _this.fieldType.toLowerCase();
	                if (_this.fieldType === 'time') {
	                    inputType = "text";
	                }
	                template = currencyTitle + '<input type="' + inputType + '" class="' + _this.class + '" ' +
	                    ' ng-model="swInput.value" ' +
	                    ' ng-disabled="swInput.editable === false" ' +
	                    ' ng-show="swInput.editing" ' +
	                    " ng-class=\"{'form-control':swInput.inListingDisplay, 'input-xs':swInput.inListingDisplay} \"" +
	                    ' name="' + _this.property + '" ' +
	                    ' placeholder="' + placeholder + '" ' +
	                    validations + currencyFormatter +
	                    ' id="swinput' + _this.swForm.name + _this.name + '" ' +
	                    ' style="' + style + '" ' + " " +
	                    _this.inputAttributes + " " +
	                    _this.eventHandlerTemplate;
	            }
	            var dateFieldTypes = ['date', 'datetime', 'time'];
	            if (dateFieldTypes.indexOf(_this.fieldType.toLowerCase()) >= 0) {
	                template = template + 'datetime-picker ';
	            }
	            if (_this.fieldType === 'time') {
	                template = template + 'data-time-only="true" date-format="' + appConfig.timeFormat.replace('tt', 'a') + '" ng-blur="swInput.pushBindings()"';
	            }
	            if (_this.fieldType === 'date') {
	                template = template + 'data-date-only="true" future-only date-format="' + appConfig.dateFormat + '" ';
	            }
	            if (template.length) {
	                template = template + ' />';
	            }
	            var actionButtons = "\n\t\t\t<a class=\"s-remove-change\"\n\t\t\t\tdata-ng-click=\"swPropertyDisplay.clear()\"\n\t\t\t\tdata-ng-if=\"swInput.edited && swInput.editing\">\n\t\t\t\t\t<i class=\"fa fa-remove\"></i>\n\t\t\t</a>\n\n\t\t\t<!-- Revert Button -->\n\t\t\t<button class=\"btn btn-xs btn-default s-revert-btn\"\n\t\t\t\t\tdata-ng-show=\"swInput.showRevert\"\n\t\t\t\t\tdata-ng-click=\"swInput.revert()\"\n\t\t\t\t\tdata-toggle=\"popover\"\n\t\t\t\t\tdata-trigger=\"hover\"\n\t\t\t\t\tdata-content=\"{{swInput.revertText}}\"\n\t\t\t\t\tdata-original-title=\"\"\n\t\t\t\t\ttitle=\"\">\n\t\t\t\t<i class=\"fa fa-refresh\"></i>\n\t\t\t</button>\n\t\t";
	            return template + actionButtons;
	        };
	        this.pullBindings = function () {
	            var bindToControllerProps = _this.$injector.get('swInputDirective')[0].bindToController;
	            for (var i in bindToControllerProps) {
	                if (!_this[i]) {
	                    if (!_this[i] && _this.swFormField && _this.swFormField[i]) {
	                        _this[i] = _this.swFormField[i];
	                    }
	                    else if (!_this[i] && _this.swPropertyDisplay && _this.swPropertyDisplay[i]) {
	                        _this[i] = _this.swPropertyDisplay[i];
	                    }
	                    else if (!_this[i] && _this.swfPropertyDisplay && _this.swfPropertyDisplay[i]) {
	                        _this[i] = _this.swfPropertyDisplay[i];
	                    }
	                    else if (!_this[i] && _this.swForm && _this.swForm[i]) {
	                        _this[i] = _this.swForm[i];
	                    }
	                }
	            }
	            _this.property = _this.property || _this.propertyIdentifier;
	            _this.propertyIdentifier = _this.propertyIdentifier || _this.property;
	            _this.type = _this.type || _this.fieldType;
	            _this.fieldType = _this.fieldType || _this.type;
	            _this.edit = _this.edit || _this.editing;
	            _this.editing = _this.editing || _this.edit;
	            _this.editing = _this.editing || true;
	            _this.fieldType = _this.fieldType || "text";
	            _this.inputAttributes = _this.inputAttributes || "";
	            _this.inputAttributes = _this.utilityService.replaceAll(_this.inputAttributes, "'", '"');
	            _this.value = _this.utilityService.getPropertyValue(_this.object, _this.property);
	        };
	        this.pushBindings = function () {
	            _this.observerService.notify('updateBindings').then(function () { });
	        };
	        this.$onInit = function () {
	            _this.pullBindings();
	            _this.eventHandlersArray = _this.eventHandlers.split(',');
	            _this.eventHandlerTemplate = "";
	            for (var i in _this.eventHandlersArray) {
	                var eventName = _this.eventHandlersArray[i];
	                if (eventName.length) {
	                    _this.eventHandlerTemplate += " ng-" + eventName + "=\"swInput.onEvent($event,'" + eventName + "')\"";
	                }
	            }
	            if (_this.object && _this.object.metaData && _this.object.metaData.className != undefined) {
	                _this.eventNameForObjectSuccess = _this.object.metaData.className.split('_')[0] + _this.context.charAt(0).toUpperCase() + _this.context.slice(1) + 'Success';
	            }
	            else {
	                _this.eventNameForObjectSuccess = _this.context.charAt(0).toUpperCase() + _this.context.slice(1) + 'Success';
	            }
	            var eventNameForObjectSuccessID = _this.eventNameForObjectSuccess + _this.property;
	            var eventNameForUpdateBindings = 'updateBindings';
	            if (_this.object && _this.object.metaData && _this.object.metaData.className != undefined) {
	                var eventNameForUpdateBindingsID = _this.object.metaData.className.split('_')[0] + _this.property + 'updateBindings';
	            }
	            else {
	                var eventNameForUpdateBindingsID = _this.property + 'updateBindings';
	            }
	            var eventNameForPullBindings = 'pullBindings';
	            if (_this.object && _this.object.metaData && _this.object.metaData.className != undefined) {
	                var eventNameForPullBindingsID = _this.object.metaData.className.split('_')[0] + _this.property + 'pullBindings';
	            }
	            else {
	                var eventNameForPullBindingsID = _this.property + 'pullBindings';
	            }
	            //attach a successObserver
	            if (_this.object) {
	                //update bindings on save success
	                _this.observerService.attach(_this.onSuccess, _this.eventNameForObjectSuccess, eventNameForObjectSuccessID);
	                //update bindings manually
	                _this.observerService.attach(_this.onSuccess, eventNameForUpdateBindings, eventNameForUpdateBindingsID);
	                //pull bindings from higher binding level manually
	                _this.observerService.attach(_this.pullBindings, eventNameForPullBindings, eventNameForPullBindingsID);
	            }
	            _this.$scope.$on("$destroy", function () {
	                _this.observerService.detachById(eventNameForUpdateBindings);
	                _this.observerService.detachById(eventNameForUpdateBindingsID);
	            });
	        };
	    }
	    return SWInputController;
	}());
	var SWInput = (function () {
	    //ngInject
	    function SWInput($compile, $timeout, $parse, fileService) {
	        var _this = this;
	        this.$compile = $compile;
	        this.$timeout = $timeout;
	        this.$parse = $parse;
	        this.fileService = fileService;
	        this.restrict = "E";
	        this.require = {
	            swForm: "?^swForm",
	            form: "?^form",
	            swFormField: "?^swFormField",
	            swPropertyDisplay: "?^swPropertyDisplay",
	            swfPropertyDisplay: "?^swfPropertyDisplay"
	        };
	        this.scope = {};
	        this.bindToController = {
	            propertyIdentifier: "@?",
	            name: "@?",
	            class: "@?",
	            errorClass: "@?",
	            option: "=?",
	            valueObject: "=?",
	            object: "=?",
	            label: "@?",
	            labelText: "@?",
	            labelClass: "@?",
	            inListingDisplay: "=?",
	            listingID: "=?",
	            pageRecordIndex: "=?",
	            propertyDisplayID: "=?",
	            initialValue: "=?",
	            optionValues: "=?",
	            edit: "=?",
	            title: "@?",
	            value: "=?",
	            errorText: "@?",
	            fieldType: "@?",
	            property: "@?",
	            binaryFileTarget: "@?",
	            rawFileTarget: "@?",
	            reverted: "=?",
	            revertToValue: "=?",
	            showRevert: "=?",
	            inputAttributes: "@?",
	            type: "@?",
	            editing: "=?",
	            eventHandlers: "@?",
	            context: "@?"
	        };
	        this.controller = SWInputController;
	        this.controllerAs = "swInput";
	        this.link = function (scope, element, attr) {
	            if (scope.swInput.type === 'file') {
	                if (angular.isUndefined(scope.swInput.object.data[scope.swInput.rawFileTarget])) {
	                    scope.swInput.object[scope.swInput.rawFileTarget] = "";
	                    scope.swInput.object.data[scope.swInput.rawFileTarget] = "";
	                }
	                var model = _this.$parse("swInput.object.data[swInput.rawFileTarget]");
	                var modelSetter = model.assign;
	                element.bind("change", function (e) {
	                    var fileToUpload = (e.srcElement || e.target).files[0];
	                    scope.$apply(function () {
	                        modelSetter(scope, fileToUpload);
	                    }, function () {
	                        throw ("swinput couldn't apply the file to scope");
	                    });
	                    _this.$timeout(function () {
	                        _this.fileService.uploadFile(fileToUpload, scope.swInput.object, scope.swInput.binaryFileTarget)
	                            .then(function (result) {
	                            scope.swInput.object[scope.swInput.property] = fileToUpload;
	                            scope.swInput.onEvent(e, "change");
	                        }, function () {
	                            //error	notify user
	                        });
	                    });
	                });
	            }
	            //renders the template and compiles it
	            element.html(scope.swInput.getTemplate());
	            _this.$compile(element.contents())(scope);
	        };
	    }
	    SWInput.Factory = function () {
	        var directive = function ($compile, $timeout, $parse, fileService) { return new SWInput($compile, $timeout, $parse, fileService); };
	        directive.$inject = [
	            '$compile',
	            '$timeout',
	            '$parse',
	            'fileService'
	        ];
	        return directive;
	    };
	    return SWInput;
	}());
	exports.SWInput = SWInput;


/***/ },
/* 165 */
/***/ function(module, exports) {

	/**********************************************************************************************
	 **********************************************************************************************
	 **********************************************************************************************
	 **		___________________________________________
	 ** 	Form Field - type have the following options (This is for the frontend so it can be modified):
	 **
	 **		checkbox			|	As a single checkbox this doesn't require any options, but it will create a hidden field for you so that the key gets submitted even when not checked.  The value of the checkbox will be 1
	 **		checkboxgroup		|	Requires the valueOptions to be an array of simple value if name and value is same or array of structs with the format of {value="", name=""}
	 **		file				|	No value can be passed in
	 **		multiselect			|	Requires the valueOptions to be an array of simple value if name and value is same or array of structs with the format of {value="", name=""}
	 **		password			|	No Value can be passed in
	 **		radiogroup			|	Requires the valueOptions to be an array of simple value if name and value is same or array of structs with the format of {value="", name=""}
	 **		select      		|	Requires the valueOptions to be an array of simple value if name and value is same or array of structs with the format of {value="", name=""}
	 **		text				|	Simple Text Field
	 **		textarea			|	Simple Textarea
	 **		yesno				|	This is used by booleans and flags to create a radio group of Yes and No
	 **		submit				|	submit button to post these properties back to the server.
	 **		------------------------------------------------------------------------------------------------------
	 **
	 **		attr.valueObject" type="any" default="" />
	 **		attr.valueObjectProperty" type="string" default="" />
	 **
	 **		General Settings that end up getting applied to the value object
	 **		attr.type" type="string" default="text"
	 **		attr.name" type="string" default=""
	 **		attr.class" type="string" default=""
	 **		attr.value" type="any" default=""
	 **		attr.valueOptions" type="array" default="#arrayNew(1)#"		<!--- Used for select, checkbox group, multiselect --->
	 **		attr.fieldAttributes" type="string" default=""
	 **
	 *********************************************************************************************
	 *********************************************************************************************
	 *********************************************************************************************
	 */
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	/**
	    * Property Display Controller handles the logic for this directive.
	    */
	var SWFFormFieldController = (function () {
	    //@ngInject
	    function SWFFormFieldController($scope, $element, $compile, utilityService) {
	        this.$scope = $scope;
	        this.$element = $element;
	        this.$compile = $compile;
	        this.utilityService = utilityService;
	        this.utilityService = utilityService;
	        this.$scope = $scope;
	        this.$element = $element;
	        this.$compile = $compile;
	    }
	    return SWFFormFieldController;
	}());
	/**
	    * Handles the logic for the frontend version of the property display.
	    */
	SWFFormFieldController.$inject = ['$scope', '$element', '$compile', 'utilityService'];
	/**
	    * This class handles configuring formFields for use in process forms on the front end.
	    */
	var SWFFormField = (function () {
	    function SWFFormField(coreFormPartialsPath, hibachiPathBuilder) {
	        this.restrict = "E";
	        this.require = { swfPropertyDisplayCtrl: "^?swfPropertyDisplay", form: "^?form" };
	        this.controller = SWFFormFieldController;
	        this.controllerAs = "swfFormField";
	        this.scope = {};
	        this.bindToController = {
	            propertyDisplay: "=?",
	            propertyIdentifier: "@?",
	            name: "@?",
	            class: "@?",
	            errorClass: "@?",
	            type: "@?"
	        };
	        this.link = function (scope, element, attrs, formController, transcludeFn) {
	        };
	        this.templateUrl = hibachiPathBuilder.buildPartialsPath(coreFormPartialsPath) + 'swfformfield.html';
	    }
	    /**
	        * Handles injecting the partials path into this class
	        */
	    SWFFormField.Factory = function () {
	        var directive = function (coreFormPartialsPath, hibachiPathBuilder) { return new SWFFormField(coreFormPartialsPath, hibachiPathBuilder); };
	        directive.$inject = [
	            'coreFormPartialsPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWFFormField;
	}());
	exports.SWFFormField = SWFFormField;


/***/ },
/* 166 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	/**
	* Form Controller handles the logic for this directive.
	*/
	var SWFormController = (function () {
	    /**
	     * This controller handles most of the logic for the swFormDirective when more complicated self inspection is needed.
	     */
	    // @ngInject
	    function SWFormController($scope, $element, $hibachi, $http, $timeout, observerService, $rootScope, entityService, utilityService) {
	        var _this = this;
	        this.$scope = $scope;
	        this.$element = $element;
	        this.$hibachi = $hibachi;
	        this.$http = $http;
	        this.$timeout = $timeout;
	        this.observerService = observerService;
	        this.$rootScope = $rootScope;
	        this.entityService = entityService;
	        this.utilityService = utilityService;
	        this.eventsObj = [];
	        this.formData = {};
	        this.isObject = function () {
	            return (angular.isObject(_this.object));
	        };
	        /** create the generic submit function */
	        this.submit = function (actions) {
	            actions = actions || _this.action;
	            _this.clearErrors();
	            _this.formData = _this.getFormData() || "";
	            _this.doActions(actions);
	        };
	        //array or comma delimited
	        this.doActions = function (actions) {
	            if (angular.isArray(actions)) {
	                for (var _i = 0, _a = actions; _i < _a.length; _i++) {
	                    var action = _a[_i];
	                    _this.doAction(action);
	                }
	            }
	            else if (angular.isString(actions)) {
	                _this.doAction(actions);
	            }
	            else {
	                throw ("Unknown type of action exception");
	            }
	        };
	        // /** iterates through the factory submitting data */
	        this.doAction = function (action) {
	            if (!action) {
	                throw "Action not defined on form";
	            }
	            _this.formData = _this.formData || {};
	            //
	            var request = _this.$rootScope.hibachiScope.doAction(action, _this.formData)
	                .then(function (result) {
	                if (_this.events && _this.events.events) {
	                    if (result.errors) {
	                        _this.parseErrors(result.errors);
	                        //trigger an onError event
	                        _this.observerService.notify("onError", { "caller": _this.context, "events": _this.events.events || "" });
	                    }
	                    else {
	                        //trigger a on success event
	                        _this.observerService.notify("onSuccess", { "caller": _this.context, "events": _this.events.events || "" });
	                    }
	                }
	            }, angular.noop);
	        };
	        this.parseEvents = function (str, evntType) {
	            if (str == undefined)
	                return;
	            var strTokens = str.split(","); //this gives the format [hide:this, show:Account_Logout, update:Account or Cart, event:element]
	            var eventsObj = {
	                "events": []
	            }; //will hold events
	            for (var token in strTokens) {
	                var eventName = strTokens[token].split(":")[0].toLowerCase().replace(' ', '');
	                var formName = strTokens[token].split(":")[1].toLowerCase().replace(' ', '');
	                if (formName == "this") {
	                    formName == _this.context.toLowerCase();
	                } //<--replaces the alias this with the name of this form.
	                var event_1 = { "name": eventName, "value": formName };
	                eventsObj.events.push(event_1);
	            }
	            if (eventsObj.events.length) {
	                _this.observerService.attach(_this.eventsHandler, "onSuccess");
	            }
	            return eventsObj;
	        };
	        /** looks at the onSuccess, onError, and onLoading and parses the string into useful subcategories */
	        this.parseEventString = function (evntStr, evntType) {
	            _this.events = _this.parseEvents(evntStr, evntType); //onSuccess : [hide:this, show:someOtherForm, refresh:Account]
	        };
	        /****
	             * Handle parsing through the server errors and injecting the error text for that field
	            * If the form only has a submit, then simply call that function and set errors.
	            ***/
	        this.parseErrors = function (errors) {
	            if (angular.isDefined(errors) && errors) {
	                angular.forEach(errors, function (val, key) {
	                    var primaryElement = _this.$element.find("[error-for='" + key + "']");
	                    _this.$timeout(function () {
	                        primaryElement.append("<span name='" + key + "Error'>" + errors[key] + "</span>");
	                    }, 0);
	                }, _this);
	            }
	        };
	        /** find and clear all errors on form */
	        this.clearErrors = function () {
	            /** clear all form errors on submit. */
	            _this.$timeout(function () {
	                var errorElements = _this.$element.find("[error-for]");
	                errorElements.empty();
	                //vm["formCtrl"][this.context].$setPristine(true);
	            }, 0);
	        };
	        this.eventsHandler = function (params) {
	            //this will call any form specific functions such as hide,show,refresh,update or whatever else you later add
	            for (var e in params.events) {
	                if (angular.isDefined(params.events[e].value) && params.events[e].value == _this.name.toLowerCase()) {
	                    if (params.events[e].name && _this[params.events[e].name]) {
	                        _this[params.events[e].name](params.events[e].value);
	                    }
	                }
	            }
	        };
	        /** hides this directive on event */
	        this.hide = function (param) {
	            if (_this.name.toLowerCase() == param) {
	                _this.$element.hide();
	            }
	        };
	        /** shows this directive on event */
	        this.show = function (param) {
	            if (_this.name.toLowerCase() == param) {
	                _this.$element.show();
	            }
	        };
	        /** refreshes this directive on event */
	        this.refresh = function (params) {
	            //stub
	        };
	        /** updates this directive on event */
	        this.update = function (params) {
	            //stub
	        };
	        /** clears this directive on event */
	        this.clear = function (params) {
	            //stub
	        };
	        /** returns all the data from the form by iterating the form elements */
	        this.getFormData = function () {
	            var iterable = _this.formCtrl;
	            angular.forEach(iterable, function (val, key) {
	                if (typeof val === 'object' && val.hasOwnProperty('$modelValue')) {
	                    if (_this.object.forms[_this.name][key].$modelValue) {
	                        val = _this.object.forms[_this.name][key].$modelValue;
	                    }
	                    else if (_this.object.forms[_this.name][key].$viewValue) {
	                        val = _this.object.forms[_this.name][key].$viewValue;
	                    }
	                    /** Check for form elements that have a name that doesn't start with $ */
	                    if (angular.isString(val)) {
	                        _this.formData[key] = val;
	                    }
	                    if (val.$modelValue) {
	                        _this.formData[key] = val.$modelValue;
	                    }
	                    else if (val.$viewValue) {
	                        _this.formData[key] = val.$viewValue;
	                    }
	                }
	            });
	            return _this.formData || "";
	        };
	        /** only use if the developer has specified these features with isProcessForm */
	        this.$hibachi = $hibachi;
	        this.utilityService = utilityService;
	        if (angular.isUndefined(this.isDirty)) {
	            this.isDirty = false;
	        }
	        //object can be either an instance or a string that will become an instance
	        if (angular.isString(this.object)) {
	            var objectNameArray = this.object.split('_');
	            this.entityName = objectNameArray[0];
	            //if the object name array has two parts then we can infer that it is a process object
	            if (objectNameArray.length > 1) {
	                this.context = this.context || objectNameArray[1];
	                this.isProcessForm = true;
	            }
	            else {
	                this.context = this.context || 'save';
	                this.isProcessForm = false;
	            }
	            //convert the string to an object
	            this.$timeout(function () {
	                _this.object = _this.$hibachi['new' + _this.object]();
	            });
	        }
	        else {
	            if (this.object && this.object.metaData) {
	                this.isProcessForm = this.object.metaData.isProcessObject;
	                this.entityName = this.object.metaData.className.split('_')[0];
	                if (this.isProcessForm) {
	                    this.context = this.context || this.object.metaData.className.split('_')[1];
	                }
	                else {
	                    this.context = this.context || 'save';
	                }
	            }
	        }
	        //
	        this.context = this.context || this.name;
	        if (this.isProcessForm) {
	            /** Cart is an alias for an Order */
	            if (this.entityName == "Order") {
	                this.entityName = "Cart";
	            }
	            ;
	        }
	        //  /** find the form scope */
	        // this.$scope.$on('anchor', (event, data) =>
	        // {
	        //     if (data.anchorType == "form" && data.scope !== undefined) {
	        //         this.formCtrl = data.scope;
	        //     }
	        // });
	        /** make sure we have our data using new logic and $hibachi*/
	        //        if (this.context == undefined || this.entityName == undefined) {
	        //            throw ("ProcessObject Undefined Exception");
	        //        }
	        /* handle events
	        */
	        if (this.onSuccess) {
	            this.parseEventString(this.onSuccess, "onSuccess");
	            observerService.attach(this.eventsHandler, "onSuccess");
	        }
	        else if (this.onError) {
	            this.parseEventString(this.onError, "onError");
	            observerService.attach(this.eventsHandler, "onError"); //stub
	        }
	    }
	    return SWFormController;
	}());
	exports.SWFormController = SWFormController;
	var SWForm = (function () {
	    // @ngInject
	    function SWForm(coreFormPartialsPath, hibachiPathBuilder) {
	        this.coreFormPartialsPath = coreFormPartialsPath;
	        this.hibachiPathBuilder = hibachiPathBuilder;
	        this.templateUrl = "";
	        this.transclude = true;
	        this.restrict = "E";
	        this.controller = SWFormController;
	        this.controllerAs = "swForm";
	        this.scope = {};
	        /**
	         * Binds all of our variables to the controller so we can access using this
	         */
	        this.bindToController = {
	            name: "@?",
	            context: "@?",
	            entityName: "@?",
	            hiddenFields: "=?",
	            action: "@?",
	            actions: "@?",
	            formClass: "@?",
	            formData: "=?",
	            object: "=?",
	            onSuccess: "@?",
	            onError: "@?",
	            hideUntil: "@?",
	            isDirty: "=?",
	            inputAttributes: "@?",
	            eventHandlers: "@?"
	        };
	        /**
	            * Sets the context of this form
	            */
	        this.link = function (scope, element, attrs, controller) {
	        };
	        this.templateUrl = hibachiPathBuilder.buildPartialsPath(this.coreFormPartialsPath) + "form.html";
	    }
	    /**
	     * Handles injecting the partials path into this class
	     */
	    SWForm.Factory = function () {
	        var directive = function (coreFormPartialsPath, hibachiPathBuilder) { return new SWForm(coreFormPartialsPath, hibachiPathBuilder); };
	        directive.$inject = ['coreFormPartialsPath', 'hibachiPathBuilder'];
	        return directive;
	    };
	    return SWForm;
	}());
	exports.SWForm = SWForm;


/***/ },
/* 167 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWFormFieldController = (function () {
	    //@ngInject
	    function SWFormFieldController($injector, $scope, $timeout, $log, $hibachi, observerService, utilityService) {
	        var _this = this;
	        this.$injector = $injector;
	        this.$scope = $scope;
	        this.$timeout = $timeout;
	        this.$log = $log;
	        this.$hibachi = $hibachi;
	        this.observerService = observerService;
	        this.utilityService = utilityService;
	        this.formFieldChanged = function (option) {
	            if (_this.fieldType === 'yesno') {
	                _this.object.data[_this.property] = option.value;
	                _this.form[_this.property].$dirty = true;
	                _this.form['selected' + _this.object.metaData.className + _this.property + _this.selectedRadioFormName].$dirty = false;
	            }
	            else if (_this.fieldType === 'select') {
	                _this.$log.debug('formfieldchanged');
	                _this.$log.debug(option);
	                if (_this.selectType === 'object' && typeof _this.object.data[_this.property].$$getIDName == "function") {
	                    _this.object.data[_this.property]['data'][_this.object.data[_this.property].$$getIDName()] = option.value;
	                    if (angular.isDefined(_this.form[_this.object.data[_this.property].$$getIDName()])) {
	                        _this.form[_this.object.data[_this.property].$$getIDName()].$dirty = true;
	                    }
	                }
	                else if (_this.selectType === 'string' && option && option.value != null) {
	                    _this.object.data[_this.property] = option.value;
	                    _this.form[_this.property].$dirty = true;
	                }
	                _this.observerService.notify(_this.object.metaData.className + _this.property.charAt(0).toUpperCase() + _this.property.slice(1) + 'OnChange', option);
	            }
	            else {
	                _this.object.data[_this.property] = option.value;
	                _this.form[_this.property].$dirty = true;
	                _this.form['selected' + _this.object.metaData.className + _this.property + _this.selectedRadioFormName].$dirty = false;
	            }
	        };
	        this.$onInit = function () {
	            var bindToControllerProps = _this.$injector.get('swFormFieldDirective')[0].bindToController;
	            for (var i in bindToControllerProps) {
	                if (!_this[i]) {
	                    if (!_this[i] && _this.swPropertyDisplay && _this.swPropertyDisplay[i]) {
	                        _this[i] = _this.swPropertyDisplay[i];
	                    }
	                    else if (!_this[i] && _this.swfPropertyDisplay && _this.swfPropertyDisplay[i]) {
	                        _this[i] = _this.swfPropertyDisplay[i];
	                    }
	                    else if (!_this[i] && _this.swForm && _this.swForm[i]) {
	                        _this[i] = _this.swForm[i];
	                    }
	                }
	            }
	            _this.property = _this.property || _this.propertyIdentifier;
	            _this.propertyIdentifier = _this.propertyIdentifier || _this.property;
	            _this.type = _this.type || _this.fieldType;
	            _this.fieldType = _this.fieldType || _this.type;
	            _this.edit = _this.edit || _this.editing;
	            _this.editing = _this.editing || _this.edit;
	            _this.editing = _this.editing || true;
	            _this.fieldType = _this.fieldType || "text";
	            if (_this.fieldType === 'yesno') {
	                _this.yesnoStrategy();
	            }
	            if (_this.fieldType === 'select') {
	                _this.selectStrategy();
	            }
	        };
	        this.selectStrategy = function () {
	            //this is specific to the admin because it implies loading of options via api
	            if (angular.isDefined(_this.object.metaData[_this.property].fieldtype)) {
	                _this.selectType = 'object';
	                _this.$log.debug('selectType:object');
	            }
	            else {
	                _this.selectType = 'string';
	                _this.$log.debug('selectType:string');
	            }
	            _this.getOptions();
	        };
	        this.getOptions = function () {
	            if (angular.isUndefined(_this.options)) {
	                if (!_this.optionsArguments || !_this.optionsArguments.hasOwnProperty('property')) {
	                    _this.optionsArguments = {
	                        'property': _this.propertyIdentifier || _this.property
	                    };
	                }
	                var optionsPromise = _this.$hibachi.getPropertyDisplayOptions(_this.object.metaData.className, _this.optionsArguments);
	                optionsPromise.then(function (value) {
	                    _this.options = value.data;
	                    if (_this.selectType === 'object') {
	                        if (angular.isUndefined(_this.object.data[_this.property])) {
	                            _this.object.data[_this.property] = _this.$hibachi['new' + _this.object.metaData[_this.property].cfc]();
	                        }
	                        if (_this.object.data[_this.property].$$getID() === '') {
	                            _this.$log.debug('no ID');
	                            _this.$log.debug(_this.object.data[_this.property].$$getIDName());
	                            _this.object.data['selected' + _this.property] = _this.options[0];
	                            _this.object.data[_this.property] = _this.$hibachi['new' + _this.object.metaData[_this.property].cfc]();
	                            _this.object.data[_this.property]['data'][_this.object.data[_this.property].$$getIDName()] = _this.options[0].value;
	                        }
	                        else {
	                            var found = false;
	                            for (var i in _this.options) {
	                                if (angular.isObject(_this.options[i].value)) {
	                                    _this.$log.debug('isObject');
	                                    _this.$log.debug(_this.object.data[_this.property].$$getIDName());
	                                    if (_this.options[i].value === _this.object.data[_this.property]) {
	                                        _this.object.data['selected' + _this.property] = _this.options[i];
	                                        _this.object.data[_this.property] = _this.options[i].value;
	                                        found = true;
	                                        break;
	                                    }
	                                }
	                                else {
	                                    _this.$log.debug('notisObject');
	                                    _this.$log.debug(_this.object.data[_this.property].$$getIDName());
	                                    if (_this.options[i].value === _this.object.data[_this.property].$$getID()) {
	                                        _this.object.data['selected' + _this.property] = _this.options[i];
	                                        _this.object.data[_this.property]['data'][_this.object.data[_this.property].$$getIDName()] = _this.options[i].value;
	                                        found = true;
	                                        break;
	                                    }
	                                }
	                                if (!found) {
	                                    _this.object.data['selected' + _this.property] = _this.options[0];
	                                }
	                            }
	                        }
	                    }
	                    else if (_this.selectType === 'string') {
	                        if (_this.object.data[_this.property] !== null) {
	                            for (var i in _this.options) {
	                                if (_this.options[i].value === _this.object.data[_this.property]) {
	                                    _this.object.data['selected' + _this.property] = _this.options[i];
	                                    _this.object.data[_this.property] = _this.options[i].value;
	                                }
	                            }
	                        }
	                        else {
	                            _this.object.data['selected' + _this.property] = _this.options[0];
	                            _this.object.data[_this.property] = _this.options[0].value;
	                        }
	                    }
	                });
	            }
	        };
	        this.yesnoStrategy = function () {
	            //format value
	            _this.selectedRadioFormName = _this.utilityService.createID(26);
	            _this.object.data[_this.property] = (_this.object.data[_this.property]
	                && _this.object.data[_this.property].length
	                && _this.object.data[_this.property].toLowerCase().trim() === 'yes') || _this.object.data[_this.property] == 1 ? 1 : 0;
	            _this.options = [
	                {
	                    name: 'Yes',
	                    value: 1
	                },
	                {
	                    name: 'No',
	                    value: 0
	                }
	            ];
	            if (angular.isDefined(_this.object.data[_this.property])) {
	                for (var i in _this.options) {
	                    if (_this.options[i].value === _this.object.data[_this.property]) {
	                        _this.selected = _this.options[i];
	                        _this.object.data[_this.property] = _this.options[i].value;
	                    }
	                }
	            }
	            else {
	                _this.selected = _this.options[0];
	                _this.object.data[_this.property] = _this.options[0].value;
	            }
	            _this.$timeout(function () {
	                _this.form[_this.property].$dirty = _this.isDirty;
	            });
	        };
	        this.$injector = $injector;
	        this.$scope = $scope;
	        this.$timeout = $timeout;
	        this.$log = $log;
	        this.$hibachi = $hibachi;
	        this.observerService = observerService;
	        this.utilityService = utilityService;
	    }
	    return SWFormFieldController;
	}());
	exports.SWFormFieldController = SWFormFieldController;
	var SWFormField = (function () {
	    //@ngInject
	    function SWFormField($log, $templateCache, $window, $hibachi, formService, coreFormPartialsPath, hibachiPathBuilder) {
	        this.restrict = "EA";
	        this.require = {
	            swfPropertyDisplay: "^?swfPropertyDisplay",
	            swPropertyDisplay: "^?swPropertyDisplay",
	            form: "^?form",
	            swForm: '^?swForm'
	        };
	        this.controller = SWFormFieldController;
	        this.controllerAs = "swFormField";
	        this.scope = {};
	        this.bindToController = {
	            propertyIdentifier: "@?",
	            name: "@?",
	            class: "@?",
	            errorClass: "@?",
	            type: "@?",
	            option: "=?",
	            valueObject: "=?",
	            object: "=?",
	            label: "@?",
	            labelText: "@?",
	            labelClass: "@?",
	            optionValues: "=?",
	            edit: "=?",
	            title: "@?",
	            value: "=?",
	            errorText: "@?",
	            fieldType: "@?",
	            property: "@?",
	            inListingDisplay: "=?",
	            inputAttributes: "@?",
	            options: "=?",
	            optionsArguments: "=?",
	            eagerLoadOptions: "=?",
	            rawFileTarget: "@?",
	            binaryFileTarget: "@?",
	            isDirty: "=?",
	            onChange: "=?",
	            editable: "=?",
	            eventHandlers: "@?",
	            context: "@?"
	        };
	        this.link = function (scope, element, attrs) {
	        };
	        this.templateUrl = hibachiPathBuilder.buildPartialsPath(coreFormPartialsPath) + 'formfield.html';
	    }
	    SWFormField.Factory = function () {
	        var directive = function ($log, $templateCache, $window, $hibachi, formService, coreFormPartialsPath, hibachiPathBuilder) { return new SWFormField($log, $templateCache, $window, $hibachi, formService, coreFormPartialsPath, hibachiPathBuilder); };
	        directive.$inject = [
	            '$log',
	            '$templateCache',
	            '$window',
	            '$hibachi',
	            'formService',
	            'coreFormPartialsPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWFormField;
	}());
	exports.SWFormField = SWFormField;


/***/ },
/* 168 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWFormFieldFileController = (function () {
	    //@ngInject
	    function SWFormFieldFileController(formService) {
	        this.formService = formService;
	        if (this.propertyDisplay.isDirty == undefined)
	            this.propertyDisplay.isDirty = false;
	        this.propertyDisplay.form.$dirty = this.propertyDisplay.isDirty;
	        //this.formService.setPristinePropertyValue(this.propertyDisplay.property,this.propertyDisplay.object.data[this.propertyDisplay.property]);
	    }
	    return SWFormFieldFileController;
	}());
	var SWFormFieldFile = (function () {
	    function SWFormFieldFile(coreFormPartialsPath, hibachiPathBuilder) {
	        this.restrict = 'E';
	        this.require = "^form";
	        this.controller = SWFormFieldFileController;
	        this.controllerAs = "swFormFieldFile";
	        this.scope = true;
	        this.bindToController = {
	            propertyDisplay: "="
	        };
	        //@ngInject
	        this.link = function (scope, element, attr, formController) {
	        };
	        this.templateUrl = hibachiPathBuilder.buildPartialsPath(coreFormPartialsPath) + "file.html";
	    }
	    SWFormFieldFile.Factory = function () {
	        var directive = function (coreFormPartialsPath, hibachiPathBuilder) { return new SWFormFieldFile(coreFormPartialsPath, hibachiPathBuilder); };
	        directive.$inject = [
	            'coreFormPartialsPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWFormFieldFile;
	}());
	exports.SWFormFieldFile = SWFormFieldFile;


/***/ },
/* 169 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWFormFieldJsonController = (function () {
	    //@ngInject
	    function SWFormFieldJsonController(formService) {
	        this.propertyDisplay.form.$dirty = this.propertyDisplay.isDirty;
	    }
	    return SWFormFieldJsonController;
	}());
	var SWFormFieldJson = (function () {
	    function SWFormFieldJson(coreFormPartialsPath, hibachiPathBuilder) {
	        this.restrict = 'E';
	        this.require = "^form";
	        this.scope = true;
	        this.controller = SWFormFieldJsonController;
	        this.bindToController = {
	            propertyDisplay: "=?"
	        };
	        this.controllerAs = "ctrl";
	        this.templateUrl = "";
	        this.link = function (scope, element, attrs, formController) { };
	        this.templateUrl = hibachiPathBuilder.buildPartialsPath(coreFormPartialsPath) + "json.html";
	    }
	    SWFormFieldJson.Factory = function () {
	        var directive = function (coreFormPartialsPath, hibachiPathBuilder) { return new SWFormFieldJson(coreFormPartialsPath, hibachiPathBuilder); };
	        directive.$inject = [
	            'coreFormPartialsPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWFormFieldJson;
	}());
	exports.SWFormFieldJson = SWFormFieldJson;


/***/ },
/* 170 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWFormFieldSearchSelect = (function () {
	    function SWFormFieldSearchSelect($http, $log, $hibachi, formService, coreFormPartialsPath, hibachiPathBuilder) {
	        return {
	            templateUrl: hibachiPathBuilder.buildPartialsPath(coreFormPartialsPath) + 'search-select.html',
	            require: "^form",
	            restrict: 'E',
	            scope: {
	                propertyDisplay: "="
	            },
	            link: function (scope, element, attr, formController) {
	                //set up selectionOptions
	                scope.selectionOptions = {
	                    value: [],
	                    $$adding: false
	                };
	                //match in matches track by
	                //function to set state of adding new item
	                scope.setAdding = function (isAdding) {
	                    scope.isAdding = isAdding;
	                    scope.showAddBtn = false;
	                };
	                scope.selectedOption = {};
	                scope.showAddBtn = false;
	                var propertyMetaData = scope.propertyDisplay.object.$$getMetaData(scope.propertyDisplay.property);
	                //create basic
	                var object = $hibachi.newEntity(propertyMetaData.cfc);
	                //				scope.propertyDisplay.template = '';
	                //				//check for a template
	                //				//rules are tiered: check if an override is specified at scope.template, check if the cfc name .html exists, use
	                //				var templatePath = coreFormPartialsPath + 'formfields/searchselecttemplates/';
	                //				if(angular.isUndefined(scope.propertyDisplay.template)){
	                //					var templatePromise = $http.get(templatePath+propertyMetaData.cfcProperCase+'.html',function(){
	                //						$log.debug('template');
	                //						scope.propertyDisplay.template = templatePath+propertyMetaData.cfcProperCase+'.html';
	                //					},function(){
	                //						scope.propertyDisplay.template = templatePath+'index.html';
	                //						$log.debug('template');
	                //						$log.debug(scope.propertyDisplay.template);
	                //					});
	                //				}
	                //set up query function for finding related object
	                scope.cfcProperCase = propertyMetaData.cfcProperCase;
	                scope.selectionOptions.getOptionsByKeyword = function (keyword) {
	                    var filterGroupsConfig = '[' +
	                        ' {  ' +
	                        '"filterGroup":[  ' +
	                        '{' +
	                        ' "propertyIdentifier":"_' + scope.cfcProperCase.toLowerCase() + '.' + scope.cfcProperCase + 'Name",' +
	                        ' "comparisonOperator":"like",' +
	                        ' "ormtype":"string",' +
	                        ' "value":"%' + keyword + '%"' +
	                        '  }' +
	                        ' ]' +
	                        ' }' +
	                        ']';
	                    return $hibachi.getEntity(propertyMetaData.cfc, { filterGroupsConfig: filterGroupsConfig.trim() })
	                        .then(function (value) {
	                        $log.debug('typesByKeyword');
	                        $log.debug(value);
	                        scope.selectionOptions.value = value.pageRecords;
	                        var myLength = keyword.length;
	                        if (myLength > 0) {
	                            scope.showAddBtn = true;
	                        }
	                        else {
	                            scope.showAddBtn = false;
	                        }
	                        return scope.selectionOptions.value;
	                    });
	                };
	                var propertyPromise = scope.propertyDisplay.object['$$get' + propertyMetaData.nameCapitalCase]();
	                propertyPromise.then(function (data) {
	                });
	                //set up behavior when selecting an item
	                scope.selectItem = function ($item, $model, $label) {
	                    scope.$item = $item;
	                    scope.$model = $model;
	                    scope.$label = $label;
	                    scope.showAddBtn = false; //turns off the add btn on select
	                    //angular.extend(inflatedObject.data,$item);
	                    object.$$init($item);
	                    $log.debug('select item');
	                    $log.debug(object);
	                    scope.propertyDisplay.object['$$set' + propertyMetaData.nameCapitalCase](object);
	                };
	                //				if(angular.isUndefined(scope.propertyDipslay.object[scope.propertyDisplay.property])){
	                //					$log.debug('getmeta');
	                //					$log.debug(scope.propertyDisplay.object.metaData[scope.propertyDisplay.property]);
	                //
	                //					//scope.propertyDipslay.object['$$get'+]
	                //				}
	                //
	                //				scope.propertyDisplay.object.data[scope.propertyDisplay.property].$dirty = true;
	            }
	        };
	    }
	    SWFormFieldSearchSelect.Factory = function () {
	        var directive = function ($http, $log, $hibachi, formService, coreFormPartialsPath, hibachiPathBuilder) { return new SWFormFieldSearchSelect($http, $log, $hibachi, formService, coreFormPartialsPath, hibachiPathBuilder); };
	        directive.$inject = [
	            '$http',
	            '$log',
	            '$hibachi',
	            'formService',
	            'coreFormPartialsPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWFormFieldSearchSelect;
	}());
	exports.SWFormFieldSearchSelect = SWFormFieldSearchSelect;


/***/ },
/* 171 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWFormRegistrar = (function () {
	    //@ngInject
	    function SWFormRegistrar(formService, coreFormPartialsPath, hibachiPathBuilder) {
	        return {
	            restrict: 'E',
	            require: ["^form", "^swForm"],
	            scope: {
	                object: "=?",
	                context: "@?",
	                name: "@?",
	                isDirty: "=?"
	            },
	            link: function (scope, element, attrs, formController, transclude) {
	                /*add form info at the form level*/
	                scope.$watch(function () { return formController[0]; }, function () {
	                    formController[1].formCtrl = formController[0];
	                });
	                formController[0].$$swFormInfo = {
	                    object: scope.object,
	                    context: scope.context || 'save',
	                    name: scope.name
	                };
	                var makeRandomID = function makeid(count) {
	                    var text = "";
	                    var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
	                    for (var i = 0; i < count; i++)
	                        text += possible.charAt(Math.floor(Math.random() * possible.length));
	                    return text;
	                };
	                if (scope.isDirty) {
	                    formController[0].autoDirty = true;
	                }
	                scope.form = formController[0];
	                /*register form with service*/
	                formController[0].name = scope.name;
	                formController[0].$setDirty();
	                formService.setForm(formController[0]);
	                /*register form at object level*/
	                if (!angular.isDefined(scope.object.forms)) {
	                    scope.object.forms = {};
	                }
	                scope.object.forms[scope.name] = formController[0];
	            }
	        };
	    }
	    SWFormRegistrar.Factory = function () {
	        var directive = function (formService, coreFormPartialsPath, hibachiPathBuilder) { return new SWFormRegistrar(formService, coreFormPartialsPath, hibachiPathBuilder); };
	        directive.$inject = [
	            'formService',
	            'coreFormPartialsPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWFormRegistrar;
	}());
	exports.SWFormRegistrar = SWFormRegistrar;
	// 	angular.module('slatwalladmin').directive('swFormRegistrar',[ 'formService', 'partialsPath', (formService, partialsPath) => new swFormRegistrar(formService, partialsPath)]);
	// }


/***/ },
/* 172 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWErrorDisplayController = (function () {
	    //@ngInject
	    function SWErrorDisplayController($injector) {
	        this.$injector = $injector;
	        this.$injector = $injector;
	    }
	    SWErrorDisplayController.prototype.$onInit = function () {
	        var bindToControllerProps = this.$injector.get('swErrorDisplayDirective')[0].bindToController;
	        for (var i in bindToControllerProps) {
	            if (!this[i] && i !== 'name') {
	                if (!this[i] && this.swPropertyDisplay && this.swPropertyDisplay[i]) {
	                    this[i] = this.swPropertyDisplay[i];
	                }
	                else if (!this[i] && this.swfPropertyDisplay && this.swfPropertyDisplay[i]) {
	                    this[i] = this.swfPropertyDisplay[i];
	                }
	                else if (!this[i] && this.swForm && this.swForm[i]) {
	                    this[i] = this.swForm[i];
	                }
	            }
	        }
	        this.property = this.property || this.propertyIdentifier;
	        this.propertyIdentifier = this.propertyIdentifier || this.property;
	        if (!this.name && this.property) {
	            this.name = this.property;
	        }
	    };
	    return SWErrorDisplayController;
	}());
	exports.SWErrorDisplayController = SWErrorDisplayController;
	var SWErrorDisplay = (function () {
	    // @ngInject
	    function SWErrorDisplay(coreFormPartialsPath, hibachiPathBuilder) {
	        this.coreFormPartialsPath = coreFormPartialsPath;
	        this.hibachiPathBuilder = hibachiPathBuilder;
	        this.require = {
	            swForm: "^?swForm",
	            form: "^?form",
	            swPropertyDisplay: "^?swPropertyDisplay",
	            swfPropertyDisplay: "^?swfPropertyDisplay"
	        };
	        this.restrict = "E";
	        this.controller = SWErrorDisplayController;
	        this.controllerAs = "swErrorDisplay";
	        this.scope = {};
	        this.bindToController = {
	            form: "=?",
	            name: "@?",
	            property: "@?",
	            propertyIdentifier: "@?",
	            errorClass: "@?"
	        };
	        this.templateUrl = hibachiPathBuilder.buildPartialsPath(this.coreFormPartialsPath) + "errordisplay.html";
	    }
	    SWErrorDisplay.Factory = function () {
	        var directive = function (coreFormPartialsPath, hibachiPathBuilder) { return new SWErrorDisplay(coreFormPartialsPath, hibachiPathBuilder); };
	        directive.$inject = [
	            'coreFormPartialsPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWErrorDisplay;
	}());
	exports.SWErrorDisplay = SWErrorDisplay;


/***/ },
/* 173 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWAddressFormController = (function () {
	    //@ngInject
	    function SWAddressFormController($log) {
	        var _this = this;
	        this.$log = $log;
	        this.showAddressBookSelect = false;
	        this.showCountrySelect = true;
	        this.showSubmitButton = true;
	        this.param = "?slataction=";
	        this.getAction = function () {
	            if (!angular.isDefined(_this.action)) {
	                _this.action = "addAddress";
	            }
	            if (_this.action.indexOf(":") != -1 && _this.action.indexOf(_this.param) == -1) {
	                _this.action = _this.param + _this.action;
	            }
	            return _this.action;
	        };
	        this.hasField = function (field) {
	            if (_this.fieldList.indexOf(field) != -1) {
	                return true;
	            }
	            return false;
	        };
	        //if exists, just name it slatwall.
	        if (angular.isDefined(this.slatwallScope)) {
	            this.slatwall = this.slatwallScope;
	        }
	        if (this.fieldList == undefined) {
	            this.fieldList = "countryCode,name,company,streetAddress,street2Address,locality,city,stateCode,postalCode";
	        }
	        if (this.showAddressBookSelect == undefined) {
	            this.showAddressBookSelect = false;
	        }
	        if (this.showCountrySelect == undefined) {
	            this.showCountrySelect = true;
	        }
	        if (this.action == undefined) {
	            this.showSubmitButton = false;
	        }
	    }
	    return SWAddressFormController;
	}());
	exports.SWAddressFormController = SWAddressFormController;
	var SWAddressForm = (function () {
	    // @ngInject
	    function SWAddressForm(coreFormPartialsPath, hibachiPathBuilder) {
	        this.coreFormPartialsPath = coreFormPartialsPath;
	        this.hibachiPathBuilder = hibachiPathBuilder;
	        this.templateUrl = "";
	        this.controller = SWAddressFormController;
	        this.controllerAs = 'SwAddressForm';
	        this.bindToController = {
	            action: '@',
	            actionText: '@',
	            customPartial: '@',
	            slatwallScope: '=',
	            address: "=",
	            id: "@?",
	            fieldNamePrefix: "@",
	            fieldList: "@",
	            fieldClass: "@",
	            tabIndex: "@",
	            addressName: "@",
	            showAddressBookSelect: "@",
	            showCountrySelect: "@",
	            showSubmitButton: "@"
	        };
	        this.templateUrl = hibachiPathBuilder.buildPartialsPath(this.coreFormPartialsPath) + "addressform.html";
	    }
	    /**
	     * Handles injecting the partials path into this class
	     */
	    SWAddressForm.Factory = function () {
	        var directive = function (coreFormPartialsPath, hibachiPathBuilder) { return new SWAddressForm(coreFormPartialsPath, hibachiPathBuilder); };
	        directive.$inject = ['coreFormPartialsPath', 'hibachiPathBuilder'];
	        return directive;
	    };
	    return SWAddressForm;
	}());
	exports.SWAddressForm = SWAddressForm;


/***/ },
/* 174 */
/***/ function(module, exports) {

	"use strict";
	var SWPropertyDisplayController = (function () {
	    //@ngInject
	    function SWPropertyDisplayController($filter, utilityService, $injector, metadataService, observerService, listingService) {
	        var _this = this;
	        this.$filter = $filter;
	        this.utilityService = utilityService;
	        this.$injector = $injector;
	        this.metadataService = metadataService;
	        this.observerService = observerService;
	        this.listingService = listingService;
	        this.saved = false;
	        this.optionValues = [];
	        this.$onInit = function () {
	            var bindToControllerProps = _this.$injector.get('swPropertyDisplayDirective')[0].bindToController;
	            for (var i in bindToControllerProps) {
	                if (!_this[i] && _this.swForm && _this.swForm[i]) {
	                    _this[i] = _this.swForm[i];
	                }
	            }
	            _this.errors = {};
	            _this.edited = false;
	            _this.initialValue = _this.object.data[_this.property];
	            _this.propertyDisplayID = _this.utilityService.createID(32);
	            if (angular.isUndefined(_this.showSave)) {
	                _this.showSave = true;
	            }
	            if (angular.isUndefined(_this.inListingDisplay)) {
	                _this.inListingDisplay = false;
	            }
	            if (angular.isUndefined(_this.rowSaveEnabled)) {
	                _this.rowSaveEnabled = _this.inListingDisplay;
	            }
	            if (angular.isDefined(_this.revertToValue) && angular.isUndefined(_this.showRevert)) {
	                _this.showRevert = true;
	            }
	            if (angular.isDefined(_this.revertToValue) && angular.isUndefined(_this.revertText)) {
	                _this.revertText = _this.revertToValue;
	            }
	            if (angular.isUndefined(_this.showRevert)) {
	                _this.showRevert = false;
	            }
	            if (angular.isUndefined(_this.rawFileTarget)) {
	                _this.rawFileTarget = _this.property;
	            }
	            if (angular.isUndefined(_this.editing)) {
	                _this.editing = false;
	            }
	            if (angular.isUndefined(_this.editable)) {
	                _this.editable = true;
	            }
	            if (angular.isUndefined(_this.isHidden)) {
	                _this.isHidden = false;
	            }
	            if (angular.isUndefined(_this.noValidate)) {
	                _this.noValidate = false;
	            }
	            if (angular.isUndefined(_this.inModal)) {
	                _this.inModal = false;
	            }
	            if (angular.isUndefined(_this.optionsArguments)) {
	                _this.optionsArguments = {};
	            }
	            if ((_this.fieldType !== 'hidden' &&
	                angular.isUndefined(_this.inListingDisplay)) ||
	                (angular.isDefined(_this.inListingDisplay) && !_this.inListingDisplay)) {
	                _this.showLabel = true;
	            }
	            else {
	                _this.showLabel = false;
	            }
	            if (angular.isDefined(_this.pageRecord) && angular.isUndefined(_this.pageRecord.edited)) {
	                _this.pageRecord.edited = false;
	            }
	            _this.applyFilter = function (model, filter) {
	                try {
	                    return _this.$filter(filter)(model);
	                }
	                catch (e) {
	                    return model;
	                }
	            };
	            _this.property = _this.property || _this.propertyIdentifier;
	            _this.propertyIdentifier = _this.propertyIdentifier || _this.property;
	            _this.type = _this.type || _this.fieldType;
	            _this.fieldType = _this.fieldType || _this.type;
	            _this.edit = _this.edit || _this.editing;
	            _this.editing = _this.editing || _this.edit;
	            //swfproperty logic
	            if (angular.isUndefined(_this.type) && _this.object && _this.object.metaData) {
	                _this.type = _this.metadataService.getPropertyFieldType(_this.object, _this.propertyIdentifier);
	            }
	            if (angular.isUndefined(_this.title) && _this.object && _this.object.metaData) {
	                _this.labelText = _this.metadataService.getPropertyTitle(_this.object, _this.propertyIdentifier);
	            }
	            _this.labelText = _this.labelText || _this.title;
	            _this.title = _this.title || _this.labelText;
	            _this.type = _this.type || "text";
	            _this.class = _this.class || "form-control";
	            _this.fieldAttributes = _this.fieldAttributes || "";
	            _this.label = _this.label || "true";
	            _this.labelText = _this.labelText || "";
	            _this.labelClass = _this.labelClass || "";
	            _this.name = _this.name || "unnamed";
	            _this.object = _this.object || _this.swForm.object; //this is the process object
	            /** handle options */
	            if (_this.options && angular.isString(_this.options)) {
	                var optionsArray = [];
	                optionsArray = _this.options.toString().split(",");
	                angular.forEach(optionsArray, function (o) {
	                    var newOption = {
	                        name: "",
	                        value: ""
	                    };
	                    newOption.name = o;
	                    newOption.value = o;
	                    _this.optionValues.push(newOption);
	                });
	            }
	            /** handle turning the options into an array of objects */
	            /** handle setting the default value for the yes / no element  */
	            if (_this.type == "yesno" && (_this.value && angular.isString(_this.value))) {
	                _this.selected == _this.value;
	            }
	            if (angular.isUndefined(_this.hint) && _this.object && _this.object.metaData) {
	                _this.hint = _this.metadataService.getPropertyHintByObjectAndPropertyIdentifier(_this.object, _this.propertyIdentifier);
	            }
	            if ((_this.hasOnChangeCallback || _this.inListingDisplay || _this.onChangeEvent) &&
	                (angular.isDefined(_this.swForm) && angular.isDefined(_this.name))) {
	                _this.swInputOnChangeEvent = _this.swForm.name + _this.name + 'change';
	                _this.observerService.attach(_this.onChange, _this.swInputOnChangeEvent);
	            }
	        };
	        this.onChange = function (result) {
	            _this.edited = true;
	            if (_this.saved) {
	                _this.saved = false;
	            }
	            if (_this.hasOnChangeCallback) {
	                _this.onChangeCallback(result);
	            }
	            if (_this.inListingDisplay && _this.rowSaveEnabled) {
	                _this.listingService.markEdited(_this.listingID, _this.pageRecordIndex, _this.propertyDisplayID, _this.save);
	            }
	            if (angular.isDefined(_this.onChangeEvent)) {
	                _this.observerService.notify(_this.onChangeEvent, result);
	            }
	        };
	        this.clear = function () {
	            if (_this.reverted) {
	                _this.reverted = false;
	                _this.showRevert = true;
	            }
	            _this.edited = false;
	            _this.object.data[_this.property] = _this.initialValue;
	            if (_this.inListingDisplay && _this.rowSaveEnabled) {
	                _this.listingService.markUnedited(_this.listingID, _this.pageRecordIndex, _this.propertyDisplayID);
	            }
	        };
	        this.revert = function () {
	            _this.showRevert = false;
	            _this.reverted = true;
	            _this.object.data[_this.property] = _this.revertToValue;
	            _this.onChange();
	        };
	        this.save = function () {
	            //do this eagerly to hide save will reverse if theres an error
	            _this.edited = false;
	            _this.saved = true;
	            if (!_this.inModal) {
	                _this.object.$$save().then(function (response) {
	                    if (_this.hasSaveCallback) {
	                        _this.saveCallback(response);
	                    }
	                }, function (reason) {
	                    _this.edited = true;
	                    _this.saved = false;
	                });
	            }
	            else if (_this.hasModalCallback) {
	                _this.modalCallback();
	            }
	        };
	    }
	    return SWPropertyDisplayController;
	}());
	exports.SWPropertyDisplayController = SWPropertyDisplayController;
	var SWPropertyDisplay = (function () {
	    //@ngInject
	    function SWPropertyDisplay($compile, scopeService, coreFormPartialsPath, hibachiPathBuilder, swpropertyPartialPath) {
	        var _this = this;
	        this.$compile = $compile;
	        this.scopeService = scopeService;
	        this.coreFormPartialsPath = coreFormPartialsPath;
	        this.hibachiPathBuilder = hibachiPathBuilder;
	        this.swpropertyPartialPath = swpropertyPartialPath;
	        this.require = { swForm: "?^swForm", form: "?^form" };
	        this.restrict = 'AE';
	        this.scope = {};
	        this.bindToController = {
	            //swfproperty scope
	            type: "@?",
	            name: "@?",
	            class: "@?",
	            edit: "@?",
	            valueObject: "=?",
	            valueObjectProperty: "=?",
	            propertyIdentifier: "@?",
	            valueOptions: "=?",
	            fieldAttributes: "@?",
	            label: "@?",
	            labelText: "@?",
	            labelClass: "@?",
	            errorText: "@?",
	            errorClass: "@?",
	            formTemplate: "@?",
	            //swpropertyscope
	            property: "@?",
	            object: "=?",
	            editable: "=?",
	            editing: "=?",
	            isHidden: "=?",
	            title: "=?",
	            hint: "@?",
	            options: "=?",
	            optionsArguments: "=?",
	            eagerLoadOptions: "=?",
	            isDirty: "=?",
	            onChangeCallback: "&?onChange",
	            onChangeEvent: "@?",
	            saveCallback: "&?",
	            fieldType: "@?",
	            rawFileTarget: "@?",
	            binaryFileTarget: "@?",
	            noValidate: "=?",
	            inListingDisplay: "=?",
	            inModal: "=?",
	            modalCallback: "&?",
	            hasModalCallback: "=?",
	            rowSaveEnabled: "=?",
	            revertToValue: "=?",
	            revertText: "@?",
	            showRevert: "=?",
	            showSave: "=?",
	            placeholderText: "@",
	            placeholderRbKey: "@",
	            inputAttributes: "@?",
	            optionValues: "=?",
	            eventHandlers: "@?",
	            context: "@?"
	        };
	        this.controller = SWPropertyDisplayController;
	        this.controllerAs = "swPropertyDisplay";
	        this.templateUrlPath = "propertydisplay.html";
	        this.link = function ($scope, element, attrs, formController) {
	            $scope.frmController = formController;
	            $scope.swfPropertyDisplay = $scope.swPropertyDisplay;
	            if (angular.isDefined(attrs.onChange)) {
	                $scope.swPropertyDisplay.hasOnChangeCallback = true;
	            }
	            else {
	                $scope.swPropertyDisplay.hasOnChangeCallback = false;
	            }
	            if (angular.isDefined(attrs.saveCallback)) {
	                $scope.swPropertyDisplay.hasSaveCallback = true;
	            }
	            else {
	                $scope.swPropertyDisplay.hasSaveCallback = false;
	            }
	            if (angular.isDefined($scope.swPropertyDisplay.inListingDisplay) && $scope.swPropertyDisplay.inListingDisplay) {
	                var currentScope = _this.scopeService.getRootParentScope($scope, "pageRecord");
	                if (angular.isDefined(currentScope["pageRecord"])) {
	                    $scope.swPropertyDisplay.pageRecord = currentScope["pageRecord"];
	                }
	                var currentScope = _this.scopeService.getRootParentScope($scope, "pageRecordKey");
	                if (angular.isDefined(currentScope["pageRecordKey"])) {
	                    $scope.swPropertyDisplay.pageRecordIndex = currentScope["pageRecordKey"];
	                }
	                var currentScope = _this.scopeService.getRootParentScope($scope, "swListingDisplay");
	                if (angular.isDefined(currentScope["swListingDisplay"])) {
	                    $scope.swPropertyDisplay.listingID = currentScope["swListingDisplay"].tableID;
	                }
	            }
	            if (angular.isDefined($scope.swPropertyDisplay.inModal) && $scope.swPropertyDisplay.inModal) {
	                var modalScope = _this.scopeService.getRootParentScope($scope, "swModalLauncher");
	                $scope.swPropertyDisplay.modalName = modalScope.swModalLauncher.modalName;
	                if (angular.isFunction(modalScope.swModalLauncher.launchModal)) {
	                    $scope.swPropertyDisplay.modalCallback = modalScope.swModalLauncher.launchModal;
	                    $scope.swPropertyDisplay.hasModalCallback = true;
	                }
	            }
	        };
	        this.templateUrl = this.hibachiPathBuilder.buildPartialsPath(this.coreFormPartialsPath) + swpropertyPartialPath;
	    }
	    SWPropertyDisplay.Factory = function (swpropertyClass, swpropertyPartialPath) {
	        var directive = function ($compile, scopeService, coreFormPartialsPath, hibachiPathBuilder) { return new swpropertyClass($compile, scopeService, coreFormPartialsPath, hibachiPathBuilder, 
	        //not an inejctable don't add to $inject. This is in the form.module Factory implementation
	        swpropertyPartialPath); };
	        directive.$inject = ['$compile', 'scopeService', 'coreFormPartialsPath', 'hibachiPathBuilder'];
	        return directive;
	    };
	    return SWPropertyDisplay;
	}());
	SWPropertyDisplay.$inject = ['coreFormPartialsPath', 'hibachiPathBuilder'];
	exports.SWPropertyDisplay = SWPropertyDisplay;


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var swpropertydisplay_1 = __webpack_require__(174);
	var SWFPropertyDisplayController = (function (_super) {
	    __extends(SWFPropertyDisplayController, _super);
	    //@ngInject
	    function SWFPropertyDisplayController($filter, utilityService, $injector, metadataService, observerService) {
	        var _this = _super.call(this, $filter, utilityService, $injector, metadataService, observerService) || this;
	        _this.$filter = $filter;
	        _this.utilityService = utilityService;
	        _this.$injector = $injector;
	        _this.metadataService = metadataService;
	        _this.observerService = observerService;
	        _this.editing = true;
	        return _this;
	    }
	    return SWFPropertyDisplayController;
	}(swpropertydisplay_1.SWPropertyDisplayController));
	exports.SWFPropertyDisplayController = SWFPropertyDisplayController;
	var SWFPropertyDisplay = (function (_super) {
	    __extends(SWFPropertyDisplay, _super);
	    //@ngInject
	    function SWFPropertyDisplay($compile, scopeService, coreFormPartialsPath, hibachiPathBuilder, swpropertyPartialPath) {
	        var _this = _super.call(this, $compile, scopeService, coreFormPartialsPath, hibachiPathBuilder, swpropertyPartialPath) || this;
	        _this.$compile = $compile;
	        _this.scopeService = scopeService;
	        _this.coreFormPartialsPath = coreFormPartialsPath;
	        _this.hibachiPathBuilder = hibachiPathBuilder;
	        _this.swpropertyPartialPath = swpropertyPartialPath;
	        _this.controller = SWFPropertyDisplayController;
	        _this.controllerAs = "swfPropertyDisplay";
	        _this.link = function (scope, element, attrs) {
	        };
	        return _this;
	    }
	    return SWFPropertyDisplay;
	}(swpropertydisplay_1.SWPropertyDisplay));
	exports.SWFPropertyDisplay = SWFPropertyDisplay;


/***/ },
/* 176 */
/***/ function(module, exports) {

	"use strict";
	var SWFormSubscriberController = (function () {
	    //@ngInject
	    function SWFormSubscriberController($log, $compile, $hibachi, utilityService, rbkeyService, $injector) {
	        var _this = this;
	        this.$log = $log;
	        this.$compile = $compile;
	        this.$hibachi = $hibachi;
	        this.utilityService = utilityService;
	        this.rbkeyService = rbkeyService;
	        this.$injector = $injector;
	        this.$onInit = function () {
	            var bindToControllerProps = _this.$injector.get('swFormSubscriberDirective')[0].bindToController;
	            for (var i in bindToControllerProps) {
	                if (!_this[i]) {
	                    if (!_this[i] && _this.swForm && _this.swForm[i]) {
	                        _this[i] = _this.swForm[i];
	                    }
	                }
	            }
	            _this.property = _this.property || _this.propertyIdentifier;
	            _this.propertyIdentifier = _this.propertyIdentifier || _this.property;
	            _this.type = _this.type || _this.fieldType;
	            _this.fieldType = _this.fieldType || _this.type;
	            _this.edit = _this.edit || _this.editing;
	            _this.editing = _this.editing || _this.edit;
	            _this.editing = _this.editing || true;
	            _this.fieldType = _this.fieldType || "text";
	            _this.inputAttributes = _this.inputAttributes || "";
	        };
	        this.utilityService = utilityService;
	        this.$hibachi = $hibachi;
	        this.rbkeyService = rbkeyService;
	        this.$log = $log;
	        this.$injector = $injector;
	    }
	    return SWFormSubscriberController;
	}());
	var SWFormSubscriber = (function () {
	    //ngInject
	    function SWFormSubscriber() {
	        this.restrict = "A";
	        this.require = {
	            swForm: "?^swForm",
	            form: "?^form"
	        };
	        this.scope = {};
	        this.bindToController = {
	            propertyIdentifier: "@?",
	            name: "@?",
	            class: "@?",
	            errorClass: "@?",
	            option: "=?",
	            valueObject: "=?",
	            object: "=?",
	            label: "@?",
	            labelText: "@?",
	            labelClass: "@?",
	            optionValues: "=?",
	            edit: "=?",
	            title: "@?",
	            value: "=?",
	            errorText: "@?",
	            fieldType: "@?",
	            property: "@?",
	            inputAttributes: "@?",
	            type: "@?",
	            editing: "=?"
	        };
	        this.controller = SWFormSubscriberController;
	        this.controllerAs = "SWFormSubscriber";
	        this.link = function (scope, element, attr) {
	        };
	    }
	    SWFormSubscriber.Factory = function () {
	        var directive = function () { return new SWFormSubscriber(); };
	        directive.$inject = [];
	        return directive;
	    };
	    return SWFormSubscriber;
	}());
	exports.SWFormSubscriber = SWFormSubscriber;


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/tsd.d.ts" />
	/// <reference path="../../typings/hibachiTypescript.d.ts" />
	"use strict";
	//components
	var swvalidate_1 = __webpack_require__(178);
	var swvalidationminlength_1 = __webpack_require__(179);
	var swvalidationdatatype_1 = __webpack_require__(180);
	var swvalidationeq_1 = __webpack_require__(181);
	var swvalidationgte_1 = __webpack_require__(182);
	var swvalidationlte_1 = __webpack_require__(183);
	var swvalidationmaxlength_1 = __webpack_require__(184);
	var swvalidationmaxvalue_1 = __webpack_require__(185);
	var swvalidationminvalue_1 = __webpack_require__(186);
	var swvalidationneq_1 = __webpack_require__(187);
	var swvalidationnumeric_1 = __webpack_require__(188);
	var swvalidationregex_1 = __webpack_require__(189);
	var swvalidationrequired_1 = __webpack_require__(190);
	var swvalidationunique_1 = __webpack_require__(191);
	var swvalidationuniqueornull_1 = __webpack_require__(192);
	//services
	var validationservice_1 = __webpack_require__(193);
	var core_module_1 = __webpack_require__(3);
	var validationmodule = angular.module('hibachi.validation', [core_module_1.coremodule.name])
	    .run([function () {
	    }])
	    .directive('swValidate', swvalidate_1.SWValidate.Factory())
	    .directive('swvalidationminlength', swvalidationminlength_1.SWValidationMinLength.Factory())
	    .directive('swvalidationdatatype', swvalidationdatatype_1.SWValidationDataType.Factory())
	    .directive('swvalidationeq', swvalidationeq_1.SWValidationEq.Factory())
	    .directive("swvalidationgte", swvalidationgte_1.SWValidationGte.Factory())
	    .directive("swvalidationlte", swvalidationlte_1.SWValidationLte.Factory())
	    .directive('swvalidationmaxlength', swvalidationmaxlength_1.SWValidationMaxLength.Factory())
	    .directive("swvalidationmaxvalue", swvalidationmaxvalue_1.SWValidationMaxValue.Factory())
	    .directive("swvalidationminvalue", swvalidationminvalue_1.SWValidationMinValue.Factory())
	    .directive("swvalidationneq", swvalidationneq_1.SWValidationNeq.Factory())
	    .directive("swvalidationnumeric", swvalidationnumeric_1.SWValidationNumeric.Factory())
	    .directive("swvalidationregex", swvalidationregex_1.SWValidationRegex.Factory())
	    .directive("swvalidationrequired", swvalidationrequired_1.SWValidationRequired.Factory())
	    .directive("swvalidationunique", swvalidationunique_1.SWValidationUnique.Factory())
	    .directive("swvalidationuniqueornull", swvalidationuniqueornull_1.SWValidationUniqueOrNull.Factory())
	    .service("validationService", validationservice_1.ValidationService);
	exports.validationmodule = validationmodule;


/***/ },
/* 178 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	/**
	 * This validate directive will look at the current element, figure out the context (save, edit, delete) and
	 * validate based on that context as defined in the validation properties object.
	 */
	// 'use strict';
	// angular.module('slatwalladmin').directive('swValidate',
	"use strict";
	// [ '$log','$hibachi', function($log, $hibachi) {
	var SWValidate = (function () {
	    function SWValidate($log, $hibachi) {
	        return {
	            restrict: "A",
	            require: '^ngModel',
	            link: function (scope, elem, attr, ngModel) {
	                //Define our contexts and validation property enums.
	                var ContextsEnum = {
	                    SAVE: { name: "save", value: 0 },
	                    DELETE: { name: "delete", value: 1 },
	                    EDIT: { name: "edit", value: 2 }
	                };
	                var ValidationPropertiesEnum = {
	                    REGEX: { name: "regex", value: 0 },
	                    MIN_VALUE: { name: "minValue", value: 1 },
	                    MAX_VALUE: { name: "maxValue", value: 2 },
	                    EQ: { name: "eq", value: 3 },
	                    NEQ: { name: "neq", value: 4 },
	                    UNIQUE: { name: "unique", value: 5 },
	                    LTE: { name: "lte", value: 6 },
	                    GTE: { name: "gte", value: 7 },
	                    MIN_LENGTH: { name: "minLength", value: 8 },
	                    MAX_LENGTH: { name: "maxLength", value: 9 },
	                    DATA_TYPE: { name: "dataType", value: 10 },
	                    REQUIRED: { name: "required", value: 11 }
	                };
	                scope.validationPropertiesEnum = ValidationPropertiesEnum;
	                scope.contextsEnum = ContextsEnum;
	                var myCurrentContext = scope.contextsEnum.SAVE; //We are only checking the save context right now.
	                var contextNamesArray = getNamesFromObject(ContextsEnum); //Convert for higher order functions.
	                var validationPropertiesArray = getNamesFromObject(ValidationPropertiesEnum); //Convert for higher order functions.
	                var validationObject = scope.propertyDisplay.object.validations.properties; //Get the scope validation object.
	                var errors = scope.propertyDisplay.errors;
	                var errorMessages = [];
	                var failFlag = 0;
	                /**
	                * Iterates over the validation object looking for the current elements validations, maps that to a validation function list
	                * and calls those validate functions. When a validation fails, an error is set, the elements border turns red.
	                */
	                function validate(name, context, elementValue) {
	                    var validationResults = {};
	                    validationResults = { "name": "name", "context": "context", "required": "required", "error": "none", "errorkey": "none" };
	                    for (var key in validationObject) {
	                        // Look for the current attribute in the
	                        // validation parameters.
	                        if (key === name || key === name + "Flag") {
	                            // Now that we have found the current
	                            // validation parameters, iterate
	                            // through them looking for
	                            // the required parameters that match
	                            // the current page context (save,
	                            // delete, etc.)
	                            for (var inner in validationObject[key]) {
	                                var required = validationObject[key][inner].required || "false"; // Get
	                                // the
	                                // required
	                                // value
	                                var context = validationObject[key][inner].contexts || "none"; // Get
	                                // the
	                                // element
	                                // context
	                                //Setup the validation results object to pass back to caller.
	                                validationResults = { "name": key, "context": context, "required": required, "error": "none", "errorkey": "none" };
	                                var elementValidationArr = map(checkHasValidationType, validationPropertiesArray, validationObject[key][inner]);
	                                //Iterate over the array and call the validate function if it has that property.
	                                for (var i = 0; i < elementValidationArr.length; i++) {
	                                    if (elementValidationArr[i] == true) {
	                                        if (validationPropertiesArray[i] === "regex" && elementValue !== "") {
	                                            //Get the regex string to match and send to validation function.
	                                            var re = validationObject[key][inner].regex;
	                                            var result = validate_RegExp(elementValue, re); //true if pattern match, fail otherwise.
	                                            if (result != true) {
	                                                errorMessages
	                                                    .push("Invalid input");
	                                                validationResults.error = errorMessages[errorMessages.length - 1];
	                                                validationResults.errorkey = "invalid-" + ValidationPropertiesEnum["REGEX"].name;
	                                                validationResults.fail = true;
	                                            }
	                                            else {
	                                                errorMessages
	                                                    .push("Valid input");
	                                                validationResults.error = errorMessages[errorMessages.length - 1];
	                                                validationResults.errorkey = "invalid-" + ValidationPropertiesEnum["REGEX"].name;
	                                                validationResults.fail = false;
	                                            }
	                                            return validationResults;
	                                        }
	                                        if (validationPropertiesArray[i] === "minValue") {
	                                            var validationMinValue = validationObject[key][inner].minValue;
	                                            $log.debug(validationMinValue);
	                                            var result = validate_MinValue(elementValue, validationMinValue);
	                                            $log.debug("e>v" + result + " :" + elementValue, ":" + validationMinValue);
	                                            if (result != true) {
	                                                errorMessages
	                                                    .push("Minimum value is: "
	                                                    + validationMinValue);
	                                                validationResults.error = errorMessages[errorMessages.length - 1];
	                                                validationResults.errorkey = "invalid-" + ValidationPropertiesEnum["MIN_VALUE"].name;
	                                                validationResults.fail = true;
	                                            }
	                                            else {
	                                                validationResults.error = errorMessages[errorMessages.length - 1];
	                                                validationResults.errorkey = "invalid-" + ValidationPropertiesEnum["MIN_VALUE"].name;
	                                                validationResults.fail = false;
	                                            }
	                                            return validationResults;
	                                        }
	                                        if (validationPropertiesArray[i] === "maxValue") {
	                                            var validationMaxValue = validationObject[key][inner].maxValue;
	                                            var result = validate_MaxValue(elementValue, validationMaxValue);
	                                            $log.debug("Max Value result is: " + result);
	                                            if (result != true) {
	                                                errorMessages
	                                                    .push("Maximum value is: "
	                                                    + validationMaxValue);
	                                                validationResults.error = errorMessages[errorMessages.length - 1];
	                                                validationResults.errorkey = "invalid-" + ValidationPropertiesEnum["MAX_VALUE"].name;
	                                                validationResults.fail = true;
	                                            }
	                                            return validationResults;
	                                        }
	                                        if (validationPropertiesArray[i] === "minLength") {
	                                            var validationMinLength = validationObject[key][inner].minLength;
	                                            var result = validate_MinLength(elementValue, validationMinLength);
	                                            $log.debug("Min Length result is: " + result);
	                                            if (result != true) {
	                                                errorMessages
	                                                    .push("Minimum length must be: "
	                                                    + validationMinLength);
	                                                validationResults.error = errorMessages[errorMessages.length - 1];
	                                                validationResults.errorkey = "invalid-" + ValidationPropertiesEnum["MIN_LENGTH"].name;
	                                                validationResults.fail = true;
	                                            }
	                                            return validationResults;
	                                        }
	                                        if (validationPropertiesArray[i] === "maxLength") {
	                                            var validationMaxLength = validationObject[key][inner].maxLength;
	                                            var result = validate_MaxLength(elementValue, validationMaxLength);
	                                            $log.debug("Max Length result is: " + result);
	                                            if (result != true) {
	                                                errorMessages
	                                                    .push("Maximum length is: "
	                                                    + validationMaxLength);
	                                                validationResults.error = errorMessages[errorMessages.length - 1];
	                                                validationResults.errorkey = "invalid-" + ValidationPropertiesEnum["MAX_LENGTH"].name;
	                                                validationResults.fail = true;
	                                            }
	                                            return validationResults;
	                                        }
	                                        if (validationPropertiesArray[i] === "eq") {
	                                            var validationEq = validationObject[key][inner].eq;
	                                            var result = validate_Eq(elementValue, validationEq);
	                                            if (result != true) {
	                                                errorMessages
	                                                    .push("Must equal "
	                                                    + validationEq);
	                                                validationResults.error = errorMessages[errorMessages.length - 1];
	                                                validationResults.errorkey = "invalid-" + ValidationPropertiesEnum["EQ"].name;
	                                                validationResults.fail = true;
	                                            }
	                                            return validationResults;
	                                        }
	                                        if (validationPropertiesArray[i] === "neq") {
	                                            var validationNeq = validationObject[key][inner].neq;
	                                            var result = validate_Neq(elementValue, validationNeq);
	                                            if (result != true) {
	                                                errorMessages
	                                                    .push("Must not equal: "
	                                                    + validationNeq);
	                                                validationResults.error = errorMessages[errorMessages.length - 1];
	                                                validationResults.errorkey = "invalid-" + ValidationPropertiesEnum["NEQ"].name;
	                                                validationResults.fail = true;
	                                            }
	                                            return validationResults;
	                                        }
	                                        if (validationPropertiesArray[i] === "lte") {
	                                            var validationLte = validationObject[key][inner].lte;
	                                            var result = validate_Lte(elementValue, validationLte);
	                                            if (result != true) {
	                                                errorMessages
	                                                    .push("Must be less than "
	                                                    + validationLte);
	                                                validationResults.error = errorMessages[errorMessages.length - 1];
	                                                validationResults.errorkey = "invalid-" + ValidationPropertiesEnum["LTE"].name;
	                                                validationResults.fail = true;
	                                            }
	                                            return validationResults;
	                                        }
	                                        if (validationPropertiesArray[i] === "gte") {
	                                            var validationGte = validationObject[key][inner].gte;
	                                            var result = validate_Gte(elementValue, validationGte);
	                                            if (result != true) {
	                                                errorMessages
	                                                    .push("Must be greater than: "
	                                                    + validationGte);
	                                                validationResults.error = errorMessages[errorMessages.length - 1];
	                                                validationResults.errorkey = "invalid-" + ValidationPropertiesEnum["GTE"].name;
	                                                validationResults.fail = true;
	                                            }
	                                            return validationResults;
	                                        }
	                                        if (validationPropertiesArray[i] === "required") {
	                                            var validationRequire = validationObject[key][inner].require;
	                                            var result = validate_Required(elementValue, validationRequire);
	                                            if (result != true) {
	                                                errorMessages
	                                                    .push("Required");
	                                                validationResults.error = errorMessages[errorMessages.length - 1];
	                                                validationResults.errorkey = ValidationPropertiesEnum["REQUIRED"].name;
	                                                validationResults.fail = true;
	                                            }
	                                            else {
	                                                errorMessages
	                                                    .push("Required");
	                                                validationResults.error = errorMessages[errorMessages.length - 1];
	                                                validationResults.errorkey = ValidationPropertiesEnum["REQUIRED"].name;
	                                                validationResults.fail = false;
	                                            }
	                                            return validationResults;
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    } //<---end validate.			
	                }
	                /**
	                * Function to map if we need a validation on this element.
	                */
	                function checkHasValidationType(validationProp, validationType) {
	                    if (validationProp[validationType] != undefined) {
	                        return true;
	                    }
	                    else {
	                        return false;
	                    }
	                }
	                /**
	                * Iterates over the properties object finding which types of validation are needed.
	                */
	                function map(func, array, obj) {
	                    var result = [];
	                    forEach(array, function (element) {
	                        result.push(func(obj, element));
	                    });
	                    return result;
	                }
	                /**
	                * Array iteration helper.
	                */
	                function forEach(array, action) {
	                    for (var i = 0; i < array.length; i++)
	                        action(array[i]);
	                }
	                /**
	                * Helper function to read all the names in our enums into an array that the higher order functions can use.
	                */
	                function getNamesFromObject(obj) {
	                    var result = [];
	                    for (var i in obj) {
	                        var name = obj[i].name || "stub";
	                        result.push(name);
	                    }
	                    return result;
	                }
	                /**
	                * Tests the value for a RegExp match given by the pattern string.
	                * Validates true if pattern match, false otherwise.
	                */
	                function validate_RegExp(value, pattern) {
	                    var regex = new RegExp(pattern);
	                    if (regex.test(value)) {
	                        return true;
	                    }
	                    return false;
	                }
	                /**
	                * Validates true if userValue >= minValue (inclusive)
	                */
	                function validate_MinValue(userValue, minValue) {
	                    return (userValue >= minValue);
	                }
	                /**
	                * Validates true if userValue <= maxValue (inclusive)
	                */
	                function validate_MaxValue(userValue, maxValue) {
	                    return (userValue <= maxValue) ? true : false;
	                }
	                /**
	                * Validates true if length of the userValue >= minLength (inclusive)
	                */
	                function validate_MinLength(userValue, minLength) {
	                    return (userValue.length >= minLength) ? true : false;
	                }
	                /**
	                * Validates true if length of the userValue <= maxLength (inclusive)
	                */
	                function validate_MaxLength(userValue, maxLength) {
	                    return (userValue.length <= maxLength) ? true : false;
	                }
	                /**
	                * Validates true if the userValue == eqValue
	                */
	                function validate_Eq(userValue, eqValue) {
	                    return (userValue == eqValue) ? true : false;
	                }
	                /**
	                * Validates true if the userValue != neqValue
	                */
	                function validate_Neq(userValue, neqValue) {
	                    return (userValue != neqValue) ? true : false;
	                }
	                /**
	                * Validates true if the userValue < decisionValue (exclusive)
	                */
	                function validate_Lte(userValue, decisionValue) {
	                    return (userValue < decisionValue) ? true : false;
	                }
	                /**
	                * Validates true if the userValue > decisionValue (exclusive)
	                */
	                function validate_Gte(userValue, decisionValue) {
	                    return (userValue > decisionValue) ? true : false;
	                }
	                /**
	                * Validates true if the userValue === property
	                */
	                function validate_EqProperty(userValue, property) {
	                    return (userValue === property) ? true : false;
	                }
	                /**
	                * Validates true if the given value is !NaN (Negate, Not a Number).
	                */
	                function validate_IsNumeric(value) {
	                    return !isNaN(value) ? true : false;
	                }
	                /**
	                * Validates true if the given userValue is empty and the field is required.
	                */
	                function validate_Required(property, userValue) {
	                    return (userValue == "" && property == true) ? true : false;
	                }
	                /**
	                * Handles the 'eager' validation on every key press.
	                */
	                ngModel.$parsers.unshift(function (value) {
	                    var name = elem.context.name; //Get the element name for the validate function.
	                    var currentValue = elem.val(); //Get the current element value to check validations against.
	                    var val = validate(name, myCurrentContext, currentValue) || {};
	                    //Check if field is required.				
	                    $log.debug(scope);
	                    $log.debug(val);
	                    ngModel.$setValidity(val.errorkey, !val.fail);
	                    return true;
	                }); //<---end $parsers
	                /**
	                * This handles 'lazy' validation on blur.
	                */
	                elem.bind('blur', function (e) {
	                });
	            }
	        };
	    }
	    SWValidate.Factory = function () {
	        var directive = function ($log, $hibachi) { return new SWValidate($log, $hibachi); };
	        directive.$inject = ['$log', '$hibachi'];
	        return directive;
	    };
	    return SWValidate;
	}());
	exports.SWValidate = SWValidate;


/***/ },
/* 179 */
/***/ function(module, exports) {

	"use strict";
	var SWValidationMinLength = (function () {
	    function SWValidationMinLength($log, validationService) {
	        return {
	            restrict: "A",
	            require: "^ngModel",
	            link: function (scope, element, attributes, ngModel) {
	                ngModel.$validators.swvalidationminlength =
	                    function (modelValue, viewValue) {
	                        var length = 0;
	                        if (viewValue && viewValue.length) {
	                            length = viewValue.length;
	                        }
	                        return validationService.validateMinLength(length || 0, attributes.swvalidationminlength);
	                    };
	            }
	        };
	    }
	    SWValidationMinLength.Factory = function () {
	        var directive = function ($log, validationService) { return new SWValidationMinLength($log, validationService); };
	        directive.$inject = ['$log', 'validationService'];
	        return directive;
	    };
	    return SWValidationMinLength;
	}());
	exports.SWValidationMinLength = SWValidationMinLength;


/***/ },
/* 180 */
/***/ function(module, exports) {

	"use strict";
	var SWValidationDataType = (function () {
	    //@ngInject
	    function SWValidationDataType(validationService) {
	        return {
	            restrict: "A",
	            require: "^ngModel",
	            link: function (scope, element, attributes, ngModel) {
	                var isValidFunction = function (modelValue) {
	                    return validationService.validateDataType(modelValue, attributes.swvalidationdatatype);
	                };
	                ngModel.$validators.swvalidationdatatype = isValidFunction;
	                ngModel.$validators['swvalidation' + attributes.swvalidationdatatype] = isValidFunction;
	            }
	        };
	    }
	    SWValidationDataType.Factory = function () {
	        var directive = function (validationService) { return new SWValidationDataType(validationService); };
	        directive.$inject = ['validationService'];
	        return directive;
	    };
	    return SWValidationDataType;
	}());
	exports.SWValidationDataType = SWValidationDataType;


/***/ },
/* 181 */
/***/ function(module, exports) {

	"use strict";
	var SWValidationEq = (function () {
	    //@ngInject
	    function SWValidationEq(validationService) {
	        return {
	            restrict: "A",
	            require: "^ngModel",
	            link: function (scope, element, attributes, ngModel) {
	                ngModel.$validators.swvalidationeq =
	                    function (modelValue, viewValue) {
	                        return validationService.validateEq(modelValue, attributes.swvalidationeq);
	                    }; //<--end function
	            } //<--end link
	        };
	    }
	    SWValidationEq.Factory = function () {
	        var directive = function (validationService) { return new SWValidationEq(validationService); };
	        directive.$inject = [
	            'validationService'
	        ];
	        return directive;
	    };
	    return SWValidationEq;
	}());
	exports.SWValidationEq = SWValidationEq;


/***/ },
/* 182 */
/***/ function(module, exports) {

	"use strict";
	var SWValidationGte = (function () {
	    function SWValidationGte(validationService) {
	        return {
	            restrict: "A",
	            require: "^ngModel",
	            link: function (scope, element, attributes, ngModel) {
	                ngModel.$validators.swvalidationGte =
	                    function (modelValue, viewValue) {
	                        return validationService.validateGte(modelValue, attributes.swvalidationGte);
	                    }; //<--end function
	            } //<--end link
	        };
	    }
	    SWValidationGte.Factory = function () {
	        var directive = function (validationService) { return new SWValidationGte(validationService); };
	        directive.$inject = ['validationService'];
	        return directive;
	    };
	    return SWValidationGte;
	}());
	exports.SWValidationGte = SWValidationGte;


/***/ },
/* 183 */
/***/ function(module, exports) {

	"use strict";
	var SWValidationLte = (function () {
	    function SWValidationLte(validationService) {
	        return {
	            restrict: "A",
	            require: "^ngModel",
	            link: function (scope, element, attributes, ngModel) {
	                ngModel.$validators.swvalidationlte =
	                    function (modelValue, viewValue) {
	                        return validationService.validateLte(modelValue, attributes.swvalidationlte);
	                    };
	            }
	        };
	    }
	    SWValidationLte.Factory = function () {
	        var directive = function (validationService) { return new SWValidationLte(validationService); };
	        directive.$inject = ['validationService'];
	        return directive;
	    };
	    return SWValidationLte;
	}());
	exports.SWValidationLte = SWValidationLte;


/***/ },
/* 184 */
/***/ function(module, exports) {

	"use strict";
	var SWValidationMaxLength = (function () {
	    function SWValidationMaxLength(validationService) {
	        return {
	            restrict: "A",
	            require: "^ngModel",
	            link: function (scope, element, attributes, ngModel) {
	                ngModel.$validators.swvalidationmaxlength =
	                    function (modelValue, viewValue) {
	                        var length = 0;
	                        if (viewValue && viewValue.length) {
	                            length = viewValue.length;
	                        }
	                        return validationService.validateMaxLength(length || 0, attributes.swvalidationmaxlength);
	                    };
	            }
	        };
	    }
	    SWValidationMaxLength.Factory = function () {
	        var directive = function (validationService) { return new SWValidationMaxLength(validationService); };
	        directive.$inject = ['validationService'];
	        return directive;
	    };
	    return SWValidationMaxLength;
	}());
	exports.SWValidationMaxLength = SWValidationMaxLength;


/***/ },
/* 185 */
/***/ function(module, exports) {

	"use strict";
	var SWValidationMaxValue = (function () {
	    function SWValidationMaxValue(validationService) {
	        return {
	            restrict: "A",
	            require: "^ngModel",
	            link: function (scope, element, attributes, ngModel) {
	                ngModel.$validators.swvalidationmaxvalue =
	                    function (modelValue, viewValue) {
	                        if (viewValue == null) {
	                            return true;
	                        }
	                        validationService.validateMaxValue(viewValue, attributes.swvalidationmaxvalue);
	                    };
	            }
	        };
	    }
	    SWValidationMaxValue.Factory = function () {
	        var directive = function (validationService) { return new SWValidationMaxValue(validationService); };
	        directive.$inject = ['validationService'];
	        return directive;
	    };
	    return SWValidationMaxValue;
	}());
	exports.SWValidationMaxValue = SWValidationMaxValue;


/***/ },
/* 186 */
/***/ function(module, exports) {

	"use strict";
	var SWValidationMinValue = (function () {
	    function SWValidationMinValue(validationService) {
	        return {
	            restrict: "A",
	            require: "^ngModel",
	            link: function (scope, element, attributes, ngModel) {
	                ngModel.$validators.swvalidationminvalue =
	                    function (modelValue, viewValue) {
	                        if (viewValue == null) {
	                            return true;
	                        }
	                        return validationService.validateMinValue(viewValue, attributes.swvalidationminvalue);
	                    };
	            }
	        };
	    }
	    SWValidationMinValue.Factory = function () {
	        var directive = function (validationService) { return new SWValidationMinValue(validationService); };
	        directive.$inject = ['validationService'];
	        return directive;
	    };
	    return SWValidationMinValue;
	}());
	exports.SWValidationMinValue = SWValidationMinValue;


/***/ },
/* 187 */
/***/ function(module, exports) {

	"use strict";
	var SWValidationNeq = (function () {
	    function SWValidationNeq(validationService) {
	        return {
	            restrict: "A",
	            require: "^ngModel",
	            link: function (scope, element, attributes, ngModel) {
	                ngModel.$validators.swvalidationneq =
	                    function (modelValue) {
	                        return validationService.validateNeq(modelValue, attributes.swvalidationneq);
	                    };
	            }
	        };
	    }
	    SWValidationNeq.Factory = function () {
	        var directive = function (validationService) { return new SWValidationNeq(validationService); };
	        directive.$inject = ['validationService'];
	        return directive;
	    };
	    return SWValidationNeq;
	}());
	exports.SWValidationNeq = SWValidationNeq;


/***/ },
/* 188 */
/***/ function(module, exports) {

	"use strict";
	var SWValidationNumeric = (function () {
	    function SWValidationNumeric(validationService) {
	        return {
	            restrict: "A",
	            require: "^ngModel",
	            link: function (scope, element, attributes, ngModel) {
	                ngModel.$validators.swvalidationnumeric =
	                    function (modelValue, viewValue) {
	                        return validationService.validateNumeric(viewValue);
	                    };
	            }
	        };
	    }
	    SWValidationNumeric.Factory = function () {
	        var directive = function (validationService) { return new SWValidationNumeric(validationService); };
	        directive.$inject = ['validationService'];
	        return directive;
	    };
	    return SWValidationNumeric;
	}());
	exports.SWValidationNumeric = SWValidationNumeric;


/***/ },
/* 189 */
/***/ function(module, exports) {

	"use strict";
	var SWValidationRegex = (function () {
	    function SWValidationRegex(validationService) {
	        return {
	            restrict: "A",
	            require: "^ngModel",
	            link: function (scope, element, attributes, ngModel) {
	                ngModel.$validators.swvalidationregex =
	                    function (modelValue) {
	                        //Returns true if this user value (model value) does match the pattern
	                        return validationService.validateRegex(modelValue, attributes.swvalidationregex);
	                    };
	            }
	        };
	    }
	    SWValidationRegex.Factory = function () {
	        var directive = function (validationService) { return new SWValidationRegex(validationService); };
	        directive.$inject = ['validationService'];
	        return directive;
	    };
	    return SWValidationRegex;
	}());
	exports.SWValidationRegex = SWValidationRegex;


/***/ },
/* 190 */
/***/ function(module, exports) {

	"use strict";
	var SWValidationRequired = (function () {
	    //@ngInject
	    function SWValidationRequired(validationService) {
	        return {
	            restrict: "A",
	            require: "^ngModel",
	            link: function (scope, element, attributes, ngModel) {
	                ngModel.$validators.swvalidationrequired =
	                    function (modelValue, viewValue) {
	                        var value = modelValue || viewValue;
	                        if (attributes.swvalidationrequired === "true") {
	                            return validationService.validateRequired(value);
	                        }
	                        else {
	                            return true;
	                        }
	                    };
	            }
	        };
	    }
	    SWValidationRequired.Factory = function () {
	        var directive = function (validationService) { return new SWValidationRequired(validationService); };
	        directive.$inject = ['validationService'];
	        return directive;
	    };
	    return SWValidationRequired;
	}());
	exports.SWValidationRequired = SWValidationRequired;


/***/ },
/* 191 */
/***/ function(module, exports) {

	"use strict";
	var SWValidationUnique = (function () {
	    //@ngInject
	    function SWValidationUnique($http, $q, $hibachi, $log, validationService) {
	        return {
	            restrict: "A",
	            require: ["ngModel", "^?swFormField"],
	            link: function (scope, element, attributes, controllers) {
	                var ngModel = controllers[0];
	                ngModel.$asyncValidators.swvalidationunique = function (modelValue, viewValue) {
	                    var currentValue = modelValue || viewValue;
	                    var property = controllers[1].property;
	                    return validationService.validateUnique(currentValue, controllers[1].object, property);
	                };
	            }
	        };
	    }
	    SWValidationUnique.Factory = function () {
	        var directive = function ($http, $q, $hibachi, $log, validationService) { return new SWValidationUnique($http, $q, $hibachi, $log, validationService); };
	        directive.$inject = ['$http', '$q', '$hibachi', '$log', 'validationService'];
	        return directive;
	    };
	    return SWValidationUnique;
	}());
	exports.SWValidationUnique = SWValidationUnique;


/***/ },
/* 192 */
/***/ function(module, exports) {

	"use strict";
	var SWValidationUniqueOrNull = (function () {
	    //@ngInject
	    function SWValidationUniqueOrNull($http, $q, $hibachi, $log, validationService) {
	        return {
	            restrict: "A",
	            require: "ngModel",
	            link: function (scope, element, attributes, ngModel) {
	                ngModel.$asyncValidators.swvalidationuniqueornull = function (modelValue, viewValue) {
	                    var currentValue = modelValue || viewValue;
	                    var property = scope.propertyDisplay.property;
	                    return validationService.validateUniqueOrNull(currentValue, scope.propertyDisplay.object, property);
	                };
	            }
	        };
	    }
	    SWValidationUniqueOrNull.Factory = function () {
	        var directive = function ($http, $q, $hibachi, $log, validationService) { return new SWValidationUniqueOrNull($http, $q, $hibachi, $log, validationService); };
	        directive.$inject = ['$http', '$q', '$hibachi', '$log', 'validationService'];
	        return directive;
	    };
	    return SWValidationUniqueOrNull;
	}());
	exports.SWValidationUniqueOrNull = SWValidationUniqueOrNull;


/***/ },
/* 193 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	/*services return promises which can be handled uniquely based on success or failure by the controller*/
	"use strict";
	var ValidationService = (function () {
	    //@ngInject
	    function ValidationService($hibachi, $q) {
	        var _this = this;
	        this.$hibachi = $hibachi;
	        this.$q = $q;
	        this.MY_EMAIL_REGEXP = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
	        this.validateUnique = function (value, object, property) {
	            var deferred = _this.$q.defer();
	            //First time the asyncValidators function is loaded the
	            //key won't be set  so ensure that we have
	            //key and propertyName before checking with the server
	            if (object && property) {
	                _this.$hibachi.checkUniqueValue(object, property, value)
	                    .then(function (unique) {
	                    if (unique) {
	                        deferred.resolve(); //It's unique
	                    }
	                    else {
	                        deferred.reject(); //Add unique to $errors
	                    }
	                });
	            }
	            else {
	                deferred.resolve(); //Ensure promise is resolved if we hit this
	            }
	            return deferred.promise;
	        };
	        this.validateUniqueOrNull = function (value, object, property) {
	            var deferred = _this.$q.defer();
	            //First time the asyncValidators function is loaded the
	            //key won't be set  so ensure that we have
	            //key and propertyName before checking with the server
	            if (object && property) {
	                _this.$hibachi.checkUniqueOrNullValue(object, property, value)
	                    .then(function (unique) {
	                    if (unique) {
	                        deferred.resolve(); //It's unique
	                    }
	                    else {
	                        deferred.reject(); //Add unique to $errors
	                    }
	                });
	            }
	            else {
	                deferred.resolve(); //Ensure promise is resolved if we hit this
	            }
	            return deferred.promise;
	        };
	        this.validateEmail = function (value) {
	            return _this.validateDataType(value, 'email');
	        };
	        this.validateDataType = function (value, type) {
	            if (value == null) {
	                return true;
	            } //let required validate this
	            if (angular.isString(value) && type === "string") {
	                return true;
	            }
	            if (angular.isNumber(parseInt(value)) && type === "numeric") {
	                return true;
	            }
	            if (angular.isArray(value) && type === "array") {
	                return true;
	            }
	            if (angular.isDate(value) && type === "date") {
	                return true;
	            }
	            if (angular.isObject(value) && type === "object") {
	                return true;
	            }
	            if (type === 'email') {
	                return _this.MY_EMAIL_REGEXP.test(value);
	            }
	            if (angular.isUndefined(value && type === "undefined")) {
	                return true;
	            }
	            return false;
	        };
	        this.validateEq = function (value, expectedValue) {
	            return (value === expectedValue);
	        };
	        this.validateNeq = function (value, expectedValue) {
	            return (value !== expectedValue);
	        };
	        this.validateGte = function (value, comparisonValue) {
	            if (comparisonValue === void 0) { comparisonValue = 0; }
	            if (angular.isString(value)) {
	                value = parseInt(value);
	            }
	            if (angular.isString(comparisonValue)) {
	                comparisonValue = parseInt(comparisonValue);
	            }
	            return (value >= comparisonValue);
	        };
	        this.validateLte = function (value, comparisonValue) {
	            if (comparisonValue === void 0) { comparisonValue = 0; }
	            if (angular.isString(value)) {
	                value = parseInt(value);
	            }
	            if (angular.isString(comparisonValue)) {
	                comparisonValue = parseInt(comparisonValue);
	            }
	            return (value <= comparisonValue);
	        };
	        this.validateMaxLength = function (value, comparisonValue) {
	            if (comparisonValue === void 0) { comparisonValue = 0; }
	            return _this.validateLte(value, comparisonValue);
	        };
	        this.validateMaxValue = function (value, comparisonValue) {
	            if (comparisonValue === void 0) { comparisonValue = 0; }
	            return _this.validateLte(value, comparisonValue);
	        };
	        this.validateMinLength = function (value, comparisonValue) {
	            if (comparisonValue === void 0) { comparisonValue = 0; }
	            return _this.validateGte(value, comparisonValue);
	        };
	        this.validateMinValue = function (value, comparisonValue) {
	            if (comparisonValue === void 0) { comparisonValue = 0; }
	            return _this.validateGte(value, comparisonValue);
	        };
	        this.validateNumeric = function (value) {
	            return !isNaN(value);
	        };
	        this.validateRegex = function (value, pattern) {
	            var regex = new RegExp(pattern);
	            return regex.test(value);
	        };
	        this.validateRequired = function (value) {
	            if (value) {
	                return true;
	            }
	            else {
	                return false;
	            }
	        };
	        this.$hibachi = $hibachi;
	        this.$q = $q;
	    }
	    return ValidationService;
	}());
	exports.ValidationService = ValidationService;


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/// <reference path='../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../typings/tsd.d.ts' />
	//services
	var workflowconditionservice_1 = __webpack_require__(195);
	var scheduleservice_1 = __webpack_require__(196);
	//directives
	var swadmincreatesuperuser_1 = __webpack_require__(197);
	var swworkflowbasic_1 = __webpack_require__(198);
	var swworkflowcondition_1 = __webpack_require__(199);
	var swworkflowconditiongroupitem_1 = __webpack_require__(200);
	var swworkflowconditiongroups_1 = __webpack_require__(201);
	var swworkflowtask_1 = __webpack_require__(202);
	var swworkflowtaskactions_1 = __webpack_require__(203);
	var swworkflowtasks_1 = __webpack_require__(204);
	var swworkflowtrigger_1 = __webpack_require__(205);
	var swworkflowtriggers_1 = __webpack_require__(206);
	var swworkflowtriggerhistory_1 = __webpack_require__(207);
	var swschedulepreview_1 = __webpack_require__(208);
	//filters
	var workflowmodule = angular.module('hibachi.workflow', ['hibachi.collection']).config(function () {
	})
	    .constant('workflowPartialsPath', 'workflow/components/')
	    .service('workflowConditionService', workflowconditionservice_1.WorkflowConditionService)
	    .service('scheduleService', scheduleservice_1.ScheduleService)
	    .directive('swAdminCreateSuperUser', swadmincreatesuperuser_1.SWAdminCreateSuperUser.Factory())
	    .directive('swWorkflowBasic', swworkflowbasic_1.SWWorkflowBasic.Factory())
	    .directive('swWorkflowCondition', swworkflowcondition_1.SWWorkflowCondition.Factory())
	    .directive('swWorkflowConditionGroupItem', swworkflowconditiongroupitem_1.SWWorkflowConditionGroupItem.Factory())
	    .directive('swWorkflowConditionGroups', swworkflowconditiongroups_1.SWWorkflowConditionGroups.Factory())
	    .directive('swWorkflowTask', swworkflowtask_1.SWWorkflowTask.Factory())
	    .directive('swWorkflowTaskActions', swworkflowtaskactions_1.SWWorkflowTaskActions.Factory())
	    .directive('swWorkflowTasks', swworkflowtasks_1.SWWorkflowTasks.Factory())
	    .directive('swWorkflowTrigger', swworkflowtrigger_1.SWWorkflowTrigger.Factory())
	    .directive('swWorkflowTriggers', swworkflowtriggers_1.SWWorkflowTriggers.Factory())
	    .directive('swWorkflowTriggerHistory', swworkflowtriggerhistory_1.SWWorkflowTriggerHistory.Factory())
	    .directive('swSchedulePreview', swschedulepreview_1.SWSchedulePreview.Factory());
	exports.workflowmodule = workflowmodule;


/***/ },
/* 195 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var WorkflowCondition = (function () {
	    function WorkflowCondition() {
	        this.propertyIdentifer = "";
	        this.comparisonOperator = "";
	        this.value = "";
	        this.displayPropertyIdentifier = "";
	        this.$$disabled = false;
	        this.$$isClosed = true;
	        this.$$isNew = true;
	    }
	    return WorkflowCondition;
	}());
	exports.WorkflowCondition = WorkflowCondition;
	var WorkflowConditionGroupItem = (function () {
	    function WorkflowConditionGroupItem() {
	        this.workflowConditionGroup = [];
	    }
	    return WorkflowConditionGroupItem;
	}());
	exports.WorkflowConditionGroupItem = WorkflowConditionGroupItem;
	var WorkflowConditionService = (function () {
	    function WorkflowConditionService($log, $hibachi, alertService) {
	        var _this = this;
	        this.$log = $log;
	        this.newWorkflowCondition = function () {
	            return new WorkflowCondition;
	        };
	        this.addWorkflowCondition = function (groupItem, condition) {
	            _this.$log.debug('addWorkflowCondition');
	            _this.$log.debug(groupItem);
	            _this.$log.debug(condition);
	            if (groupItem.length >= 1) {
	                condition.logicalOperator = 'AND';
	            }
	            groupItem.push(condition);
	        };
	        this.newWorkflowConditionGroupItem = function () {
	            return new WorkflowConditionGroupItem;
	        };
	        this.addWorkflowConditionGroupItem = function (group, groupItem) {
	            group.push(groupItem);
	        };
	    }
	    return WorkflowConditionService;
	}());
	WorkflowConditionService.$inject = ["$log", "$hibachi", "alertService"];
	exports.WorkflowConditionService = WorkflowConditionService;


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var baseentityservice_1 = __webpack_require__(9);
	var ScheduleService = (function (_super) {
	    __extends(ScheduleService, _super);
	    //@ngInject
	    function ScheduleService($injector, $hibachi, utilityService) {
	        var _this = _super.call(this, $injector, $hibachi, utilityService, 'Schedule') || this;
	        _this.$injector = $injector;
	        _this.$hibachi = $hibachi;
	        _this.utilityService = utilityService;
	        _this.schedulePreview = {};
	        _this.clearSchedulePreview = function () {
	            _this.schedulePreview = {};
	        };
	        _this.addSchedulePreviewItem = function (cdate, longMonthName) {
	            if (longMonthName === void 0) { longMonthName = true; }
	            var weekday = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
	            var month = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
	            var monthShort = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'June', 'July', 'Aug', 'Sept', 'Oct', 'Nov', 'Dec'];
	            var currentDate = (cdate.getMonth() + 1) + '-' + cdate.getDate() + '-' + cdate.getFullYear();
	            if (_this.schedulePreview[currentDate] === undefined) {
	                _this.schedulePreview[currentDate] = {
	                    day: cdate.getDate(),
	                    month: (longMonthName) ? month[cdate.getMonth() + 1] : monthShort[cdate.getMonth() + 1],
	                    year: cdate.getFullYear(),
	                    weekday: weekday[cdate.getDay()],
	                    times: []
	                };
	            }
	            _this.schedulePreview[currentDate].times.push(cdate.toLocaleTimeString());
	        };
	        _this.buildSchedulePreview = function (scheduleObject, totalOfPreviews) {
	            if (totalOfPreviews === void 0) { totalOfPreviews = 10; }
	            _this.clearSchedulePreview();
	            var startTime = new Date(Date.parse(scheduleObject.frequencyStartTime));
	            var endTime = (scheduleObject.frequencyEndTime.trim()) ? new Date(Date.parse(scheduleObject.frequencyEndTime)) : false;
	            var now = new Date();
	            var startPoint = new Date();
	            startPoint.setHours(startTime.getHours());
	            startPoint.setMinutes(startTime.getMinutes());
	            startPoint.setSeconds(startTime.getSeconds());
	            var daysToRun = [];
	            if (scheduleObject.recuringType == 'weekly') {
	                daysToRun = scheduleObject.daysOfWeekToRun.toString().split(',');
	                if (!daysToRun.length || scheduleObject.daysOfWeekToRun.toString().trim() == '') {
	                    return _this.schedulePreview;
	                }
	            }
	            if (scheduleObject.recuringType == 'monthly') {
	                daysToRun = scheduleObject.daysOfMonthToRun.toString().split(',');
	                if (!daysToRun.length || !scheduleObject.daysOfWeekToRun || scheduleObject.daysOfWeekToRun.toString().trim() == '') {
	                    return _this.schedulePreview;
	                }
	            }
	            var datesAdded = 0;
	            for (var i = 0;; i++) {
	                if (datesAdded >= totalOfPreviews || i >= 500)
	                    break;
	                var timeToadd = (scheduleObject.frequencyInterval && scheduleObject.frequencyInterval.toString().trim()) ? (scheduleObject.frequencyInterval * i) * 60000 : i * 24 * 60 * 60 * 1000;
	                var currentDatetime = new Date(startPoint.getTime() + timeToadd);
	                if (currentDatetime < now)
	                    continue;
	                if (scheduleObject.recuringType == 'weekly') {
	                    if (daysToRun.indexOf((currentDatetime.getDay() + 1).toString()) == -1)
	                        continue;
	                }
	                else if (scheduleObject.recuringType == 'monthly') {
	                    if (daysToRun.indexOf(currentDatetime.getDate().toString()) == -1)
	                        continue;
	                }
	                if (!endTime) {
	                    _this.addSchedulePreviewItem(currentDatetime);
	                    datesAdded++;
	                }
	                else {
	                    if (_this.utilityService.minutesOfDay(startTime) <= _this.utilityService.minutesOfDay(currentDatetime)
	                        && _this.utilityService.minutesOfDay(endTime) >= _this.utilityService.minutesOfDay(currentDatetime)) {
	                        _this.addSchedulePreviewItem(currentDatetime);
	                        datesAdded++;
	                    }
	                }
	            }
	            return _this.schedulePreview;
	        };
	        return _this;
	    }
	    return ScheduleService;
	}(baseentityservice_1.BaseEntityService));
	exports.ScheduleService = ScheduleService;


/***/ },
/* 197 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWAdminCreateSuperUser = (function () {
	    function SWAdminCreateSuperUser($log, $hibachi, workflowPartialsPath, hibachiPathBuilder) {
	        return {
	            restrict: 'E',
	            scope: {},
	            templateUrl: hibachiPathBuilder.buildPartialsPath(workflowPartialsPath) + "admincreatesuperuser.html",
	            link: function (scope, element, attrs) {
	                scope.Account_SetupInitialAdmin = $hibachi.newAccount_SetupInitialAdmin();
	            }
	        };
	    }
	    SWAdminCreateSuperUser.Factory = function () {
	        var directive = function ($log, $hibachi, workflowPartialsPath, hibachiPathBuilder) { return new SWAdminCreateSuperUser($log, $hibachi, workflowPartialsPath, hibachiPathBuilder); };
	        directive.$inject = [
	            '$log',
	            '$hibachi',
	            'workflowPartialsPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWAdminCreateSuperUser;
	}());
	exports.SWAdminCreateSuperUser = SWAdminCreateSuperUser;


/***/ },
/* 198 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWWorkflowBasic = (function () {
	    function SWWorkflowBasic($log, $location, $hibachi, formService, workflowPartialsPath, hibachiPathBuilder) {
	        return {
	            restrict: 'A',
	            scope: {
	                workflow: "="
	            },
	            templateUrl: hibachiPathBuilder.buildPartialsPath(workflowPartialsPath) + "workflowbasic.html",
	            link: function (scope, element, attrs) {
	            }
	        };
	    }
	    SWWorkflowBasic.Factory = function () {
	        var directive = function ($log, $location, $hibachi, formService, workflowPartialsPath, hibachiPathBuilder) { return new SWWorkflowBasic($log, $location, $hibachi, formService, workflowPartialsPath, hibachiPathBuilder); };
	        directive.$inject = [
	            '$log',
	            '$location',
	            '$hibachi',
	            'formService',
	            'workflowPartialsPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWWorkflowBasic;
	}());
	exports.SWWorkflowBasic = SWWorkflowBasic;


/***/ },
/* 199 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWWorkflowCondition = (function () {
	    function SWWorkflowCondition($log, $location, $hibachi, formService, metadataService, workflowPartialsPath, hibachiPathBuilder) {
	        return {
	            restrict: 'E',
	            scope: {
	                workflowCondition: "=",
	                workflowConditionIndex: "=",
	                workflow: "=",
	                filterPropertiesList: "="
	            },
	            templateUrl: hibachiPathBuilder.buildPartialsPath(workflowPartialsPath) + "workflowcondition.html",
	            link: function (scope, element, attrs) {
	                $log.debug('workflowCondition init');
	                $log.debug(scope);
	                scope.selectBreadCrumb = function (breadCrumbIndex) {
	                    //splice out array items above index
	                    var removeCount = scope.filterItem.breadCrumbs.length - 1 - breadCrumbIndex;
	                    scope.filterItem.breadCrumbs.splice(breadCrumbIndex + 1, removeCount);
	                    scope.selectedFilterPropertyChanged(null);
	                };
	                scope.selectedFilterPropertyChanged = function (selectedFilterProperty) {
	                    $log.debug('selectedFilterProperty');
	                    $log.debug(selectedFilterProperty);
	                    scope.selectedFilterProperty = selectedFilterProperty;
	                };
	                if (angular.isUndefined(scope.workflowCondition.breadCrumbs)) {
	                    scope.workflowCondition.breadCrumbs = [];
	                    if (scope.workflowCondition.propertyIdentifier === "") {
	                        scope.workflowCondition.breadCrumbs = [
	                            {
	                                entityAlias: scope.workflow.data.workflowObject,
	                                cfc: scope.workflow.data.workflowObject,
	                                propertyIdentifier: scope.workflow.data.workflowObject
	                            }
	                        ];
	                    }
	                    else {
	                        var entityAliasArrayFromString = scope.workflowCondition.propertyIdentifier.split('.');
	                        entityAliasArrayFromString.pop();
	                        for (var i in entityAliasArrayFromString) {
	                            var breadCrumb = {
	                                entityAlias: entityAliasArrayFromString[i],
	                                cfc: entityAliasArrayFromString[i],
	                                propertyIdentifier: entityAliasArrayFromString[i]
	                            };
	                            scope.workflowCondition.breadCrumbs.push(breadCrumb);
	                        }
	                    }
	                }
	                else {
	                    angular.forEach(scope.workflowCondition.breadCrumbs, function (breadCrumb, key) {
	                        if (angular.isUndefined(scope.filterPropertiesList[breadCrumb.propertyIdentifier])) {
	                            var filterPropertiesPromise = $hibachi.getFilterPropertiesByBaseEntityName(breadCrumb.cfc, true);
	                            filterPropertiesPromise.then(function (value) {
	                                metadataService.setPropertiesList(value, breadCrumb.propertyIdentifier);
	                                scope.filterPropertiesList[breadCrumb.propertyIdentifier] = metadataService.getPropertiesListByBaseEntityAlias(breadCrumb.propertyIdentifier);
	                                metadataService.formatPropertiesList(scope.filterPropertiesList[breadCrumb.propertyIdentifier], breadCrumb.propertyIdentifier);
	                                var entityAliasArrayFromString = scope.workflowCondition.propertyIdentifier.split('.');
	                                entityAliasArrayFromString.pop();
	                                entityAliasArrayFromString = entityAliasArrayFromString.join('.').trim();
	                                if (angular.isDefined(scope.filterPropertiesList[entityAliasArrayFromString])) {
	                                    for (var i in scope.filterPropertiesList[entityAliasArrayFromString].data) {
	                                        var filterProperty = scope.filterPropertiesList[entityAliasArrayFromString].data[i];
	                                        if (filterProperty.propertyIdentifier === scope.workflowCondition.propertyIdentifier) {
	                                            //selectItem from drop down
	                                            scope.selectedFilterProperty = filterProperty;
	                                            //decorate with value and comparison Operator so we can use it in the Condition section
	                                            scope.selectedFilterProperty.value = scope.workflowCondition.value;
	                                            scope.selectedFilterProperty.comparisonOperator = scope.workflowCondition.comparisonOperator;
	                                        }
	                                    }
	                                }
	                            });
	                        }
	                        else {
	                            var entityAliasArrayFromString = scope.workflowCondition.propertyIdentifier.split('.');
	                            entityAliasArrayFromString.pop();
	                            entityAliasArrayFromString = entityAliasArrayFromString.join('.').trim();
	                            if (angular.isDefined(scope.filterPropertiesList[entityAliasArrayFromString])) {
	                                for (var i in scope.filterPropertiesList[entityAliasArrayFromString].data) {
	                                    var filterProperty = scope.filterPropertiesList[entityAliasArrayFromString].data[i];
	                                    if (filterProperty.propertyIdentifier === scope.workflowCondition.propertyIdentifier) {
	                                        //selectItem from drop down
	                                        scope.selectedFilterProperty = filterProperty;
	                                        //decorate with value and comparison Operator so we can use it in the Condition section
	                                        scope.selectedFilterProperty.value = scope.workflowCondition.value;
	                                        scope.selectedFilterProperty.comparisonOperator = scope.workflowCondition.comparisonOperator;
	                                    }
	                                }
	                            }
	                        }
	                    });
	                }
	            }
	        };
	    }
	    SWWorkflowCondition.Factory = function () {
	        var directive = function ($log, $location, $hibachi, formService, metadataService, workflowPartialsPath, hibachiPathBuilder) { return new SWWorkflowCondition($log, $location, $hibachi, formService, metadataService, workflowPartialsPath, hibachiPathBuilder); };
	        directive.$inject = [
	            '$log',
	            '$location',
	            '$hibachi',
	            'formService',
	            'metadataService',
	            'workflowPartialsPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWWorkflowCondition;
	}());
	exports.SWWorkflowCondition = SWWorkflowCondition;


/***/ },
/* 200 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWWorkflowConditionGroupItem = (function () {
	    function SWWorkflowConditionGroupItem($log, $location, $hibachi, formService, workflowPartialsPath, hibachiPathBuilder) {
	        return {
	            restrict: 'E',
	            templateUrl: hibachiPathBuilder.buildPartialsPath(workflowPartialsPath) + "workflowconditiongroupitem.html",
	            link: function (scope, element, attrs) {
	            }
	        };
	    }
	    SWWorkflowConditionGroupItem.Factory = function () {
	        var directive = function ($log, $location, $hibachi, formService, workflowPartialsPath, hibachiPathBuilder) { return new SWWorkflowConditionGroupItem($log, $location, $hibachi, formService, workflowPartialsPath, hibachiPathBuilder); };
	        directive.$inject = [
	            '$log',
	            '$location',
	            '$hibachi',
	            'formService',
	            'workflowPartialsPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWWorkflowConditionGroupItem;
	}());
	exports.SWWorkflowConditionGroupItem = SWWorkflowConditionGroupItem;


/***/ },
/* 201 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWWorkflowConditionGroups = (function () {
	    function SWWorkflowConditionGroups($log, workflowConditionService, workflowPartialsPath, hibachiPathBuilder) {
	        return {
	            restrict: 'E',
	            scope: {
	                workflowConditionGroupItem: "=",
	                workflowConditionGroup: "=",
	                workflow: "=",
	                filterPropertiesList: "="
	            },
	            templateUrl: hibachiPathBuilder.buildPartialsPath(workflowPartialsPath) + "workflowconditiongroups.html",
	            link: function (scope, element, attrs) {
	                $log.debug('workflowconditiongroups init');
	                scope.addWorkflowCondition = function () {
	                    $log.debug('addWorkflowCondition');
	                    var workflowCondition = workflowConditionService.newWorkflowCondition();
	                    workflowConditionService.addWorkflowCondition(scope.workflowConditionGroupItem, workflowCondition);
	                };
	                scope.addWorkflowGroupItem = function () {
	                    $log.debug('addWorkflowGrouptItem');
	                    var workflowConditionGroupItem = workflowConditionService.newWorkflowConditionGroupItem();
	                    workflowConditionService.addWorkflowConditionGroupItem(scope.workflowConditionItem, workflowConditionGroupItem);
	                };
	            }
	        };
	    }
	    SWWorkflowConditionGroups.Factory = function () {
	        var directive = function ($log, workflowConditionService, workflowPartialsPath, hibachiPathBuilder) { return new SWWorkflowConditionGroups($log, workflowConditionService, workflowPartialsPath, hibachiPathBuilder); };
	        directive.$inject = [
	            '$log',
	            'workflowConditionService',
	            'workflowPartialsPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWWorkflowConditionGroups;
	}());
	exports.SWWorkflowConditionGroups = SWWorkflowConditionGroups;


/***/ },
/* 202 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWWorkflowTask = (function () {
	    function SWWorkflowTask($log, $location, $timeout, $hibachi, metadataService, collectionService, workflowPartialsPath, hibachiPathBuilder) {
	        return {
	            restrict: 'E',
	            scope: {
	                workflowTask: "=",
	                workflowTasks: "=",
	            },
	            templateUrl: hibachiPathBuilder.buildPartialsPath(workflowPartialsPath) + "workflowtask.html",
	            link: function (scope, element, attrs) {
	                scope.removeWorkflowTask = function (workflowTask) {
	                    var deletePromise = workflowTask.$$delete();
	                    deletePromise.then(function () {
	                        if (workflowTask === scope.workflowTasks.selectedTask) {
	                            delete scope.workflowTasks.selectedTask;
	                        }
	                        scope.workflowTasks.splice(workflowTask.$$index, 1);
	                        for (var i in scope.workflowTasks) {
	                            scope.workflowTasks[i].$$index = i;
	                        }
	                    });
	                };
	            }
	        };
	    }
	    SWWorkflowTask.Factory = function () {
	        var directive = function ($log, $location, $timeout, $hibachi, metadataService, collectionService, workflowPartialsPath, hibachiPathBuilder) { return new SWWorkflowTask($log, $location, $timeout, $hibachi, metadataService, collectionService, workflowPartialsPath, hibachiPathBuilder); };
	        directive.$inject = [
	            '$log',
	            '$location',
	            '$timeout',
	            '$hibachi',
	            'metadataService',
	            'collectionService',
	            'workflowPartialsPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWWorkflowTask;
	}());
	exports.SWWorkflowTask = SWWorkflowTask;


/***/ },
/* 203 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWWorkflowTaskActionsController = (function () {
	    //@ngInject
	    function SWWorkflowTaskActionsController($scope, $log, $hibachi, metadataService, collectionService, workflowPartialsPath, hibachiPathBuilder, collectionConfigService, observerService) {
	        var _this = this;
	        this.$scope = $scope;
	        this.$log = $log;
	        this.$hibachi = $hibachi;
	        this.metadataService = metadataService;
	        this.collectionService = collectionService;
	        this.workflowPartialsPath = workflowPartialsPath;
	        this.hibachiPathBuilder = hibachiPathBuilder;
	        this.collectionConfigService = collectionConfigService;
	        this.observerService = observerService;
	        this.$log.debug('Workflow Task Actions Init');
	        this.$log.debug(this.workflowTask);
	        this.openActions = false;
	        this.observerService.attach(function (item) {
	            if (angular.isDefined(_this.emailTemplateCollectionConfig)) {
	                _this.emailTemplateCollectionConfig.clearFilters();
	                _this.emailTemplateCollectionConfig.addFilter("emailTemplateObject", item.value);
	            }
	            if (angular.isDefined(_this.printTemplateCollectionConfig)) {
	                _this.printTemplateCollectionConfig.clearFilters();
	                _this.printTemplateCollectionConfig.addFilter("printTemplateObject", item.value);
	            }
	        }, 'WorkflowWorkflowObjectOnChange');
	        /**
	         * Returns the correct object based on the selected object type.
	         */
	        var getObjectByActionType = function (workflowTaskAction) {
	            if (workflowTaskAction.data.actionType === 'email') {
	                workflowTaskAction.$$getEmailTemplate();
	            }
	            else if (workflowTaskAction.data.actionType === 'print') {
	                workflowTaskAction.$$getPrintTemplate();
	            }
	        };
	        /**
	         * --------------------------------------------------------------------------------------------------------
	         * Returns workflow task action, and saves them to the scope variable workflowtaskactions
	         * --------------------------------------------------------------------------------------------------------
	         */
	        this.getWorkflowTaskActions = function () {
	            /***
	             Note:
	             This conditional is checking whether or not we need to be retrieving to
	             items all over again. If we already have them, we won't make another
	             trip to the database.

	             ***/
	            if (angular.isUndefined(_this.workflowTask.data.workflowTaskActions)) {
	                var workflowTaskPromise = _this.workflowTask.$$getWorkflowTaskActions();
	                workflowTaskPromise.then(function () {
	                    _this.workflowTaskActions = _this.workflowTask.data.workflowTaskActions;
	                    angular.forEach(_this.workflowTaskActions, function (workflowTaskAction) {
	                        getObjectByActionType(workflowTaskAction);
	                    });
	                    _this.$log.debug(_this.workflowTaskActions);
	                });
	            }
	            else {
	                _this.workflowTaskActions = _this.workflowTask.data.workflowTaskActions;
	            }
	            if (angular.isUndefined(_this.workflowTask.data.workflowTaskActions)) {
	                _this.workflowTask.data.workflowTaskActions = [];
	                _this.workflowTaskActions = _this.workflowTask.data.workflowTaskActions;
	            }
	        };
	        this.getWorkflowTaskActions(); //Call get
	        /**
	         * --------------------------------------------------------------------------------------------------------
	         * Saves the workflow task actions by calling the objects $$save method.
	         * @param taskAction
	         * --------------------------------------------------------------------------------------------------------
	         */
	        this.saveWorkflowTaskAction = function (taskAction, context) {
	            _this.$log.debug("Context: " + context);
	            _this.$log.debug("saving task action and parent task");
	            _this.$log.debug(taskAction);
	            var savePromise = _this.workflowTaskActions.selectedTaskAction.$$save();
	            savePromise.then(function () {
	                var taSavePromise = taskAction.$$save;
	                //Clear the form by adding a new task action if 'save and add another' otherwise, set save and set finished
	                if (context == 'add') {
	                    _this.$log.debug("Save and New");
	                    _this.addWorkflowTaskAction(taskAction);
	                    _this.finished = false;
	                }
	                else if (context == "finish") {
	                    _this.finished = true;
	                }
	            }, function (err) {
	                angular.element('a[href="/##j-basic-2"]').click();
	                console.warn(err);
	            });
	        }; //<--end save
	        /**
	         * Sets the editing state to show/hide the edit screen.
	         */
	        this.setHidden = function (task) {
	            if (!angular.isObject(task)) {
	                task = {};
	            }
	            if (angular.isUndefined(task.hidden)) {
	                task.hidden = false;
	            }
	            else {
	                _this.$log.debug("setHidden()", "Setting Hide Value To " + !task.hidden);
	                task.hidden = !task.hidden;
	            }
	        };
	        /**
	         * --------------------------------------------------------------------------------------------------------
	         * Adds workflow action items by calling the workflowTask objects $$addWorkflowTaskAction() method
	         * and sets the result to scope.
	         * @param taskAction
	         * --------------------------------------------------------------------------------------------------------
	         */
	        this.addWorkflowTaskAction = function (taskAction) {
	            var workflowTaskAction = _this.workflowTask.$$addWorkflowTaskAction();
	            _this.selectWorkflowTaskAction(workflowTaskAction);
	            _this.$log.debug(_this.workflow);
	        };
	        /**
	         * --------------------------------------------------------------------------------------------------------
	         * Selects a new task action and populates the task action properties.
	         * --------------------------------------------------------------------------------------------------------
	         */
	        this.selectWorkflowTaskAction = function (workflowTaskAction) {
	            _this.$log.debug("Selecting new task action for editing: ");
	            _this.$log.debug(workflowTaskAction);
	            _this.finished = false;
	            _this.workflowTaskActions.selectedTaskAction = undefined;
	            var filterPropertiesPromise = _this.$hibachi.getFilterPropertiesByBaseEntityName(_this.workflowTask.data.workflow.data.workflowObject, true);
	            filterPropertiesPromise.then(function (value) {
	                _this.filterPropertiesList = {
	                    baseEntityName: _this.workflowTask.data.workflow.data.workflowObject,
	                    baseEntityAlias: "_" + _this.workflowTask.data.workflow.data.workflowObject
	                };
	                _this.metadataService.setPropertiesList(value, _this.workflowTask.data.workflow.data.workflowObject);
	                _this.filterPropertiesList[_this.workflowTask.data.workflow.data.workflowObject] = _this.metadataService.getPropertiesListByBaseEntityAlias(_this.workflowTask.data.workflow.data.workflowObject);
	                _this.metadataService.formatPropertiesList(_this.filterPropertiesList[_this.workflowTask.data.workflow.data.workflowObject], _this.workflowTask.data.workflow.data.workflowObject);
	                _this.workflowTaskActions.selectedTaskAction = workflowTaskAction;
	                _this.emailTemplateSelected = (_this.workflowTaskActions.selectedTaskAction.data.emailTemplate) ? _this.workflowTaskActions.selectedTaskAction.data.emailTemplate.data.emailTemplateName : '';
	                _this.emailTemplateCollectionConfig = _this.collectionConfigService.newCollectionConfig("EmailTemplate");
	                _this.emailTemplateCollectionConfig.setDisplayProperties("emailTemplateID,emailTemplateName");
	                _this.emailTemplateCollectionConfig.addFilter("emailTemplateObject", _this.workflowTask.data.workflow.data.workflowObject);
	                _this.printTemplateSelected = (_this.workflowTaskActions.selectedTaskAction.data.printTemplate) ? _this.workflowTaskActions.selectedTaskAction.data.printTemplate.data.printTemplateName : '';
	                _this.printTemplateCollectionConfig = _this.collectionConfigService.newCollectionConfig("PrintTemplate");
	                _this.printTemplateCollectionConfig.setDisplayProperties("printTemplateID,printTemplateName");
	                _this.printTemplateCollectionConfig.addFilter("printTemplateObject", _this.workflowTask.data.workflow.data.workflowObject);
	            });
	        };
	        /**
	         * Overrides the confirm directive method deleteEntity. This is needed for the modal popup.
	         */
	        this.deleteEntity = function (entity) {
	            _this.removeWorkflowTaskAction(entity);
	        };
	        /**
	         * --------------------------------------------------------------------------------------------------------
	         * Removes a workflow task action by calling the selected tasks $$delete method
	         * and reindexes the list.
	         * --------------------------------------------------------------------------------------------------------
	         */
	        this.removeWorkflowTaskAction = function (workflowTaskAction) {
	            var deletePromise = workflowTaskAction.$$delete();
	            deletePromise.then(function () {
	                if (workflowTaskAction === _this.workflowTaskActions.selectedTaskAction) {
	                    delete _this.workflowTaskActions.selectedTaskAction;
	                }
	                _this.$log.debug("removeWorkflowTaskAction");
	                _this.$log.debug(workflowTaskAction);
	                _this.workflowTaskActions.splice(workflowTaskAction.$$actionIndex, 1);
	                for (var i in _this.workflowTaskActions) {
	                    _this.workflowTaskActions[i].$$actionIndex = i;
	                }
	            });
	        };
	        this.searchProcess = {
	            name: ''
	        };
	        /**
	         * Watches for changes in the proccess
	         */
	        this.showProcessOptions = false;
	        this.processOptions = [];
	        //this.$scope.$watch('swWorkflowTaskActions.searchProcess.name', (newValue, oldValue)=>{
	        //    if(newValue !== oldValue){
	        //        this.getProcessOptions(this.workflowTask.data.workflow.data.workflowObject);
	        //    }
	        //});
	        /**
	         * Retrieves the proccess options for a workflow trigger action.
	         */
	        this.getProcessOptions = function (objectName) {
	            if (!_this.processOptions.length) {
	                var proccessOptionsPromise = _this.$hibachi.getProcessOptions(objectName);
	                proccessOptionsPromise.then(function (value) {
	                    _this.$log.debug('getProcessOptions');
	                    _this.processOptions = value.data;
	                });
	            }
	            _this.showProcessOptions = true;
	        };
	        /**
	         * Changes the selected process option value.
	         */
	        this.selectProcess = function (processOption) {
	            _this.workflowTaskActions.selectedTaskAction.data.processMethod = processOption.value;
	            _this.searchProcess.name = processOption.name;
	            _this.workflowTaskActions.selectedTaskAction.forms.selectedTaskAction.$setDirty();
	            //this.searchProcess = processOption.name;
	            _this.showProcessOptions = false;
	        };
	        this.selectEmailTemplate = function (item) {
	            if (angular.isDefined(_this.workflowTaskActions.selectedTaskAction.data.emailTemplate)) {
	                _this.workflowTaskActions.selectedTaskAction.data.emailTemplate.data.emailTemplateID = item.emailTemplateID;
	            }
	            else {
	                var templateEmail = _this.$hibachi.newEmailTemplate();
	                templateEmail.data.emailTemplateID = item.emailTemplateID;
	                _this.workflowTaskActions.selectedTaskAction.$$setEmailTemplate(templateEmail);
	            }
	        };
	        this.selectPrintTemplate = function (item) {
	            if (angular.isDefined(_this.workflowTaskActions.selectedTaskAction.data.printTemplate)) {
	                _this.workflowTaskActions.selectedTaskAction.data.printTemplate.data.printTemplateID = item.printTemplateID;
	            }
	            else {
	                var templatePrint = _this.$hibachi.newPrintTemplate();
	                templatePrint.data.printTemplateID = item.printTemplateID;
	                _this.workflowTaskActions.selectedTaskAction.$$setPrintTemplate(templatePrint);
	            }
	        };
	    }
	    return SWWorkflowTaskActionsController;
	}());
	var SWWorkflowTaskActions = (function () {
	    function SWWorkflowTaskActions(workflowPartialsPath, hibachiPathBuilder) {
	        this.workflowPartialsPath = workflowPartialsPath;
	        this.hibachiPathBuilder = hibachiPathBuilder;
	        this.restrict = 'AE';
	        this.scope = {};
	        this.bindToController = {
	            workflowTask: "="
	        };
	        this.controller = SWWorkflowTaskActionsController;
	        this.controllerAs = "swWorkflowTaskActions";
	        this.link = function ($scope, element, attrs) {
	        };
	        this.templateUrl = this.hibachiPathBuilder.buildPartialsPath(this.workflowPartialsPath) + "workflowtaskactions.html";
	    }
	    SWWorkflowTaskActions.Factory = function () {
	        var directive = function (workflowPartialsPath, hibachiPathBuilder) { return new SWWorkflowTaskActions(workflowPartialsPath, hibachiPathBuilder); };
	        directive.$inject = ['workflowPartialsPath', 'hibachiPathBuilder'];
	        return directive;
	    };
	    return SWWorkflowTaskActions;
	}());
	SWWorkflowTaskActions.$inject = ['workflowPartialsPath', 'hibachiPathBuilder'];
	exports.SWWorkflowTaskActions = SWWorkflowTaskActions;


/***/ },
/* 204 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	/**
	 * Handles adding, editing, and deleting Workflows Tasks.
	 */
	var SWWorkflowTasks = (function () {
	    function SWWorkflowTasks($log, $hibachi, metadataService, workflowPartialsPath, hibachiPathBuilder) {
	        return {
	            restrict: 'A',
	            scope: {
	                workflow: "="
	            },
	            templateUrl: hibachiPathBuilder.buildPartialsPath(workflowPartialsPath) + "workflowtasks.html",
	            link: function (scope, element, attrs) {
	                scope.workflowPartialsPath = hibachiPathBuilder.buildPartialsPath(workflowPartialsPath);
	                scope.propertiesList = {};
	                function logger(context, message) {
	                    $log.debug("SwWorkflowTasks :" + context + " : " + message);
	                }
	                /**
	                 * Sets workflowTasks on the scope by populating with $$getWorkflowTasks()
	                 */
	                scope.getWorkflowTasks = function () {
	                    logger("getWorkflowTasks", "Retrieving items");
	                    logger("getWorkflowTasks", "Workflow Tasks");
	                    $log.debug(scope.workflowTasks);
	                    if (!scope.workflow.$$isPersisted()) {
	                        scope.workflow.data.workflowTasks = [];
	                        scope.workflowTasks = scope.workflow.data.workflowTasks;
	                        return;
	                    }
	                    /***
	                       Note:
	                       This conditional is checking whether or not we need to be retrieving to
	                       items all over again. If we already have them, we won't make another
	                       trip to the database.

	                     ***/
	                    if (angular.isUndefined(scope.workflow.data.workflowTasks)) {
	                        var workflowTasksPromise = scope.workflow.$$getWorkflowTasks();
	                        workflowTasksPromise.then(function () {
	                            scope.workflowTasks = scope.workflow.data.workflowTasks;
	                        });
	                    }
	                    else {
	                        logger("getWorkflowTasks", "Retrieving cached Items");
	                        scope.workflowTasks = scope.workflow.data.workflowTasks;
	                    }
	                    if (angular.isUndefined(scope.workflow.data.workflowTasks)) {
	                        //Reset the workflowTasks.
	                        logger("getWorkflowTasks", "workflowTasks is undefined.");
	                        scope.workflow.data.workflowTasks = [];
	                        scope.workflowTasks = scope.workflow.data.workflowTasks;
	                    }
	                };
	                scope.getWorkflowTasks(); //call tasks
	                /**
	                 * Sets the editing state to show/hide the edit screen.
	                 */
	                scope.setHidden = function (task) {
	                    if (!angular.isObject(task) || angular.isUndefined(task.hidden)) {
	                        task.hidden = false;
	                    }
	                    else {
	                        logger("setHidden()", "Setting Hide Value To " + !task.hidden);
	                        task.hidden = !task.hidden;
	                    }
	                };
	                /**
	                 * Add a workflow task and logs the result.
	                 */
	                scope.addWorkflowTask = function () {
	                    var newWorkflowTask = scope.workflow.$$addWorkflowTask();
	                    logger("var newWorkflowTask", newWorkflowTask);
	                    scope.selectWorkflowTask(newWorkflowTask);
	                };
	                /**
	                  * Watches the select for changes.
	                  */
	                scope.$watch('workflowTasks.selectedTask.data.workflow.data.workflowObject', function (newValue, oldValue) {
	                    logger("scope.$watch", "Change Detected " + newValue + " from " + oldValue);
	                    if ((newValue !== oldValue && angular.isDefined(scope.workflowTasks.selectedTask))) {
	                        logger("scope.$watch", "Change to " + newValue);
	                        scope.workflowTasks.selectedTask.data.taskConditionsConfig.baseEntityAlias = newValue;
	                        scope.workflowTasks.selectedTask.data.taskConditionsConfig.baseEntityName = newValue;
	                    }
	                });
	                /**
	                   * --------------------------------------------------------------------------------------------------------
	                   * Saves the workflow task by calling the objects $$save method.
	                   * @param task
	                   * --------------------------------------------------------------------------------------------------------
	                   */
	                scope.saveWorkflowTask = function (task, context) {
	                    //scope.workflowTasks.selectedTask.$$setWorkflow(scope.workflow);
	                    scope.workflowTasks.selectedTask.$$save().then(function (res) {
	                        scope.done = true;
	                        delete scope.workflowTasks.selectedTask;
	                        if (context === 'add') {
	                            logger("SaveWorkflowTask", "Save and New");
	                            scope.addWorkflowTask();
	                            scope.finished = true;
	                        }
	                        else if (context == "finish") {
	                            scope.finished = false;
	                        }
	                    }, function (err) {
	                    });
	                }; //<--end save*/
	                /**
	                 * Select a workflow task.
	                 */
	                scope.selectWorkflowTask = function (workflowTask) {
	                    scope.done = false;
	                    logger("selectWorkflowTask", "selecting a workflow task");
	                    $log.debug(workflowTask);
	                    scope.finished = false;
	                    scope.workflowTasks.selectedTask = undefined;
	                    var filterPropertiesPromise = $hibachi.getFilterPropertiesByBaseEntityName(scope.workflow.data.workflowObject, true);
	                    filterPropertiesPromise.then(function (value) {
	                        scope.filterPropertiesList = {
	                            baseEntityName: scope.workflow.data.workflowObject,
	                            baseEntityAlias: "_" + scope.workflow.data.workflowObject
	                        };
	                        metadataService.setPropertiesList(value, scope.workflow.data.workflowObject);
	                        scope.filterPropertiesList[scope.workflow.data.workflowObject] = metadataService.getPropertiesListByBaseEntityAlias(scope.workflow.data.workflowObject);
	                        metadataService.formatPropertiesList(scope.filterPropertiesList[scope.workflow.data.workflowObject], scope.workflow.data.workflowObject);
	                        scope.workflowTasks.selectedTask = workflowTask;
	                    });
	                };
	                /* Does a delete of the property using delete */
	                scope.softRemoveTask = function (workflowTask) {
	                    logger("SoftRemoveTask", "calling delete");
	                    if (workflowTask === scope.workflowTasks.selectedTask) {
	                        delete scope.workflowTasks.selectedTask;
	                    }
	                    scope.removeIndexFromTasks(workflowTask.$$index);
	                    scope.reindexTaskList();
	                };
	                /* Does an API call delete using $$delete */
	                scope.hardRemoveTask = function (workflowTask) {
	                    logger("HardRemoveTask", "$$delete");
	                    var deletePromise = workflowTask.$$delete();
	                    deletePromise.then(function () {
	                        if (workflowTask === scope.workflowTasks.selectedTask) {
	                            delete scope.workflowTasks.selectedTask;
	                        }
	                        scope.removeIndexFromTasks(workflowTask.$$index);
	                        scope.reindexTaskList();
	                    });
	                };
	                /*Override the delete entity in the confirmation controller*/
	                scope.deleteEntity = function (entity) {
	                    scope.hardRemoveTask(entity);
	                };
	                /* Re-indexes the task list */
	                scope.reindexTaskList = function () {
	                    for (var i in scope.workflowTasks) {
	                        logger("ReIndexing the list", i);
	                        scope.workflowTasks[i].$$index = i;
	                    }
	                };
	                /* Removes the tasks index from the tasks array */
	                scope.removeIndexFromTasks = function (index) {
	                    logger("RemoveIndexFromTasks", index);
	                    scope.workflowTasks.splice(index, 1);
	                };
	            }
	        };
	    }
	    SWWorkflowTasks.Factory = function () {
	        var directive = function ($log, $hibachi, metadataService, workflowPartialsPath, hibachiPathBuilder) { return new SWWorkflowTasks($log, $hibachi, metadataService, workflowPartialsPath, hibachiPathBuilder); };
	        directive.$inject = [
	            '$log',
	            '$hibachi',
	            'metadataService',
	            'workflowPartialsPath',
	            'hibachiPathBuilder'
	        ];
	        return directive;
	    };
	    return SWWorkflowTasks;
	}());
	exports.SWWorkflowTasks = SWWorkflowTasks;


/***/ },
/* 205 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWWorkflowTrigger = (function () {
	    function SWWorkflowTrigger($http, $hibachi, alertService, metadataService, workflowPartialsPath, hibachiPathBuilder, utilityService) {
	        return {
	            restrict: 'A',
	            replace: true,
	            scope: {
	                workflowTrigger: "=",
	                workflowTriggers: "="
	            },
	            templateUrl: hibachiPathBuilder.buildPartialsPath(workflowPartialsPath) + "workflowtrigger.html",
	            link: function (scope, element, attrs) {
	                /**
	                 * Selects the current workflow trigger.
	                 */
	                scope.selectWorkflowTrigger = function (workflowTrigger) {
	                    scope.done = false;
	                    scope.finished = false;
	                    scope.workflowTriggers.selectedTrigger = undefined;
	                    var filterPropertiesPromise = $hibachi.getFilterPropertiesByBaseEntityName(scope.workflowTrigger.data.workflow.data.workflowObject, true);
	                    filterPropertiesPromise.then(function (value) {
	                        scope.filterPropertiesList = {
	                            baseEntityName: scope.workflowTrigger.data.workflow.data.workflowObject,
	                            baseEntityAlias: "_" + scope.workflowTrigger.data.workflow.data.workflowObject
	                        };
	                        metadataService.setPropertiesList(value, scope.workflowTrigger.data.workflow.data.workflowObject);
	                        scope.filterPropertiesList[scope.workflowTrigger.data.workflow.data.workflowObject] = metadataService.getPropertiesListByBaseEntityAlias(scope.workflowTrigger.data.workflow.data.workflowObject);
	                        metadataService.formatPropertiesList(scope.filterPropertiesList[scope.workflowTrigger.data.workflow.data.workflowObject], scope.workflowTrigger.data.workflow.data.workflowObject);
	                        scope.workflowTriggers.selectedTrigger = workflowTrigger;
	                    });
	                };
	                scope.executingTrigger = false;
	                scope.executeWorkflowTrigger = function (workflowTrigger) {
	                    if (scope.executingTrigger)
	                        return;
	                    if (!workflowTrigger.data.workflow.data.workflowTasks || !workflowTrigger.data.workflow.data.workflowTasks.length) {
	                        var alert = alertService.newAlert();
	                        alert.msg = "You don't have any Task yet!";
	                        alert.type = "error";
	                        alert.fade = true;
	                        alertService.addAlert(alert);
	                        return;
	                    }
	                    scope.executingTrigger = true;
	                    var appConfig = $hibachi.getConfig();
	                    var urlString = appConfig.baseURL + '/index.cfm/?' + appConfig.action + '=api:workflow.executeScheduleWorkflowTrigger&workflowTriggerID=' + workflowTrigger.data.workflowTriggerID + '&x=' + utilityService.createID();
	                    $http.get(urlString).finally(function () {
	                        scope.executingTrigger = false;
	                        var alert = alertService.newAlert();
	                        alert.msg = "Task Triggered Successfully. Check History for Status";
	                        alert.type = "success";
	                        alert.fade = true;
	                        alertService.addAlert(alert);
	                    });
	                };
	                /**
	                 * Overrides the delete function for the confirmation modal. Delegates to the normal delete method.
	                 */
	                scope.deleteEntity = function (entity, index) {
	                    scope.deleteTrigger(entity, index);
	                };
	                /**
	                 * Hard deletes a workflow trigger
	                 */
	                scope.deleteTrigger = function (workflowTrigger, index) {
	                    var deleteTriggerPromise = $hibachi.saveEntity('WorkflowTrigger', workflowTrigger.data.workflowTriggerID, {}, 'Delete');
	                    deleteTriggerPromise.then(function (value) {
	                        scope.workflowTriggers.splice(index, 1);
	                    });
	                };
	            }
	        };
	    }
	    SWWorkflowTrigger.Factory = function () {
	        var directive = function ($http, $hibachi, alertService, metadataService, workflowPartialsPath, hibachiPathBuilder, utilityService) { return new SWWorkflowTrigger($http, $hibachi, alertService, metadataService, workflowPartialsPath, hibachiPathBuilder, utilityService); };
	        directive.$inject = [
	            '$http',
	            '$hibachi',
	            'alertService',
	            'metadataService',
	            'workflowPartialsPath',
	            'hibachiPathBuilder',
	            'utilityService'
	        ];
	        return directive;
	    };
	    return SWWorkflowTrigger;
	}());
	exports.SWWorkflowTrigger = SWWorkflowTrigger;


/***/ },
/* 206 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWWorkflowTriggers = (function () {
	    function SWWorkflowTriggers($hibachi, workflowPartialsPath, formService, observerService, hibachiPathBuilder, collectionConfigService, scheduleService, dialogService, $timeout) {
	        return {
	            restrict: 'E',
	            scope: {
	                workflow: "="
	            },
	            templateUrl: hibachiPathBuilder.buildPartialsPath(workflowPartialsPath) + "workflowtriggers.html",
	            link: function (scope, element, attrs, formController) {
	                scope.schedule = {};
	                scope.$watch('workflowTriggers.selectedTrigger', function (newValue, oldValue) {
	                    if (newValue !== undefined && newValue !== oldValue) {
	                        if (newValue.data.triggerType == 'Schedule') {
	                            if (angular.isDefined(newValue.data.schedule)) {
	                                scope.schedule.selectedName = newValue.data.schedule.data.scheduleName;
	                                scope.selectSchedule(newValue.data.schedule.data);
	                            }
	                            if (angular.isDefined(newValue.data.scheduleCollection)) {
	                                scope.selectedCollection = newValue.data.scheduleCollection.data.collectionName;
	                            }
	                        }
	                        else {
	                            scope.searchEvent.name = scope.workflowTriggers.selectedTrigger.triggerEventTitle;
	                        }
	                    }
	                });
	                scope.collectionCollectionConfig = collectionConfigService.newCollectionConfig("Collection");
	                scope.collectionCollectionConfig.setDisplayProperties("collectionID,collectionName");
	                scope.collectionCollectionConfig.addFilter("collectionObject", scope.workflow.data.workflowObject);
	                observerService.attach(function (item) {
	                    scope.collectionCollectionConfig.clearFilters();
	                    scope.collectionCollectionConfig.addFilter("collectionObject", item.value);
	                    scope.eventOptions = [];
	                }, 'WorkflowWorkflowObjectOnChange');
	                scope.scheduleCollectionConfig = collectionConfigService.newCollectionConfig("Schedule");
	                scope.scheduleCollectionConfig.setDisplayProperties("scheduleID,scheduleName,daysOfMonthToRun,daysOfWeekToRun,recuringType,frequencyStartTime,frequencyEndTime,frequencyInterval");
	                scope.daysOfweek = [];
	                scope.daysOfMonth = [];
	                scope.$id = 'swWorkflowTriggers';
	                /**
	                 * Retrieves the workflow triggers.
	                 */
	                scope.getWorkflowTriggers = function () {
	                    /***
	                       Note:
	                       This conditional is checking whether or not we need to be retrieving to
	                       items all over again. If we already have them, we won't make another
	                       trip to the database.

	                    ***/
	                    if (!scope.workflow.$$isPersisted()) {
	                        scope.workflow.data.workflowTriggers = [];
	                        scope.workflowTriggers = scope.workflow.data.workflowTriggers;
	                        return;
	                    }
	                    if (angular.isUndefined(scope.workflow.data.workflowTriggers)) {
	                        var workflowTriggersPromise = scope.workflow.$$getWorkflowTriggers();
	                        workflowTriggersPromise.then(function () {
	                            scope.workflowTriggers = scope.workflow.data.workflowTriggers;
	                            /* resets the workflow trigger */
	                            if (angular.isUndefined(scope.workflow.data.workflowTriggers)) {
	                                scope.workflow.data.workflowTriggers = [];
	                                scope.workflowTriggers = scope.workflow.data.workflowTriggers;
	                            }
	                            angular.forEach(scope.workflowTriggers, function (workflowTrigger, key) {
	                                if (workflowTrigger.data.triggerType === 'Schedule') {
	                                    workflowTrigger.$$getSchedule();
	                                    workflowTrigger.$$getScheduleCollection();
	                                } //<---end if
	                            }); //<---end forEach
	                        }); //<---end workflow triggers promise
	                    }
	                    else {
	                        //Use the cached versions.
	                        scope.workflowTriggers = scope.workflow.data.workflowTriggers;
	                    } //<---end else
	                };
	                scope.getWorkflowTriggers(); //call triggers
	                scope.showCollections = false;
	                scope.collections = [];
	                scope.searchEvent = {
	                    name: ''
	                };
	                /**
	                 * Watches for changes in the event
	                 */
	                scope.showEventOptions = false;
	                scope.eventOptions = [];
	                /**
	                 * Retrieves the event options for a workflow trigger item.
	                 */
	                scope.getEventOptions = function (objectName) {
	                    if (!scope.eventOptions.length) {
	                        var eventOptionsPromise = $hibachi.getEventOptions(objectName);
	                        eventOptionsPromise.then(function (value) {
	                            scope.eventOptions = value.data;
	                        });
	                    }
	                    scope.showEventOptions = !scope.showEventOptions;
	                };
	                /**
	                 * Saves the workflow triggers.
	                 */
	                scope.saveWorkflowTrigger = function (context) {
	                    if (!scope.workflowTriggers.selectedTrigger.$$isPersisted()) {
	                        scope.workflowTriggers.selectedTrigger.$$setWorkflow(scope.workflow);
	                    }
	                    var saveWorkflowTriggerPromise = scope.workflowTriggers.selectedTrigger.$$save();
	                    saveWorkflowTriggerPromise.then(function () {
	                        scope.showEventOptions = true;
	                        scope.searchEvent = {
	                            name: ''
	                        };
	                        scope.schedule.selectedName = '';
	                        scope.schedulePreview = {};
	                        //Clear the form by adding a new task action if 'save and add another' otherwise, set save and set finished
	                        if (context == 'add') {
	                            scope.addWorkflowTrigger();
	                        }
	                        else if (context == "finish") {
	                            scope.workflowTriggers.selectedTrigger = undefined;
	                        }
	                    });
	                };
	                scope.closeTrigger = function () {
	                    console.warn("workflow", scope.workflow);
	                    if (!scope.workflowTriggers.selectedTrigger.$$isPersisted()) {
	                        scope.workflowTriggers.selectedTrigger.$$setWorkflow();
	                    }
	                    scope.workflowTriggers.selectedTrigger = undefined;
	                };
	                /**
	                 * Changes the selected trigger value.
	                 */
	                scope.selectEvent = function (eventOption) {
	                    //Needs to clear old and set new.
	                    scope.workflowTriggers.selectedTrigger.data.triggerEventTitle = eventOption.name;
	                    scope.workflowTriggers.selectedTrigger.data.triggerEvent = eventOption.value;
	                    if (eventOption.entityName == scope.workflow.data.workflowObject) {
	                        scope.workflowTriggers.selectedTrigger.data.objectPropertyIdentifier = '';
	                    }
	                    else {
	                        scope.workflowTriggers.selectedTrigger.data.objectPropertyIdentifier = eventOption.entityName;
	                    }
	                    scope.searchEvent.name = eventOption.name;
	                    scope.showEventOptions = false;
	                    observerService.notifyById('pullBindings', 'WorkflowTriggertriggerEventpullBindings').then(function () {
	                    });
	                    observerService.notifyById('pullBindings', 'WorkflowTriggertriggerEventTitlepullBindings').then(function () {
	                    });
	                };
	                /**
	                 * Selects a new collection.
	                 */
	                scope.selectCollection = function (collection) {
	                    scope.workflowTriggers.selectedTrigger.data.scheduleCollection = collection;
	                    scope.showCollections = false;
	                };
	                /**
	                 * Removes a workflow trigger
	                 */
	                scope.removeWorkflowTrigger = function (workflowTrigger) {
	                    if (workflowTrigger === scope.workflowTriggers.selectedTrigger) {
	                        delete scope.workflowTriggers.selectedTrigger;
	                    }
	                    scope.workflowTriggers.splice(workflowTrigger.$$index, 1);
	                };
	                scope.setAsEvent = function (workflowTrigger) {
	                    if (!workflowTrigger.$$isPersisted()) {
	                        workflowTrigger.data.saveTriggerHistoryFlag = 0;
	                    }
	                    //add event,  clear schedule
	                };
	                scope.setAsSchedule = function (workflowTrigger) {
	                    if (!workflowTrigger.$$isPersisted()) {
	                        workflowTrigger.data.saveTriggerHistoryFlag = 1;
	                    }
	                };
	                /**
	                 * Adds a workflow trigger.
	                 */
	                scope.addWorkflowTrigger = function () {
	                    var newWorkflowTrigger = $hibachi.newWorkflowTrigger();
	                    scope.workflowTriggers.selectedTrigger = newWorkflowTrigger;
	                };
	                scope.addNewSchedule = function () {
	                    scope.createSchedule = true;
	                    scope.scheduleEntity = $hibachi.newSchedule();
	                };
	                scope.saveSchedule = function () {
	                    if (scope.scheduleEntity.data.recuringType == 'weekly') {
	                        scope.scheduleEntity.data.daysOfWeekToRun = scope.daysOfweek.filter(Number).join();
	                    }
	                    else if (scope.scheduleEntity.data.recuringType == 'monthly') {
	                        scope.scheduleEntity.data.daysOfMonthToRun = scope.daysOfMonth.filter(Number).join();
	                    }
	                    scope.scheduleEntity.$$save().then(function (res) {
	                        scope.schedule.selectedName = angular.copy(scope.scheduleEntity.data.scheduleName);
	                        scope.selectSchedule(angular.copy(scope.scheduleEntity.data));
	                        formService.resetForm(scope.scheduleEntity.forms['scheduleForm']);
	                        scope.createSchedule = false;
	                    }, function () {
	                    });
	                };
	                scope.selectCollection = function (item) {
	                    if (item === undefined) {
	                        scope.workflowTriggers.selectedTrigger.$$setScheduleCollection();
	                        return;
	                    }
	                    if (angular.isDefined(scope.workflowTriggers.selectedTrigger.data.scheduleCollection)) {
	                        scope.workflowTriggers.selectedTrigger.data.scheduleCollection.data.collectionID = item.collectionID;
	                        scope.workflowTriggers.selectedTrigger.data.scheduleCollection.data.collectionName = item.collectionName;
	                    }
	                    else {
	                        var _collection = $hibachi.newCollection();
	                        _collection.data.collectionID = item.collectionID;
	                        _collection.data.collectionName = item.collectionName;
	                        scope.workflowTriggers.selectedTrigger.$$setScheduleCollection(_collection);
	                    }
	                };
	                scope.viewCollection = function () {
	                    if (angular.isDefined(scope.workflowTriggers.selectedTrigger.data.scheduleCollection)) {
	                        dialogService.addPageDialog('org/Hibachi/client/src/collection/components/criteriacreatecollection', {
	                            entityName: 'Collection',
	                            entityId: scope.workflowTriggers.selectedTrigger.data.scheduleCollection.data.collectionID,
	                            readOnly: true
	                        });
	                    }
	                };
	                scope.selectSchedule = function (item) {
	                    if (item === undefined) {
	                        scope.schedulePreview = {};
	                        scope.workflowTriggers.selectedTrigger.$$setSchedule();
	                        return;
	                    }
	                    scope.schedulePreview = scheduleService.buildSchedulePreview(item, 6);
	                    if (angular.isDefined(scope.workflowTriggers.selectedTrigger.data.schedule)) {
	                        scope.workflowTriggers.selectedTrigger.data.schedule.data.scheduleID = item.scheduleID;
	                        scope.workflowTriggers.selectedTrigger.data.schedule.data.scheduleName = item.scheduleName;
	                    }
	                    else {
	                        var _schedule = $hibachi.newSchedule();
	                        _schedule.data.scheduleID = item.scheduleID;
	                        _schedule.data.scheduleName = item.scheduleName;
	                        scope.workflowTriggers.selectedTrigger.$$setSchedule(_schedule);
	                    }
	                };
	            }
	        };
	    }
	    SWWorkflowTriggers.Factory = function () {
	        var directive = function ($hibachi, workflowPartialsPath, formService, observerService, hibachiPathBuilder, collectionConfigService, scheduleService, dialogService, $timeout) { return new SWWorkflowTriggers($hibachi, workflowPartialsPath, formService, observerService, hibachiPathBuilder, collectionConfigService, scheduleService, dialogService, $timeout); };
	        directive.$inject = [
	            '$hibachi',
	            'workflowPartialsPath',
	            'formService',
	            'observerService',
	            'hibachiPathBuilder',
	            'collectionConfigService',
	            'scheduleService',
	            'dialogService',
	            '$timeout'
	        ];
	        return directive;
	    };
	    return SWWorkflowTriggers;
	}());
	exports.SWWorkflowTriggers = SWWorkflowTriggers;


/***/ },
/* 207 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWWorkflowTriggerHistory = (function () {
	    function SWWorkflowTriggerHistory($log, $location, $hibachi, formService, workflowPartialsPath, hibachiPathBuilder, $rootScope) {
	        return {
	            restrict: 'A',
	            scope: {
	                workflow: "="
	            },
	            templateUrl: hibachiPathBuilder.buildPartialsPath(workflowPartialsPath) + "workflowtriggerhistory.html",
	            link: function (scope, element, attrs) {
	                $rootScope.workflowID = scope.workflow.data.workflowID;
	            }
	        };
	    }
	    SWWorkflowTriggerHistory.Factory = function () {
	        var directive = function ($log, $location, $hibachi, formService, workflowPartialsPath, hibachiPathBuilder, $rootScope) { return new SWWorkflowTriggerHistory($log, $location, $hibachi, formService, workflowPartialsPath, hibachiPathBuilder, $rootScope); };
	        directive.$inject = [
	            '$log',
	            '$location',
	            '$hibachi',
	            'formService',
	            'workflowPartialsPath',
	            'hibachiPathBuilder',
	            '$rootScope'
	        ];
	        return directive;
	    };
	    return SWWorkflowTriggerHistory;
	}());
	exports.SWWorkflowTriggerHistory = SWWorkflowTriggerHistory;


/***/ },
/* 208 */
/***/ function(module, exports) {

	"use strict";
	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	var SWSchedulePreviewController = (function () {
	    function SWSchedulePreviewController() {
	    }
	    return SWSchedulePreviewController;
	}());
	var SWSchedulePreview = (function () {
	    function SWSchedulePreview(workflowPartialsPath, hibachiPathBuilder) {
	        this.workflowPartialsPath = workflowPartialsPath;
	        this.hibachiPathBuilder = hibachiPathBuilder;
	        this.restrict = 'AE';
	        this.scope = {};
	        this.bindToController = {
	            schedule: "="
	        };
	        this.controller = SWSchedulePreviewController;
	        this.controllerAs = "swSchedulePreview";
	        this.templateUrl = this.hibachiPathBuilder.buildPartialsPath(this.workflowPartialsPath) + "schedulepreview.html";
	    }
	    SWSchedulePreview.Factory = function () {
	        var directive = function (workflowPartialsPath, hibachiPathBuilder) { return new SWSchedulePreview(workflowPartialsPath, hibachiPathBuilder); };
	        directive.$inject = ['workflowPartialsPath', 'hibachiPathBuilder'];
	        return directive;
	    };
	    return SWSchedulePreview;
	}());
	SWSchedulePreview.$inject = ['workflowPartialsPath', 'hibachiPathBuilder'];
	exports.SWSchedulePreview = SWSchedulePreview;


/***/ },
/* 209 */
/***/ function(module, exports) {

	/// <reference path='../../../typings/hibachiTypescript.d.ts' />
	/// <reference path='../../../typings/tsd.d.ts' />
	"use strict";
	var SWSaveAndFinishController = (function () {
	    //@ngInject
	    function SWSaveAndFinishController($hibachi, dialogService, alertService, rbkeyService, $log) {
	        var _this = this;
	        this.$hibachi = $hibachi;
	        this.dialogService = dialogService;
	        this.alertService = alertService;
	        this.rbkeyService = rbkeyService;
	        this.$log = $log;
	        this.saving = false;
	        this.initialSetup = function () {
	            if (!angular.isDefined(_this.finish)) {
	                _this.openNewDialog = false;
	            }
	            else {
	                _this.openNewDialog = (_this.finish.toLowerCase() == 'true') ? false : true;
	            }
	            if (_this.openNewDialog) {
	                _this.rbKey = 'admin.define.saveandnew';
	            }
	            else {
	                _this.rbKey = 'admin.define.saveandfinish';
	            }
	        };
	        this.save = function () {
	            _this.saving = true;
	            var savePromise = _this.entity.$$save();
	            savePromise.then(function (data) {
	                _this.dialogService.removeCurrentDialog();
	                if (_this.openNewDialog && angular.isDefined(_this.partial)) {
	                    _this.dialogService.addPageDialog(_this.partial);
	                }
	                else {
	                    if (angular.isDefined(_this.redirectUrl)) {
	                        window.location.href = _this.redirectUrl;
	                    }
	                    else if (angular.isDefined(_this.redirectAction)) {
	                        if (angular.isUndefined(_this.redirectQueryString)) {
	                            _this.redirectQueryString = "";
	                        }
	                        window.location.href = _this.$hibachi.buildUrl(_this.redirectAction, _this.redirectQueryString);
	                    }
	                    else {
	                        _this.$log.debug("You did not specify a redirect for swSaveAndFinish");
	                    }
	                }
	            }).catch(function (data) {
	                if (angular.isDefined(_this.customErrorRbkey)) {
	                    data = _this.rbkeyService.getRBKey(_this.customErrorRbkey);
	                }
	                if (angular.isString(data)) {
	                    var alert = _this.alertService.newAlert();
	                    alert.msg = data;
	                    alert.type = "error";
	                    alert.fade = true;
	                    _this.alertService.addAlert(alert);
	                }
	                else {
	                    _this.alertService.addAlerts(data);
	                }
	            }).finally(function () {
	                _this.saving = false;
	            });
	        };
	        if (!angular.isFunction(this.entity.$$save)) {
	            throw ("Your entity does not have the $$save function.");
	        }
	        this.initialSetup();
	    }
	    return SWSaveAndFinishController;
	}());
	exports.SWSaveAndFinishController = SWSaveAndFinishController;
	var SWSaveAndFinish = (function () {
	    //@ngInject
	    function SWSaveAndFinish(hibachiPartialsPath, hibachiPathBuilder) {
	        this.hibachiPartialsPath = hibachiPartialsPath;
	        this.restrict = "EA";
	        this.scope = {};
	        this.controller = SWSaveAndFinishController;
	        this.controllerAs = "swSaveAndFinish";
	        this.bindToController = {
	            entity: "=",
	            redirectUrl: "@?",
	            redirectAction: "@?",
	            redirectQueryString: "@?",
	            finish: "@?",
	            partial: "@?",
	            customErrorRbkey: "@?"
	        };
	        this.templateUrl = hibachiPathBuilder.buildPartialsPath(hibachiPartialsPath) + "saveandfinish.html";
	    }
	    SWSaveAndFinish.Factory = function () {
	        var directive = function (hibachiPartialsPath, hibachiPathBuilder) { return new SWSaveAndFinish(hibachiPartialsPath, hibachiPathBuilder); };
	        directive.$inject = ["hibachiPartialsPath", "hibachiPathBuilder"];
	        return directive;
	    };
	    return SWSaveAndFinish;
	}());
	exports.SWSaveAndFinish = SWSaveAndFinish;


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/tsd.d.ts" />
	/// <reference path="../../typings/hibachiTypescript.d.ts" />
	"use strict";
	var alert_module_1 = __webpack_require__(98);
	var loggermodule = angular.module('logger', [alert_module_1.alertmodule.name])
	    .run([function () {
	    }]);
	exports.loggermodule = loggermodule;


/***/ }
]);